[{
  "history_id" : "9i1n8kwcfsw",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport uuid\nfrom snowcast_utils import day_index\nimport matplotlib.colors as mcolors\n\n# Import utility functions and variables from 'snowcast_utils'\nfrom snowcast_utils import work_dir, test_start_date\n\n# Define a custom colormap with specified colors and ranges\ncolors = [\n    (0.8627, 0.8627, 0.8627),  # #DCDCDC - 0 - 1\n    (0.8627, 1.0000, 1.0000),  # #DCFFFF - 1 - 2\n    (0.6000, 1.0000, 1.0000),  # #99FFFF - 2 - 4\n    (0.5569, 0.8235, 1.0000),  # #8ED2FF - 4 - 6\n    (0.4509, 0.6196, 0.8745),  # #739EDF - 6 - 8\n    (0.4157, 0.4706, 1.0000),  # #6A78FF - 8 - 10\n    (0.4235, 0.2784, 1.0000),  # #6C47FF - 10 - 12\n    (0.5529, 0.0980, 1.0000),  # #8D19FF - 12 - 14\n    (0.7333, 0.0000, 0.9176),  # #BB00EA - 14 - 16\n    (0.8392, 0.0000, 0.7490),  # #D600BF - 16 - 18\n    (0.7569, 0.0039, 0.4549),  # #C10074 - 18 - 20\n    (0.6784, 0.0000, 0.1961),  # #AD0032 - 20 - 30\n    (0.5020, 0.0000, 0.0000)   # #800000 - > 30\n]\n\ncmap_name = 'custom_snow_colormap'\ncustom_cmap = mcolors.ListedColormap(colors)\n\n# Define the lat_lon_to_map_coordinates function\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    \"\"\"\n    Convert latitude and longitude coordinates to map coordinates.\n\n    Args:\n        lon (float or array-like): Longitude coordinate(s).\n        lat (float or array-like): Latitude coordinate(s).\n        m (Basemap): Basemap object representing the map projection.\n\n    Returns:\n        tuple: Tuple containing the converted map coordinates (x, y).\n    \"\"\"\n    x, y = m(lon, lat)\n    return x, y\n\n# Define value ranges for color mapping\nfixed_value_ranges = [1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 30]\n\ndef create_color_maps_with_value_range(df_col, value_ranges=None):\n    \"\"\"\n    Create a colormap for value ranges and map data values to colors.\n\n    Args:\n        df_col (pd.Series): A Pandas Series containing data values.\n        value_ranges (list, optional): A list of value ranges for color mapping.\n            If not provided, the ranges will be determined automatically.\n\n    Returns:\n        tuple: Tuple containing the color mapping and the updated value ranges.\n    \"\"\"\n    new_value_ranges = value_ranges\n    if value_ranges is None:\n        max_value = df_col.max()\n        min_value = df_col.min()\n        if min_value < 0:\n            min_value = 0\n        step_size = (max_value - min_value) / 12\n\n        # Create 10 periods\n        new_value_ranges = [min_value + i * step_size for i in range(12)]\n    \n    print(\"new_value_ranges: \", new_value_ranges)\n  \n    # Define a custom function to map data values to colors\n    def map_value_to_color(value):\n        # Iterate through the value ranges to find the appropriate color index\n        for i, range_max in enumerate(new_value_ranges):\n            if value <= range_max:\n                return colors[i]\n\n        # If the value is greater than the largest range, return the last color\n        return colors[-1]\n\n    # Map predicted_swe values to colors using the custom function\n    color_mapping = [map_value_to_color(value) for value in df_col.values]\n    return color_mapping, new_value_ranges\n\ndef convert_csvs_to_images():\n    \"\"\"\n    Convert CSV data to images with color-coded SWE predictions.\n\n    Returns:\n        None\n    \"\"\"\n    global fixed_value_ranges\n    data = pd.read_csv(\"/home/chetana/gridmet_test_run/test_data_predicted.csv\")\n    print(\"statistic of predicted_swe: \", data['predicted_swe'].describe())\n    data['predicted_swe'].fillna(0, inplace=True)\n    \n    for column in data.columns:\n        column_data = data[column]\n        print(column_data.describe())\n    \n    # Create a figure with a white background\n    fig = plt.figure(facecolor='white')\n\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    x, y = m(data['lon'].values, data['lat'].values)\n    print(data.columns)\n\n    color_mapping, value_ranges = create_color_maps_with_value_range(data[\"predicted_swe\"], fixed_value_ranges)\n    \n    # Plot the data using the custom colormap\n    plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\n    \n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_date = datetime(1900, 1, 1)\n    day_value = day_index\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    timestamp_string = result_date.strftime(\"%Y-%m-%d\")\n    \n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    # Create custom legend elements using the same colormap\n    legend_elements = [Patch(color=colors[i], label=f\"{value_ranges[i]} - {value_ranges[i+1]-1}\" if i < len(value_ranges) - 1 else f\"> {value_ranges[-1]}\") for i in range(len(value_ranges))]\n\n    # Create the legend outside the map\n    legend = plt.legend(handles=legend_elements, loc='upper left', title='Legend', fontsize=8)\n    legend.set_bbox_to_anchor((1.01, 1)) \n\n    # Remove the color bar\n    #plt.colorbar().remove()\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Set the aspect ratio to 'equal' to keep the plot at the center\n    plt.gca().set_aspect('equal', adjustable='box')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15, right=0.80)  # Adjust right margin to accommodate the legend\n    # Show the plot or save it to a file\n    new_plot_path = f'/home/chetana/gridmet_test_run/predicted_swe-{test_start_date}.png'\n    print(f\"The new plot is saved to {new_plot_path}\")\n    plt.savefig(new_plot_path)\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\ndef convert_csvs_to_images_simple():\n    \"\"\"\n    Convert CSV data to simple scatter plot images for predicted SWE.\n\n    Returns:\n        None\n    \"\"\"\n    selected_date = datetime.strptime(test_start_date, \"%Y-%m-%d\")\n    var_name = \"predicted_swe\"\n    test_csv = \"/home/chetana/gridmet_test_run/test_data_predicted.csv\"\n    result_var_df = pd.read_csv(test_csv)\n    result_var_df.replace('--', pd.NA, inplace=True)\n    result_var_df.dropna(inplace=True)\n    result_var_df[var_name] = pd.to_numeric(result_var_df[var_name], errors='coerce')\n    \n    colormaplist, value_ranges = create_color_maps_with_value_range(result_var_df[var_name], fixed_value_ranges)\n\n    # Create a scatter plot\n    plt.scatter(result_var_df[\"lon\"].values, \n                result_var_df[\"lat\"].values, \n                label='Predicted SWE', \n                c=result_var_df['predicted_swe'], \n                cmap='viridis', \n                s=1, \n                edgecolor='none',\n               )\n\n    # Add a colorbar\n    cbar = plt.colorbar()\n    cbar.set_label('Predicted SWE')  # Label for the colorbar\n    \n    # Add labels and a legend\n    plt.xlabel('Longitude')\n    plt.ylabel('Latitude')\n    plt.title(f'SWE Prediction Map {test_start_date}')\n    plt.legend()\n\n    res_png_path = f\"{work_dir}/testing_output/{str(selected_date.year)}_{var_name}_{test_start_date}.png\"\n    plt.savefig(res_png_path)\n    print(f\"test image is saved at {res_png_path}\")\n    plt.close()\n\n# Uncomment the function call you want to use:\n# convert_csvs_to_images()\nconvert_csvs_to_images_simple()\n",
  "history_output" : "today date = 2023-10-09\ntest start date:  2023-09-16\ntest end date:  2023-10-09\n/home/chetana\nnew_value_ranges:  [1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 30]\ntest image is saved at /home/chetana/gridmet_test_run/testing_output/2023_predicted_swe_2023-09-16.png\n",
  "history_begin_time" : 1696864181344,
  "history_end_time" : 1696864191192,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "100001",
  "indicator" : "Done"
},{
  "history_id" : "vq1y1hxdjdz",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport uuid\nfrom snowcast_utils import day_index\nimport matplotlib.colors as mcolors\n\n# Import utility functions and variables from 'snowcast_utils'\nfrom snowcast_utils import work_dir, test_start_date\n\n# Define a custom colormap with specified colors and ranges\ncolors = [\n    (0.8627, 0.8627, 0.8627),  # #DCDCDC - 0 - 1\n    (0.8627, 1.0000, 1.0000),  # #DCFFFF - 1 - 2\n    (0.6000, 1.0000, 1.0000),  # #99FFFF - 2 - 4\n    (0.5569, 0.8235, 1.0000),  # #8ED2FF - 4 - 6\n    (0.4509, 0.6196, 0.8745),  # #739EDF - 6 - 8\n    (0.4157, 0.4706, 1.0000),  # #6A78FF - 8 - 10\n    (0.4235, 0.2784, 1.0000),  # #6C47FF - 10 - 12\n    (0.5529, 0.0980, 1.0000),  # #8D19FF - 12 - 14\n    (0.7333, 0.0000, 0.9176),  # #BB00EA - 14 - 16\n    (0.8392, 0.0000, 0.7490),  # #D600BF - 16 - 18\n    (0.7569, 0.0039, 0.4549),  # #C10074 - 18 - 20\n    (0.6784, 0.0000, 0.1961),  # #AD0032 - 20 - 30\n    (0.5020, 0.0000, 0.0000)   # #800000 - > 30\n]\n\ncmap_name = 'custom_snow_colormap'\ncustom_cmap = mcolors.ListedColormap(colors)\n\n# Define the lat_lon_to_map_coordinates function\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    \"\"\"\n    Convert latitude and longitude coordinates to map coordinates.\n\n    Args:\n        lon (float or array-like): Longitude coordinate(s).\n        lat (float or array-like): Latitude coordinate(s).\n        m (Basemap): Basemap object representing the map projection.\n\n    Returns:\n        tuple: Tuple containing the converted map coordinates (x, y).\n    \"\"\"\n    x, y = m(lon, lat)\n    return x, y\n\n# Define value ranges for color mapping\nfixed_value_ranges = [1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 30]\n\ndef create_color_maps_with_value_range(df_col, value_ranges=None):\n    \"\"\"\n    Create a colormap for value ranges and map data values to colors.\n\n    Args:\n        df_col (pd.Series): A Pandas Series containing data values.\n        value_ranges (list, optional): A list of value ranges for color mapping.\n            If not provided, the ranges will be determined automatically.\n\n    Returns:\n        tuple: Tuple containing the color mapping and the updated value ranges.\n    \"\"\"\n    new_value_ranges = value_ranges\n    if value_ranges is None:\n        max_value = df_col.max()\n        min_value = df_col.min()\n        if min_value < 0:\n            min_value = 0\n        step_size = (max_value - min_value) / 12\n\n        # Create 10 periods\n        new_value_ranges = [min_value + i * step_size for i in range(12)]\n    \n    print(\"new_value_ranges: \", new_value_ranges)\n  \n    # Define a custom function to map data values to colors\n    def map_value_to_color(value):\n        # Iterate through the value ranges to find the appropriate color index\n        for i, range_max in enumerate(new_value_ranges):\n            if value <= range_max:\n                return colors[i]\n\n        # If the value is greater than the largest range, return the last color\n        return colors[-1]\n\n    # Map predicted_swe values to colors using the custom function\n    color_mapping = [map_value_to_color(value) for value in df_col.values]\n    return color_mapping, new_value_ranges\n\ndef convert_csvs_to_images():\n    \"\"\"\n    Convert CSV data to images with color-coded SWE predictions.\n\n    Returns:\n        None\n    \"\"\"\n    global fixed_value_ranges\n    data = pd.read_csv(\"/home/chetana/gridmet_test_run/test_data_predicted.csv\")\n    print(\"statistic of predicted_swe: \", data['predicted_swe'].describe())\n    data['predicted_swe'].fillna(0, inplace=True)\n    \n    for column in data.columns:\n        column_data = data[column]\n        print(column_data.describe())\n    \n    # Create a figure with a white background\n    fig = plt.figure(facecolor='white')\n\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    x, y = m(data['lon'].values, data['lat'].values)\n    print(data.columns)\n\n    color_mapping, value_ranges = create_color_maps_with_value_range(data[\"predicted_swe\"], fixed_value_ranges)\n    \n    # Plot the data using the custom colormap\n    plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\n    \n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_date = datetime(1900, 1, 1)\n    day_value = day_index\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    timestamp_string = result_date.strftime(\"%Y-%m-%d\")\n    \n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    # Create custom legend elements using the same colormap\n    legend_elements = [Patch(color=colors[i], label=f\"{value_ranges[i]} - {value_ranges[i+1]-1}\" if i < len(value_ranges) - 1 else f\"> {value_ranges[-1]}\") for i in range(len(value_ranges))]\n\n    # Create the legend outside the map\n    legend = plt.legend(handles=legend_elements, loc='upper left', title='Legend', fontsize=8)\n    legend.set_bbox_to_anchor((1.01, 1)) \n\n    # Remove the color bar\n    #plt.colorbar().remove()\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Set the aspect ratio to 'equal' to keep the plot at the center\n    plt.gca().set_aspect('equal', adjustable='box')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15, right=0.80)  # Adjust right margin to accommodate the legend\n    # Show the plot or save it to a file\n    new_plot_path = f'/home/chetana/gridmet_test_run/predicted_swe-{test_start_date}.png'\n    print(f\"The new plot is saved to {new_plot_path}\")\n    plt.savefig(new_plot_path)\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\ndef convert_csvs_to_images_simple():\n    \"\"\"\n    Convert CSV data to simple scatter plot images for predicted SWE.\n\n    Returns:\n        None\n    \"\"\"\n    selected_date = datetime.strptime(test_start_date, \"%Y-%m-%d\")\n    var_name = \"predicted_swe\"\n    test_csv = \"/home/chetana/gridmet_test_run/test_data_predicted.csv\"\n    result_var_df = pd.read_csv(test_csv)\n    result_var_df.replace('--', pd.NA, inplace=True)\n    result_var_df.dropna(inplace=True)\n    result_var_df[var_name] = pd.to_numeric(result_var_df[var_name], errors='coerce')\n    \n    colormaplist, value_ranges = create_color_maps_with_value_range(result_var_df[var_name], fixed_value_ranges)\n\n    # Create a scatter plot\n    plt.scatter(result_var_df[\"lon\"].values, \n                result_var_df[\"lat\"].values, \n                label='Predicted SWE', \n                c=result_var_df['predicted_swe'], \n                cmap='viridis', \n                s=1, \n                edgecolor='none',\n               )\n\n    # Add a colorbar\n    cbar = plt.colorbar()\n    cbar.set_label('Predicted SWE')  # Label for the colorbar\n    \n    # Add labels and a legend\n    plt.xlabel('Longitude')\n    plt.ylabel('Latitude')\n    plt.title(f'SWE Prediction Map {test_start_date}')\n    plt.legend()\n\n    res_png_path = f\"{work_dir}/testing_output/{str(selected_date.year)}_{var_name}_{test_start_date}.png\"\n    plt.savefig(res_png_path)\n    print(f\"test image is saved at {res_png_path}\")\n    plt.close()\n\n# Uncomment the function call you want to use:\n# convert_csvs_to_images()\nconvert_csvs_to_images_simple()\n",
  "history_output" : "today date = 2023-10-09\ntest start date:  2023-09-15\ntest end date:  2023-10-09\n/home/chetana\nnew_value_ranges:  [1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 30]\ntest image is saved at /home/chetana/gridmet_test_run/testing_output/2023_predicted_swe_2023-09-15.png\n",
  "history_begin_time" : 1696862657427,
  "history_end_time" : 1696862669186,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "100001",
  "indicator" : "Done"
},{
  "history_id" : "nfcqghhvef1",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport uuid\nfrom snowcast_utils import day_index\nimport matplotlib.colors as mcolors\n\n# Import utility functions and variables from 'snowcast_utils'\nfrom snowcast_utils import work_dir, test_start_date\n\n# Define a custom colormap with specified colors and ranges\ncolors = [\n    (0.8627, 0.8627, 0.8627),  # #DCDCDC - 0 - 1\n    (0.8627, 1.0000, 1.0000),  # #DCFFFF - 1 - 2\n    (0.6000, 1.0000, 1.0000),  # #99FFFF - 2 - 4\n    (0.5569, 0.8235, 1.0000),  # #8ED2FF - 4 - 6\n    (0.4509, 0.6196, 0.8745),  # #739EDF - 6 - 8\n    (0.4157, 0.4706, 1.0000),  # #6A78FF - 8 - 10\n    (0.4235, 0.2784, 1.0000),  # #6C47FF - 10 - 12\n    (0.5529, 0.0980, 1.0000),  # #8D19FF - 12 - 14\n    (0.7333, 0.0000, 0.9176),  # #BB00EA - 14 - 16\n    (0.8392, 0.0000, 0.7490),  # #D600BF - 16 - 18\n    (0.7569, 0.0039, 0.4549),  # #C10074 - 18 - 20\n    (0.6784, 0.0000, 0.1961),  # #AD0032 - 20 - 30\n    (0.5020, 0.0000, 0.0000)   # #800000 - > 30\n]\n\ncmap_name = 'custom_snow_colormap'\ncustom_cmap = mcolors.ListedColormap(colors)\n\n# Define the lat_lon_to_map_coordinates function\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    \"\"\"\n    Convert latitude and longitude coordinates to map coordinates.\n\n    Args:\n        lon (float or array-like): Longitude coordinate(s).\n        lat (float or array-like): Latitude coordinate(s).\n        m (Basemap): Basemap object representing the map projection.\n\n    Returns:\n        tuple: Tuple containing the converted map coordinates (x, y).\n    \"\"\"\n    x, y = m(lon, lat)\n    return x, y\n\n# Define value ranges for color mapping\nfixed_value_ranges = [1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 30]\n\ndef create_color_maps_with_value_range(df_col, value_ranges=None):\n    \"\"\"\n    Create a colormap for value ranges and map data values to colors.\n\n    Args:\n        df_col (pd.Series): A Pandas Series containing data values.\n        value_ranges (list, optional): A list of value ranges for color mapping.\n            If not provided, the ranges will be determined automatically.\n\n    Returns:\n        tuple: Tuple containing the color mapping and the updated value ranges.\n    \"\"\"\n    new_value_ranges = value_ranges\n    if value_ranges is None:\n        max_value = df_col.max()\n        min_value = df_col.min()\n        if min_value < 0:\n            min_value = 0\n        step_size = (max_value - min_value) / 12\n\n        # Create 10 periods\n        new_value_ranges = [min_value + i * step_size for i in range(12)]\n    \n    print(\"new_value_ranges: \", new_value_ranges)\n  \n    # Define a custom function to map data values to colors\n    def map_value_to_color(value):\n        # Iterate through the value ranges to find the appropriate color index\n        for i, range_max in enumerate(new_value_ranges):\n            if value <= range_max:\n                return colors[i]\n\n        # If the value is greater than the largest range, return the last color\n        return colors[-1]\n\n    # Map predicted_swe values to colors using the custom function\n    color_mapping = [map_value_to_color(value) for value in df_col.values]\n    return color_mapping, new_value_ranges\n\ndef convert_csvs_to_images():\n    \"\"\"\n    Convert CSV data to images with color-coded SWE predictions.\n\n    Returns:\n        None\n    \"\"\"\n    global fixed_value_ranges\n    data = pd.read_csv(\"/home/chetana/gridmet_test_run/test_data_predicted.csv\")\n    print(\"statistic of predicted_swe: \", data['predicted_swe'].describe())\n    data['predicted_swe'].fillna(0, inplace=True)\n    \n    for column in data.columns:\n        column_data = data[column]\n        print(column_data.describe())\n    \n    # Create a figure with a white background\n    fig = plt.figure(facecolor='white')\n\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    x, y = m(data['lon'].values, data['lat'].values)\n    print(data.columns)\n\n    color_mapping, value_ranges = create_color_maps_with_value_range(data[\"predicted_swe\"], fixed_value_ranges)\n    \n    # Plot the data using the custom colormap\n    plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\n    \n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_date = datetime(1900, 1, 1)\n    day_value = day_index\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    timestamp_string = result_date.strftime(\"%Y-%m-%d\")\n    \n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    # Create custom legend elements using the same colormap\n    legend_elements = [Patch(color=colors[i], label=f\"{value_ranges[i]} - {value_ranges[i+1]-1}\" if i < len(value_ranges) - 1 else f\"> {value_ranges[-1]}\") for i in range(len(value_ranges))]\n\n    # Create the legend outside the map\n    legend = plt.legend(handles=legend_elements, loc='upper left', title='Legend', fontsize=8)\n    legend.set_bbox_to_anchor((1.01, 1)) \n\n    # Remove the color bar\n    #plt.colorbar().remove()\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Set the aspect ratio to 'equal' to keep the plot at the center\n    plt.gca().set_aspect('equal', adjustable='box')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15, right=0.80)  # Adjust right margin to accommodate the legend\n    # Show the plot or save it to a file\n    new_plot_path = f'/home/chetana/gridmet_test_run/predicted_swe-{test_start_date}.png'\n    print(f\"The new plot is saved to {new_plot_path}\")\n    plt.savefig(new_plot_path)\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\ndef convert_csvs_to_images_simple():\n    \"\"\"\n    Convert CSV data to simple scatter plot images for predicted SWE.\n\n    Returns:\n        None\n    \"\"\"\n    selected_date = datetime.strptime(test_start_date, \"%Y-%m-%d\")\n    var_name = \"predicted_swe\"\n    test_csv = \"/home/chetana/gridmet_test_run/test_data_predicted.csv\"\n    result_var_df = pd.read_csv(test_csv)\n    result_var_df.replace('--', pd.NA, inplace=True)\n    result_var_df.dropna(inplace=True)\n    result_var_df[var_name] = pd.to_numeric(result_var_df[var_name], errors='coerce')\n    \n    colormaplist, value_ranges = create_color_maps_with_value_range(result_var_df[var_name], fixed_value_ranges)\n\n    # Create a scatter plot\n    plt.scatter(result_var_df[\"lon\"].values, \n                result_var_df[\"lat\"].values, \n                label='Predicted SWE', \n                c=result_var_df['predicted_swe'], \n                cmap='viridis', \n                s=1, \n                edgecolor='none',\n               )\n\n    # Add a colorbar\n    cbar = plt.colorbar()\n    cbar.set_label('Predicted SWE')  # Label for the colorbar\n    \n    # Add labels and a legend\n    plt.xlabel('Longitude')\n    plt.ylabel('Latitude')\n    plt.title(f'SWE Prediction Map {test_start_date}')\n    plt.legend()\n\n    res_png_path = f\"{work_dir}/testing_output/{str(selected_date.year)}_{var_name}_{test_start_date}.png\"\n    plt.savefig(res_png_path)\n    print(f\"test image is saved at {res_png_path}\")\n    plt.close()\n\n# Uncomment the function call you want to use:\n# convert_csvs_to_images()\nconvert_csvs_to_images_simple()\n",
  "history_output" : "today date = 2023-10-09\ntest start date:  2023-06-15\ntest end date:  2023-10-09\n/home/chetana\nnew_value_ranges:  [1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 30]\ntest image is saved at /home/chetana/gridmet_test_run/testing_output/2023_predicted_swe_2023-06-15.png\n",
  "history_begin_time" : 1696832487213,
  "history_end_time" : 1696832494342,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "100001",
  "indicator" : "Done"
},{
  "history_id" : "flsqiylzed7",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport uuid\nfrom snowcast_utils import day_index\nimport matplotlib.colors as mcolors\n\n# Import utility functions and variables from 'snowcast_utils'\nfrom snowcast_utils import work_dir, test_start_date\n\n# Define a custom colormap with specified colors and ranges\ncolors = [\n    (0.8627, 0.8627, 0.8627),  # #DCDCDC - 0 - 1\n    (0.8627, 1.0000, 1.0000),  # #DCFFFF - 1 - 2\n    (0.6000, 1.0000, 1.0000),  # #99FFFF - 2 - 4\n    (0.5569, 0.8235, 1.0000),  # #8ED2FF - 4 - 6\n    (0.4509, 0.6196, 0.8745),  # #739EDF - 6 - 8\n    (0.4157, 0.4706, 1.0000),  # #6A78FF - 8 - 10\n    (0.4235, 0.2784, 1.0000),  # #6C47FF - 10 - 12\n    (0.5529, 0.0980, 1.0000),  # #8D19FF - 12 - 14\n    (0.7333, 0.0000, 0.9176),  # #BB00EA - 14 - 16\n    (0.8392, 0.0000, 0.7490),  # #D600BF - 16 - 18\n    (0.7569, 0.0039, 0.4549),  # #C10074 - 18 - 20\n    (0.6784, 0.0000, 0.1961),  # #AD0032 - 20 - 30\n    (0.5020, 0.0000, 0.0000)   # #800000 - > 30\n]\n\ncmap_name = 'custom_snow_colormap'\ncustom_cmap = mcolors.ListedColormap(colors)\n\n# Define the lat_lon_to_map_coordinates function\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    \"\"\"\n    Convert latitude and longitude coordinates to map coordinates.\n\n    Args:\n        lon (float or array-like): Longitude coordinate(s).\n        lat (float or array-like): Latitude coordinate(s).\n        m (Basemap): Basemap object representing the map projection.\n\n    Returns:\n        tuple: Tuple containing the converted map coordinates (x, y).\n    \"\"\"\n    x, y = m(lon, lat)\n    return x, y\n\n# Define value ranges for color mapping\nfixed_value_ranges = [1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 30]\n\ndef create_color_maps_with_value_range(df_col, value_ranges=None):\n    \"\"\"\n    Create a colormap for value ranges and map data values to colors.\n\n    Args:\n        df_col (pd.Series): A Pandas Series containing data values.\n        value_ranges (list, optional): A list of value ranges for color mapping.\n            If not provided, the ranges will be determined automatically.\n\n    Returns:\n        tuple: Tuple containing the color mapping and the updated value ranges.\n    \"\"\"\n    new_value_ranges = value_ranges\n    if value_ranges is None:\n        max_value = df_col.max()\n        min_value = df_col.min()\n        if min_value < 0:\n            min_value = 0\n        step_size = (max_value - min_value) / 12\n\n        # Create 10 periods\n        new_value_ranges = [min_value + i * step_size for i in range(12)]\n    \n    print(\"new_value_ranges: \", new_value_ranges)\n  \n    # Define a custom function to map data values to colors\n    def map_value_to_color(value):\n        # Iterate through the value ranges to find the appropriate color index\n        for i, range_max in enumerate(new_value_ranges):\n            if value <= range_max:\n                return colors[i]\n\n        # If the value is greater than the largest range, return the last color\n        return colors[-1]\n\n    # Map predicted_swe values to colors using the custom function\n    color_mapping = [map_value_to_color(value) for value in df_col.values]\n    return color_mapping, new_value_ranges\n\ndef convert_csvs_to_images():\n    \"\"\"\n    Convert CSV data to images with color-coded SWE predictions.\n\n    Returns:\n        None\n    \"\"\"\n    global fixed_value_ranges\n    data = pd.read_csv(\"/home/chetana/gridmet_test_run/test_data_predicted.csv\")\n    print(\"statistic of predicted_swe: \", data['predicted_swe'].describe())\n    data['predicted_swe'].fillna(0, inplace=True)\n    \n    for column in data.columns:\n        column_data = data[column]\n        print(column_data.describe())\n    \n    # Create a figure with a white background\n    fig = plt.figure(facecolor='white')\n\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    x, y = m(data['lon'].values, data['lat'].values)\n    print(data.columns)\n\n    color_mapping, value_ranges = create_color_maps_with_value_range(data[\"predicted_swe\"], fixed_value_ranges)\n    \n    # Plot the data using the custom colormap\n    plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\n    \n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_date = datetime(1900, 1, 1)\n    day_value = day_index\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    timestamp_string = result_date.strftime(\"%Y-%m-%d\")\n    \n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    # Create custom legend elements using the same colormap\n    legend_elements = [Patch(color=colors[i], label=f\"{value_ranges[i]} - {value_ranges[i+1]-1}\" if i < len(value_ranges) - 1 else f\"> {value_ranges[-1]}\") for i in range(len(value_ranges))]\n\n    # Create the legend outside the map\n    legend = plt.legend(handles=legend_elements, loc='upper left', title='Legend', fontsize=8)\n    legend.set_bbox_to_anchor((1.01, 1)) \n\n    # Remove the color bar\n    #plt.colorbar().remove()\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Set the aspect ratio to 'equal' to keep the plot at the center\n    plt.gca().set_aspect('equal', adjustable='box')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15, right=0.80)  # Adjust right margin to accommodate the legend\n    # Show the plot or save it to a file\n    new_plot_path = f'/home/chetana/gridmet_test_run/predicted_swe-{test_start_date}.png'\n    print(f\"The new plot is saved to {new_plot_path}\")\n    plt.savefig(new_plot_path)\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\ndef convert_csvs_to_images_simple():\n    \"\"\"\n    Convert CSV data to simple scatter plot images for predicted SWE.\n\n    Returns:\n        None\n    \"\"\"\n    selected_date = datetime.strptime(test_start_date, \"%Y-%m-%d\")\n    var_name = \"predicted_swe\"\n    test_csv = \"/home/chetana/gridmet_test_run/test_data_predicted.csv\"\n    result_var_df = pd.read_csv(test_csv)\n    result_var_df.replace('--', pd.NA, inplace=True)\n    result_var_df.dropna(inplace=True)\n    result_var_df[var_name] = pd.to_numeric(result_var_df[var_name], errors='coerce')\n    \n    colormaplist, value_ranges = create_color_maps_with_value_range(result_var_df[var_name], fixed_value_ranges)\n\n    # Create a scatter plot\n    plt.scatter(result_var_df[\"lon\"].values, \n                result_var_df[\"lat\"].values, \n                label='Predicted SWE', \n                c=result_var_df['predicted_swe'], \n                cmap='viridis', \n                s=1, \n                edgecolor='none',\n               )\n\n    # Add a colorbar\n    cbar = plt.colorbar()\n    cbar.set_label('Predicted SWE')  # Label for the colorbar\n    \n    # Add labels and a legend\n    plt.xlabel('Longitude')\n    plt.ylabel('Latitude')\n    plt.title(f'SWE Prediction Map {test_start_date}')\n    plt.legend()\n\n    res_png_path = f\"{work_dir}/testing_output/{str(selected_date.year)}_{var_name}_{test_start_date}.png\"\n    plt.savefig(res_png_path)\n    print(f\"test image is saved at {res_png_path}\")\n    plt.close()\n\n# Uncomment the function call you want to use:\n# convert_csvs_to_images()\nconvert_csvs_to_images_simple()\n",
  "history_output" : "today date = 2023-10-09\ntest start date:  2023-02-12\ntest end date:  2023-10-09\n/home/chetana\nnew_value_ranges:  [1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 30]\ntest image is saved at /home/chetana/gridmet_test_run/testing_output/2023_predicted_swe_2023-02-12.png\n",
  "history_begin_time" : 1696832092482,
  "history_end_time" : 1696832099844,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "100001",
  "indicator" : "Done"
},{
  "history_id" : "xa70dg04m2r",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport uuid\nfrom snowcast_utils import day_index\nimport matplotlib.colors as mcolors\n\n# Import utility functions and variables from 'snowcast_utils'\nfrom snowcast_utils import work_dir, test_start_date\n\n# Define a custom colormap with specified colors and ranges\ncolors = [\n    (0.8627, 0.8627, 0.8627),  # #DCDCDC - 0 - 1\n    (0.8627, 1.0000, 1.0000),  # #DCFFFF - 1 - 2\n    (0.6000, 1.0000, 1.0000),  # #99FFFF - 2 - 4\n    (0.5569, 0.8235, 1.0000),  # #8ED2FF - 4 - 6\n    (0.4509, 0.6196, 0.8745),  # #739EDF - 6 - 8\n    (0.4157, 0.4706, 1.0000),  # #6A78FF - 8 - 10\n    (0.4235, 0.2784, 1.0000),  # #6C47FF - 10 - 12\n    (0.5529, 0.0980, 1.0000),  # #8D19FF - 12 - 14\n    (0.7333, 0.0000, 0.9176),  # #BB00EA - 14 - 16\n    (0.8392, 0.0000, 0.7490),  # #D600BF - 16 - 18\n    (0.7569, 0.0039, 0.4549),  # #C10074 - 18 - 20\n    (0.6784, 0.0000, 0.1961),  # #AD0032 - 20 - 30\n    (0.5020, 0.0000, 0.0000)   # #800000 - > 30\n]\n\ncmap_name = 'custom_snow_colormap'\ncustom_cmap = mcolors.ListedColormap(colors)\n\n# Define the lat_lon_to_map_coordinates function\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    \"\"\"\n    Convert latitude and longitude coordinates to map coordinates.\n\n    Args:\n        lon (float or array-like): Longitude coordinate(s).\n        lat (float or array-like): Latitude coordinate(s).\n        m (Basemap): Basemap object representing the map projection.\n\n    Returns:\n        tuple: Tuple containing the converted map coordinates (x, y).\n    \"\"\"\n    x, y = m(lon, lat)\n    return x, y\n\n# Define value ranges for color mapping\nfixed_value_ranges = [1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 30]\n\ndef create_color_maps_with_value_range(df_col, value_ranges=None):\n    \"\"\"\n    Create a colormap for value ranges and map data values to colors.\n\n    Args:\n        df_col (pd.Series): A Pandas Series containing data values.\n        value_ranges (list, optional): A list of value ranges for color mapping.\n            If not provided, the ranges will be determined automatically.\n\n    Returns:\n        tuple: Tuple containing the color mapping and the updated value ranges.\n    \"\"\"\n    new_value_ranges = value_ranges\n    if value_ranges is None:\n        max_value = df_col.max()\n        min_value = df_col.min()\n        if min_value < 0:\n            min_value = 0\n        step_size = (max_value - min_value) / 12\n\n        # Create 10 periods\n        new_value_ranges = [min_value + i * step_size for i in range(12)]\n    \n    print(\"new_value_ranges: \", new_value_ranges)\n  \n    # Define a custom function to map data values to colors\n    def map_value_to_color(value):\n        # Iterate through the value ranges to find the appropriate color index\n        for i, range_max in enumerate(new_value_ranges):\n            if value <= range_max:\n                return colors[i]\n\n        # If the value is greater than the largest range, return the last color\n        return colors[-1]\n\n    # Map predicted_swe values to colors using the custom function\n    color_mapping = [map_value_to_color(value) for value in df_col.values]\n    return color_mapping, new_value_ranges\n\ndef convert_csvs_to_images():\n    \"\"\"\n    Convert CSV data to images with color-coded SWE predictions.\n\n    Returns:\n        None\n    \"\"\"\n    global fixed_value_ranges\n    data = pd.read_csv(\"/home/chetana/gridmet_test_run/test_data_predicted.csv\")\n    print(\"statistic of predicted_swe: \", data['predicted_swe'].describe())\n    data['predicted_swe'].fillna(0, inplace=True)\n    \n    for column in data.columns:\n        column_data = data[column]\n        print(column_data.describe())\n    \n    # Create a figure with a white background\n    fig = plt.figure(facecolor='white')\n\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    x, y = m(data['lon'].values, data['lat'].values)\n    print(data.columns)\n\n    color_mapping, value_ranges = create_color_maps_with_value_range(data[\"predicted_swe\"], fixed_value_ranges)\n    \n    # Plot the data using the custom colormap\n    plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\n    \n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_date = datetime(1900, 1, 1)\n    day_value = day_index\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    timestamp_string = result_date.strftime(\"%Y-%m-%d\")\n    \n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    # Create custom legend elements using the same colormap\n    legend_elements = [Patch(color=colors[i], label=f\"{value_ranges[i]} - {value_ranges[i+1]-1}\" if i < len(value_ranges) - 1 else f\"> {value_ranges[-1]}\") for i in range(len(value_ranges))]\n\n    # Create the legend outside the map\n    legend = plt.legend(handles=legend_elements, loc='upper left', title='Legend', fontsize=8)\n    legend.set_bbox_to_anchor((1.01, 1)) \n\n    # Remove the color bar\n    #plt.colorbar().remove()\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Set the aspect ratio to 'equal' to keep the plot at the center\n    plt.gca().set_aspect('equal', adjustable='box')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15, right=0.80)  # Adjust right margin to accommodate the legend\n    # Show the plot or save it to a file\n    new_plot_path = f'/home/chetana/gridmet_test_run/predicted_swe-{test_start_date}.png'\n    print(f\"The new plot is saved to {new_plot_path}\")\n    plt.savefig(new_plot_path)\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\ndef convert_csvs_to_images_simple():\n    \"\"\"\n    Convert CSV data to simple scatter plot images for predicted SWE.\n\n    Returns:\n        None\n    \"\"\"\n    selected_date = datetime.strptime(test_start_date, \"%Y-%m-%d\")\n    var_name = \"predicted_swe\"\n    test_csv = \"/home/chetana/gridmet_test_run/test_data_predicted.csv\"\n    result_var_df = pd.read_csv(test_csv)\n    result_var_df.replace('--', pd.NA, inplace=True)\n    result_var_df.dropna(inplace=True)\n    result_var_df[var_name] = pd.to_numeric(result_var_df[var_name], errors='coerce')\n    \n    colormaplist, value_ranges = create_color_maps_with_value_range(result_var_df[var_name], fixed_value_ranges)\n\n    # Create a scatter plot\n    plt.scatter(result_var_df[\"lon\"].values, \n                result_var_df[\"lat\"].values, \n                label='Predicted SWE', \n                c=result_var_df['predicted_swe'], \n                cmap='viridis', \n                s=1, \n                edgecolor='none',\n               )\n\n    # Add a colorbar\n    cbar = plt.colorbar()\n    cbar.set_label('Predicted SWE')  # Label for the colorbar\n    \n    # Add labels and a legend\n    plt.xlabel('Longitude')\n    plt.ylabel('Latitude')\n    plt.title(f'SWE Prediction Map {test_start_date}')\n    plt.legend()\n\n    res_png_path = f\"{work_dir}/testing_output/{str(selected_date.year)}_{var_name}_{test_start_date}.png\"\n    plt.savefig(res_png_path)\n    print(f\"test image is saved at {res_png_path}\")\n    plt.close()\n\n# Uncomment the function call you want to use:\n# convert_csvs_to_images()\nconvert_csvs_to_images_simple()\n",
  "history_output" : "today date = 2023-10-09\ntest start date:  2023-02-11\ntest end date:  2023-10-09\n/home/chetana\nnew_value_ranges:  [1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 30]\ntest image is saved at /home/chetana/gridmet_test_run/testing_output/2023_predicted_swe_2023-02-11.png\n",
  "history_begin_time" : 1696830416463,
  "history_end_time" : 1696830427385,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "100001",
  "indicator" : "Done"
},{
  "history_id" : "OfcjQRi2izt6",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport uuid\nfrom snowcast_utils import day_index\nimport matplotlib.colors as mcolors\n\n# Import utility functions and variables from 'snowcast_utils'\nfrom snowcast_utils import work_dir, test_start_date\n\n# Define a custom colormap with specified colors and ranges\ncolors = [\n    (0.8627, 0.8627, 0.8627),  # #DCDCDC - 0 - 1\n    (0.8627, 1.0000, 1.0000),  # #DCFFFF - 1 - 2\n    (0.6000, 1.0000, 1.0000),  # #99FFFF - 2 - 4\n    (0.5569, 0.8235, 1.0000),  # #8ED2FF - 4 - 6\n    (0.4509, 0.6196, 0.8745),  # #739EDF - 6 - 8\n    (0.4157, 0.4706, 1.0000),  # #6A78FF - 8 - 10\n    (0.4235, 0.2784, 1.0000),  # #6C47FF - 10 - 12\n    (0.5529, 0.0980, 1.0000),  # #8D19FF - 12 - 14\n    (0.7333, 0.0000, 0.9176),  # #BB00EA - 14 - 16\n    (0.8392, 0.0000, 0.7490),  # #D600BF - 16 - 18\n    (0.7569, 0.0039, 0.4549),  # #C10074 - 18 - 20\n    (0.6784, 0.0000, 0.1961),  # #AD0032 - 20 - 30\n    (0.5020, 0.0000, 0.0000)   # #800000 - > 30\n]\n\ncmap_name = 'custom_snow_colormap'\ncustom_cmap = mcolors.ListedColormap(colors)\n\n# Define the lat_lon_to_map_coordinates function\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    \"\"\"\n    Convert latitude and longitude coordinates to map coordinates.\n\n    Args:\n        lon (float or array-like): Longitude coordinate(s).\n        lat (float or array-like): Latitude coordinate(s).\n        m (Basemap): Basemap object representing the map projection.\n\n    Returns:\n        tuple: Tuple containing the converted map coordinates (x, y).\n    \"\"\"\n    x, y = m(lon, lat)\n    return x, y\n\n# Define value ranges for color mapping\nfixed_value_ranges = [1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 30]\n\ndef create_color_maps_with_value_range(df_col, value_ranges=None):\n    \"\"\"\n    Create a colormap for value ranges and map data values to colors.\n\n    Args:\n        df_col (pd.Series): A Pandas Series containing data values.\n        value_ranges (list, optional): A list of value ranges for color mapping.\n            If not provided, the ranges will be determined automatically.\n\n    Returns:\n        tuple: Tuple containing the color mapping and the updated value ranges.\n    \"\"\"\n    new_value_ranges = value_ranges\n    if value_ranges is None:\n        max_value = df_col.max()\n        min_value = df_col.min()\n        if min_value < 0:\n            min_value = 0\n        step_size = (max_value - min_value) / 12\n\n        # Create 10 periods\n        new_value_ranges = [min_value + i * step_size for i in range(12)]\n    \n    print(\"new_value_ranges: \", new_value_ranges)\n  \n    # Define a custom function to map data values to colors\n    def map_value_to_color(value):\n        # Iterate through the value ranges to find the appropriate color index\n        for i, range_max in enumerate(new_value_ranges):\n            if value <= range_max:\n                return colors[i]\n\n        # If the value is greater than the largest range, return the last color\n        return colors[-1]\n\n    # Map predicted_swe values to colors using the custom function\n    color_mapping = [map_value_to_color(value) for value in df_col.values]\n    return color_mapping, new_value_ranges\n\ndef convert_csvs_to_images():\n    \"\"\"\n    Convert CSV data to images with color-coded SWE predictions.\n\n    Returns:\n        None\n    \"\"\"\n    global fixed_value_ranges\n    data = pd.read_csv(\"/home/chetana/gridmet_test_run/test_data_predicted.csv\")\n    print(\"statistic of predicted_swe: \", data['predicted_swe'].describe())\n    data['predicted_swe'].fillna(0, inplace=True)\n    \n    for column in data.columns:\n        column_data = data[column]\n        print(column_data.describe())\n    \n    # Create a figure with a white background\n    fig = plt.figure(facecolor='white')\n\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    x, y = m(data['lon'].values, data['lat'].values)\n    print(data.columns)\n\n    color_mapping, value_ranges = create_color_maps_with_value_range(data[\"predicted_swe\"], fixed_value_ranges)\n    \n    # Plot the data using the custom colormap\n    plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\n    \n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_date = datetime(1900, 1, 1)\n    day_value = day_index\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    timestamp_string = result_date.strftime(\"%Y-%m-%d\")\n    \n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    # Create custom legend elements using the same colormap\n    legend_elements = [Patch(color=colors[i], label=f\"{value_ranges[i]} - {value_ranges[i+1]-1}\" if i < len(value_ranges) - 1 else f\"> {value_ranges[-1]}\") for i in range(len(value_ranges))]\n\n    # Create the legend outside the map\n    legend = plt.legend(handles=legend_elements, loc='upper left', title='Legend', fontsize=8)\n    legend.set_bbox_to_anchor((1.01, 1)) \n\n    # Remove the color bar\n    #plt.colorbar().remove()\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Set the aspect ratio to 'equal' to keep the plot at the center\n    plt.gca().set_aspect('equal', adjustable='box')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15, right=0.80)  # Adjust right margin to accommodate the legend\n    # Show the plot or save it to a file\n    new_plot_path = f'/home/chetana/gridmet_test_run/predicted_swe-{test_start_date}.png'\n    print(f\"The new plot is saved to {new_plot_path}\")\n    plt.savefig(new_plot_path)\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\ndef convert_csvs_to_images_simple():\n    \"\"\"\n    Convert CSV data to simple scatter plot images for predicted SWE.\n\n    Returns:\n        None\n    \"\"\"\n    selected_date = datetime.strptime(test_start_date, \"%Y-%m-%d\")\n    var_name = \"predicted_swe\"\n    test_csv = \"/home/chetana/gridmet_test_run/test_data_predicted.csv\"\n    result_var_df = pd.read_csv(test_csv)\n    result_var_df.replace('--', pd.NA, inplace=True)\n    result_var_df.dropna(inplace=True)\n    result_var_df[var_name] = pd.to_numeric(result_var_df[var_name], errors='coerce')\n    \n    colormaplist, value_ranges = create_color_maps_with_value_range(result_var_df[var_name], fixed_value_ranges)\n\n    # Create a scatter plot\n    plt.scatter(result_var_df[\"lon\"].values, \n                result_var_df[\"lat\"].values, \n                label='Predicted SWE', \n                c=result_var_df['predicted_swe'], \n                cmap='viridis', \n                s=1, \n                edgecolor='none',\n               )\n\n    # Add a colorbar\n    cbar = plt.colorbar()\n    cbar.set_label('Predicted SWE')  # Label for the colorbar\n    \n    # Add labels and a legend\n    plt.xlabel('Longitude')\n    plt.ylabel('Latitude')\n    plt.title(f'SWE Prediction Map {test_start_date}')\n    plt.legend()\n\n    res_png_path = f\"{work_dir}/testing_output/{str(selected_date.year)}_{var_name}_{test_start_date}.png\"\n    plt.savefig(res_png_path)\n    print(f\"test image is saved at {res_png_path}\")\n    plt.close()\n\n# Uncomment the function call you want to use:\n# convert_csvs_to_images()\nconvert_csvs_to_images_simple()\n",
  "history_output" : "today date = 2023-10-09\ntest start date:  2023-02-10\ntest end date:  2023-10-09\n/home/chetana\nnew_value_ranges:  [1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 30]\ntest image is saved at /home/chetana/gridmet_test_run/testing_output/2023_predicted_swe_2023-02-10.png\n",
  "history_begin_time" : 1696829966186,
  "history_end_time" : 1696829976411,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "nTvtBD1hs3ja",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport uuid\nfrom snowcast_utils import day_index\nimport matplotlib.colors as mcolors\n\n# Import utility functions and variables from 'snowcast_utils'\nfrom snowcast_utils import work_dir, test_start_date\n\n# Define a custom colormap with specified colors and ranges\ncolors = [\n    (0.8627, 0.8627, 0.8627),  # #DCDCDC - 0 - 1\n    (0.8627, 1.0000, 1.0000),  # #DCFFFF - 1 - 2\n    (0.6000, 1.0000, 1.0000),  # #99FFFF - 2 - 4\n    (0.5569, 0.8235, 1.0000),  # #8ED2FF - 4 - 6\n    (0.4509, 0.6196, 0.8745),  # #739EDF - 6 - 8\n    (0.4157, 0.4706, 1.0000),  # #6A78FF - 8 - 10\n    (0.4235, 0.2784, 1.0000),  # #6C47FF - 10 - 12\n    (0.5529, 0.0980, 1.0000),  # #8D19FF - 12 - 14\n    (0.7333, 0.0000, 0.9176),  # #BB00EA - 14 - 16\n    (0.8392, 0.0000, 0.7490),  # #D600BF - 16 - 18\n    (0.7569, 0.0039, 0.4549),  # #C10074 - 18 - 20\n    (0.6784, 0.0000, 0.1961),  # #AD0032 - 20 - 30\n    (0.5020, 0.0000, 0.0000)   # #800000 - > 30\n]\n\ncmap_name = 'custom_snow_colormap'\ncustom_cmap = mcolors.ListedColormap(colors)\n\n# Define the lat_lon_to_map_coordinates function\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    \"\"\"\n    Convert latitude and longitude coordinates to map coordinates.\n\n    Args:\n        lon (float or array-like): Longitude coordinate(s).\n        lat (float or array-like): Latitude coordinate(s).\n        m (Basemap): Basemap object representing the map projection.\n\n    Returns:\n        tuple: Tuple containing the converted map coordinates (x, y).\n    \"\"\"\n    x, y = m(lon, lat)\n    return x, y\n\n# Define value ranges for color mapping\nfixed_value_ranges = [1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 30]\n\ndef create_color_maps_with_value_range(df_col, value_ranges=None):\n    \"\"\"\n    Create a colormap for value ranges and map data values to colors.\n\n    Args:\n        df_col (pd.Series): A Pandas Series containing data values.\n        value_ranges (list, optional): A list of value ranges for color mapping.\n            If not provided, the ranges will be determined automatically.\n\n    Returns:\n        tuple: Tuple containing the color mapping and the updated value ranges.\n    \"\"\"\n    new_value_ranges = value_ranges\n    if value_ranges is None:\n        max_value = df_col.max()\n        min_value = df_col.min()\n        if min_value < 0:\n            min_value = 0\n        step_size = (max_value - min_value) / 12\n\n        # Create 10 periods\n        new_value_ranges = [min_value + i * step_size for i in range(12)]\n    \n    print(\"new_value_ranges: \", new_value_ranges)\n  \n    # Define a custom function to map data values to colors\n    def map_value_to_color(value):\n        # Iterate through the value ranges to find the appropriate color index\n        for i, range_max in enumerate(new_value_ranges):\n            if value <= range_max:\n                return colors[i]\n\n        # If the value is greater than the largest range, return the last color\n        return colors[-1]\n\n    # Map predicted_swe values to colors using the custom function\n    color_mapping = [map_value_to_color(value) for value in df_col.values]\n    return color_mapping, new_value_ranges\n\ndef convert_csvs_to_images():\n    \"\"\"\n    Convert CSV data to images with color-coded SWE predictions.\n\n    Returns:\n        None\n    \"\"\"\n    global fixed_value_ranges\n    data = pd.read_csv(\"/home/chetana/gridmet_test_run/test_data_predicted.csv\")\n    print(\"statistic of predicted_swe: \", data['predicted_swe'].describe())\n    data['predicted_swe'].fillna(0, inplace=True)\n    \n    for column in data.columns:\n        column_data = data[column]\n        print(column_data.describe())\n    \n    # Create a figure with a white background\n    fig = plt.figure(facecolor='white')\n\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    x, y = m(data['lon'].values, data['lat'].values)\n    print(data.columns)\n\n    color_mapping, value_ranges = create_color_maps_with_value_range(data[\"predicted_swe\"], fixed_value_ranges)\n    \n    # Plot the data using the custom colormap\n    plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\n    \n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_date = datetime(1900, 1, 1)\n    day_value = day_index\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    timestamp_string = result_date.strftime(\"%Y-%m-%d\")\n    \n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    # Create custom legend elements using the same colormap\n    legend_elements = [Patch(color=colors[i], label=f\"{value_ranges[i]} - {value_ranges[i+1]-1}\" if i < len(value_ranges) - 1 else f\"> {value_ranges[-1]}\") for i in range(len(value_ranges))]\n\n    # Create the legend outside the map\n    legend = plt.legend(handles=legend_elements, loc='upper left', title='Legend', fontsize=8)\n    legend.set_bbox_to_anchor((1.01, 1)) \n\n    # Remove the color bar\n    #plt.colorbar().remove()\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Set the aspect ratio to 'equal' to keep the plot at the center\n    plt.gca().set_aspect('equal', adjustable='box')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15, right=0.80)  # Adjust right margin to accommodate the legend\n    # Show the plot or save it to a file\n    new_plot_path = f'/home/chetana/gridmet_test_run/predicted_swe-{test_start_date}.png'\n    print(f\"The new plot is saved to {new_plot_path}\")\n    plt.savefig(new_plot_path)\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\ndef convert_csvs_to_images_simple():\n    \"\"\"\n    Convert CSV data to simple scatter plot images for predicted SWE.\n\n    Returns:\n        None\n    \"\"\"\n    selected_date = datetime.strptime(test_start_date, \"%Y-%m-%d\")\n    var_name = \"predicted_swe\"\n    test_csv = \"/home/chetana/gridmet_test_run/test_data_predicted.csv\"\n    result_var_df = pd.read_csv(test_csv)\n    result_var_df.replace('--', pd.NA, inplace=True)\n    result_var_df.dropna(inplace=True)\n    result_var_df[var_name] = pd.to_numeric(result_var_df[var_name], errors='coerce')\n    \n    colormaplist, value_ranges = create_color_maps_with_value_range(result_var_df[var_name], fixed_value_ranges)\n\n    # Create a scatter plot\n    plt.scatter(result_var_df[\"lon\"].values, \n                result_var_df[\"lat\"].values, \n                label='Predicted SWE', \n                c=result_var_df['predicted_swe'], \n                cmap='viridis', \n                s=1, \n                edgecolor='none',\n               )\n\n    # Add a colorbar\n    cbar = plt.colorbar()\n    cbar.set_label('Predicted SWE')  # Label for the colorbar\n    \n    # Add labels and a legend\n    plt.xlabel('Longitude')\n    plt.ylabel('Latitude')\n    plt.title(f'SWE Prediction Map {test_start_date}')\n    plt.legend()\n\n    res_png_path = f\"{work_dir}/testing_output/{str(selected_date.year)}_{var_name}_{test_start_date}.png\"\n    plt.savefig(res_png_path)\n    print(f\"test image is saved at {res_png_path}\")\n    plt.close()\n\n# Uncomment the function call you want to use:\n# convert_csvs_to_images()\nconvert_csvs_to_images_simple()\n",
  "history_output" : "today date = 2023-10-08\ntest start date:  2023-02-10\ntest end date:  2023-10-08\n/home/chetana\nnew_value_ranges:  [1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 30]\ntest image is saved at /home/chetana/gridmet_test_run/testing_output/2023_predicted_swe_2023-02-10.png\n",
  "history_begin_time" : 1696787765418,
  "history_end_time" : 1696787770738,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "2tjn2htnjfp",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport uuid\nfrom snowcast_utils import day_index\nimport matplotlib.colors as mcolors\n\n# Import utility functions and variables from 'snowcast_utils'\nfrom snowcast_utils import work_dir, test_start_date\n\n# Define a custom colormap with specified colors and ranges\ncolors = [\n    (0.8627, 0.8627, 0.8627),  # #DCDCDC - 0 - 1\n    (0.8627, 1.0000, 1.0000),  # #DCFFFF - 1 - 2\n    (0.6000, 1.0000, 1.0000),  # #99FFFF - 2 - 4\n    (0.5569, 0.8235, 1.0000),  # #8ED2FF - 4 - 6\n    (0.4509, 0.6196, 0.8745),  # #739EDF - 6 - 8\n    (0.4157, 0.4706, 1.0000),  # #6A78FF - 8 - 10\n    (0.4235, 0.2784, 1.0000),  # #6C47FF - 10 - 12\n    (0.5529, 0.0980, 1.0000),  # #8D19FF - 12 - 14\n    (0.7333, 0.0000, 0.9176),  # #BB00EA - 14 - 16\n    (0.8392, 0.0000, 0.7490),  # #D600BF - 16 - 18\n    (0.7569, 0.0039, 0.4549),  # #C10074 - 18 - 20\n    (0.6784, 0.0000, 0.1961),  # #AD0032 - 20 - 30\n    (0.5020, 0.0000, 0.0000)   # #800000 - > 30\n]\n\ncmap_name = 'custom_snow_colormap'\ncustom_cmap = mcolors.ListedColormap(colors)\n\n# Define the lat_lon_to_map_coordinates function\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    \"\"\"\n    Convert latitude and longitude coordinates to map coordinates.\n\n    Args:\n        lon (float or array-like): Longitude coordinate(s).\n        lat (float or array-like): Latitude coordinate(s).\n        m (Basemap): Basemap object representing the map projection.\n\n    Returns:\n        tuple: Tuple containing the converted map coordinates (x, y).\n    \"\"\"\n    x, y = m(lon, lat)\n    return x, y\n\n# Define value ranges for color mapping\nfixed_value_ranges = [1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 30]\n\ndef create_color_maps_with_value_range(df_col, value_ranges=None):\n    \"\"\"\n    Create a colormap for value ranges and map data values to colors.\n\n    Args:\n        df_col (pd.Series): A Pandas Series containing data values.\n        value_ranges (list, optional): A list of value ranges for color mapping.\n            If not provided, the ranges will be determined automatically.\n\n    Returns:\n        tuple: Tuple containing the color mapping and the updated value ranges.\n    \"\"\"\n    new_value_ranges = value_ranges\n    if value_ranges is None:\n        max_value = df_col.max()\n        min_value = df_col.min()\n        if min_value < 0:\n            min_value = 0\n        step_size = (max_value - min_value) / 12\n\n        # Create 10 periods\n        new_value_ranges = [min_value + i * step_size for i in range(12)]\n    \n    print(\"new_value_ranges: \", new_value_ranges)\n  \n    # Define a custom function to map data values to colors\n    def map_value_to_color(value):\n        # Iterate through the value ranges to find the appropriate color index\n        for i, range_max in enumerate(new_value_ranges):\n            if value <= range_max:\n                return colors[i]\n\n        # If the value is greater than the largest range, return the last color\n        return colors[-1]\n\n    # Map predicted_swe values to colors using the custom function\n    color_mapping = [map_value_to_color(value) for value in df_col.values]\n    return color_mapping, new_value_ranges\n\ndef convert_csvs_to_images():\n    \"\"\"\n    Convert CSV data to images with color-coded SWE predictions.\n\n    Returns:\n        None\n    \"\"\"\n    global fixed_value_ranges\n    data = pd.read_csv(\"/home/chetana/gridmet_test_run/test_data_predicted.csv\")\n    print(\"statistic of predicted_swe: \", data['predicted_swe'].describe())\n    data['predicted_swe'].fillna(0, inplace=True)\n    \n    for column in data.columns:\n        column_data = data[column]\n        print(column_data.describe())\n    \n    # Create a figure with a white background\n    fig = plt.figure(facecolor='white')\n\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    x, y = m(data['lon'].values, data['lat'].values)\n    print(data.columns)\n\n    color_mapping, value_ranges = create_color_maps_with_value_range(data[\"predicted_swe\"], fixed_value_ranges)\n    \n    # Plot the data using the custom colormap\n    plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\n    \n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_date = datetime(1900, 1, 1)\n    day_value = day_index\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    timestamp_string = result_date.strftime(\"%Y-%m-%d\")\n    \n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    # Create custom legend elements using the same colormap\n    legend_elements = [Patch(color=colors[i], label=f\"{value_ranges[i]} - {value_ranges[i+1]-1}\" if i < len(value_ranges) - 1 else f\"> {value_ranges[-1]}\") for i in range(len(value_ranges))]\n\n    # Create the legend outside the map\n    legend = plt.legend(handles=legend_elements, loc='upper left', title='Legend', fontsize=8)\n    legend.set_bbox_to_anchor((1.01, 1)) \n\n    # Remove the color bar\n    #plt.colorbar().remove()\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Set the aspect ratio to 'equal' to keep the plot at the center\n    plt.gca().set_aspect('equal', adjustable='box')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15, right=0.80)  # Adjust right margin to accommodate the legend\n    # Show the plot or save it to a file\n    new_plot_path = f'/home/chetana/gridmet_test_run/predicted_swe-{test_start_date}.png'\n    print(f\"The new plot is saved to {new_plot_path}\")\n    plt.savefig(new_plot_path)\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\ndef convert_csvs_to_images_simple():\n    \"\"\"\n    Convert CSV data to simple scatter plot images for predicted SWE.\n\n    Returns:\n        None\n    \"\"\"\n    selected_date = datetime.strptime(test_start_date, \"%Y-%m-%d\")\n    var_name = \"predicted_swe\"\n    test_csv = \"/home/chetana/gridmet_test_run/test_data_predicted.csv\"\n    result_var_df = pd.read_csv(test_csv)\n    result_var_df.replace('--', pd.NA, inplace=True)\n    result_var_df.dropna(inplace=True)\n    result_var_df[var_name] = pd.to_numeric(result_var_df[var_name], errors='coerce')\n    \n    colormaplist, value_ranges = create_color_maps_with_value_range(result_var_df[var_name], fixed_value_ranges)\n\n    # Create a scatter plot\n    plt.scatter(result_var_df[\"lon\"].values, \n                result_var_df[\"lat\"].values, \n                label='Predicted SWE', \n                c=result_var_df['predicted_swe'], \n                cmap='viridis', \n                s=1, \n                edgecolor='none',\n               )\n\n    # Add a colorbar\n    cbar = plt.colorbar()\n    cbar.set_label('Predicted SWE')  # Label for the colorbar\n    \n    # Add labels and a legend\n    plt.xlabel('Longitude')\n    plt.ylabel('Latitude')\n    plt.title(f'SWE Prediction Map {test_start_date}')\n    plt.legend()\n\n    res_png_path = f\"{work_dir}/testing_output/{str(selected_date.year)}_{var_name}_{test_start_date}.png\"\n    plt.savefig(res_png_path)\n    print(f\"test image is saved at {res_png_path}\")\n    plt.close()\n\n# Uncomment the function call you want to use:\n# convert_csvs_to_images()\nconvert_csvs_to_images_simple()\n",
  "history_output" : "",
  "history_begin_time" : 1696787741319,
  "history_end_time" : 1696787743787,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "100001",
  "indicator" : "Failed"
},{
  "history_id" : "fxhrkjdxb1p",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport uuid\nfrom snowcast_utils import day_index\nimport matplotlib.colors as mcolors\n\n# Import utility functions and variables from 'snowcast_utils'\nfrom snowcast_utils import work_dir, test_start_date\n\n# Define a custom colormap with specified colors and ranges\ncolors = [\n    (0.8627, 0.8627, 0.8627),  # #DCDCDC - 0 - 1\n    (0.8627, 1.0000, 1.0000),  # #DCFFFF - 1 - 2\n    (0.6000, 1.0000, 1.0000),  # #99FFFF - 2 - 4\n    (0.5569, 0.8235, 1.0000),  # #8ED2FF - 4 - 6\n    (0.4509, 0.6196, 0.8745),  # #739EDF - 6 - 8\n    (0.4157, 0.4706, 1.0000),  # #6A78FF - 8 - 10\n    (0.4235, 0.2784, 1.0000),  # #6C47FF - 10 - 12\n    (0.5529, 0.0980, 1.0000),  # #8D19FF - 12 - 14\n    (0.7333, 0.0000, 0.9176),  # #BB00EA - 14 - 16\n    (0.8392, 0.0000, 0.7490),  # #D600BF - 16 - 18\n    (0.7569, 0.0039, 0.4549),  # #C10074 - 18 - 20\n    (0.6784, 0.0000, 0.1961),  # #AD0032 - 20 - 30\n    (0.5020, 0.0000, 0.0000)   # #800000 - > 30\n]\n\ncmap_name = 'custom_snow_colormap'\ncustom_cmap = mcolors.ListedColormap(colors)\n\n# Define the lat_lon_to_map_coordinates function\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    \"\"\"\n    Convert latitude and longitude coordinates to map coordinates.\n\n    Args:\n        lon (float or array-like): Longitude coordinate(s).\n        lat (float or array-like): Latitude coordinate(s).\n        m (Basemap): Basemap object representing the map projection.\n\n    Returns:\n        tuple: Tuple containing the converted map coordinates (x, y).\n    \"\"\"\n    x, y = m(lon, lat)\n    return x, y\n\n# Define value ranges for color mapping\nfixed_value_ranges = [1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 30]\n\ndef create_color_maps_with_value_range(df_col, value_ranges=None):\n    \"\"\"\n    Create a colormap for value ranges and map data values to colors.\n\n    Args:\n        df_col (pd.Series): A Pandas Series containing data values.\n        value_ranges (list, optional): A list of value ranges for color mapping.\n            If not provided, the ranges will be determined automatically.\n\n    Returns:\n        tuple: Tuple containing the color mapping and the updated value ranges.\n    \"\"\"\n    new_value_ranges = value_ranges\n    if value_ranges is None:\n        max_value = df_col.max()\n        min_value = df_col.min()\n        if min_value < 0:\n            min_value = 0\n        step_size = (max_value - min_value) / 12\n\n        # Create 10 periods\n        new_value_ranges = [min_value + i * step_size for i in range(12)]\n    \n    print(\"new_value_ranges: \", new_value_ranges)\n  \n    # Define a custom function to map data values to colors\n    def map_value_to_color(value):\n        # Iterate through the value ranges to find the appropriate color index\n        for i, range_max in enumerate(new_value_ranges):\n            if value <= range_max:\n                return colors[i]\n\n        # If the value is greater than the largest range, return the last color\n        return colors[-1]\n\n    # Map predicted_swe values to colors using the custom function\n    color_mapping = [map_value_to_color(value) for value in df_col.values]\n    return color_mapping, new_value_ranges\n\ndef convert_csvs_to_images():\n    \"\"\"\n    Convert CSV data to images with color-coded SWE predictions.\n\n    Returns:\n        None\n    \"\"\"\n    global fixed_value_ranges\n    data = pd.read_csv(\"/home/chetana/gridmet_test_run/test_data_predicted.csv\")\n    print(\"statistic of predicted_swe: \", data['predicted_swe'].describe())\n    data['predicted_swe'].fillna(0, inplace=True)\n    \n    for column in data.columns:\n        column_data = data[column]\n        print(column_data.describe())\n    \n    # Create a figure with a white background\n    fig = plt.figure(facecolor='white')\n\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    x, y = m(data['lon'].values, data['lat'].values)\n    print(data.columns)\n\n    color_mapping, value_ranges = create_color_maps_with_value_range(data[\"predicted_swe\"], fixed_value_ranges)\n    \n    # Plot the data using the custom colormap\n    plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\n    \n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_date = datetime(1900, 1, 1)\n    day_value = day_index\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    timestamp_string = result_date.strftime(\"%Y-%m-%d\")\n    \n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    # Create custom legend elements using the same colormap\n    legend_elements = [Patch(color=colors[i], label=f\"{value_ranges[i]} - {value_ranges[i+1]-1}\" if i < len(value_ranges) - 1 else f\"> {value_ranges[-1]}\") for i in range(len(value_ranges))]\n\n    # Create the legend outside the map\n    legend = plt.legend(handles=legend_elements, loc='upper left', title='Legend', fontsize=8)\n    legend.set_bbox_to_anchor((1.01, 1)) \n\n    # Remove the color bar\n    #plt.colorbar().remove()\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Set the aspect ratio to 'equal' to keep the plot at the center\n    plt.gca().set_aspect('equal', adjustable='box')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15, right=0.80)  # Adjust right margin to accommodate the legend\n    # Show the plot or save it to a file\n    new_plot_path = f'/home/chetana/gridmet_test_run/predicted_swe-{test_start_date}.png'\n    print(f\"The new plot is saved to {new_plot_path}\")\n    plt.savefig(new_plot_path)\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\ndef convert_csvs_to_images_simple():\n    \"\"\"\n    Convert CSV data to simple scatter plot images for predicted SWE.\n\n    Returns:\n        None\n    \"\"\"\n    selected_date = datetime.strptime(test_start_date, \"%Y-%m-%d\")\n    var_name = \"predicted_swe\"\n    test_csv = \"/home/chetana/gridmet_test_run/test_data_predicted.csv\"\n    result_var_df = pd.read_csv(test_csv)\n    result_var_df.replace('--', pd.NA, inplace=True)\n    result_var_df.dropna(inplace=True)\n    result_var_df[var_name] = pd.to_numeric(result_var_df[var_name], errors='coerce')\n    \n    colormaplist, value_ranges = create_color_maps_with_value_range(result_var_df[var_name], fixed_value_ranges)\n\n    # Create a scatter plot\n    plt.scatter(result_var_df[\"lon\"].values, \n                result_var_df[\"lat\"].values, \n                label='Predicted SWE', \n                c=result_var_df['predicted_swe'], \n                cmap='viridis', \n                s=1, \n                edgecolor='none',\n               )\n\n    # Add a colorbar\n    cbar = plt.colorbar()\n    cbar.set_label('Predicted SWE')  # Label for the colorbar\n    \n    # Add labels and a legend\n    plt.xlabel('Longitude')\n    plt.ylabel('Latitude')\n    plt.title(f'SWE Prediction Map {test_start_date}')\n    plt.legend()\n\n    res_png_path = f\"{work_dir}/testing_output/{str(selected_date.year)}_{var_name}_{test_start_date}.png\"\n    plt.savefig(res_png_path)\n    print(f\"test image is saved at {res_png_path}\")\n    plt.close()\n\n# Uncomment the function call you want to use:\n# convert_csvs_to_images()\nconvert_csvs_to_images_simple()\n",
  "history_output" : "today date = 2023-10-08\ntest start date:  2023-01-20\ntest end date:  2023-10-08\n/home/chetana\nnew_value_ranges:  [1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 30]\ntest image is saved at /home/chetana/gridmet_test_run/testing_output/2023_predicted_swe_2023-01-20.png\n",
  "history_begin_time" : 1696786915814,
  "history_end_time" : 1696786922884,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "100001",
  "indicator" : "Done"
},{
  "history_id" : "7xbxpEGaOUJk",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport uuid\nfrom snowcast_utils import day_index\nimport matplotlib.colors as mcolors\n\n# Import utility functions and variables from 'snowcast_utils'\nfrom snowcast_utils import work_dir, test_start_date\n\n# Define a custom colormap with specified colors and ranges\ncolors = [\n    (0.8627, 0.8627, 0.8627),  # #DCDCDC - 0 - 1\n    (0.8627, 1.0000, 1.0000),  # #DCFFFF - 1 - 2\n    (0.6000, 1.0000, 1.0000),  # #99FFFF - 2 - 4\n    (0.5569, 0.8235, 1.0000),  # #8ED2FF - 4 - 6\n    (0.4509, 0.6196, 0.8745),  # #739EDF - 6 - 8\n    (0.4157, 0.4706, 1.0000),  # #6A78FF - 8 - 10\n    (0.4235, 0.2784, 1.0000),  # #6C47FF - 10 - 12\n    (0.5529, 0.0980, 1.0000),  # #8D19FF - 12 - 14\n    (0.7333, 0.0000, 0.9176),  # #BB00EA - 14 - 16\n    (0.8392, 0.0000, 0.7490),  # #D600BF - 16 - 18\n    (0.7569, 0.0039, 0.4549),  # #C10074 - 18 - 20\n    (0.6784, 0.0000, 0.1961),  # #AD0032 - 20 - 30\n    (0.5020, 0.0000, 0.0000)   # #800000 - > 30\n]\n\ncmap_name = 'custom_snow_colormap'\ncustom_cmap = mcolors.ListedColormap(colors)\n\n# Define the lat_lon_to_map_coordinates function\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    \"\"\"\n    Convert latitude and longitude coordinates to map coordinates.\n\n    Args:\n        lon (float or array-like): Longitude coordinate(s).\n        lat (float or array-like): Latitude coordinate(s).\n        m (Basemap): Basemap object representing the map projection.\n\n    Returns:\n        tuple: Tuple containing the converted map coordinates (x, y).\n    \"\"\"\n    x, y = m(lon, lat)\n    return x, y\n\n# Define value ranges for color mapping\nfixed_value_ranges = [1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 30]\n\ndef create_color_maps_with_value_range(df_col, value_ranges=None):\n    \"\"\"\n    Create a colormap for value ranges and map data values to colors.\n\n    Args:\n        df_col (pd.Series): A Pandas Series containing data values.\n        value_ranges (list, optional): A list of value ranges for color mapping.\n            If not provided, the ranges will be determined automatically.\n\n    Returns:\n        tuple: Tuple containing the color mapping and the updated value ranges.\n    \"\"\"\n    new_value_ranges = value_ranges\n    if value_ranges is None:\n        max_value = df_col.max()\n        min_value = df_col.min()\n        if min_value < 0:\n            min_value = 0\n        step_size = (max_value - min_value) / 12\n\n        # Create 10 periods\n        new_value_ranges = [min_value + i * step_size for i in range(12)]\n    \n    print(\"new_value_ranges: \", new_value_ranges)\n  \n    # Define a custom function to map data values to colors\n    def map_value_to_color(value):\n        # Iterate through the value ranges to find the appropriate color index\n        for i, range_max in enumerate(new_value_ranges):\n            if value <= range_max:\n                return colors[i]\n\n        # If the value is greater than the largest range, return the last color\n        return colors[-1]\n\n    # Map predicted_swe values to colors using the custom function\n    color_mapping = [map_value_to_color(value) for value in df_col.values]\n    return color_mapping, new_value_ranges\n\ndef convert_csvs_to_images():\n    \"\"\"\n    Convert CSV data to images with color-coded SWE predictions.\n\n    Returns:\n        None\n    \"\"\"\n    global fixed_value_ranges\n    data = pd.read_csv(\"/home/chetana/gridmet_test_run/test_data_predicted.csv\")\n    print(\"statistic of predicted_swe: \", data['predicted_swe'].describe())\n    data['predicted_swe'].fillna(0, inplace=True)\n    \n    for column in data.columns:\n        column_data = data[column]\n        print(column_data.describe())\n    \n    # Create a figure with a white background\n    fig = plt.figure(facecolor='white')\n\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    x, y = m(data['lon'].values, data['lat'].values)\n    print(data.columns)\n\n    color_mapping, value_ranges = create_color_maps_with_value_range(data[\"predicted_swe\"], fixed_value_ranges)\n    \n    # Plot the data using the custom colormap\n    plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\n    \n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_date = datetime(1900, 1, 1)\n    day_value = day_index\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    timestamp_string = result_date.strftime(\"%Y-%m-%d\")\n    \n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    # Create custom legend elements using the same colormap\n    legend_elements = [Patch(color=colors[i], label=f\"{value_ranges[i]} - {value_ranges[i+1]-1}\" if i < len(value_ranges) - 1 else f\"> {value_ranges[-1]}\") for i in range(len(value_ranges))]\n\n    # Create the legend outside the map\n    legend = plt.legend(handles=legend_elements, loc='upper left', title='Legend', fontsize=8)\n    legend.set_bbox_to_anchor((1.01, 1)) \n\n    # Remove the color bar\n    #plt.colorbar().remove()\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Set the aspect ratio to 'equal' to keep the plot at the center\n    plt.gca().set_aspect('equal', adjustable='box')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15, right=0.80)  # Adjust right margin to accommodate the legend\n    # Show the plot or save it to a file\n    new_plot_path = f'/home/chetana/gridmet_test_run/predicted_swe-{test_start_date}.png'\n    print(f\"The new plot is saved to {new_plot_path}\")\n    plt.savefig(new_plot_path)\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\ndef convert_csvs_to_images_simple():\n    \"\"\"\n    Convert CSV data to simple scatter plot images for predicted SWE.\n\n    Returns:\n        None\n    \"\"\"\n    selected_date = datetime.strptime(test_start_date, \"%Y-%m-%d\")\n    var_name = \"predicted_swe\"\n    test_csv = \"/home/chetana/gridmet_test_run/test_data_predicted.csv\"\n    result_var_df = pd.read_csv(test_csv)\n    result_var_df.replace('--', pd.NA, inplace=True)\n    result_var_df.dropna(inplace=True)\n    result_var_df[var_name] = pd.to_numeric(result_var_df[var_name], errors='coerce')\n    \n    colormaplist, value_ranges = create_color_maps_with_value_range(result_var_df[var_name], fixed_value_ranges)\n\n    # Create a scatter plot\n    plt.scatter(result_var_df[\"lon\"].values, \n                result_var_df[\"lat\"].values, \n                label='Predicted SWE', \n                c=result_var_df['predicted_swe'], \n                cmap='viridis', \n                s=1, \n                edgecolor='none',\n               )\n\n    # Add a colorbar\n    cbar = plt.colorbar()\n    cbar.set_label('Predicted SWE')  # Label for the colorbar\n    \n    # Add labels and a legend\n    plt.xlabel('Longitude')\n    plt.ylabel('Latitude')\n    plt.title(f'SWE Prediction Map {test_start_date}')\n    plt.legend()\n\n    res_png_path = f\"{work_dir}/testing_output/{str(selected_date.year)}_{var_name}_{test_start_date}.png\"\n    plt.savefig(res_png_path)\n    print(f\"test image is saved at {res_png_path}\")\n    plt.close()\n\n# Uncomment the function call you want to use:\n# convert_csvs_to_images()\nconvert_csvs_to_images_simple()\n",
  "history_output" : "today date = 2023-10-08\ntest start date:  2023-01-20\ntest end date:  2023-10-08\n/home/chetana\nnew_value_ranges:  [1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 30]\ntest image is saved at /home/chetana/gridmet_test_run/testing_output/2023_predicted_swe_2023-01-20.png\n",
  "history_begin_time" : 1696773715776,
  "history_end_time" : 1696773721094,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "an0W8d7lxZLG",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport uuid\nfrom snowcast_utils import day_index\n\n# Import utility functions and variables from 'snowcast_utils'\nfrom snowcast_utils import work_dir, test_start_date\n\n# Define a custom colormap with specified colors and ranges\ncolors = [\n    (0.8627, 0.8627, 0.8627),  # #DCDCDC - 0 - 1\n    (0.8627, 1.0000, 1.0000),  # #DCFFFF - 1 - 2\n    (0.6000, 1.0000, 1.0000),  # #99FFFF - 2 - 4\n    (0.5569, 0.8235, 1.0000),  # #8ED2FF - 4 - 6\n    (0.4509, 0.6196, 0.8745),  # #739EDF - 6 - 8\n    (0.4157, 0.4706, 1.0000),  # #6A78FF - 8 - 10\n    (0.4235, 0.2784, 1.0000),  # #6C47FF - 10 - 12\n    (0.5529, 0.0980, 1.0000),  # #8D19FF - 12 - 14\n    (0.7333, 0.0000, 0.9176),  # #BB00EA - 14 - 16\n    (0.8392, 0.0000, 0.7490),  # #D600BF - 16 - 18\n    (0.7569, 0.0039, 0.4549),  # #C10074 - 18 - 20\n    (0.6784, 0.0000, 0.1961),  # #AD0032 - 20 - 30\n    (0.5020, 0.0000, 0.0000)   # #800000 - > 30\n]\n\ncmap_name = 'custom_snow_colormap'\ncustom_cmap = mcolors.ListedColormap(colors)\n\n# Define the lat_lon_to_map_coordinates function\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    \"\"\"\n    Convert latitude and longitude coordinates to map coordinates.\n\n    Args:\n        lon (float or array-like): Longitude coordinate(s).\n        lat (float or array-like): Latitude coordinate(s).\n        m (Basemap): Basemap object representing the map projection.\n\n    Returns:\n        tuple: Tuple containing the converted map coordinates (x, y).\n    \"\"\"\n    x, y = m(lon, lat)\n    return x, y\n\n# Define value ranges for color mapping\nfixed_value_ranges = [1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 30]\n\ndef create_color_maps_with_value_range(df_col, value_ranges=None):\n    \"\"\"\n    Create a colormap for value ranges and map data values to colors.\n\n    Args:\n        df_col (pd.Series): A Pandas Series containing data values.\n        value_ranges (list, optional): A list of value ranges for color mapping.\n            If not provided, the ranges will be determined automatically.\n\n    Returns:\n        tuple: Tuple containing the color mapping and the updated value ranges.\n    \"\"\"\n    new_value_ranges = value_ranges\n    if value_ranges is None:\n        max_value = df_col.max()\n        min_value = df_col.min()\n        if min_value < 0:\n            min_value = 0\n        step_size = (max_value - min_value) / 12\n\n        # Create 10 periods\n        new_value_ranges = [min_value + i * step_size for i in range(12)]\n    \n    print(\"new_value_ranges: \", new_value_ranges)\n  \n    # Define a custom function to map data values to colors\n    def map_value_to_color(value):\n        # Iterate through the value ranges to find the appropriate color index\n        for i, range_max in enumerate(new_value_ranges):\n            if value <= range_max:\n                return colors[i]\n\n        # If the value is greater than the largest range, return the last color\n        return colors[-1]\n\n    # Map predicted_swe values to colors using the custom function\n    color_mapping = [map_value_to_color(value) for value in df_col.values]\n    return color_mapping, new_value_ranges\n\ndef convert_csvs_to_images():\n    \"\"\"\n    Convert CSV data to images with color-coded SWE predictions.\n\n    Returns:\n        None\n    \"\"\"\n    global fixed_value_ranges\n    data = pd.read_csv(\"/home/chetana/gridmet_test_run/test_data_predicted.csv\")\n    print(\"statistic of predicted_swe: \", data['predicted_swe'].describe())\n    data['predicted_swe'].fillna(0, inplace=True)\n    \n    for column in data.columns:\n        column_data = data[column]\n        print(column_data.describe())\n    \n    # Create a figure with a white background\n    fig = plt.figure(facecolor='white')\n\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    x, y = m(data['lon'].values, data['lat'].values)\n    print(data.columns)\n\n    color_mapping, value_ranges = create_color_maps_with_value_range(data[\"predicted_swe\"], fixed_value_ranges)\n    \n    # Plot the data using the custom colormap\n    plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\n    \n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_date = datetime(1900, 1, 1)\n    day_value = day_index\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    timestamp_string = result_date.strftime(\"%Y-%m-%d\")\n    \n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    # Create custom legend elements using the same colormap\n    legend_elements = [Patch(color=colors[i], label=f\"{value_ranges[i]} - {value_ranges[i+1]-1}\" if i < len(value_ranges) - 1 else f\"> {value_ranges[-1]}\") for i in range(len(value_ranges))]\n\n    # Create the legend outside the map\n    legend = plt.legend(handles=legend_elements, loc='upper left', title='Legend', fontsize=8)\n    legend.set_bbox_to_anchor((1.01, 1)) \n\n    # Remove the color bar\n    #plt.colorbar().remove()\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Set the aspect ratio to 'equal' to keep the plot at the center\n    plt.gca().set_aspect('equal', adjustable='box')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15, right=0.80)  # Adjust right margin to accommodate the legend\n    # Show the plot or save it to a file\n    new_plot_path = f'/home/chetana/gridmet_test_run/predicted_swe-{test_start_date}.png'\n    print(f\"The new plot is saved to {new_plot_path}\")\n    plt.savefig(new_plot_path)\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\ndef convert_csvs_to_images_simple():\n    \"\"\"\n    Convert CSV data to simple scatter plot images for predicted SWE.\n\n    Returns:\n        None\n    \"\"\"\n    selected_date = datetime.strptime(test_start_date, \"%Y-%m-%d\")\n    var_name = \"predicted_swe\"\n    test_csv = \"/home/chetana/gridmet_test_run/test_data_predicted.csv\"\n    result_var_df = pd.read_csv(test_csv)\n    result_var_df.replace('--', pd.NA, inplace=True)\n    result_var_df.dropna(inplace=True)\n    result_var_df[var_name] = pd.to_numeric(result_var_df[var_name], errors='coerce')\n    \n    colormaplist, value_ranges = create_color_maps_with_value_range(result_var_df[var_name], fixed_value_ranges)\n\n    # Create a scatter plot\n    plt.scatter(result_var_df[\"lon\"].values, \n                result_var_df[\"lat\"].values, \n                label='Predicted SWE', \n                c=result_var_df['predicted_swe'], \n                cmap='viridis', \n                s=1, \n                edgecolor='none',\n               )\n\n    # Add a colorbar\n    cbar = plt.colorbar()\n    cbar.set_label('Predicted SWE')  # Label for the colorbar\n    \n    # Add labels and a legend\n    plt.xlabel('Longitude')\n    plt.ylabel('Latitude')\n    plt.title(f'SWE Prediction Map {test_start_date}')\n    plt.legend()\n\n    res_png_path = f\"{work_dir}/testing_output/{str(selected_date.year)}_{var_name}_{test_start_date}.png\"\n    plt.savefig(res_png_path)\n    print(f\"test image is saved at {res_png_path}\")\n    plt.close()\n\n# Uncomment the function call you want to use:\n# convert_csvs_to_images()\nconvert_csvs_to_images_simple()\n",
  "history_output" : "today date = 2023-10-08\ntest start date:  2023-01-20\ntest end date:  2023-10-08\n/home/chetana\nTraceback (most recent call last):\n  File \"/home/chetana/gw-workspace/an0W8d7lxZLG/convert_results_to_images.py\", line 30, in <module>\n    custom_cmap = mcolors.ListedColormap(colors)\nNameError: name 'mcolors' is not defined\n",
  "history_begin_time" : 1696773662632,
  "history_end_time" : 1696773663643,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Failed"
},{
  "history_id" : "b751hivwwoe",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport uuid\nfrom snowcast_utils import day_index\n\n# Import utility functions and variables from 'snowcast_utils'\nfrom snowcast_utils import work_dir, test_start_date\n\n# Define a custom colormap with specified colors and ranges\ncolors = [\n    (0.8627, 0.8627, 0.8627),  # #DCDCDC - 0 - 1\n    (0.8627, 1.0000, 1.0000),  # #DCFFFF - 1 - 2\n    (0.6000, 1.0000, 1.0000),  # #99FFFF - 2 - 4\n    (0.5569, 0.8235, 1.0000),  # #8ED2FF - 4 - 6\n    (0.4509, 0.6196, 0.8745),  # #739EDF - 6 - 8\n    (0.4157, 0.4706, 1.0000),  # #6A78FF - 8 - 10\n    (0.4235, 0.2784, 1.0000),  # #6C47FF - 10 - 12\n    (0.5529, 0.0980, 1.0000),  # #8D19FF - 12 - 14\n    (0.7333, 0.0000, 0.9176),  # #BB00EA - 14 - 16\n    (0.8392, 0.0000, 0.7490),  # #D600BF - 16 - 18\n    (0.7569, 0.0039, 0.4549),  # #C10074 - 18 - 20\n    (0.6784, 0.0000, 0.1961),  # #AD0032 - 20 - 30\n    (0.5020, 0.0000, 0.0000)   # #800000 - > 30\n]\n\ncmap_name = 'custom_snow_colormap'\ncustom_cmap = mcolors.ListedColormap(colors)\n\n# Define the lat_lon_to_map_coordinates function\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    \"\"\"\n    Convert latitude and longitude coordinates to map coordinates.\n\n    Args:\n        lon (float or array-like): Longitude coordinate(s).\n        lat (float or array-like): Latitude coordinate(s).\n        m (Basemap): Basemap object representing the map projection.\n\n    Returns:\n        tuple: Tuple containing the converted map coordinates (x, y).\n    \"\"\"\n    x, y = m(lon, lat)\n    return x, y\n\n# Define value ranges for color mapping\nfixed_value_ranges = [1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 30]\n\ndef create_color_maps_with_value_range(df_col, value_ranges=None):\n    \"\"\"\n    Create a colormap for value ranges and map data values to colors.\n\n    Args:\n        df_col (pd.Series): A Pandas Series containing data values.\n        value_ranges (list, optional): A list of value ranges for color mapping.\n            If not provided, the ranges will be determined automatically.\n\n    Returns:\n        tuple: Tuple containing the color mapping and the updated value ranges.\n    \"\"\"\n    new_value_ranges = value_ranges\n    if value_ranges is None:\n        max_value = df_col.max()\n        min_value = df_col.min()\n        if min_value < 0:\n            min_value = 0\n        step_size = (max_value - min_value) / 12\n\n        # Create 10 periods\n        new_value_ranges = [min_value + i * step_size for i in range(12)]\n    \n    print(\"new_value_ranges: \", new_value_ranges)\n  \n    # Define a custom function to map data values to colors\n    def map_value_to_color(value):\n        # Iterate through the value ranges to find the appropriate color index\n        for i, range_max in enumerate(new_value_ranges):\n            if value <= range_max:\n                return colors[i]\n\n        # If the value is greater than the largest range, return the last color\n        return colors[-1]\n\n    # Map predicted_swe values to colors using the custom function\n    color_mapping = [map_value_to_color(value) for value in df_col.values]\n    return color_mapping, new_value_ranges\n\ndef convert_csvs_to_images():\n    \"\"\"\n    Convert CSV data to images with color-coded SWE predictions.\n\n    Returns:\n        None\n    \"\"\"\n    global fixed_value_ranges\n    data = pd.read_csv(\"/home/chetana/gridmet_test_run/test_data_predicted.csv\")\n    print(\"statistic of predicted_swe: \", data['predicted_swe'].describe())\n    data['predicted_swe'].fillna(0, inplace=True)\n    \n    for column in data.columns:\n        column_data = data[column]\n        print(column_data.describe())\n    \n    # Create a figure with a white background\n    fig = plt.figure(facecolor='white')\n\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    x, y = m(data['lon'].values, data['lat'].values)\n    print(data.columns)\n\n    color_mapping, value_ranges = create_color_maps_with_value_range(data[\"predicted_swe\"], fixed_value_ranges)\n    \n    # Plot the data using the custom colormap\n    plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\n    \n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_date = datetime(1900, 1, 1)\n    day_value = day_index\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    timestamp_string = result_date.strftime(\"%Y-%m-%d\")\n    \n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    # Create custom legend elements using the same colormap\n    legend_elements = [Patch(color=colors[i], label=f\"{value_ranges[i]} - {value_ranges[i+1]-1}\" if i < len(value_ranges) - 1 else f\"> {value_ranges[-1]}\") for i in range(len(value_ranges))]\n\n    # Create the legend outside the map\n    legend = plt.legend(handles=legend_elements, loc='upper left', title='Legend', fontsize=8)\n    legend.set_bbox_to_anchor((1.01, 1)) \n\n    # Remove the color bar\n    #plt.colorbar().remove()\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Set the aspect ratio to 'equal' to keep the plot at the center\n    plt.gca().set_aspect('equal', adjustable='box')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15, right=0.80)  # Adjust right margin to accommodate the legend\n    # Show the plot or save it to a file\n    new_plot_path = f'/home/chetana/gridmet_test_run/predicted_swe-{test_start_date}.png'\n    print(f\"The new plot is saved to {new_plot_path}\")\n    plt.savefig(new_plot_path)\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\ndef convert_csvs_to_images_simple():\n    \"\"\"\n    Convert CSV data to simple scatter plot images for predicted SWE.\n\n    Returns:\n        None\n    \"\"\"\n    selected_date = datetime.strptime(test_start_date, \"%Y-%m-%d\")\n    var_name = \"predicted_swe\"\n    test_csv = \"/home/chetana/gridmet_test_run/test_data_predicted.csv\"\n    result_var_df = pd.read_csv(test_csv)\n    result_var_df.replace('--', pd.NA, inplace=True)\n    result_var_df.dropna(inplace=True)\n    result_var_df[var_name] = pd.to_numeric(result_var_df[var_name], errors='coerce')\n    \n    colormaplist, value_ranges = create_color_maps_with_value_range(result_var_df[var_name], fixed_value_ranges)\n\n    # Create a scatter plot\n    plt.scatter(result_var_df[\"lon\"].values, \n                result_var_df[\"lat\"].values, \n                label='Predicted SWE', \n                c=result_var_df['predicted_swe'], \n                cmap='viridis', \n                s=1, \n                edgecolor='none',\n               )\n\n    # Add a colorbar\n    cbar = plt.colorbar()\n    cbar.set_label('Predicted SWE')  # Label for the colorbar\n    \n    # Add labels and a legend\n    plt.xlabel('Longitude')\n    plt.ylabel('Latitude')\n    plt.title(f'SWE Prediction Map {test_start_date}')\n    plt.legend()\n\n    res_png_path = f\"{work_dir}/testing_output/{str(selected_date.year)}_{var_name}_{test_start_date}.png\"\n    plt.savefig(res_png_path)\n    print(f\"test image is saved at {res_png_path}\")\n    plt.close()\n\n# Uncomment the function call you want to use:\n# convert_csvs_to_images()\nconvert_csvs_to_images_simple()\n",
  "history_output" : "today date = 2023-10-08\ntest start date:  2023-01-20\ntest end date:  2023-10-08\n/home/chetana\nTraceback (most recent call last):\n  File \"/home/chetana/gw-workspace/b751hivwwoe/convert_results_to_images.py\", line 30, in <module>\n    custom_cmap = mcolors.ListedColormap(colors)\nNameError: name 'mcolors' is not defined\n",
  "history_begin_time" : 1696772041673,
  "history_end_time" : 1696772045794,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "100001",
  "indicator" : "Failed"
},{
  "history_id" : "1254gyn9igj",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport uuid\nfrom snowcast_utils import day_index\nimport matplotlib.colors as mcolors\nfrom matplotlib.patches import Patch\nfrom snowcast_utils import day_index, work_dir, test_start_date\n\n# Define the custom colormap with specified colors and ranges\ncolors = [\n    (0.8627, 0.8627, 0.8627),  # #DCDCDC - 0 - 1\n    (0.8627, 1.0000, 1.0000),  # #DCFFFF - 1 - 2\n    (0.6000, 1.0000, 1.0000),  # #99FFFF - 2 - 4\n    (0.5569, 0.8235, 1.0000),  # #8ED2FF - 4 - 6\n    (0.4509, 0.6196, 0.8745),  # #739EDF - 6 - 8\n    (0.4157, 0.4706, 1.0000),  # #6A78FF - 8 - 10\n    (0.4235, 0.2784, 1.0000),  # #6C47FF - 10 - 12\n    (0.5529, 0.0980, 1.0000),  # #8D19FF - 12 - 14\n    (0.7333, 0.0000, 0.9176),  # #BB00EA - 14 - 16\n    (0.8392, 0.0000, 0.7490),  # #D600BF - 16 - 18\n    (0.7569, 0.0039, 0.4549),  # #C10074 - 18 - 20\n    (0.6784, 0.0000, 0.1961),  # #AD0032 - 20 - 30\n    (0.5020, 0.0000, 0.0000)   # #800000 - > 30\n]\n\ncmap_name = 'custom_snow_colormap'\ncustom_cmap = mcolors.ListedColormap(colors)\n\n# Define the lat_lon_to_map_coordinates function\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\n# Define your value ranges for color mapping\nfixed_value_ranges = [1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 30]\n#value_ranges = [0.1, 0.2, 0.4, 0.6, 0.8, 1.0, 1.2, 1.5, 1.8, 2, 2.5, 3]\n\ndef create_color_maps_with_value_range(df_col, value_ranges=None):\n  new_value_ranges = value_ranges\n  if value_ranges == None:\n    max_value = df_col.max()\n    min_value = df_col.min()\n    if min_value < 0:\n      min_value = 0\n    step_size = (max_value - min_value) / 12\n\n    # Create 10 periods\n    new_value_ranges = [min_value + i * step_size for i in range(12)]\n    \n  print(\"new_value_ranges: \", new_value_ranges)\n  \n  # Define your custom function to map data values to colors\n  def map_value_to_color(value):\n    # Iterate through the value ranges to find the appropriate color index\n    for i, range_max in enumerate(new_value_ranges):\n      if value <= range_max:\n        return colors[i]\n\n      # If the value is greater than the largest range, return the last color\n      return colors[-1]\n\n    # Map predicted_swe values to colors using the custom function\n  color_mapping = [map_value_to_color(value) for value in df_col.values]\n  return color_mapping, new_value_ranges\n\ndef convert_csvs_to_images():\n    global fixed_value_ranges\n    data = pd.read_csv(\"/home/chetana/gridmet_test_run/test_data_predicted.csv\")\n#     print(data.head())\n    print(\"statistic of predicted_swe: \", data['predicted_swe'].describe())\n    data['predicted_swe'].fillna(0, inplace=True)\n    #data['predicted_swe'] = data['predicted_swe'].apply(lambda x: 0 if x < 2 else x)\n    \n    for column in data.columns:\n      column_data = data[column]\n      print(column_data.describe())\n\n#       # Print or process the description as needed\n#       print(f\"Column: {column}\")\n#       print(description)\n    \n    # Create a figure with a white background\n    fig = plt.figure(facecolor='white')\n\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    print(\"data['lon'].values = \", data['lon'].values)\n    x, y = m(data['lon'].values, data['lat'].values)\n#     print(\"x = \", x)\n#     print(\"y = \", y)\n#     print(\"v = \", data['predicted_swe'].values)\n    print(data.columns)\n\n    color_mapping, value_ranges = create_color_maps_with_value_range(data[\"predicted_swe\"], fixed_value_ranges)\n    \n    # Plot the data using the custom colormap\n    plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\n    \n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_date = datetime(1900, 1, 1)\n    day_value = day_index\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    timestamp_string = result_date.strftime(\"%Y-%m-%d\")\n    \n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    # Create custom legend elements using the same colormap\n    legend_elements = [Patch(color=colors[i], label=f\"{value_ranges[i]} - {value_ranges[i+1]-1}\" if i < len(value_ranges) - 1 else f\"> {value_ranges[-1]}\") for i in range(len(value_ranges))]\n\n    # Create the legend outside the map\n    legend = plt.legend(handles=legend_elements, loc='upper left', title='Legend', fontsize=8)\n    legend.set_bbox_to_anchor((1.01, 1)) \n\n    # Remove the color bar\n    #plt.colorbar().remove()\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Set the aspect ratio to 'equal' to keep the plot at the center\n    plt.gca().set_aspect('equal', adjustable='box')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15, right=0.80)  # Adjust right margin to accommodate the legend\n    # Show the plot or save it to a file\n    new_plot_path = f'/home/chetana/gridmet_test_run/predicted_swe-{test_start_date}.png'\n    print(f\"The new plot is saved to {new_plot_path}\")\n    plt.savefig(new_plot_path)\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\ndef convert_csvs_to_images_simple():\n    selected_date = datetime.strptime(test_start_date, \"%Y-%m-%d\")\n    var_name = \"predicted_swe\"\n    test_csv = \"/home/chetana/gridmet_test_run/test_data_predicted.csv\"\n    result_var_df = pd.read_csv(test_csv)\n    result_var_df.replace('--', pd.NA, inplace=True)\n    result_var_df.dropna(inplace=True)\n    result_var_df[var_name] = pd.to_numeric(result_var_df[var_name], errors='coerce')\n    print(result_var_df.head())\n    #print(gridmet_var_df[\"Latitude\"].describe())\n    #print(gridmet_var_df[\"Longitude\"].describe())\n    print(result_var_df[var_name].describe())\n\n    colormaplist, value_ranges = create_color_maps_with_value_range(result_var_df[var_name], fixed_value_ranges)\n\n    # Create a scatter plot\n    plt.scatter(result_var_df[\"lon\"].values, \n                result_var_df[\"lat\"].values, \n                label='Predicted SWE', \n                #color=colormaplist, \n                c=result_var_df['predicted_swe'], \n                cmap='viridis', \n                s=1, \n                edgecolor='none',\n#                 vmin=0,  # Set the minimum value\n#                 vmax=12\n               )\n\n    # Add a colorbar\n    cbar = plt.colorbar()\n    cbar.set_label('Predicted SWE')  # Label for the colorbar\n    \n    # Add labels and a legend\n    plt.xlabel('Longitude')\n    plt.ylabel('Latitude')\n    plt.title(f'SWE Prediction Map {test_start_date}')\n    plt.legend()\n\n    res_png_path = f\"{work_dir}/testing_output/{str(selected_date.year)}_{var_name}_{test_start_date}.png\"\n    plt.savefig(res_png_path)\n    print(f\"test image is saved at {res_png_path}\")\n    plt.close()\n    \n#convert_csvs_to_images()\n\nconvert_csvs_to_images_simple()\n",
  "history_output" : "today date = 2023-10-06\ntest start date:  2023-01-19\ntest end date:  2023-10-06\n/home/chetana\n     date   lat      lon  SWE  ...     aspect  eastness  northness  predicted_swe\n69  44943  49.0 -122.516    0  ...   91.84747  0.785138  -0.032228         7.4780\n70  44943  49.0 -122.480    0  ...   90.00000  0.785398   0.000000         7.4715\n71  44943  49.0 -122.444    0  ...  329.53427 -0.469250   0.711381         7.4730\n72  44943  49.0 -122.408    0  ...  270.00000 -0.785398   0.000000         7.4730\n73  44943  49.0 -122.372    0  ...   83.99069  0.782643   0.104310         7.4715\n[5 rows x 20 columns]\ncount    288650.000000\nmean          7.473006\nstd           0.038311\nmin           7.051000\n25%           7.470500\n50%           7.481500\n75%           7.492000\nmax           7.500000\nName: predicted_swe, dtype: float64\nnew_value_ranges:  [1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 30]\ntest image is saved at /home/chetana/gridmet_test_run/testing_output/2023_predicted_swe_2023-01-19.png\n",
  "history_begin_time" : 1696603191658,
  "history_end_time" : 1696603198869,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "100001",
  "indicator" : "Done"
},{
  "history_id" : "LbRvPdFJrOQx",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport uuid\nfrom snowcast_utils import day_index\nimport matplotlib.colors as mcolors\nfrom matplotlib.patches import Patch\nfrom snowcast_utils import day_index, work_dir, test_start_date\n\n# Define the custom colormap with specified colors and ranges\ncolors = [\n    (0.8627, 0.8627, 0.8627),  # #DCDCDC - 0 - 1\n    (0.8627, 1.0000, 1.0000),  # #DCFFFF - 1 - 2\n    (0.6000, 1.0000, 1.0000),  # #99FFFF - 2 - 4\n    (0.5569, 0.8235, 1.0000),  # #8ED2FF - 4 - 6\n    (0.4509, 0.6196, 0.8745),  # #739EDF - 6 - 8\n    (0.4157, 0.4706, 1.0000),  # #6A78FF - 8 - 10\n    (0.4235, 0.2784, 1.0000),  # #6C47FF - 10 - 12\n    (0.5529, 0.0980, 1.0000),  # #8D19FF - 12 - 14\n    (0.7333, 0.0000, 0.9176),  # #BB00EA - 14 - 16\n    (0.8392, 0.0000, 0.7490),  # #D600BF - 16 - 18\n    (0.7569, 0.0039, 0.4549),  # #C10074 - 18 - 20\n    (0.6784, 0.0000, 0.1961),  # #AD0032 - 20 - 30\n    (0.5020, 0.0000, 0.0000)   # #800000 - > 30\n]\n\ncmap_name = 'custom_snow_colormap'\ncustom_cmap = mcolors.ListedColormap(colors)\n\n# Define the lat_lon_to_map_coordinates function\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\n# Define your value ranges for color mapping\nfixed_value_ranges = [1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 30]\n#value_ranges = [0.1, 0.2, 0.4, 0.6, 0.8, 1.0, 1.2, 1.5, 1.8, 2, 2.5, 3]\n\ndef create_color_maps_with_value_range(df_col, value_ranges=None):\n  new_value_ranges = value_ranges\n  if value_ranges == None:\n    max_value = df_col.max()\n    min_value = df_col.min()\n    if min_value < 0:\n      min_value = 0\n    step_size = (max_value - min_value) / 12\n\n    # Create 10 periods\n    new_value_ranges = [min_value + i * step_size for i in range(12)]\n    \n  print(\"new_value_ranges: \", new_value_ranges)\n  \n  # Define your custom function to map data values to colors\n  def map_value_to_color(value):\n    # Iterate through the value ranges to find the appropriate color index\n    for i, range_max in enumerate(new_value_ranges):\n      if value <= range_max:\n        return colors[i]\n\n      # If the value is greater than the largest range, return the last color\n      return colors[-1]\n\n    # Map predicted_swe values to colors using the custom function\n  color_mapping = [map_value_to_color(value) for value in df_col.values]\n  return color_mapping, new_value_ranges\n\ndef convert_csvs_to_images():\n    global fixed_value_ranges\n    data = pd.read_csv(\"/home/chetana/gridmet_test_run/test_data_predicted.csv\")\n#     print(data.head())\n    print(\"statistic of predicted_swe: \", data['predicted_swe'].describe())\n    data['predicted_swe'].fillna(0, inplace=True)\n    #data['predicted_swe'] = data['predicted_swe'].apply(lambda x: 0 if x < 2 else x)\n    \n    for column in data.columns:\n      column_data = data[column]\n      print(column_data.describe())\n\n#       # Print or process the description as needed\n#       print(f\"Column: {column}\")\n#       print(description)\n    \n    # Create a figure with a white background\n    fig = plt.figure(facecolor='white')\n\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    print(\"data['lon'].values = \", data['lon'].values)\n    x, y = m(data['lon'].values, data['lat'].values)\n#     print(\"x = \", x)\n#     print(\"y = \", y)\n#     print(\"v = \", data['predicted_swe'].values)\n    print(data.columns)\n\n    color_mapping, value_ranges = create_color_maps_with_value_range(data[\"predicted_swe\"], fixed_value_ranges)\n    \n    # Plot the data using the custom colormap\n    plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\n    \n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_date = datetime(1900, 1, 1)\n    day_value = day_index\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    timestamp_string = result_date.strftime(\"%Y-%m-%d\")\n    \n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    # Create custom legend elements using the same colormap\n    legend_elements = [Patch(color=colors[i], label=f\"{value_ranges[i]} - {value_ranges[i+1]-1}\" if i < len(value_ranges) - 1 else f\"> {value_ranges[-1]}\") for i in range(len(value_ranges))]\n\n    # Create the legend outside the map\n    legend = plt.legend(handles=legend_elements, loc='upper left', title='Legend', fontsize=8)\n    legend.set_bbox_to_anchor((1.01, 1)) \n\n    # Remove the color bar\n    #plt.colorbar().remove()\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Set the aspect ratio to 'equal' to keep the plot at the center\n    plt.gca().set_aspect('equal', adjustable='box')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15, right=0.80)  # Adjust right margin to accommodate the legend\n    # Show the plot or save it to a file\n    new_plot_path = f'/home/chetana/gridmet_test_run/predicted_swe-{test_start_date}.png'\n    print(f\"The new plot is saved to {new_plot_path}\")\n    plt.savefig(new_plot_path)\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\ndef convert_csvs_to_images_simple():\n    selected_date = datetime.strptime(test_start_date, \"%Y-%m-%d\")\n    var_name = \"predicted_swe\"\n    test_csv = \"/home/chetana/gridmet_test_run/test_data_predicted.csv\"\n    result_var_df = pd.read_csv(test_csv)\n    result_var_df.replace('--', pd.NA, inplace=True)\n    result_var_df.dropna(inplace=True)\n    result_var_df[var_name] = pd.to_numeric(result_var_df[var_name], errors='coerce')\n    print(result_var_df.head())\n    #print(gridmet_var_df[\"Latitude\"].describe())\n    #print(gridmet_var_df[\"Longitude\"].describe())\n    print(result_var_df[var_name].describe())\n\n    colormaplist, value_ranges = create_color_maps_with_value_range(result_var_df[var_name], fixed_value_ranges)\n\n    # Create a scatter plot\n    plt.scatter(result_var_df[\"lon\"].values, \n                result_var_df[\"lat\"].values, \n                label='Predicted SWE', \n                #color=colormaplist, \n                c=result_var_df['predicted_swe'], \n                cmap='viridis', \n                s=1, \n                edgecolor='none',\n#                 vmin=0,  # Set the minimum value\n#                 vmax=12\n               )\n\n    # Add a colorbar\n    cbar = plt.colorbar()\n    cbar.set_label('Predicted SWE')  # Label for the colorbar\n    \n    # Add labels and a legend\n    plt.xlabel('Longitude')\n    plt.ylabel('Latitude')\n    plt.title(f'SWE Prediction Map {test_start_date}')\n    plt.legend()\n\n    res_png_path = f\"{work_dir}/testing_output/{str(selected_date.year)}_{var_name}_{test_start_date}.png\"\n    plt.savefig(res_png_path)\n    print(f\"test image is saved at {res_png_path}\")\n    plt.close()\n    \n#convert_csvs_to_images()\n\nconvert_csvs_to_images_simple()\n",
  "history_output" : "today date = 2023-10-04\ntest start date:  2023-01-18\ntest end date:  2023-10-04\n/home/chetana\n     date   lat      lon  SWE  ...     aspect  eastness  northness  predicted_swe\n69  44942  49.0 -122.516    0  ...   91.84747  0.785138  -0.032228         7.4685\n70  44942  49.0 -122.480    0  ...   90.00000  0.785398   0.000000         7.4685\n71  44942  49.0 -122.444    0  ...  329.53427 -0.469250   0.711381         7.4700\n72  44942  49.0 -122.408    0  ...  270.00000 -0.785398   0.000000         7.4700\n73  44942  49.0 -122.372    0  ...   83.99069  0.782643   0.104310         7.4685\n[5 rows x 20 columns]\ncount    288650.000000\nmean          7.473773\nstd           0.040527\nmin           7.046500\n25%           7.472000\n50%           7.485000\n75%           7.492000\nmax           7.500000\nName: predicted_swe, dtype: float64\nnew_value_ranges:  [1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 30]\ntest image is saved at /home/chetana/gridmet_test_run/testing_output/2023_predicted_swe_2023-01-18.png\n",
  "history_begin_time" : 1696432872657,
  "history_end_time" : 1696432878211,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "709hf466d51",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport uuid\nfrom snowcast_utils import day_index\nimport matplotlib.colors as mcolors\nfrom matplotlib.patches import Patch\nfrom snowcast_utils import day_index, work_dir, test_start_date\n\n# Define the custom colormap with specified colors and ranges\ncolors = [\n    (0.8627, 0.8627, 0.8627),  # #DCDCDC - 0 - 1\n    (0.8627, 1.0000, 1.0000),  # #DCFFFF - 1 - 2\n    (0.6000, 1.0000, 1.0000),  # #99FFFF - 2 - 4\n    (0.5569, 0.8235, 1.0000),  # #8ED2FF - 4 - 6\n    (0.4509, 0.6196, 0.8745),  # #739EDF - 6 - 8\n    (0.4157, 0.4706, 1.0000),  # #6A78FF - 8 - 10\n    (0.4235, 0.2784, 1.0000),  # #6C47FF - 10 - 12\n    (0.5529, 0.0980, 1.0000),  # #8D19FF - 12 - 14\n    (0.7333, 0.0000, 0.9176),  # #BB00EA - 14 - 16\n    (0.8392, 0.0000, 0.7490),  # #D600BF - 16 - 18\n    (0.7569, 0.0039, 0.4549),  # #C10074 - 18 - 20\n    (0.6784, 0.0000, 0.1961),  # #AD0032 - 20 - 30\n    (0.5020, 0.0000, 0.0000)   # #800000 - > 30\n]\n\ncmap_name = 'custom_snow_colormap'\ncustom_cmap = mcolors.ListedColormap(colors)\n\n# Define the lat_lon_to_map_coordinates function\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\n# Define your value ranges for color mapping\nfixed_value_ranges = [1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 30]\n#value_ranges = [0.1, 0.2, 0.4, 0.6, 0.8, 1.0, 1.2, 1.5, 1.8, 2, 2.5, 3]\n\ndef create_color_maps_with_value_range(df_col, value_ranges=None):\n  new_value_ranges = value_ranges\n  if value_ranges == None:\n    max_value = df_col.max()\n    min_value = df_col.min()\n    if min_value < 0:\n      min_value = 0\n    step_size = (max_value - min_value) / 12\n\n    # Create 10 periods\n    new_value_ranges = [min_value + i * step_size for i in range(12)]\n    \n  print(\"new_value_ranges: \", new_value_ranges)\n  \n  # Define your custom function to map data values to colors\n  def map_value_to_color(value):\n    # Iterate through the value ranges to find the appropriate color index\n    for i, range_max in enumerate(new_value_ranges):\n      if value <= range_max:\n        return colors[i]\n\n      # If the value is greater than the largest range, return the last color\n      return colors[-1]\n\n    # Map predicted_swe values to colors using the custom function\n  color_mapping = [map_value_to_color(value) for value in df_col.values]\n  return color_mapping, new_value_ranges\n\ndef convert_csvs_to_images():\n    global fixed_value_ranges\n    data = pd.read_csv(\"/home/chetana/gridmet_test_run/test_data_predicted.csv\")\n#     print(data.head())\n    print(\"statistic of predicted_swe: \", data['predicted_swe'].describe())\n    data['predicted_swe'].fillna(0, inplace=True)\n    #data['predicted_swe'] = data['predicted_swe'].apply(lambda x: 0 if x < 2 else x)\n    \n    for column in data.columns:\n      column_data = data[column]\n      print(column_data.describe())\n\n#       # Print or process the description as needed\n#       print(f\"Column: {column}\")\n#       print(description)\n    \n    # Create a figure with a white background\n    fig = plt.figure(facecolor='white')\n\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    print(\"data['lon'].values = \", data['lon'].values)\n    x, y = m(data['lon'].values, data['lat'].values)\n#     print(\"x = \", x)\n#     print(\"y = \", y)\n#     print(\"v = \", data['predicted_swe'].values)\n    print(data.columns)\n\n    color_mapping, value_ranges = create_color_maps_with_value_range(data[\"predicted_swe\"], fixed_value_ranges)\n    \n    # Plot the data using the custom colormap\n    plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\n    \n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_date = datetime(1900, 1, 1)\n    day_value = day_index\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    timestamp_string = result_date.strftime(\"%Y-%m-%d\")\n    \n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    # Create custom legend elements using the same colormap\n    legend_elements = [Patch(color=colors[i], label=f\"{value_ranges[i]} - {value_ranges[i+1]-1}\" if i < len(value_ranges) - 1 else f\"> {value_ranges[-1]}\") for i in range(len(value_ranges))]\n\n    # Create the legend outside the map\n    legend = plt.legend(handles=legend_elements, loc='upper left', title='Legend', fontsize=8)\n    legend.set_bbox_to_anchor((1.01, 1)) \n\n    # Remove the color bar\n    #plt.colorbar().remove()\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Set the aspect ratio to 'equal' to keep the plot at the center\n    plt.gca().set_aspect('equal', adjustable='box')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15, right=0.80)  # Adjust right margin to accommodate the legend\n    # Show the plot or save it to a file\n    new_plot_path = f'/home/chetana/gridmet_test_run/predicted_swe-{test_start_date}.png'\n    print(f\"The new plot is saved to {new_plot_path}\")\n    plt.savefig(new_plot_path)\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\ndef convert_csvs_to_images_simple():\n    selected_date = datetime.strptime(test_start_date, \"%Y-%m-%d\")\n    var_name = \"predicted_swe\"\n    test_csv = \"/home/chetana/gridmet_test_run/test_data_predicted.csv\"\n    result_var_df = pd.read_csv(test_csv)\n    result_var_df.replace('--', pd.NA, inplace=True)\n    result_var_df.dropna(inplace=True)\n    result_var_df[var_name] = pd.to_numeric(result_var_df[var_name], errors='coerce')\n    print(result_var_df.head())\n    #print(gridmet_var_df[\"Latitude\"].describe())\n    #print(gridmet_var_df[\"Longitude\"].describe())\n    print(result_var_df[var_name].describe())\n\n    colormaplist, value_ranges = create_color_maps_with_value_range(result_var_df[var_name], fixed_value_ranges)\n\n    # Create a scatter plot\n    plt.scatter(result_var_df[\"lon\"].values, \n                result_var_df[\"lat\"].values, \n                label='Predicted SWE', \n                #color=colormaplist, \n                c=result_var_df['predicted_swe'], \n                cmap='viridis', \n                s=1, \n                edgecolor='none',\n#                 vmin=0,  # Set the minimum value\n#                 vmax=12\n               )\n\n    # Add a colorbar\n    cbar = plt.colorbar()\n    cbar.set_label('Predicted SWE')  # Label for the colorbar\n    \n    # Add labels and a legend\n    plt.xlabel('Longitude')\n    plt.ylabel('Latitude')\n    plt.title(f'SWE Prediction Map {test_start_date}')\n    plt.legend()\n\n    res_png_path = f\"{work_dir}/testing_output/{str(selected_date.year)}_{var_name}_{test_start_date}.png\"\n    plt.savefig(res_png_path)\n    print(f\"test image is saved at {res_png_path}\")\n    plt.close()\n    \n#convert_csvs_to_images()\n\nconvert_csvs_to_images_simple()\n",
  "history_output" : "today date = 2023-10-04\ntest start date:  2023-01-18\ntest end date:  2023-10-04\n/home/chetana\nTraceback (most recent call last):\n  File \"/home/chetana/gw-workspace/709hf466d51/convert_results_to_images.py\", line 214, in <module>\n    convert_csvs_to_images_simple()\n  File \"/home/chetana/gw-workspace/709hf466d51/convert_results_to_images.py\", line 173, in convert_csvs_to_images_simple\n    result_var_df = pd.read_csv(test_csv)\n  File \"/home/chetana/anaconda3/lib/python3.9/site-packages/pandas/util/_decorators.py\", line 211, in wrapper\n    return func(*args, **kwargs)\n  File \"/home/chetana/anaconda3/lib/python3.9/site-packages/pandas/util/_decorators.py\", line 331, in wrapper\n    return func(*args, **kwargs)\n  File \"/home/chetana/anaconda3/lib/python3.9/site-packages/pandas/io/parsers/readers.py\", line 950, in read_csv\n    return _read(filepath_or_buffer, kwds)\n  File \"/home/chetana/anaconda3/lib/python3.9/site-packages/pandas/io/parsers/readers.py\", line 605, in _read\n    parser = TextFileReader(filepath_or_buffer, **kwds)\n  File \"/home/chetana/anaconda3/lib/python3.9/site-packages/pandas/io/parsers/readers.py\", line 1442, in __init__\n    self._engine = self._make_engine(f, self.engine)\n  File \"/home/chetana/anaconda3/lib/python3.9/site-packages/pandas/io/parsers/readers.py\", line 1735, in _make_engine\n    self.handles = get_handle(\n  File \"/home/chetana/anaconda3/lib/python3.9/site-packages/pandas/io/common.py\", line 856, in get_handle\n    handle = open(\nFileNotFoundError: [Errno 2] No such file or directory: '/home/chetana/gridmet_test_run/test_data_predicted.csv'\n",
  "history_begin_time" : 1696432516781,
  "history_end_time" : 1696432519690,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "100001",
  "indicator" : "Failed"
},{
  "history_id" : "0rp5hcbz142",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport uuid\nfrom snowcast_utils import day_index\nimport matplotlib.colors as mcolors\nfrom matplotlib.patches import Patch\nfrom snowcast_utils import day_index, work_dir, test_start_date\n\n# Define the custom colormap with specified colors and ranges\ncolors = [\n    (0.8627, 0.8627, 0.8627),  # #DCDCDC - 0 - 1\n    (0.8627, 1.0000, 1.0000),  # #DCFFFF - 1 - 2\n    (0.6000, 1.0000, 1.0000),  # #99FFFF - 2 - 4\n    (0.5569, 0.8235, 1.0000),  # #8ED2FF - 4 - 6\n    (0.4509, 0.6196, 0.8745),  # #739EDF - 6 - 8\n    (0.4157, 0.4706, 1.0000),  # #6A78FF - 8 - 10\n    (0.4235, 0.2784, 1.0000),  # #6C47FF - 10 - 12\n    (0.5529, 0.0980, 1.0000),  # #8D19FF - 12 - 14\n    (0.7333, 0.0000, 0.9176),  # #BB00EA - 14 - 16\n    (0.8392, 0.0000, 0.7490),  # #D600BF - 16 - 18\n    (0.7569, 0.0039, 0.4549),  # #C10074 - 18 - 20\n    (0.6784, 0.0000, 0.1961),  # #AD0032 - 20 - 30\n    (0.5020, 0.0000, 0.0000)   # #800000 - > 30\n]\n\ncmap_name = 'custom_snow_colormap'\ncustom_cmap = mcolors.ListedColormap(colors)\n\n# Define the lat_lon_to_map_coordinates function\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\n# Define your value ranges for color mapping\nfixed_value_ranges = [1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 30]\n#value_ranges = [0.1, 0.2, 0.4, 0.6, 0.8, 1.0, 1.2, 1.5, 1.8, 2, 2.5, 3]\n\ndef create_color_maps_with_value_range(df_col, value_ranges=None):\n  new_value_ranges = value_ranges\n  if value_ranges == None:\n    max_value = df_col.max()\n    min_value = df_col.min()\n    if min_value < 0:\n      min_value = 0\n    step_size = (max_value - min_value) / 12\n\n    # Create 10 periods\n    new_value_ranges = [min_value + i * step_size for i in range(12)]\n    \n  print(\"new_value_ranges: \", new_value_ranges)\n  \n  # Define your custom function to map data values to colors\n  def map_value_to_color(value):\n    # Iterate through the value ranges to find the appropriate color index\n    for i, range_max in enumerate(new_value_ranges):\n      if value <= range_max:\n        return colors[i]\n\n      # If the value is greater than the largest range, return the last color\n      return colors[-1]\n\n    # Map predicted_swe values to colors using the custom function\n  color_mapping = [map_value_to_color(value) for value in df_col.values]\n  return color_mapping, new_value_ranges\n\ndef convert_csvs_to_images():\n    global fixed_value_ranges\n    data = pd.read_csv(\"/home/chetana/gridmet_test_run/test_data_predicted.csv\")\n#     print(data.head())\n    print(\"statistic of predicted_swe: \", data['predicted_swe'].describe())\n    data['predicted_swe'].fillna(0, inplace=True)\n    #data['predicted_swe'] = data['predicted_swe'].apply(lambda x: 0 if x < 2 else x)\n    \n    for column in data.columns:\n      column_data = data[column]\n      print(column_data.describe())\n\n#       # Print or process the description as needed\n#       print(f\"Column: {column}\")\n#       print(description)\n    \n    # Create a figure with a white background\n    fig = plt.figure(facecolor='white')\n\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    print(\"data['lon'].values = \", data['lon'].values)\n    x, y = m(data['lon'].values, data['lat'].values)\n#     print(\"x = \", x)\n#     print(\"y = \", y)\n#     print(\"v = \", data['predicted_swe'].values)\n    print(data.columns)\n\n    color_mapping, value_ranges = create_color_maps_with_value_range(data[\"predicted_swe\"], fixed_value_ranges)\n    \n    # Plot the data using the custom colormap\n    plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\n    \n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_date = datetime(1900, 1, 1)\n    day_value = day_index\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    timestamp_string = result_date.strftime(\"%Y-%m-%d\")\n    \n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    # Create custom legend elements using the same colormap\n    legend_elements = [Patch(color=colors[i], label=f\"{value_ranges[i]} - {value_ranges[i+1]-1}\" if i < len(value_ranges) - 1 else f\"> {value_ranges[-1]}\") for i in range(len(value_ranges))]\n\n    # Create the legend outside the map\n    legend = plt.legend(handles=legend_elements, loc='upper left', title='Legend', fontsize=8)\n    legend.set_bbox_to_anchor((1.01, 1)) \n\n    # Remove the color bar\n    #plt.colorbar().remove()\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Set the aspect ratio to 'equal' to keep the plot at the center\n    plt.gca().set_aspect('equal', adjustable='box')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15, right=0.80)  # Adjust right margin to accommodate the legend\n    # Show the plot or save it to a file\n    new_plot_path = f'/home/chetana/gridmet_test_run/predicted_swe-{test_start_date}.png'\n    print(f\"The new plot is saved to {new_plot_path}\")\n    plt.savefig(new_plot_path)\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\ndef convert_csvs_to_images_simple():\n    selected_date = datetime.strptime(test_start_date, \"%Y-%m-%d\")\n    var_name = \"predicted_swe\"\n    test_csv = \"/home/chetana/gridmet_test_run/test_data_predicted.csv\"\n    result_var_df = pd.read_csv(test_csv)\n    result_var_df.replace('--', pd.NA, inplace=True)\n    result_var_df.dropna(inplace=True)\n    result_var_df[var_name] = pd.to_numeric(result_var_df[var_name], errors='coerce')\n    print(result_var_df.head())\n    #print(gridmet_var_df[\"Latitude\"].describe())\n    #print(gridmet_var_df[\"Longitude\"].describe())\n    print(result_var_df[var_name].describe())\n\n    colormaplist, value_ranges = create_color_maps_with_value_range(result_var_df[var_name], fixed_value_ranges)\n\n    # Create a scatter plot\n    plt.scatter(result_var_df[\"lon\"].values, \n                result_var_df[\"lat\"].values, \n                label='Predicted SWE', \n                #color=colormaplist, \n                c=result_var_df['predicted_swe'], \n                cmap='viridis', \n                s=1, \n                edgecolor='none',\n#                 vmin=0,  # Set the minimum value\n#                 vmax=12\n               )\n\n    # Add a colorbar\n    cbar = plt.colorbar()\n    cbar.set_label('Predicted SWE')  # Label for the colorbar\n    \n    # Add labels and a legend\n    plt.xlabel('Longitude')\n    plt.ylabel('Latitude')\n    plt.title(f'SWE Prediction Map {test_start_date}')\n    plt.legend()\n\n    res_png_path = f\"{work_dir}/testing_output/{str(selected_date.year)}_{var_name}_{test_start_date}.png\"\n    plt.savefig(res_png_path)\n    print(f\"test image is saved at {res_png_path}\")\n    \n#convert_csvs_to_images()\n\nconvert_csvs_to_images_simple()\n",
  "history_output" : "today date = 2023-09-27\ntest start date:  2023-01-15\ntest end date:  2023-09-27\n/home/chetana\n     date   lat      lon  SWE  ...     aspect  eastness  northness  predicted_swe\n69  44633  49.0 -122.516    0  ...   91.84747  0.785138  -0.032228        10.1720\n70  44633  49.0 -122.480    0  ...   90.00000  0.785398   0.000000        10.1790\n71  44633  49.0 -122.444    0  ...  329.53427 -0.469250   0.711381        10.1035\n72  44633  49.0 -122.408    0  ...  270.00000 -0.785398   0.000000        10.1450\n73  44633  49.0 -122.372    0  ...   83.99069  0.782643   0.104310        10.2305\n[5 rows x 20 columns]\ncount    288650.000000\nmean          9.639122\nstd           0.676329\nmin           7.775500\n25%           9.042500\n50%           9.934500\n75%          10.240000\nmax          10.370000\nName: predicted_swe, dtype: float64\nnew_value_ranges:  [1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 30]\ntest image is saved at /home/chetana/gridmet_test_run/testing_output/2023_predicted_swe_2023-01-15.png\n",
  "history_begin_time" : 1695828139688,
  "history_end_time" : 1695828146837,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "100001",
  "indicator" : "Done"
},{
  "history_id" : "n8cqbjhoe4m",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport uuid\nfrom snowcast_utils import day_index\nimport matplotlib.colors as mcolors\nfrom matplotlib.patches import Patch\nfrom snowcast_utils import day_index, work_dir, test_start_date\n\n# Define the custom colormap with specified colors and ranges\ncolors = [\n    (0.8627, 0.8627, 0.8627),  # #DCDCDC - 0 - 1\n    (0.8627, 1.0000, 1.0000),  # #DCFFFF - 1 - 2\n    (0.6000, 1.0000, 1.0000),  # #99FFFF - 2 - 4\n    (0.5569, 0.8235, 1.0000),  # #8ED2FF - 4 - 6\n    (0.4509, 0.6196, 0.8745),  # #739EDF - 6 - 8\n    (0.4157, 0.4706, 1.0000),  # #6A78FF - 8 - 10\n    (0.4235, 0.2784, 1.0000),  # #6C47FF - 10 - 12\n    (0.5529, 0.0980, 1.0000),  # #8D19FF - 12 - 14\n    (0.7333, 0.0000, 0.9176),  # #BB00EA - 14 - 16\n    (0.8392, 0.0000, 0.7490),  # #D600BF - 16 - 18\n    (0.7569, 0.0039, 0.4549),  # #C10074 - 18 - 20\n    (0.6784, 0.0000, 0.1961),  # #AD0032 - 20 - 30\n    (0.5020, 0.0000, 0.0000)   # #800000 - > 30\n]\n\ncmap_name = 'custom_snow_colormap'\ncustom_cmap = mcolors.ListedColormap(colors)\n\n# Define the lat_lon_to_map_coordinates function\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\n# Define your value ranges for color mapping\nfixed_value_ranges = [1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 30]\n#value_ranges = [0.1, 0.2, 0.4, 0.6, 0.8, 1.0, 1.2, 1.5, 1.8, 2, 2.5, 3]\n\ndef create_color_maps_with_value_range(df_col, value_ranges=None):\n  new_value_ranges = value_ranges\n  if value_ranges == None:\n    max_value = df_col.max()\n    min_value = df_col.min()\n    if min_value < 0:\n      min_value = 0\n    step_size = (max_value - min_value) / 12\n\n    # Create 10 periods\n    new_value_ranges = [min_value + i * step_size for i in range(12)]\n    \n  print(\"new_value_ranges: \", new_value_ranges)\n  \n  # Define your custom function to map data values to colors\n  def map_value_to_color(value):\n    # Iterate through the value ranges to find the appropriate color index\n    for i, range_max in enumerate(new_value_ranges):\n      if value <= range_max:\n        return colors[i]\n\n      # If the value is greater than the largest range, return the last color\n      return colors[-1]\n\n    # Map predicted_swe values to colors using the custom function\n  color_mapping = [map_value_to_color(value) for value in df_col.values]\n  return color_mapping, new_value_ranges\n\ndef convert_csvs_to_images():\n    global fixed_value_ranges\n    data = pd.read_csv(\"/home/chetana/gridmet_test_run/test_data_predicted.csv\")\n#     print(data.head())\n    print(\"statistic of predicted_swe: \", data['predicted_swe'].describe())\n    data['predicted_swe'].fillna(0, inplace=True)\n    #data['predicted_swe'] = data['predicted_swe'].apply(lambda x: 0 if x < 2 else x)\n    \n    for column in data.columns:\n      column_data = data[column]\n      print(column_data.describe())\n\n#       # Print or process the description as needed\n#       print(f\"Column: {column}\")\n#       print(description)\n    \n    # Create a figure with a white background\n    fig = plt.figure(facecolor='white')\n\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    print(\"data['lon'].values = \", data['lon'].values)\n    x, y = m(data['lon'].values, data['lat'].values)\n#     print(\"x = \", x)\n#     print(\"y = \", y)\n#     print(\"v = \", data['predicted_swe'].values)\n    print(data.columns)\n\n    color_mapping, value_ranges = create_color_maps_with_value_range(data[\"predicted_swe\"], fixed_value_ranges)\n    \n    # Plot the data using the custom colormap\n    plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\n    \n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_date = datetime(1900, 1, 1)\n    day_value = day_index\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    timestamp_string = result_date.strftime(\"%Y-%m-%d\")\n    \n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    # Create custom legend elements using the same colormap\n    legend_elements = [Patch(color=colors[i], label=f\"{value_ranges[i]} - {value_ranges[i+1]-1}\" if i < len(value_ranges) - 1 else f\"> {value_ranges[-1]}\") for i in range(len(value_ranges))]\n\n    # Create the legend outside the map\n    legend = plt.legend(handles=legend_elements, loc='upper left', title='Legend', fontsize=8)\n    legend.set_bbox_to_anchor((1.01, 1)) \n\n    # Remove the color bar\n    #plt.colorbar().remove()\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Set the aspect ratio to 'equal' to keep the plot at the center\n    plt.gca().set_aspect('equal', adjustable='box')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15, right=0.80)  # Adjust right margin to accommodate the legend\n    # Show the plot or save it to a file\n    new_plot_path = f'/home/chetana/gridmet_test_run/predicted_swe-{test_start_date}.png'\n    print(f\"The new plot is saved to {new_plot_path}\")\n    plt.savefig(new_plot_path)\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\ndef convert_csvs_to_images_simple():\n    selected_date = datetime.strptime(test_start_date, \"%Y-%m-%d\")\n    var_name = \"predicted_swe\"\n    test_csv = \"/home/chetana/gridmet_test_run/test_data_predicted.csv\"\n    result_var_df = pd.read_csv(test_csv)\n    result_var_df.replace('--', pd.NA, inplace=True)\n    result_var_df.dropna(inplace=True)\n    result_var_df[var_name] = pd.to_numeric(result_var_df[var_name], errors='coerce')\n    print(result_var_df.head())\n    #print(gridmet_var_df[\"Latitude\"].describe())\n    #print(gridmet_var_df[\"Longitude\"].describe())\n    print(result_var_df[var_name].describe())\n\n    colormaplist, value_ranges = create_color_maps_with_value_range(result_var_df[var_name], fixed_value_ranges)\n\n    # Create a scatter plot\n    plt.scatter(result_var_df[\"lon\"].values, \n                result_var_df[\"lat\"].values, \n                label='Predicted SWE', \n                #color=colormaplist, \n                c=result_var_df['predicted_swe'], \n                cmap='viridis', \n                s=1, \n                edgecolor='none',\n#                 vmin=0,  # Set the minimum value\n#                 vmax=12\n               )\n\n    # Add a colorbar\n    cbar = plt.colorbar()\n    cbar.set_label('Predicted SWE')  # Label for the colorbar\n    \n    # Add labels and a legend\n    plt.xlabel('Longitude')\n    plt.ylabel('Latitude')\n    plt.title(f'SWE Prediction Map {test_start_date}')\n    plt.legend()\n\n    res_png_path = f\"{work_dir}/testing_output/{str(selected_date.year)}_{var_name}_{test_start_date}.png\"\n    plt.savefig(res_png_path)\n    print(f\"test image is saved at {res_png_path}\")\n    \n#convert_csvs_to_images()\n\nconvert_csvs_to_images_simple()\n",
  "history_output" : "Cannot run program \"/home/chetana/anaconda3/conda/bin/python\" (in directory \"/home/chetana/gw-workspace/n8cqbjhoe4m\"): error=2, No such file or directory",
  "history_begin_time" : 1695827864608,
  "history_end_time" : 1695827867010,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "100001",
  "indicator" : "Stopped"
},{
  "history_id" : "djoc2k7h3qr",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport uuid\nfrom snowcast_utils import day_index\nimport matplotlib.colors as mcolors\nfrom matplotlib.patches import Patch\nfrom snowcast_utils import day_index, work_dir, test_start_date\n\n# Define the custom colormap with specified colors and ranges\ncolors = [\n    (0.8627, 0.8627, 0.8627),  # #DCDCDC - 0 - 1\n    (0.8627, 1.0000, 1.0000),  # #DCFFFF - 1 - 2\n    (0.6000, 1.0000, 1.0000),  # #99FFFF - 2 - 4\n    (0.5569, 0.8235, 1.0000),  # #8ED2FF - 4 - 6\n    (0.4509, 0.6196, 0.8745),  # #739EDF - 6 - 8\n    (0.4157, 0.4706, 1.0000),  # #6A78FF - 8 - 10\n    (0.4235, 0.2784, 1.0000),  # #6C47FF - 10 - 12\n    (0.5529, 0.0980, 1.0000),  # #8D19FF - 12 - 14\n    (0.7333, 0.0000, 0.9176),  # #BB00EA - 14 - 16\n    (0.8392, 0.0000, 0.7490),  # #D600BF - 16 - 18\n    (0.7569, 0.0039, 0.4549),  # #C10074 - 18 - 20\n    (0.6784, 0.0000, 0.1961),  # #AD0032 - 20 - 30\n    (0.5020, 0.0000, 0.0000)   # #800000 - > 30\n]\n\ncmap_name = 'custom_snow_colormap'\ncustom_cmap = mcolors.ListedColormap(colors)\n\n# Define the lat_lon_to_map_coordinates function\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\n# Define your value ranges for color mapping\nfixed_value_ranges = [1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 30]\n#value_ranges = [0.1, 0.2, 0.4, 0.6, 0.8, 1.0, 1.2, 1.5, 1.8, 2, 2.5, 3]\n\ndef create_color_maps_with_value_range(df_col, value_ranges=None):\n  new_value_ranges = value_ranges\n  if value_ranges == None:\n    max_value = df_col.max()\n    min_value = df_col.min()\n    if min_value < 0:\n      min_value = 0\n    step_size = (max_value - min_value) / 12\n\n    # Create 10 periods\n    new_value_ranges = [min_value + i * step_size for i in range(12)]\n    \n  print(\"new_value_ranges: \", new_value_ranges)\n  \n  # Define your custom function to map data values to colors\n  def map_value_to_color(value):\n    # Iterate through the value ranges to find the appropriate color index\n    for i, range_max in enumerate(new_value_ranges):\n      if value <= range_max:\n        return colors[i]\n\n      # If the value is greater than the largest range, return the last color\n      return colors[-1]\n\n    # Map predicted_swe values to colors using the custom function\n  color_mapping = [map_value_to_color(value) for value in df_col.values]\n  return color_mapping, new_value_ranges\n\ndef convert_csvs_to_images():\n    global fixed_value_ranges\n    data = pd.read_csv(\"/home/chetana/gridmet_test_run/test_data_predicted.csv\")\n#     print(data.head())\n    print(\"statistic of predicted_swe: \", data['predicted_swe'].describe())\n    data['predicted_swe'].fillna(0, inplace=True)\n    #data['predicted_swe'] = data['predicted_swe'].apply(lambda x: 0 if x < 2 else x)\n    \n    for column in data.columns:\n      column_data = data[column]\n      print(column_data.describe())\n\n#       # Print or process the description as needed\n#       print(f\"Column: {column}\")\n#       print(description)\n    \n    # Create a figure with a white background\n    fig = plt.figure(facecolor='white')\n\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    print(\"data['lon'].values = \", data['lon'].values)\n    x, y = m(data['lon'].values, data['lat'].values)\n#     print(\"x = \", x)\n#     print(\"y = \", y)\n#     print(\"v = \", data['predicted_swe'].values)\n    print(data.columns)\n\n    color_mapping, value_ranges = create_color_maps_with_value_range(data[\"predicted_swe\"], fixed_value_ranges)\n    \n    # Plot the data using the custom colormap\n    plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\n    \n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_date = datetime(1900, 1, 1)\n    day_value = day_index\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    timestamp_string = result_date.strftime(\"%Y-%m-%d\")\n    \n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    # Create custom legend elements using the same colormap\n    legend_elements = [Patch(color=colors[i], label=f\"{value_ranges[i]} - {value_ranges[i+1]-1}\" if i < len(value_ranges) - 1 else f\"> {value_ranges[-1]}\") for i in range(len(value_ranges))]\n\n    # Create the legend outside the map\n    legend = plt.legend(handles=legend_elements, loc='upper left', title='Legend', fontsize=8)\n    legend.set_bbox_to_anchor((1.01, 1)) \n\n    # Remove the color bar\n    #plt.colorbar().remove()\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Set the aspect ratio to 'equal' to keep the plot at the center\n    plt.gca().set_aspect('equal', adjustable='box')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15, right=0.80)  # Adjust right margin to accommodate the legend\n    # Show the plot or save it to a file\n    new_plot_path = f'/home/chetana/gridmet_test_run/predicted_swe-{test_start_date}.png'\n    print(f\"The new plot is saved to {new_plot_path}\")\n    plt.savefig(new_plot_path)\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\ndef convert_csvs_to_images_simple():\n    selected_date = datetime.strptime(test_start_date, \"%Y-%m-%d\")\n    var_name = \"predicted_swe\"\n    test_csv = \"/home/chetana/gridmet_test_run/test_data_predicted.csv\"\n    result_var_df = pd.read_csv(test_csv)\n    result_var_df.replace('--', pd.NA, inplace=True)\n    result_var_df.dropna(inplace=True)\n    result_var_df[var_name] = pd.to_numeric(result_var_df[var_name], errors='coerce')\n    print(result_var_df.head())\n    #print(gridmet_var_df[\"Latitude\"].describe())\n    #print(gridmet_var_df[\"Longitude\"].describe())\n    print(result_var_df[var_name].describe())\n\n    colormaplist, value_ranges = create_color_maps_with_value_range(result_var_df[var_name], fixed_value_ranges)\n\n    # Create a scatter plot\n    plt.scatter(result_var_df[\"lon\"].values, \n                result_var_df[\"lat\"].values, \n                label='Predicted SWE', \n                #color=colormaplist, \n                c=result_var_df['predicted_swe'], \n                cmap='viridis', \n                s=1, \n                edgecolor='none',\n#                 vmin=0,  # Set the minimum value\n#                 vmax=12\n               )\n\n    # Add a colorbar\n    cbar = plt.colorbar()\n    cbar.set_label('Predicted SWE')  # Label for the colorbar\n    \n    # Add labels and a legend\n    plt.xlabel('Longitude')\n    plt.ylabel('Latitude')\n    plt.title(f'SWE Prediction Map {test_start_date}')\n    plt.legend()\n\n    res_png_path = f\"{work_dir}/testing_output/{str(selected_date.year)}_{var_name}_{test_start_date}.png\"\n    plt.savefig(res_png_path)\n    print(f\"test image is saved at {res_png_path}\")\n    \n#convert_csvs_to_images()\n\nconvert_csvs_to_images_simple()\n",
  "history_output" : "today date = 2023-09-26\ntest start date:  2022-03-15\ntest end date:  2023-09-26\n/home/chetana\n     date   lat      lon  SWE  ...     aspect  eastness  northness  predicted_swe\n69  44633  49.0 -122.516    0  ...   91.84747  0.785138  -0.032228        10.1720\n70  44633  49.0 -122.480    0  ...   90.00000  0.785398   0.000000        10.1790\n71  44633  49.0 -122.444    0  ...  329.53427 -0.469250   0.711381        10.1035\n72  44633  49.0 -122.408    0  ...  270.00000 -0.785398   0.000000        10.1450\n73  44633  49.0 -122.372    0  ...   83.99069  0.782643   0.104310        10.2305\n[5 rows x 20 columns]\ncount    288650.000000\nmean          9.639122\nstd           0.676329\nmin           7.775500\n25%           9.042500\n50%           9.934500\n75%          10.240000\nmax          10.370000\nName: predicted_swe, dtype: float64\nnew_value_ranges:  [1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 30]\ntest image is saved at /home/chetana/gridmet_test_run/testing_output/2022_predicted_swe_2022-03-15.png\n",
  "history_begin_time" : 1695696668396,
  "history_end_time" : 1695696675058,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "100001",
  "indicator" : "Done"
},{
  "history_id" : "svx0atr2fms",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport uuid\nfrom snowcast_utils import day_index\nimport matplotlib.colors as mcolors\nfrom matplotlib.patches import Patch\nfrom snowcast_utils import day_index, work_dir, test_start_date\n\n# Define the custom colormap with specified colors and ranges\ncolors = [\n    (0.8627, 0.8627, 0.8627),  # #DCDCDC - 0 - 1\n    (0.8627, 1.0000, 1.0000),  # #DCFFFF - 1 - 2\n    (0.6000, 1.0000, 1.0000),  # #99FFFF - 2 - 4\n    (0.5569, 0.8235, 1.0000),  # #8ED2FF - 4 - 6\n    (0.4509, 0.6196, 0.8745),  # #739EDF - 6 - 8\n    (0.4157, 0.4706, 1.0000),  # #6A78FF - 8 - 10\n    (0.4235, 0.2784, 1.0000),  # #6C47FF - 10 - 12\n    (0.5529, 0.0980, 1.0000),  # #8D19FF - 12 - 14\n    (0.7333, 0.0000, 0.9176),  # #BB00EA - 14 - 16\n    (0.8392, 0.0000, 0.7490),  # #D600BF - 16 - 18\n    (0.7569, 0.0039, 0.4549),  # #C10074 - 18 - 20\n    (0.6784, 0.0000, 0.1961),  # #AD0032 - 20 - 30\n    (0.5020, 0.0000, 0.0000)   # #800000 - > 30\n]\n\ncmap_name = 'custom_snow_colormap'\ncustom_cmap = mcolors.ListedColormap(colors)\n\n# Define the lat_lon_to_map_coordinates function\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\n# Define your value ranges for color mapping\nfixed_value_ranges = [1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 30]\n#value_ranges = [0.1, 0.2, 0.4, 0.6, 0.8, 1.0, 1.2, 1.5, 1.8, 2, 2.5, 3]\n\ndef create_color_maps_with_value_range(df_col, value_ranges=None):\n  new_value_ranges = value_ranges\n  if value_ranges == None:\n    max_value = df_col.max()\n    min_value = df_col.min()\n    if min_value < 0:\n      min_value = 0\n    step_size = (max_value - min_value) / 12\n\n    # Create 10 periods\n    new_value_ranges = [min_value + i * step_size for i in range(12)]\n    \n  print(\"new_value_ranges: \", new_value_ranges)\n  \n  # Define your custom function to map data values to colors\n  def map_value_to_color(value):\n    # Iterate through the value ranges to find the appropriate color index\n    for i, range_max in enumerate(new_value_ranges):\n      if value <= range_max:\n        return colors[i]\n\n      # If the value is greater than the largest range, return the last color\n      return colors[-1]\n\n    # Map predicted_swe values to colors using the custom function\n  color_mapping = [map_value_to_color(value) for value in df_col.values]\n  return color_mapping, new_value_ranges\n\ndef convert_csvs_to_images():\n    global fixed_value_ranges\n    data = pd.read_csv(\"/home/chetana/gridmet_test_run/test_data_predicted.csv\")\n#     print(data.head())\n    print(\"statistic of predicted_swe: \", data['predicted_swe'].describe())\n    data['predicted_swe'].fillna(0, inplace=True)\n    #data['predicted_swe'] = data['predicted_swe'].apply(lambda x: 0 if x < 2 else x)\n    \n    for column in data.columns:\n      column_data = data[column]\n      print(column_data.describe())\n\n#       # Print or process the description as needed\n#       print(f\"Column: {column}\")\n#       print(description)\n    \n    # Create a figure with a white background\n    fig = plt.figure(facecolor='white')\n\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    print(\"data['lon'].values = \", data['lon'].values)\n    x, y = m(data['lon'].values, data['lat'].values)\n#     print(\"x = \", x)\n#     print(\"y = \", y)\n#     print(\"v = \", data['predicted_swe'].values)\n    print(data.columns)\n\n    color_mapping, value_ranges = create_color_maps_with_value_range(data[\"predicted_swe\"], fixed_value_ranges)\n    \n    # Plot the data using the custom colormap\n    plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\n    \n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_date = datetime(1900, 1, 1)\n    day_value = day_index\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    timestamp_string = result_date.strftime(\"%Y-%m-%d\")\n    \n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    # Create custom legend elements using the same colormap\n    legend_elements = [Patch(color=colors[i], label=f\"{value_ranges[i]} - {value_ranges[i+1]-1}\" if i < len(value_ranges) - 1 else f\"> {value_ranges[-1]}\") for i in range(len(value_ranges))]\n\n    # Create the legend outside the map\n    legend = plt.legend(handles=legend_elements, loc='upper left', title='Legend', fontsize=8)\n    legend.set_bbox_to_anchor((1.01, 1)) \n\n    # Remove the color bar\n    #plt.colorbar().remove()\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Set the aspect ratio to 'equal' to keep the plot at the center\n    plt.gca().set_aspect('equal', adjustable='box')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15, right=0.80)  # Adjust right margin to accommodate the legend\n    # Show the plot or save it to a file\n    new_plot_path = f'/home/chetana/gridmet_test_run/predicted_swe-{test_start_date}.png'\n    print(f\"The new plot is saved to {new_plot_path}\")\n    plt.savefig(new_plot_path)\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\ndef convert_csvs_to_images_simple():\n    selected_date = datetime.strptime(test_start_date, \"%Y-%m-%d\")\n    var_name = \"predicted_swe\"\n    test_csv = \"/home/chetana/gridmet_test_run/test_data_predicted.csv\"\n    result_var_df = pd.read_csv(test_csv)\n    result_var_df.replace('--', pd.NA, inplace=True)\n    result_var_df.dropna(inplace=True)\n    result_var_df[var_name] = pd.to_numeric(result_var_df[var_name], errors='coerce')\n    print(result_var_df.head())\n    #print(gridmet_var_df[\"Latitude\"].describe())\n    #print(gridmet_var_df[\"Longitude\"].describe())\n    print(result_var_df[var_name].describe())\n\n    colormaplist, value_ranges = create_color_maps_with_value_range(result_var_df[var_name], fixed_value_ranges)\n\n    # Create a scatter plot\n    plt.scatter(result_var_df[\"lon\"].values, \n                result_var_df[\"lat\"].values, \n                label='Predicted SWE', \n                #color=colormaplist, \n                c=result_var_df['predicted_swe'], \n                cmap='viridis', \n                s=1, \n                edgecolor='none',\n#                 vmin=0,  # Set the minimum value\n#                 vmax=12\n               )\n\n    # Add a colorbar\n    cbar = plt.colorbar()\n    cbar.set_label('Predicted SWE')  # Label for the colorbar\n    \n    # Add labels and a legend\n    plt.xlabel('Longitude')\n    plt.ylabel('Latitude')\n    plt.title(f'SWE Prediction Map {test_start_date}')\n    plt.legend()\n\n    res_png_path = f\"{work_dir}/testing_output/{str(selected_date.year)}_{var_name}_{test_start_date}.png\"\n    plt.savefig(res_png_path)\n    print(f\"test image is saved at {res_png_path}\")\n    \n#convert_csvs_to_images()\n\nconvert_csvs_to_images_simple()\n",
  "history_output" : "today date = 2023-09-26\ntest start date:  2022-04-17\ntest end date:  2023-09-26\n/home/chetana\n     date   lat      lon  SWE  ...     aspect  eastness  northness  predicted_swe\n69  44666  49.0 -122.516  255  ...   91.84747  0.785138  -0.032228         2.5475\n70  44666  49.0 -122.480  255  ...   90.00000  0.785398   0.000000         2.5565\n71  44666  49.0 -122.444  255  ...  329.53427 -0.469250   0.711381         2.5315\n72  44666  49.0 -122.408  255  ...  270.00000 -0.785398   0.000000         2.5570\n73  44666  49.0 -122.372  255  ...   83.99069  0.782643   0.104310         2.5930\n[5 rows x 20 columns]\ncount    288650.000000\nmean          2.536505\nstd           0.113148\nmin           2.112500\n25%           2.449500\n50%           2.549750\n75%           2.637500\nmax           2.800500\nName: predicted_swe, dtype: float64\nnew_value_ranges:  [1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 30]\ntest image is saved at /home/chetana/gridmet_test_run/testing_output/2022_predicted_swe_2022-04-17.png\n",
  "history_begin_time" : 1695694433488,
  "history_end_time" : 1695694440078,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "100001",
  "indicator" : "Done"
},{
  "history_id" : "QixnnaKjNMCG",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport uuid\nfrom snowcast_utils import day_index\nimport matplotlib.colors as mcolors\nfrom matplotlib.patches import Patch\nfrom snowcast_utils import day_index, work_dir, test_start_date\n\n# Define the custom colormap with specified colors and ranges\ncolors = [\n    (0.8627, 0.8627, 0.8627),  # #DCDCDC - 0 - 1\n    (0.8627, 1.0000, 1.0000),  # #DCFFFF - 1 - 2\n    (0.6000, 1.0000, 1.0000),  # #99FFFF - 2 - 4\n    (0.5569, 0.8235, 1.0000),  # #8ED2FF - 4 - 6\n    (0.4509, 0.6196, 0.8745),  # #739EDF - 6 - 8\n    (0.4157, 0.4706, 1.0000),  # #6A78FF - 8 - 10\n    (0.4235, 0.2784, 1.0000),  # #6C47FF - 10 - 12\n    (0.5529, 0.0980, 1.0000),  # #8D19FF - 12 - 14\n    (0.7333, 0.0000, 0.9176),  # #BB00EA - 14 - 16\n    (0.8392, 0.0000, 0.7490),  # #D600BF - 16 - 18\n    (0.7569, 0.0039, 0.4549),  # #C10074 - 18 - 20\n    (0.6784, 0.0000, 0.1961),  # #AD0032 - 20 - 30\n    (0.5020, 0.0000, 0.0000)   # #800000 - > 30\n]\n\ncmap_name = 'custom_snow_colormap'\ncustom_cmap = mcolors.ListedColormap(colors)\n\n# Define the lat_lon_to_map_coordinates function\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\n# Define your value ranges for color mapping\nfixed_value_ranges = [1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 30]\n#value_ranges = [0.1, 0.2, 0.4, 0.6, 0.8, 1.0, 1.2, 1.5, 1.8, 2, 2.5, 3]\n\ndef create_color_maps_with_value_range(df_col, value_ranges=None):\n  new_value_ranges = value_ranges\n  if value_ranges == None:\n    max_value = df_col.max()\n    min_value = df_col.min()\n    if min_value < 0:\n      min_value = 0\n    step_size = (max_value - min_value) / 12\n\n    # Create 10 periods\n    new_value_ranges = [min_value + i * step_size for i in range(12)]\n    \n  print(\"new_value_ranges: \", new_value_ranges)\n  \n  # Define your custom function to map data values to colors\n  def map_value_to_color(value):\n    # Iterate through the value ranges to find the appropriate color index\n    for i, range_max in enumerate(new_value_ranges):\n      if value <= range_max:\n        return colors[i]\n\n      # If the value is greater than the largest range, return the last color\n      return colors[-1]\n\n    # Map predicted_swe values to colors using the custom function\n  color_mapping = [map_value_to_color(value) for value in df_col.values]\n  return color_mapping, new_value_ranges\n\ndef convert_csvs_to_images():\n    global fixed_value_ranges\n    data = pd.read_csv(\"/home/chetana/gridmet_test_run/test_data_predicted.csv\")\n#     print(data.head())\n    print(\"statistic of predicted_swe: \", data['predicted_swe'].describe())\n    data['predicted_swe'].fillna(0, inplace=True)\n    #data['predicted_swe'] = data['predicted_swe'].apply(lambda x: 0 if x < 2 else x)\n    \n    for column in data.columns:\n      column_data = data[column]\n      print(column_data.describe())\n\n#       # Print or process the description as needed\n#       print(f\"Column: {column}\")\n#       print(description)\n    \n    # Create a figure with a white background\n    fig = plt.figure(facecolor='white')\n\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    print(\"data['lon'].values = \", data['lon'].values)\n    x, y = m(data['lon'].values, data['lat'].values)\n#     print(\"x = \", x)\n#     print(\"y = \", y)\n#     print(\"v = \", data['predicted_swe'].values)\n    print(data.columns)\n\n    color_mapping, value_ranges = create_color_maps_with_value_range(data[\"predicted_swe\"], fixed_value_ranges)\n    \n    # Plot the data using the custom colormap\n    plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\n    \n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_date = datetime(1900, 1, 1)\n    day_value = day_index\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    timestamp_string = result_date.strftime(\"%Y-%m-%d\")\n    \n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    # Create custom legend elements using the same colormap\n    legend_elements = [Patch(color=colors[i], label=f\"{value_ranges[i]} - {value_ranges[i+1]-1}\" if i < len(value_ranges) - 1 else f\"> {value_ranges[-1]}\") for i in range(len(value_ranges))]\n\n    # Create the legend outside the map\n    legend = plt.legend(handles=legend_elements, loc='upper left', title='Legend', fontsize=8)\n    legend.set_bbox_to_anchor((1.01, 1)) \n\n    # Remove the color bar\n    #plt.colorbar().remove()\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Set the aspect ratio to 'equal' to keep the plot at the center\n    plt.gca().set_aspect('equal', adjustable='box')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15, right=0.80)  # Adjust right margin to accommodate the legend\n    # Show the plot or save it to a file\n    new_plot_path = f'/home/chetana/gridmet_test_run/predicted_swe-{test_start_date}.png'\n    print(f\"The new plot is saved to {new_plot_path}\")\n    plt.savefig(new_plot_path)\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\ndef convert_csvs_to_images_simple():\n    selected_date = datetime.strptime(test_start_date, \"%Y-%m-%d\")\n    var_name = \"predicted_swe\"\n    test_csv = \"/home/chetana/gridmet_test_run/test_data_predicted.csv\"\n    result_var_df = pd.read_csv(test_csv)\n    result_var_df.replace('--', pd.NA, inplace=True)\n    result_var_df.dropna(inplace=True)\n    result_var_df[var_name] = pd.to_numeric(result_var_df[var_name], errors='coerce')\n    print(result_var_df.head())\n    #print(gridmet_var_df[\"Latitude\"].describe())\n    #print(gridmet_var_df[\"Longitude\"].describe())\n    print(result_var_df[var_name].describe())\n\n    colormaplist, value_ranges = create_color_maps_with_value_range(result_var_df[var_name], fixed_value_ranges)\n\n    # Create a scatter plot\n    plt.scatter(result_var_df[\"lon\"].values, \n                result_var_df[\"lat\"].values, \n                label='Predicted SWE', \n                #color=colormaplist, \n                c=result_var_df['predicted_swe'], \n                cmap='viridis', \n                s=1, \n                edgecolor='none',\n#                 vmin=0,  # Set the minimum value\n#                 vmax=12\n               )\n\n    # Add a colorbar\n    cbar = plt.colorbar()\n    cbar.set_label('Predicted SWE')  # Label for the colorbar\n    \n    # Add labels and a legend\n    plt.xlabel('Longitude')\n    plt.ylabel('Latitude')\n    plt.title(f'SWE Prediction Map {test_start_date}')\n    plt.legend()\n\n    res_png_path = f\"{work_dir}/testing_output/{str(selected_date.year)}_{var_name}_{test_start_date}.png\"\n    plt.savefig(res_png_path)\n    print(f\"test image is saved at {res_png_path}\")\n    \n#convert_csvs_to_images()\n\nconvert_csvs_to_images_simple()\n",
  "history_output" : "today date = 2023-09-26\ntest start date:  2022-01-17\ntest end date:  2023-09-26\n/home/chetana\n     date   lat      lon  SWE  ...     aspect  eastness  northness  predicted_swe\n69  44576  49.0 -122.516    0  ...   91.84747  0.785138  -0.032228         9.8830\n70  44576  49.0 -122.480    0  ...   90.00000  0.785398   0.000000         9.8865\n71  44576  49.0 -122.444    0  ...  329.53427 -0.469250   0.711381         9.8560\n72  44576  49.0 -122.408    0  ...  270.00000 -0.785398   0.000000         9.8495\n73  44576  49.0 -122.372    0  ...   83.99069  0.782643   0.104310         9.8830\n[5 rows x 20 columns]\ncount    288650.000000\nmean          9.588171\nstd           0.445232\nmin           7.576500\n25%           9.470500\n50%           9.808500\n75%           9.877000\nmax           9.943000\nName: predicted_swe, dtype: float64\nnew_value_ranges:  [1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 30]\ntest image is saved at /home/chetana/gridmet_test_run/testing_output/2022_predicted_swe_2022-01-17.png\n",
  "history_begin_time" : 1695693960057,
  "history_end_time" : 1695693965479,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "MyvpDIYMDmcA",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport uuid\nfrom snowcast_utils import day_index\nimport matplotlib.colors as mcolors\nfrom matplotlib.patches import Patch\nfrom snowcast_utils import day_index, work_dir, test_start_date\n\n# Define the custom colormap with specified colors and ranges\ncolors = [\n    (0.8627, 0.8627, 0.8627),  # #DCDCDC - 0 - 1\n    (0.8627, 1.0000, 1.0000),  # #DCFFFF - 1 - 2\n    (0.6000, 1.0000, 1.0000),  # #99FFFF - 2 - 4\n    (0.5569, 0.8235, 1.0000),  # #8ED2FF - 4 - 6\n    (0.4509, 0.6196, 0.8745),  # #739EDF - 6 - 8\n    (0.4157, 0.4706, 1.0000),  # #6A78FF - 8 - 10\n    (0.4235, 0.2784, 1.0000),  # #6C47FF - 10 - 12\n    (0.5529, 0.0980, 1.0000),  # #8D19FF - 12 - 14\n    (0.7333, 0.0000, 0.9176),  # #BB00EA - 14 - 16\n    (0.8392, 0.0000, 0.7490),  # #D600BF - 16 - 18\n    (0.7569, 0.0039, 0.4549),  # #C10074 - 18 - 20\n    (0.6784, 0.0000, 0.1961),  # #AD0032 - 20 - 30\n    (0.5020, 0.0000, 0.0000)   # #800000 - > 30\n]\n\ncmap_name = 'custom_snow_colormap'\ncustom_cmap = mcolors.ListedColormap(colors)\n\n# Define the lat_lon_to_map_coordinates function\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\n# Define your value ranges for color mapping\nfixed_value_ranges = [1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 30]\n#value_ranges = [0.1, 0.2, 0.4, 0.6, 0.8, 1.0, 1.2, 1.5, 1.8, 2, 2.5, 3]\n\ndef create_color_maps_with_value_range(df_col, value_ranges=None):\n  new_value_ranges = value_ranges\n  if value_ranges == None:\n    max_value = df_col.max()\n    min_value = df_col.min()\n    if min_value < 0:\n      min_value = 0\n    step_size = (max_value - min_value) / 12\n\n    # Create 10 periods\n    new_value_ranges = [min_value + i * step_size for i in range(12)]\n    \n  print(\"new_value_ranges: \", new_value_ranges)\n  \n  # Define your custom function to map data values to colors\n  def map_value_to_color(value):\n    # Iterate through the value ranges to find the appropriate color index\n    for i, range_max in enumerate(new_value_ranges):\n      if value <= range_max:\n        return colors[i]\n\n      # If the value is greater than the largest range, return the last color\n      return colors[-1]\n\n    # Map predicted_swe values to colors using the custom function\n  color_mapping = [map_value_to_color(value) for value in df_col.values]\n  return color_mapping, new_value_ranges\n\ndef convert_csvs_to_images():\n    global fixed_value_ranges\n    data = pd.read_csv(\"/home/chetana/gridmet_test_run/test_data_predicted.csv\")\n#     print(data.head())\n    print(\"statistic of predicted_swe: \", data['predicted_swe'].describe())\n    data['predicted_swe'].fillna(0, inplace=True)\n    #data['predicted_swe'] = data['predicted_swe'].apply(lambda x: 0 if x < 2 else x)\n    \n    for column in data.columns:\n      column_data = data[column]\n      print(column_data.describe())\n\n#       # Print or process the description as needed\n#       print(f\"Column: {column}\")\n#       print(description)\n    \n    # Create a figure with a white background\n    fig = plt.figure(facecolor='white')\n\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    print(\"data['lon'].values = \", data['lon'].values)\n    x, y = m(data['lon'].values, data['lat'].values)\n#     print(\"x = \", x)\n#     print(\"y = \", y)\n#     print(\"v = \", data['predicted_swe'].values)\n    print(data.columns)\n\n    color_mapping, value_ranges = create_color_maps_with_value_range(data[\"predicted_swe\"], fixed_value_ranges)\n    \n    # Plot the data using the custom colormap\n    plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\n    \n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_date = datetime(1900, 1, 1)\n    day_value = day_index\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    timestamp_string = result_date.strftime(\"%Y-%m-%d\")\n    \n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    # Create custom legend elements using the same colormap\n    legend_elements = [Patch(color=colors[i], label=f\"{value_ranges[i]} - {value_ranges[i+1]-1}\" if i < len(value_ranges) - 1 else f\"> {value_ranges[-1]}\") for i in range(len(value_ranges))]\n\n    # Create the legend outside the map\n    legend = plt.legend(handles=legend_elements, loc='upper left', title='Legend', fontsize=8)\n    legend.set_bbox_to_anchor((1.01, 1)) \n\n    # Remove the color bar\n    #plt.colorbar().remove()\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Set the aspect ratio to 'equal' to keep the plot at the center\n    plt.gca().set_aspect('equal', adjustable='box')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15, right=0.80)  # Adjust right margin to accommodate the legend\n    # Show the plot or save it to a file\n    new_plot_path = f'/home/chetana/gridmet_test_run/predicted_swe-{test_start_date}.png'\n    print(f\"The new plot is saved to {new_plot_path}\")\n    plt.savefig(new_plot_path)\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\ndef convert_csvs_to_images_simple():\n    selected_date = datetime.strptime(test_start_date, \"%Y-%m-%d\")\n    var_name = \"predicted_swe\"\n    test_csv = \"/home/chetana/gridmet_test_run/test_data_predicted.csv\"\n    result_var_df = pd.read_csv(test_csv)\n    result_var_df.replace('--', pd.NA, inplace=True)\n    result_var_df.dropna(inplace=True)\n    result_var_df[var_name] = pd.to_numeric(result_var_df[var_name], errors='coerce')\n    print(result_var_df.head())\n    #print(gridmet_var_df[\"Latitude\"].describe())\n    #print(gridmet_var_df[\"Longitude\"].describe())\n    print(result_var_df[var_name].describe())\n\n    colormaplist, value_ranges = create_color_maps_with_value_range(result_var_df[var_name], fixed_value_ranges)\n\n    # Create a scatter plot\n    plt.scatter(result_var_df[\"lon\"].values, \n                result_var_df[\"lat\"].values, \n                label='Predicted SWE', \n                #color=colormaplist, \n                c=result_var_df['predicted_swe'], \n                cmap='viridis', \n                s=5, \n                edgecolor='none',\n#                 vmin=0,  # Set the minimum value\n#                 vmax=12\n               )\n\n    # Add a colorbar\n    cbar = plt.colorbar()\n    cbar.set_label('Predicted SWE')  # Label for the colorbar\n    \n    # Add labels and a legend\n    plt.xlabel('Longitude')\n    plt.ylabel('Latitude')\n    plt.title(f'SWE Prediction Map {test_start_date}')\n    plt.legend()\n\n    res_png_path = f\"{work_dir}/testing_output/{str(selected_date.year)}_{var_name}_{test_start_date}.png\"\n    plt.savefig(res_png_path)\n    print(f\"test image is saved at {res_png_path}\")\n    \n#convert_csvs_to_images()\n\nconvert_csvs_to_images_simple()\n",
  "history_output" : "today date = 2023-09-26\ntest start date:  2022-01-17\ntest end date:  2023-09-26\n/home/chetana\n     date   lat      lon  SWE  ...     aspect  eastness  northness  predicted_swe\n69  44576  49.0 -122.516    0  ...   91.84747  0.785138  -0.032228         9.8830\n70  44576  49.0 -122.480    0  ...   90.00000  0.785398   0.000000         9.8865\n71  44576  49.0 -122.444    0  ...  329.53427 -0.469250   0.711381         9.8560\n72  44576  49.0 -122.408    0  ...  270.00000 -0.785398   0.000000         9.8495\n73  44576  49.0 -122.372    0  ...   83.99069  0.782643   0.104310         9.8830\n[5 rows x 20 columns]\ncount    288650.000000\nmean          9.588171\nstd           0.445232\nmin           7.576500\n25%           9.470500\n50%           9.808500\n75%           9.877000\nmax           9.943000\nName: predicted_swe, dtype: float64\nnew_value_ranges:  [1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 30]\ntest image is saved at /home/chetana/gridmet_test_run/testing_output/2022_predicted_swe_2022-01-17.png\n",
  "history_begin_time" : 1695693906505,
  "history_end_time" : 1695693911936,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "qcm4DFO8KyeO",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport uuid\nfrom snowcast_utils import day_index\nimport matplotlib.colors as mcolors\nfrom matplotlib.patches import Patch\nfrom snowcast_utils import day_index, work_dir, test_start_date\n\n# Define the custom colormap with specified colors and ranges\ncolors = [\n    (0.8627, 0.8627, 0.8627),  # #DCDCDC - 0 - 1\n    (0.8627, 1.0000, 1.0000),  # #DCFFFF - 1 - 2\n    (0.6000, 1.0000, 1.0000),  # #99FFFF - 2 - 4\n    (0.5569, 0.8235, 1.0000),  # #8ED2FF - 4 - 6\n    (0.4509, 0.6196, 0.8745),  # #739EDF - 6 - 8\n    (0.4157, 0.4706, 1.0000),  # #6A78FF - 8 - 10\n    (0.4235, 0.2784, 1.0000),  # #6C47FF - 10 - 12\n    (0.5529, 0.0980, 1.0000),  # #8D19FF - 12 - 14\n    (0.7333, 0.0000, 0.9176),  # #BB00EA - 14 - 16\n    (0.8392, 0.0000, 0.7490),  # #D600BF - 16 - 18\n    (0.7569, 0.0039, 0.4549),  # #C10074 - 18 - 20\n    (0.6784, 0.0000, 0.1961),  # #AD0032 - 20 - 30\n    (0.5020, 0.0000, 0.0000)   # #800000 - > 30\n]\n\ncmap_name = 'custom_snow_colormap'\ncustom_cmap = mcolors.ListedColormap(colors)\n\n# Define the lat_lon_to_map_coordinates function\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\n# Define your value ranges for color mapping\nfixed_value_ranges = [1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 30]\n#value_ranges = [0.1, 0.2, 0.4, 0.6, 0.8, 1.0, 1.2, 1.5, 1.8, 2, 2.5, 3]\n\ndef create_color_maps_with_value_range(df_col, value_ranges=None):\n  new_value_ranges = value_ranges\n  if value_ranges == None:\n    max_value = df_col.max()\n    min_value = df_col.min()\n    if min_value < 0:\n      min_value = 0\n    step_size = (max_value - min_value) / 12\n\n    # Create 10 periods\n    new_value_ranges = [min_value + i * step_size for i in range(12)]\n    \n  print(\"new_value_ranges: \", new_value_ranges)\n  \n  # Define your custom function to map data values to colors\n  def map_value_to_color(value):\n    # Iterate through the value ranges to find the appropriate color index\n    for i, range_max in enumerate(new_value_ranges):\n      if value <= range_max:\n        return colors[i]\n\n      # If the value is greater than the largest range, return the last color\n      return colors[-1]\n\n    # Map predicted_swe values to colors using the custom function\n  color_mapping = [map_value_to_color(value) for value in df_col.values]\n  return color_mapping, new_value_ranges\n\ndef convert_csvs_to_images():\n    global fixed_value_ranges\n    data = pd.read_csv(\"/home/chetana/gridmet_test_run/test_data_predicted.csv\")\n#     print(data.head())\n    print(\"statistic of predicted_swe: \", data['predicted_swe'].describe())\n    data['predicted_swe'].fillna(0, inplace=True)\n    #data['predicted_swe'] = data['predicted_swe'].apply(lambda x: 0 if x < 2 else x)\n    \n    for column in data.columns:\n      column_data = data[column]\n      print(column_data.describe())\n\n#       # Print or process the description as needed\n#       print(f\"Column: {column}\")\n#       print(description)\n    \n    # Create a figure with a white background\n    fig = plt.figure(facecolor='white')\n\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    print(\"data['lon'].values = \", data['lon'].values)\n    x, y = m(data['lon'].values, data['lat'].values)\n#     print(\"x = \", x)\n#     print(\"y = \", y)\n#     print(\"v = \", data['predicted_swe'].values)\n    print(data.columns)\n\n    color_mapping, value_ranges = create_color_maps_with_value_range(data[\"predicted_swe\"], fixed_value_ranges)\n    \n    # Plot the data using the custom colormap\n    plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\n    \n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_date = datetime(1900, 1, 1)\n    day_value = day_index\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    timestamp_string = result_date.strftime(\"%Y-%m-%d\")\n    \n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    # Create custom legend elements using the same colormap\n    legend_elements = [Patch(color=colors[i], label=f\"{value_ranges[i]} - {value_ranges[i+1]-1}\" if i < len(value_ranges) - 1 else f\"> {value_ranges[-1]}\") for i in range(len(value_ranges))]\n\n    # Create the legend outside the map\n    legend = plt.legend(handles=legend_elements, loc='upper left', title='Legend', fontsize=8)\n    legend.set_bbox_to_anchor((1.01, 1)) \n\n    # Remove the color bar\n    #plt.colorbar().remove()\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Set the aspect ratio to 'equal' to keep the plot at the center\n    plt.gca().set_aspect('equal', adjustable='box')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15, right=0.80)  # Adjust right margin to accommodate the legend\n    # Show the plot or save it to a file\n    new_plot_path = f'/home/chetana/gridmet_test_run/predicted_swe-{test_start_date}.png'\n    print(f\"The new plot is saved to {new_plot_path}\")\n    plt.savefig(new_plot_path)\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\ndef convert_csvs_to_images_simple():\n    selected_date = datetime.strptime(test_start_date, \"%Y-%m-%d\")\n    var_name = \"predicted_swe\"\n    test_csv = \"/home/chetana/gridmet_test_run/test_data_predicted.csv\"\n    result_var_df = pd.read_csv(test_csv)\n    result_var_df.replace('--', pd.NA, inplace=True)\n    result_var_df.dropna(inplace=True)\n    result_var_df[var_name] = pd.to_numeric(result_var_df[var_name], errors='coerce')\n    print(result_var_df.head())\n    #print(gridmet_var_df[\"Latitude\"].describe())\n    #print(gridmet_var_df[\"Longitude\"].describe())\n    print(result_var_df[var_name].describe())\n\n    colormaplist, value_ranges = create_color_maps_with_value_range(result_var_df[var_name], fixed_value_ranges)\n\n    # Create a scatter plot\n    plt.scatter(result_var_df[\"lon\"].values, \n                result_var_df[\"lat\"].values, \n                label='Predicted SWE', \n                #color=colormaplist, \n                c=result_var_df['predicted_swe'], \n                cmap='viridis', \n                s=50, \n                edgecolor='none',\n                vmin=0,  # Set the minimum value\n                vmax=12)\n\n    # Add a colorbar\n    cbar = plt.colorbar()\n    cbar.set_label('Predicted SWE')  # Label for the colorbar\n    \n    # Add labels and a legend\n    plt.xlabel('Longitude')\n    plt.ylabel('Latitude')\n    plt.title(f'SWE Prediction Map {test_start_date}')\n    plt.legend()\n\n    res_png_path = f\"{work_dir}/testing_output/{str(selected_date.year)}_{var_name}_{test_start_date}.png\"\n    plt.savefig(res_png_path)\n    print(f\"test image is saved at {res_png_path}\")\n    \n#convert_csvs_to_images()\n\nconvert_csvs_to_images_simple()\n",
  "history_output" : "today date = 2023-09-26\ntest start date:  2022-01-17\ntest end date:  2023-09-26\n/home/chetana\n     date   lat      lon  SWE  ...     aspect  eastness  northness  predicted_swe\n69  44576  49.0 -122.516    0  ...   91.84747  0.785138  -0.032228         9.8830\n70  44576  49.0 -122.480    0  ...   90.00000  0.785398   0.000000         9.8865\n71  44576  49.0 -122.444    0  ...  329.53427 -0.469250   0.711381         9.8560\n72  44576  49.0 -122.408    0  ...  270.00000 -0.785398   0.000000         9.8495\n73  44576  49.0 -122.372    0  ...   83.99069  0.782643   0.104310         9.8830\n[5 rows x 20 columns]\ncount    288650.000000\nmean          9.588171\nstd           0.445232\nmin           7.576500\n25%           9.470500\n50%           9.808500\n75%           9.877000\nmax           9.943000\nName: predicted_swe, dtype: float64\nnew_value_ranges:  [1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 30]\ntest image is saved at /home/chetana/gridmet_test_run/testing_output/2022_predicted_swe_2022-01-17.png\n",
  "history_begin_time" : 1695693734152,
  "history_end_time" : 1695693740483,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "ORMbrs8Csc8F",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport uuid\nfrom snowcast_utils import day_index\nimport matplotlib.colors as mcolors\nfrom matplotlib.patches import Patch\nfrom snowcast_utils import day_index, work_dir, test_start_date\n\n# Define the custom colormap with specified colors and ranges\ncolors = [\n    (0.8627, 0.8627, 0.8627),  # #DCDCDC - 0 - 1\n    (0.8627, 1.0000, 1.0000),  # #DCFFFF - 1 - 2\n    (0.6000, 1.0000, 1.0000),  # #99FFFF - 2 - 4\n    (0.5569, 0.8235, 1.0000),  # #8ED2FF - 4 - 6\n    (0.4509, 0.6196, 0.8745),  # #739EDF - 6 - 8\n    (0.4157, 0.4706, 1.0000),  # #6A78FF - 8 - 10\n    (0.4235, 0.2784, 1.0000),  # #6C47FF - 10 - 12\n    (0.5529, 0.0980, 1.0000),  # #8D19FF - 12 - 14\n    (0.7333, 0.0000, 0.9176),  # #BB00EA - 14 - 16\n    (0.8392, 0.0000, 0.7490),  # #D600BF - 16 - 18\n    (0.7569, 0.0039, 0.4549),  # #C10074 - 18 - 20\n    (0.6784, 0.0000, 0.1961),  # #AD0032 - 20 - 30\n    (0.5020, 0.0000, 0.0000)   # #800000 - > 30\n]\n\ncmap_name = 'custom_snow_colormap'\ncustom_cmap = mcolors.ListedColormap(colors)\n\n# Define the lat_lon_to_map_coordinates function\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\n# Define your value ranges for color mapping\nfixed_value_ranges = [1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 30]\n#value_ranges = [0.1, 0.2, 0.4, 0.6, 0.8, 1.0, 1.2, 1.5, 1.8, 2, 2.5, 3]\n\ndef create_color_maps_with_value_range(df_col, value_ranges=None):\n  new_value_ranges = value_ranges\n  if value_ranges == None:\n    max_value = df_col.max()\n    min_value = df_col.min()\n    if min_value < 0:\n      min_value = 0\n    step_size = (max_value - min_value) / 12\n\n    # Create 10 periods\n    new_value_ranges = [min_value + i * step_size for i in range(12)]\n    \n  print(\"new_value_ranges: \", new_value_ranges)\n  \n  # Define your custom function to map data values to colors\n  def map_value_to_color(value):\n    # Iterate through the value ranges to find the appropriate color index\n    for i, range_max in enumerate(new_value_ranges):\n      if value <= range_max:\n        return colors[i]\n\n      # If the value is greater than the largest range, return the last color\n      return colors[-1]\n\n    # Map predicted_swe values to colors using the custom function\n  color_mapping = [map_value_to_color(value) for value in df_col.values]\n  return color_mapping, new_value_ranges\n\ndef convert_csvs_to_images():\n    global fixed_value_ranges\n    data = pd.read_csv(\"/home/chetana/gridmet_test_run/test_data_predicted.csv\")\n#     print(data.head())\n    print(\"statistic of predicted_swe: \", data['predicted_swe'].describe())\n    data['predicted_swe'].fillna(0, inplace=True)\n    #data['predicted_swe'] = data['predicted_swe'].apply(lambda x: 0 if x < 2 else x)\n    \n    for column in data.columns:\n      column_data = data[column]\n      print(column_data.describe())\n\n#       # Print or process the description as needed\n#       print(f\"Column: {column}\")\n#       print(description)\n    \n    # Create a figure with a white background\n    fig = plt.figure(facecolor='white')\n\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    print(\"data['lon'].values = \", data['lon'].values)\n    x, y = m(data['lon'].values, data['lat'].values)\n#     print(\"x = \", x)\n#     print(\"y = \", y)\n#     print(\"v = \", data['predicted_swe'].values)\n    print(data.columns)\n\n    color_mapping, value_ranges = create_color_maps_with_value_range(data[\"predicted_swe\"], fixed_value_ranges)\n    \n    # Plot the data using the custom colormap\n    plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\n    \n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_date = datetime(1900, 1, 1)\n    day_value = day_index\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    timestamp_string = result_date.strftime(\"%Y-%m-%d\")\n    \n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    # Create custom legend elements using the same colormap\n    legend_elements = [Patch(color=colors[i], label=f\"{value_ranges[i]} - {value_ranges[i+1]-1}\" if i < len(value_ranges) - 1 else f\"> {value_ranges[-1]}\") for i in range(len(value_ranges))]\n\n    # Create the legend outside the map\n    legend = plt.legend(handles=legend_elements, loc='upper left', title='Legend', fontsize=8)\n    legend.set_bbox_to_anchor((1.01, 1)) \n\n    # Remove the color bar\n    #plt.colorbar().remove()\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Set the aspect ratio to 'equal' to keep the plot at the center\n    plt.gca().set_aspect('equal', adjustable='box')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15, right=0.80)  # Adjust right margin to accommodate the legend\n    # Show the plot or save it to a file\n    new_plot_path = f'/home/chetana/gridmet_test_run/predicted_swe-{test_start_date}.png'\n    print(f\"The new plot is saved to {new_plot_path}\")\n    plt.savefig(new_plot_path)\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\ndef convert_csvs_to_images_simple():\n    selected_date = datetime.strptime(test_start_date, \"%Y-%m-%d\")\n    var_name = \"predicted_swe\"\n    test_csv = \"/home/chetana/gridmet_test_run/test_data_predicted.csv\"\n    result_var_df = pd.read_csv(test_csv)\n    result_var_df.replace('--', pd.NA, inplace=True)\n    result_var_df.dropna(inplace=True)\n    result_var_df[var_name] = pd.to_numeric(result_var_df[var_name], errors='coerce')\n    print(result_var_df.head())\n    #print(gridmet_var_df[\"Latitude\"].describe())\n    #print(gridmet_var_df[\"Longitude\"].describe())\n    print(result_var_df[var_name].describe())\n\n    colormaplist, value_ranges = create_color_maps_with_value_range(result_var_df[var_name], fixed_value_ranges)\n\n    # Create a scatter plot\n    plt.scatter(result_var_df[\"lon\"].values, \n                result_var_df[\"lat\"].values, \n                label='Predicted SWE', \n                #color=colormaplist, \n                c=result_var_df['predicted_swe'], \n                cmap='viridis', \n                s=50, \n                edgecolor='none',\n                vmin=0,  # Set the minimum value\n                vmax=15)\n\n    # Add a colorbar\n    cbar = plt.colorbar()\n    cbar.set_label('Predicted SWE')  # Label for the colorbar\n    \n    # Add labels and a legend\n    plt.xlabel('Longitude')\n    plt.ylabel('Latitude')\n    plt.title(f'SWE Prediction Map {test_start_date}')\n    plt.legend()\n\n    res_png_path = f\"{work_dir}/testing_output/{str(selected_date.year)}_{var_name}_{test_start_date}.png\"\n    plt.savefig(res_png_path)\n    print(f\"test image is saved at {res_png_path}\")\n    \n#convert_csvs_to_images()\n\nconvert_csvs_to_images_simple()\n",
  "history_output" : "today date = 2023-09-26\ntest start date:  2022-01-17\ntest end date:  2023-09-26\n/home/chetana\n     date   lat      lon  SWE  ...     aspect  eastness  northness  predicted_swe\n69  44576  49.0 -122.516    0  ...   91.84747  0.785138  -0.032228         9.8830\n70  44576  49.0 -122.480    0  ...   90.00000  0.785398   0.000000         9.8865\n71  44576  49.0 -122.444    0  ...  329.53427 -0.469250   0.711381         9.8560\n72  44576  49.0 -122.408    0  ...  270.00000 -0.785398   0.000000         9.8495\n73  44576  49.0 -122.372    0  ...   83.99069  0.782643   0.104310         9.8830\n[5 rows x 20 columns]\ncount    288650.000000\nmean          9.588171\nstd           0.445232\nmin           7.576500\n25%           9.470500\n50%           9.808500\n75%           9.877000\nmax           9.943000\nName: predicted_swe, dtype: float64\nnew_value_ranges:  [1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 30]\ntest image is saved at /home/chetana/gridmet_test_run/testing_output/2022_predicted_swe_2022-01-17.png\n",
  "history_begin_time" : 1695693679714,
  "history_end_time" : 1695693685952,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "q2gxq8j9qvx",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport uuid\nfrom snowcast_utils import day_index\nimport matplotlib.colors as mcolors\nfrom matplotlib.patches import Patch\nfrom snowcast_utils import day_index, work_dir, test_start_date\n\n# Define the custom colormap with specified colors and ranges\ncolors = [\n    (0.8627, 0.8627, 0.8627),  # #DCDCDC - 0 - 1\n    (0.8627, 1.0000, 1.0000),  # #DCFFFF - 1 - 2\n    (0.6000, 1.0000, 1.0000),  # #99FFFF - 2 - 4\n    (0.5569, 0.8235, 1.0000),  # #8ED2FF - 4 - 6\n    (0.4509, 0.6196, 0.8745),  # #739EDF - 6 - 8\n    (0.4157, 0.4706, 1.0000),  # #6A78FF - 8 - 10\n    (0.4235, 0.2784, 1.0000),  # #6C47FF - 10 - 12\n    (0.5529, 0.0980, 1.0000),  # #8D19FF - 12 - 14\n    (0.7333, 0.0000, 0.9176),  # #BB00EA - 14 - 16\n    (0.8392, 0.0000, 0.7490),  # #D600BF - 16 - 18\n    (0.7569, 0.0039, 0.4549),  # #C10074 - 18 - 20\n    (0.6784, 0.0000, 0.1961),  # #AD0032 - 20 - 30\n    (0.5020, 0.0000, 0.0000)   # #800000 - > 30\n]\n\ncmap_name = 'custom_snow_colormap'\ncustom_cmap = mcolors.ListedColormap(colors)\n\n# Define the lat_lon_to_map_coordinates function\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\n# Define your value ranges for color mapping\nfixed_value_ranges = [1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 30]\n#value_ranges = [0.1, 0.2, 0.4, 0.6, 0.8, 1.0, 1.2, 1.5, 1.8, 2, 2.5, 3]\n\ndef create_color_maps_with_value_range(df_col, value_ranges=None):\n  new_value_ranges = value_ranges\n  if value_ranges == None:\n    max_value = df_col.max()\n    min_value = df_col.min()\n    if min_value < 0:\n      min_value = 0\n    step_size = (max_value - min_value) / 12\n\n    # Create 10 periods\n    new_value_ranges = [min_value + i * step_size for i in range(12)]\n    \n  print(\"new_value_ranges: \", new_value_ranges)\n  \n  # Define your custom function to map data values to colors\n  def map_value_to_color(value):\n    # Iterate through the value ranges to find the appropriate color index\n    for i, range_max in enumerate(new_value_ranges):\n      if value <= range_max:\n        return colors[i]\n\n      # If the value is greater than the largest range, return the last color\n      return colors[-1]\n\n    # Map predicted_swe values to colors using the custom function\n  color_mapping = [map_value_to_color(value) for value in df_col.values]\n  return color_mapping, new_value_ranges\n\ndef convert_csvs_to_images():\n    global fixed_value_ranges\n    data = pd.read_csv(\"/home/chetana/gridmet_test_run/test_data_predicted.csv\")\n#     print(data.head())\n    print(\"statistic of predicted_swe: \", data['predicted_swe'].describe())\n    data['predicted_swe'].fillna(0, inplace=True)\n    #data['predicted_swe'] = data['predicted_swe'].apply(lambda x: 0 if x < 2 else x)\n    \n    for column in data.columns:\n      column_data = data[column]\n      print(column_data.describe())\n\n#       # Print or process the description as needed\n#       print(f\"Column: {column}\")\n#       print(description)\n    \n    # Create a figure with a white background\n    fig = plt.figure(facecolor='white')\n\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    print(\"data['lon'].values = \", data['lon'].values)\n    x, y = m(data['lon'].values, data['lat'].values)\n#     print(\"x = \", x)\n#     print(\"y = \", y)\n#     print(\"v = \", data['predicted_swe'].values)\n    print(data.columns)\n\n    color_mapping, value_ranges = create_color_maps_with_value_range(data[\"predicted_swe\"], fixed_value_ranges)\n    \n    # Plot the data using the custom colormap\n    plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\n    \n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_date = datetime(1900, 1, 1)\n    day_value = day_index\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    timestamp_string = result_date.strftime(\"%Y-%m-%d\")\n    \n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    # Create custom legend elements using the same colormap\n    legend_elements = [Patch(color=colors[i], label=f\"{value_ranges[i]} - {value_ranges[i+1]-1}\" if i < len(value_ranges) - 1 else f\"> {value_ranges[-1]}\") for i in range(len(value_ranges))]\n\n    # Create the legend outside the map\n    legend = plt.legend(handles=legend_elements, loc='upper left', title='Legend', fontsize=8)\n    legend.set_bbox_to_anchor((1.01, 1)) \n\n    # Remove the color bar\n    #plt.colorbar().remove()\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Set the aspect ratio to 'equal' to keep the plot at the center\n    plt.gca().set_aspect('equal', adjustable='box')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15, right=0.80)  # Adjust right margin to accommodate the legend\n    # Show the plot or save it to a file\n    new_plot_path = f'/home/chetana/gridmet_test_run/predicted_swe-{test_start_date}.png'\n    print(f\"The new plot is saved to {new_plot_path}\")\n    plt.savefig(new_plot_path)\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\ndef convert_csvs_to_images_simple():\n    selected_date = datetime.strptime(test_start_date, \"%Y-%m-%d\")\n    var_name = \"predicted_swe\"\n    test_csv = \"/home/chetana/gridmet_test_run/test_data_predicted.csv\"\n    result_var_df = pd.read_csv(test_csv)\n    result_var_df.replace('--', pd.NA, inplace=True)\n    result_var_df.dropna(inplace=True)\n    result_var_df[var_name] = pd.to_numeric(result_var_df[var_name], errors='coerce')\n    print(result_var_df.head())\n    #print(gridmet_var_df[\"Latitude\"].describe())\n    #print(gridmet_var_df[\"Longitude\"].describe())\n    print(result_var_df[var_name].describe())\n\n    colormaplist, value_ranges = create_color_maps_with_value_range(result_var_df[var_name], fixed_value_ranges)\n\n    # Create a scatter plot\n    plt.scatter(result_var_df[\"lon\"].values, \n                result_var_df[\"lat\"].values, \n                label='Predicted SWE', \n                #color=colormaplist, \n                c=result_var_df['predicted_swe'], \n                cmap='viridis', \n                s=50, \n                edgecolor='none'vmin=0,  # Set the minimum value\n                vmax=15)\n\n    # Add a colorbar\n    cbar = plt.colorbar()\n    cbar.set_label('Predicted SWE')  # Label for the colorbar\n    \n    # Add labels and a legend\n    plt.xlabel('Longitude')\n    plt.ylabel('Latitude')\n    plt.title(f'SWE Prediction Map {test_start_date}')\n    plt.legend()\n\n    res_png_path = f\"{work_dir}/testing_output/{str(selected_date.year)}_{var_name}_{test_start_date}.png\"\n    plt.savefig(res_png_path)\n    print(f\"test image is saved at {res_png_path}\")\n    \n#convert_csvs_to_images()\n\nconvert_csvs_to_images_simple()\n",
  "history_output" : "  File \"/home/chetana/gw-workspace/q2gxq8j9qvx/convert_results_to_images.py\", line 192\n    edgecolor='none'vmin=0,  # Set the minimum value\n                    ^\nSyntaxError: invalid syntax\n",
  "history_begin_time" : 1695693636365,
  "history_end_time" : 1695693637883,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "100001",
  "indicator" : "Failed"
},{
  "history_id" : "fzrhzy49o6f",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport uuid\nfrom snowcast_utils import day_index\nimport matplotlib.colors as mcolors\nfrom matplotlib.patches import Patch\nfrom snowcast_utils import day_index, work_dir, test_start_date\n\n# Define the custom colormap with specified colors and ranges\ncolors = [\n    (0.8627, 0.8627, 0.8627),  # #DCDCDC - 0 - 1\n    (0.8627, 1.0000, 1.0000),  # #DCFFFF - 1 - 2\n    (0.6000, 1.0000, 1.0000),  # #99FFFF - 2 - 4\n    (0.5569, 0.8235, 1.0000),  # #8ED2FF - 4 - 6\n    (0.4509, 0.6196, 0.8745),  # #739EDF - 6 - 8\n    (0.4157, 0.4706, 1.0000),  # #6A78FF - 8 - 10\n    (0.4235, 0.2784, 1.0000),  # #6C47FF - 10 - 12\n    (0.5529, 0.0980, 1.0000),  # #8D19FF - 12 - 14\n    (0.7333, 0.0000, 0.9176),  # #BB00EA - 14 - 16\n    (0.8392, 0.0000, 0.7490),  # #D600BF - 16 - 18\n    (0.7569, 0.0039, 0.4549),  # #C10074 - 18 - 20\n    (0.6784, 0.0000, 0.1961),  # #AD0032 - 20 - 30\n    (0.5020, 0.0000, 0.0000)   # #800000 - > 30\n]\n\ncmap_name = 'custom_snow_colormap'\ncustom_cmap = mcolors.ListedColormap(colors)\n\n# Define the lat_lon_to_map_coordinates function\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\n# Define your value ranges for color mapping\nfixed_value_ranges = [1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 30]\n#value_ranges = [0.1, 0.2, 0.4, 0.6, 0.8, 1.0, 1.2, 1.5, 1.8, 2, 2.5, 3]\n\ndef create_color_maps_with_value_range(df_col, value_ranges=None):\n  new_value_ranges = value_ranges\n  if value_ranges == None:\n    max_value = df_col.max()\n    min_value = df_col.min()\n    if min_value < 0:\n      min_value = 0\n    step_size = (max_value - min_value) / 12\n\n    # Create 10 periods\n    new_value_ranges = [min_value + i * step_size for i in range(12)]\n    \n  print(\"new_value_ranges: \", new_value_ranges)\n  \n  # Define your custom function to map data values to colors\n  def map_value_to_color(value):\n    # Iterate through the value ranges to find the appropriate color index\n    for i, range_max in enumerate(new_value_ranges):\n      if value <= range_max:\n        return colors[i]\n\n      # If the value is greater than the largest range, return the last color\n      return colors[-1]\n\n    # Map predicted_swe values to colors using the custom function\n  color_mapping = [map_value_to_color(value) for value in df_col.values]\n  return color_mapping, new_value_ranges\n\ndef convert_csvs_to_images():\n    global fixed_value_ranges\n    data = pd.read_csv(\"/home/chetana/gridmet_test_run/test_data_predicted.csv\")\n#     print(data.head())\n    print(\"statistic of predicted_swe: \", data['predicted_swe'].describe())\n    data['predicted_swe'].fillna(0, inplace=True)\n    #data['predicted_swe'] = data['predicted_swe'].apply(lambda x: 0 if x < 2 else x)\n    \n    for column in data.columns:\n      column_data = data[column]\n      print(column_data.describe())\n\n#       # Print or process the description as needed\n#       print(f\"Column: {column}\")\n#       print(description)\n    \n    # Create a figure with a white background\n    fig = plt.figure(facecolor='white')\n\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    print(\"data['lon'].values = \", data['lon'].values)\n    x, y = m(data['lon'].values, data['lat'].values)\n#     print(\"x = \", x)\n#     print(\"y = \", y)\n#     print(\"v = \", data['predicted_swe'].values)\n    print(data.columns)\n\n    color_mapping, value_ranges = create_color_maps_with_value_range(data[\"predicted_swe\"], fixed_value_ranges)\n    \n    # Plot the data using the custom colormap\n    plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\n    \n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_date = datetime(1900, 1, 1)\n    day_value = day_index\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    timestamp_string = result_date.strftime(\"%Y-%m-%d\")\n    \n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    # Create custom legend elements using the same colormap\n    legend_elements = [Patch(color=colors[i], label=f\"{value_ranges[i]} - {value_ranges[i+1]-1}\" if i < len(value_ranges) - 1 else f\"> {value_ranges[-1]}\") for i in range(len(value_ranges))]\n\n    # Create the legend outside the map\n    legend = plt.legend(handles=legend_elements, loc='upper left', title='Legend', fontsize=8)\n    legend.set_bbox_to_anchor((1.01, 1)) \n\n    # Remove the color bar\n    #plt.colorbar().remove()\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Set the aspect ratio to 'equal' to keep the plot at the center\n    plt.gca().set_aspect('equal', adjustable='box')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15, right=0.80)  # Adjust right margin to accommodate the legend\n    # Show the plot or save it to a file\n    new_plot_path = f'/home/chetana/gridmet_test_run/predicted_swe-{test_start_date}.png'\n    print(f\"The new plot is saved to {new_plot_path}\")\n    plt.savefig(new_plot_path)\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\ndef convert_csvs_to_images_simple():\n    selected_date = datetime.strptime(test_start_date, \"%Y-%m-%d\")\n    var_name = \"predicted_swe\"\n    test_csv = \"/home/chetana/gridmet_test_run/test_data_predicted.csv\"\n    result_var_df = pd.read_csv(test_csv)\n    result_var_df.replace('--', pd.NA, inplace=True)\n    result_var_df.dropna(inplace=True)\n    result_var_df[var_name] = pd.to_numeric(result_var_df[var_name], errors='coerce')\n    print(result_var_df.head())\n    #print(gridmet_var_df[\"Latitude\"].describe())\n    #print(gridmet_var_df[\"Longitude\"].describe())\n    print(result_var_df[var_name].describe())\n\n    colormaplist, value_ranges = create_color_maps_with_value_range(result_var_df[var_name], fixed_value_ranges)\n\n    # Create a scatter plot\n    plt.scatter(result_var_df[\"lon\"].values, \n                result_var_df[\"lat\"].values, \n                label='Predicted SWE', \n                #color=colormaplist, \n                c=result_var_df['predicted_swe'], \n                cmap='viridis', \n                s=50, \n                edgecolor='none')\n\n    # Add a colorbar\n    cbar = plt.colorbar()\n    cbar.set_label('Predicted SWE')  # Label for the colorbar\n    \n    # Add labels and a legend\n    plt.xlabel('Longitude')\n    plt.ylabel('Latitude')\n    plt.title(f'SWE Prediction Map {test_start_date}')\n    plt.legend()\n\n    res_png_path = f\"{work_dir}/testing_output/{str(selected_date.year)}_{var_name}_{test_start_date}.png\"\n    plt.savefig(res_png_path)\n    print(f\"test image is saved at {res_png_path}\")\n    \n#convert_csvs_to_images()\n\nconvert_csvs_to_images_simple()\n",
  "history_output" : "today date = 2023-09-26\ntest start date:  2022-01-17\ntest end date:  2023-09-26\n/home/chetana\n     date   lat      lon  SWE  ...     aspect  eastness  northness  predicted_swe\n69  44576  49.0 -122.516    0  ...   91.84747  0.785138  -0.032228         9.8830\n70  44576  49.0 -122.480    0  ...   90.00000  0.785398   0.000000         9.8865\n71  44576  49.0 -122.444    0  ...  329.53427 -0.469250   0.711381         9.8560\n72  44576  49.0 -122.408    0  ...  270.00000 -0.785398   0.000000         9.8495\n73  44576  49.0 -122.372    0  ...   83.99069  0.782643   0.104310         9.8830\n[5 rows x 20 columns]\ncount    288650.000000\nmean          9.588171\nstd           0.445232\nmin           7.576500\n25%           9.470500\n50%           9.808500\n75%           9.877000\nmax           9.943000\nName: predicted_swe, dtype: float64\nnew_value_ranges:  [1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 30]\ntest image is saved at /home/chetana/gridmet_test_run/testing_output/2022_predicted_swe_2022-01-17.png\n",
  "history_begin_time" : 1695693353043,
  "history_end_time" : 1695693361169,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "100001",
  "indicator" : "Done"
},{
  "history_id" : "Ga3rTKJWtw8R",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport uuid\nfrom snowcast_utils import day_index\nimport matplotlib.colors as mcolors\nfrom matplotlib.patches import Patch\nfrom snowcast_utils import day_index, work_dir, test_start_date\n\n# Define the custom colormap with specified colors and ranges\ncolors = [\n    (0.8627, 0.8627, 0.8627),  # #DCDCDC - 0 - 1\n    (0.8627, 1.0000, 1.0000),  # #DCFFFF - 1 - 2\n    (0.6000, 1.0000, 1.0000),  # #99FFFF - 2 - 4\n    (0.5569, 0.8235, 1.0000),  # #8ED2FF - 4 - 6\n    (0.4509, 0.6196, 0.8745),  # #739EDF - 6 - 8\n    (0.4157, 0.4706, 1.0000),  # #6A78FF - 8 - 10\n    (0.4235, 0.2784, 1.0000),  # #6C47FF - 10 - 12\n    (0.5529, 0.0980, 1.0000),  # #8D19FF - 12 - 14\n    (0.7333, 0.0000, 0.9176),  # #BB00EA - 14 - 16\n    (0.8392, 0.0000, 0.7490),  # #D600BF - 16 - 18\n    (0.7569, 0.0039, 0.4549),  # #C10074 - 18 - 20\n    (0.6784, 0.0000, 0.1961),  # #AD0032 - 20 - 30\n    (0.5020, 0.0000, 0.0000)   # #800000 - > 30\n]\n\ncmap_name = 'custom_snow_colormap'\ncustom_cmap = mcolors.ListedColormap(colors)\n\n# Define the lat_lon_to_map_coordinates function\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\n# Define your value ranges for color mapping\nfixed_value_ranges = [1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 30]\n#value_ranges = [0.1, 0.2, 0.4, 0.6, 0.8, 1.0, 1.2, 1.5, 1.8, 2, 2.5, 3]\n\ndef create_color_maps_with_value_range(df_col, value_ranges=None):\n  new_value_ranges = value_ranges\n  if value_ranges == None:\n    max_value = df_col.max()\n    min_value = df_col.min()\n    if min_value < 0:\n      min_value = 0\n    step_size = (max_value - min_value) / 12\n\n    # Create 10 periods\n    new_value_ranges = [min_value + i * step_size for i in range(12)]\n    \n  print(\"new_value_ranges: \", new_value_ranges)\n  \n  # Define your custom function to map data values to colors\n  def map_value_to_color(value):\n    # Iterate through the value ranges to find the appropriate color index\n    for i, range_max in enumerate(new_value_ranges):\n      if value <= range_max:\n        return colors[i]\n\n      # If the value is greater than the largest range, return the last color\n      return colors[-1]\n\n    # Map predicted_swe values to colors using the custom function\n  color_mapping = [map_value_to_color(value) for value in df_col.values]\n  return color_mapping, new_value_ranges\n\ndef convert_csvs_to_images():\n    global fixed_value_ranges\n    data = pd.read_csv(\"/home/chetana/gridmet_test_run/test_data_predicted.csv\")\n#     print(data.head())\n    print(\"statistic of predicted_swe: \", data['predicted_swe'].describe())\n    data['predicted_swe'].fillna(0, inplace=True)\n    #data['predicted_swe'] = data['predicted_swe'].apply(lambda x: 0 if x < 2 else x)\n    \n    for column in data.columns:\n      column_data = data[column]\n      print(column_data.describe())\n\n#       # Print or process the description as needed\n#       print(f\"Column: {column}\")\n#       print(description)\n    \n    # Create a figure with a white background\n    fig = plt.figure(facecolor='white')\n\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    print(\"data['lon'].values = \", data['lon'].values)\n    x, y = m(data['lon'].values, data['lat'].values)\n#     print(\"x = \", x)\n#     print(\"y = \", y)\n#     print(\"v = \", data['predicted_swe'].values)\n    print(data.columns)\n\n    color_mapping, value_ranges = create_color_maps_with_value_range(data[\"predicted_swe\"], fixed_value_ranges)\n    \n    # Plot the data using the custom colormap\n    plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\n    \n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_date = datetime(1900, 1, 1)\n    day_value = day_index\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    timestamp_string = result_date.strftime(\"%Y-%m-%d\")\n    \n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    # Create custom legend elements using the same colormap\n    legend_elements = [Patch(color=colors[i], label=f\"{value_ranges[i]} - {value_ranges[i+1]-1}\" if i < len(value_ranges) - 1 else f\"> {value_ranges[-1]}\") for i in range(len(value_ranges))]\n\n    # Create the legend outside the map\n    legend = plt.legend(handles=legend_elements, loc='upper left', title='Legend', fontsize=8)\n    legend.set_bbox_to_anchor((1.01, 1)) \n\n    # Remove the color bar\n    #plt.colorbar().remove()\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Set the aspect ratio to 'equal' to keep the plot at the center\n    plt.gca().set_aspect('equal', adjustable='box')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15, right=0.80)  # Adjust right margin to accommodate the legend\n    # Show the plot or save it to a file\n    new_plot_path = f'/home/chetana/gridmet_test_run/predicted_swe-{test_start_date}.png'\n    print(f\"The new plot is saved to {new_plot_path}\")\n    plt.savefig(new_plot_path)\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\ndef convert_csvs_to_images_simple():\n    selected_date = datetime.strptime(test_start_date, \"%Y-%m-%d\")\n    var_name = \"predicted_swe\"\n    test_csv = \"/home/chetana/gridmet_test_run/test_data_predicted.csv\"\n    result_var_df = pd.read_csv(test_csv)\n    result_var_df.replace('--', pd.NA, inplace=True)\n    result_var_df.dropna(inplace=True)\n    result_var_df[var_name] = pd.to_numeric(result_var_df[var_name], errors='coerce')\n    print(result_var_df.head())\n    #print(gridmet_var_df[\"Latitude\"].describe())\n    #print(gridmet_var_df[\"Longitude\"].describe())\n    print(result_var_df[var_name].describe())\n\n    colormaplist, value_ranges = create_color_maps_with_value_range(result_var_df[var_name], fixed_value_ranges)\n\n    # Create a scatter plot\n    plt.scatter(result_var_df[\"lon\"].values, \n                result_var_df[\"lat\"].values, \n                label='Predicted SWE', \n                #color=colormaplist, \n                c=result_var_df['predicted_swe'], \n                cmap='viridis', \n                s=50, \n                edgecolor='none')\n\n    # Add a colorbar\n    cbar = plt.colorbar()\n    cbar.set_label('Predicted SWE')  # Label for the colorbar\n    \n    # Add labels and a legend\n    plt.xlabel('Longitude')\n    plt.ylabel('Latitude')\n    plt.title(f'SWE Prediction Map {test_start_date}')\n    plt.legend()\n\n    res_png_path = f\"{work_dir}/testing_output/{str(selected_date.year)}_{var_name}_{test_start_date}.png\"\n    plt.savefig(res_png_path)\n    print(f\"test image is saved at {res_png_path}\")\n    \n#convert_csvs_to_images()\n\nconvert_csvs_to_images_simple()\n",
  "history_output" : "today date = 2023-09-24\ntest start date:  2022-01-16\ntest end date:  2023-09-24\n/home/chetana\n     date   lat      lon  SWE  ...     aspect  eastness  northness  predicted_swe\n69  44575  49.0 -122.516    0  ...   91.84747  0.785138  -0.032228        10.0070\n70  44575  49.0 -122.480    0  ...   90.00000  0.785398   0.000000        10.0075\n71  44575  49.0 -122.444    0  ...  329.53427 -0.469250   0.711381         9.9720\n72  44575  49.0 -122.408    0  ...  270.00000 -0.785398   0.000000         9.9770\n73  44575  49.0 -122.372    0  ...   83.99069  0.782643   0.104310        10.0135\n[5 rows x 20 columns]\ncount    288650.000000\nmean          9.725707\nstd           0.504980\nmin           7.509500\n25%           9.596000\n50%           9.990000\n75%          10.039000\nmax          10.102500\nName: predicted_swe, dtype: float64\nnew_value_ranges:  [1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 30]\ntest image is saved at /home/chetana/gridmet_test_run/testing_output/2022_predicted_swe_2022-01-16.png\n",
  "history_begin_time" : 1695584865017,
  "history_end_time" : 1695584871800,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "x964f7x753o",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport uuid\nfrom snowcast_utils import day_index\nimport matplotlib.colors as mcolors\nfrom matplotlib.patches import Patch\nfrom snowcast_utils import day_index, work_dir, test_start_date\n\n# Define the custom colormap with specified colors and ranges\ncolors = [\n    (0.8627, 0.8627, 0.8627),  # #DCDCDC - 0 - 1\n    (0.8627, 1.0000, 1.0000),  # #DCFFFF - 1 - 2\n    (0.6000, 1.0000, 1.0000),  # #99FFFF - 2 - 4\n    (0.5569, 0.8235, 1.0000),  # #8ED2FF - 4 - 6\n    (0.4509, 0.6196, 0.8745),  # #739EDF - 6 - 8\n    (0.4157, 0.4706, 1.0000),  # #6A78FF - 8 - 10\n    (0.4235, 0.2784, 1.0000),  # #6C47FF - 10 - 12\n    (0.5529, 0.0980, 1.0000),  # #8D19FF - 12 - 14\n    (0.7333, 0.0000, 0.9176),  # #BB00EA - 14 - 16\n    (0.8392, 0.0000, 0.7490),  # #D600BF - 16 - 18\n    (0.7569, 0.0039, 0.4549),  # #C10074 - 18 - 20\n    (0.6784, 0.0000, 0.1961),  # #AD0032 - 20 - 30\n    (0.5020, 0.0000, 0.0000)   # #800000 - > 30\n]\n\ncmap_name = 'custom_snow_colormap'\ncustom_cmap = mcolors.ListedColormap(colors)\n\n# Define the lat_lon_to_map_coordinates function\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\n# Define your value ranges for color mapping\nfixed_value_ranges = [1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 30]\n#value_ranges = [0.1, 0.2, 0.4, 0.6, 0.8, 1.0, 1.2, 1.5, 1.8, 2, 2.5, 3]\n\ndef create_color_maps_with_value_range(df_col, value_ranges=None):\n  new_value_ranges = value_ranges\n  if value_ranges == None:\n    max_value = df_col.max()\n    min_value = df_col.min()\n    if min_value < 0:\n      min_value = 0\n    step_size = (max_value - min_value) / 12\n\n    # Create 10 periods\n    new_value_ranges = [min_value + i * step_size for i in range(12)]\n    \n  print(\"new_value_ranges: \", new_value_ranges)\n  \n  # Define your custom function to map data values to colors\n  def map_value_to_color(value):\n    # Iterate through the value ranges to find the appropriate color index\n    for i, range_max in enumerate(new_value_ranges):\n      if value <= range_max:\n        return colors[i]\n\n      # If the value is greater than the largest range, return the last color\n      return colors[-1]\n\n    # Map predicted_swe values to colors using the custom function\n  color_mapping = [map_value_to_color(value) for value in df_col.values]\n  return color_mapping, new_value_ranges\n\ndef convert_csvs_to_images():\n    global fixed_value_ranges\n    data = pd.read_csv(\"/home/chetana/gridmet_test_run/test_data_predicted.csv\")\n#     print(data.head())\n    print(\"statistic of predicted_swe: \", data['predicted_swe'].describe())\n    data['predicted_swe'].fillna(0, inplace=True)\n    #data['predicted_swe'] = data['predicted_swe'].apply(lambda x: 0 if x < 2 else x)\n    \n    for column in data.columns:\n      column_data = data[column]\n      print(column_data.describe())\n\n#       # Print or process the description as needed\n#       print(f\"Column: {column}\")\n#       print(description)\n    \n    # Create a figure with a white background\n    fig = plt.figure(facecolor='white')\n\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    print(\"data['lon'].values = \", data['lon'].values)\n    x, y = m(data['lon'].values, data['lat'].values)\n#     print(\"x = \", x)\n#     print(\"y = \", y)\n#     print(\"v = \", data['predicted_swe'].values)\n    print(data.columns)\n\n    color_mapping, value_ranges = create_color_maps_with_value_range(data[\"predicted_swe\"], fixed_value_ranges)\n    \n    # Plot the data using the custom colormap\n    plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\n    \n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_date = datetime(1900, 1, 1)\n    day_value = day_index\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    timestamp_string = result_date.strftime(\"%Y-%m-%d\")\n    \n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    # Create custom legend elements using the same colormap\n    legend_elements = [Patch(color=colors[i], label=f\"{value_ranges[i]} - {value_ranges[i+1]-1}\" if i < len(value_ranges) - 1 else f\"> {value_ranges[-1]}\") for i in range(len(value_ranges))]\n\n    # Create the legend outside the map\n    legend = plt.legend(handles=legend_elements, loc='upper left', title='Legend', fontsize=8)\n    legend.set_bbox_to_anchor((1.01, 1)) \n\n    # Remove the color bar\n    #plt.colorbar().remove()\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Set the aspect ratio to 'equal' to keep the plot at the center\n    plt.gca().set_aspect('equal', adjustable='box')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15, right=0.80)  # Adjust right margin to accommodate the legend\n    # Show the plot or save it to a file\n    new_plot_path = f'/home/chetana/gridmet_test_run/predicted_swe-{test_start_date}.png'\n    print(f\"The new plot is saved to {new_plot_path}\")\n    plt.savefig(new_plot_path)\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\ndef convert_csvs_to_images_simple():\n    selected_date = datetime.strptime(test_start_date, \"%Y-%m-%d\")\n    var_name = \"predicted_swe\"\n    test_csv = \"/home/chetana/gridmet_test_run/test_data_predicted.csv\"\n    result_var_df = pd.read_csv(test_csv)\n    result_var_df.replace('--', pd.NA, inplace=True)\n    result_var_df.dropna(inplace=True)\n    result_var_df[var_name] = pd.to_numeric(result_var_df[var_name], errors='coerce')\n    print(result_var_df.head())\n    #print(gridmet_var_df[\"Latitude\"].describe())\n    #print(gridmet_var_df[\"Longitude\"].describe())\n    print(result_var_df[var_name].describe())\n\n    colormaplist, value_ranges = create_color_maps_with_value_range(result_var_df[var_name], fixed_value_ranges)\n\n    # Create a scatter plot\n    plt.scatter(result_var_df[\"lon\"].values, \n                result_var_df[\"lat\"].values, \n                label='Predicted SWE', \n                #color=colormaplist, \n                c=result_var_df['predicted_swe'], \n                cmap='viridis', \n                s=50, \n                edgecolor='none')\n\n    # Add a colorbar\n    cbar = plt.colorbar()\n    cbar.set_label('Predicted SWE')  # Label for the colorbar\n    \n    # Add labels and a legend\n    plt.xlabel('Longitude')\n    plt.ylabel('Latitude')\n    plt.title(f'SWE Prediction Map {test_start_date}')\n    plt.legend()\n\n    res_png_path = f\"{work_dir}/testing_output/{str(selected_date.year)}_{var_name}_{test_start_date}.png\"\n    plt.savefig(res_png_path)\n    print(f\"test image is saved at {res_png_path}\")\n    \n#convert_csvs_to_images()\n\nconvert_csvs_to_images_simple()\n",
  "history_output" : "today date = 2023-09-24\ntest start date:  2022-01-16\ntest end date:  2023-09-24\n/home/chetana\n     date   lat      lon  SWE  ...     aspect  eastness  northness  predicted_swe\n69  44575  49.0 -122.516    0  ...   91.84747  0.785138  -0.032228         7.6980\n70  44575  49.0 -122.480    0  ...   90.00000  0.785398   0.000000         7.6470\n71  44575  49.0 -122.444    0  ...  329.53427 -0.469250   0.711381         7.4310\n72  44575  49.0 -122.408    0  ...  270.00000 -0.785398   0.000000         7.5220\n73  44575  49.0 -122.372    0  ...   83.99069  0.782643   0.104310         7.5995\n[5 rows x 20 columns]\ncount    288650.000000\nmean          8.377054\nstd           1.931676\nmin           1.475000\n25%           7.692500\n50%           9.252000\n75%           9.713000\nmax          10.075500\nName: predicted_swe, dtype: float64\nnew_value_ranges:  [1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 30]\ntest image is saved at /home/chetana/gridmet_test_run/testing_output/2022_predicted_swe_2022-01-16.png\n",
  "history_begin_time" : 1695581094810,
  "history_end_time" : 1695581102543,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "100001",
  "indicator" : "Done"
},{
  "history_id" : "BB6Q1VLDZxKF",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport uuid\nfrom snowcast_utils import day_index\nimport matplotlib.colors as mcolors\nfrom matplotlib.patches import Patch\nfrom snowcast_utils import day_index, work_dir, test_start_date\n\n# Define the custom colormap with specified colors and ranges\ncolors = [\n    (0.8627, 0.8627, 0.8627),  # #DCDCDC - 0 - 1\n    (0.8627, 1.0000, 1.0000),  # #DCFFFF - 1 - 2\n    (0.6000, 1.0000, 1.0000),  # #99FFFF - 2 - 4\n    (0.5569, 0.8235, 1.0000),  # #8ED2FF - 4 - 6\n    (0.4509, 0.6196, 0.8745),  # #739EDF - 6 - 8\n    (0.4157, 0.4706, 1.0000),  # #6A78FF - 8 - 10\n    (0.4235, 0.2784, 1.0000),  # #6C47FF - 10 - 12\n    (0.5529, 0.0980, 1.0000),  # #8D19FF - 12 - 14\n    (0.7333, 0.0000, 0.9176),  # #BB00EA - 14 - 16\n    (0.8392, 0.0000, 0.7490),  # #D600BF - 16 - 18\n    (0.7569, 0.0039, 0.4549),  # #C10074 - 18 - 20\n    (0.6784, 0.0000, 0.1961),  # #AD0032 - 20 - 30\n    (0.5020, 0.0000, 0.0000)   # #800000 - > 30\n]\n\ncmap_name = 'custom_snow_colormap'\ncustom_cmap = mcolors.ListedColormap(colors)\n\n# Define the lat_lon_to_map_coordinates function\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\n# Define your value ranges for color mapping\nfixed_value_ranges = [1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 30]\n#value_ranges = [0.1, 0.2, 0.4, 0.6, 0.8, 1.0, 1.2, 1.5, 1.8, 2, 2.5, 3]\n\ndef create_color_maps_with_value_range(df_col, value_ranges=None):\n  new_value_ranges = value_ranges\n  if value_ranges == None:\n    max_value = df_col.max()\n    min_value = df_col.min()\n    if min_value < 0:\n      min_value = 0\n    step_size = (max_value - min_value) / 12\n\n    # Create 10 periods\n    new_value_ranges = [min_value + i * step_size for i in range(12)]\n    \n  print(\"new_value_ranges: \", new_value_ranges)\n  \n  # Define your custom function to map data values to colors\n  def map_value_to_color(value):\n    # Iterate through the value ranges to find the appropriate color index\n    for i, range_max in enumerate(new_value_ranges):\n      if value <= range_max:\n        return colors[i]\n\n      # If the value is greater than the largest range, return the last color\n      return colors[-1]\n\n    # Map predicted_swe values to colors using the custom function\n  color_mapping = [map_value_to_color(value) for value in df_col.values]\n  return color_mapping, new_value_ranges\n\ndef convert_csvs_to_images():\n    global fixed_value_ranges\n    data = pd.read_csv(\"/home/chetana/gridmet_test_run/test_data_predicted.csv\")\n#     print(data.head())\n    print(\"statistic of predicted_swe: \", data['predicted_swe'].describe())\n    data['predicted_swe'].fillna(0, inplace=True)\n    #data['predicted_swe'] = data['predicted_swe'].apply(lambda x: 0 if x < 2 else x)\n    \n    for column in data.columns:\n      column_data = data[column]\n      print(column_data.describe())\n\n#       # Print or process the description as needed\n#       print(f\"Column: {column}\")\n#       print(description)\n    \n    # Create a figure with a white background\n    fig = plt.figure(facecolor='white')\n\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    print(\"data['lon'].values = \", data['lon'].values)\n    x, y = m(data['lon'].values, data['lat'].values)\n#     print(\"x = \", x)\n#     print(\"y = \", y)\n#     print(\"v = \", data['predicted_swe'].values)\n    print(data.columns)\n\n    color_mapping, value_ranges = create_color_maps_with_value_range(data[\"predicted_swe\"], fixed_value_ranges)\n    \n    # Plot the data using the custom colormap\n    plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\n    \n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_date = datetime(1900, 1, 1)\n    day_value = day_index\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    timestamp_string = result_date.strftime(\"%Y-%m-%d\")\n    \n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    # Create custom legend elements using the same colormap\n    legend_elements = [Patch(color=colors[i], label=f\"{value_ranges[i]} - {value_ranges[i+1]-1}\" if i < len(value_ranges) - 1 else f\"> {value_ranges[-1]}\") for i in range(len(value_ranges))]\n\n    # Create the legend outside the map\n    legend = plt.legend(handles=legend_elements, loc='upper left', title='Legend', fontsize=8)\n    legend.set_bbox_to_anchor((1.01, 1)) \n\n    # Remove the color bar\n    #plt.colorbar().remove()\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Set the aspect ratio to 'equal' to keep the plot at the center\n    plt.gca().set_aspect('equal', adjustable='box')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15, right=0.80)  # Adjust right margin to accommodate the legend\n    # Show the plot or save it to a file\n    new_plot_path = f'/home/chetana/gridmet_test_run/predicted_swe-{test_start_date}.png'\n    print(f\"The new plot is saved to {new_plot_path}\")\n    plt.savefig(new_plot_path)\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\ndef convert_csvs_to_images_simple():\n    selected_date = datetime.strptime(test_start_date, \"%Y-%m-%d\")\n    var_name = \"predicted_swe\"\n    test_csv = \"/home/chetana/gridmet_test_run/test_data_predicted.csv\"\n    result_var_df = pd.read_csv(test_csv)\n    result_var_df.replace('--', pd.NA, inplace=True)\n    result_var_df.dropna(inplace=True)\n    result_var_df[var_name] = pd.to_numeric(result_var_df[var_name], errors='coerce')\n    print(result_var_df.head())\n    #print(gridmet_var_df[\"Latitude\"].describe())\n    #print(gridmet_var_df[\"Longitude\"].describe())\n    print(result_var_df[var_name].describe())\n\n    colormaplist, value_ranges = create_color_maps_with_value_range(result_var_df[var_name], fixed_value_ranges)\n\n    # Create a scatter plot\n    plt.scatter(result_var_df[\"lon\"].values, \n                result_var_df[\"lat\"].values, \n                label='Predicted SWE', \n                #color=colormaplist, \n                c=result_var_df['predicted_swe'], \n                cmap='viridis', \n                s=50, \n                edgecolor='none')\n\n    # Add a colorbar\n    cbar = plt.colorbar()\n    cbar.set_label('Predicted SWE')  # Label for the colorbar\n    \n    # Add labels and a legend\n    plt.xlabel('Longitude')\n    plt.ylabel('Latitude')\n    plt.title(f'SWE Prediction Map {test_start_date}')\n    plt.legend()\n\n    res_png_path = f\"{work_dir}/testing_output/{str(selected_date.year)}_{var_name}_{test_start_date}.png\"\n    plt.savefig(res_png_path)\n    print(f\"test image is saved at {res_png_path}\")\n    \n#convert_csvs_to_images()\n\nconvert_csvs_to_images_simple()\n",
  "history_output" : "today date = 2023-09-24\ntest start date:  2022-10-16\ntest end date:  2023-09-24\n/home/chetana\n     date   lat      lon  SWE  ...     aspect  eastness  northness  predicted_swe\n69  44848  49.0 -122.516    0  ...   91.84747  0.785138  -0.032228          0.145\n70  44848  49.0 -122.480    0  ...   90.00000  0.785398   0.000000          0.177\n71  44848  49.0 -122.444    0  ...  329.53427 -0.469250   0.711381          0.090\n72  44848  49.0 -122.408    0  ...  270.00000 -0.785398   0.000000          0.045\n73  44848  49.0 -122.372    0  ...   83.99069  0.782643   0.104310          0.145\n[5 rows x 20 columns]\ncount    288650.000000\nmean          0.091300\nstd           0.126256\nmin           0.000000\n25%           0.008500\n50%           0.054500\n75%           0.125000\nmax           1.397000\nName: predicted_swe, dtype: float64\nnew_value_ranges:  [1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 30]\ntest image is saved at /home/chetana/gridmet_test_run/testing_output/2022_predicted_swe_2022-10-16.png\n",
  "history_begin_time" : 1695580745937,
  "history_end_time" : 1695580752252,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "OagNYaKHoAKF",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport uuid\nfrom snowcast_utils import day_index\nimport matplotlib.colors as mcolors\nfrom matplotlib.patches import Patch\nfrom snowcast_utils import day_index, work_dir, test_start_date\n\n# Define the custom colormap with specified colors and ranges\ncolors = [\n    (0.8627, 0.8627, 0.8627),  # #DCDCDC - 0 - 1\n    (0.8627, 1.0000, 1.0000),  # #DCFFFF - 1 - 2\n    (0.6000, 1.0000, 1.0000),  # #99FFFF - 2 - 4\n    (0.5569, 0.8235, 1.0000),  # #8ED2FF - 4 - 6\n    (0.4509, 0.6196, 0.8745),  # #739EDF - 6 - 8\n    (0.4157, 0.4706, 1.0000),  # #6A78FF - 8 - 10\n    (0.4235, 0.2784, 1.0000),  # #6C47FF - 10 - 12\n    (0.5529, 0.0980, 1.0000),  # #8D19FF - 12 - 14\n    (0.7333, 0.0000, 0.9176),  # #BB00EA - 14 - 16\n    (0.8392, 0.0000, 0.7490),  # #D600BF - 16 - 18\n    (0.7569, 0.0039, 0.4549),  # #C10074 - 18 - 20\n    (0.6784, 0.0000, 0.1961),  # #AD0032 - 20 - 30\n    (0.5020, 0.0000, 0.0000)   # #800000 - > 30\n]\n\ncmap_name = 'custom_snow_colormap'\ncustom_cmap = mcolors.ListedColormap(colors)\n\n# Define the lat_lon_to_map_coordinates function\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\n# Define your value ranges for color mapping\nfixed_value_ranges = [1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 30]\n#value_ranges = [0.1, 0.2, 0.4, 0.6, 0.8, 1.0, 1.2, 1.5, 1.8, 2, 2.5, 3]\n\ndef create_color_maps_with_value_range(df_col, value_ranges=None):\n  new_value_ranges = value_ranges\n  if value_ranges == None:\n    max_value = df_col.max()\n    min_value = df_col.min()\n    if min_value < 0:\n      min_value = 0\n    step_size = (max_value - min_value) / 12\n\n    # Create 10 periods\n    new_value_ranges = [min_value + i * step_size for i in range(12)]\n    \n  print(\"new_value_ranges: \", new_value_ranges)\n  \n  # Define your custom function to map data values to colors\n  def map_value_to_color(value):\n    # Iterate through the value ranges to find the appropriate color index\n    for i, range_max in enumerate(new_value_ranges):\n      if value <= range_max:\n        return colors[i]\n\n      # If the value is greater than the largest range, return the last color\n      return colors[-1]\n\n    # Map predicted_swe values to colors using the custom function\n  color_mapping = [map_value_to_color(value) for value in df_col.values]\n  return color_mapping, new_value_ranges\n\ndef convert_csvs_to_images():\n    global fixed_value_ranges\n    data = pd.read_csv(\"/home/chetana/gridmet_test_run/test_data_predicted.csv\")\n#     print(data.head())\n    print(\"statistic of predicted_swe: \", data['predicted_swe'].describe())\n    data['predicted_swe'].fillna(0, inplace=True)\n    #data['predicted_swe'] = data['predicted_swe'].apply(lambda x: 0 if x < 2 else x)\n    \n    for column in data.columns:\n      column_data = data[column]\n      print(column_data.describe())\n\n#       # Print or process the description as needed\n#       print(f\"Column: {column}\")\n#       print(description)\n    \n    # Create a figure with a white background\n    fig = plt.figure(facecolor='white')\n\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    print(\"data['lon'].values = \", data['lon'].values)\n    x, y = m(data['lon'].values, data['lat'].values)\n#     print(\"x = \", x)\n#     print(\"y = \", y)\n#     print(\"v = \", data['predicted_swe'].values)\n    print(data.columns)\n\n    color_mapping, value_ranges = create_color_maps_with_value_range(data[\"predicted_swe\"], fixed_value_ranges)\n    \n    # Plot the data using the custom colormap\n    plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\n    \n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_date = datetime(1900, 1, 1)\n    day_value = day_index\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    timestamp_string = result_date.strftime(\"%Y-%m-%d\")\n    \n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    # Create custom legend elements using the same colormap\n    legend_elements = [Patch(color=colors[i], label=f\"{value_ranges[i]} - {value_ranges[i+1]-1}\" if i < len(value_ranges) - 1 else f\"> {value_ranges[-1]}\") for i in range(len(value_ranges))]\n\n    # Create the legend outside the map\n    legend = plt.legend(handles=legend_elements, loc='upper left', title='Legend', fontsize=8)\n    legend.set_bbox_to_anchor((1.01, 1)) \n\n    # Remove the color bar\n    #plt.colorbar().remove()\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Set the aspect ratio to 'equal' to keep the plot at the center\n    plt.gca().set_aspect('equal', adjustable='box')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15, right=0.80)  # Adjust right margin to accommodate the legend\n    # Show the plot or save it to a file\n    new_plot_path = f'/home/chetana/gridmet_test_run/predicted_swe-{test_start_date}.png'\n    print(f\"The new plot is saved to {new_plot_path}\")\n    plt.savefig(new_plot_path)\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\ndef convert_csvs_to_images_simple():\n    selected_date = datetime.strptime(test_start_date, \"%Y-%m-%d\")\n    var_name = \"predicted_swe\"\n    test_csv = \"/home/chetana/gridmet_test_run/test_data_predicted.csv\"\n    result_var_df = pd.read_csv(test_csv)\n    result_var_df.replace('--', pd.NA, inplace=True)\n    result_var_df.dropna(inplace=True)\n    result_var_df[var_name] = pd.to_numeric(result_var_df[var_name], errors='coerce')\n    print(result_var_df.head())\n    #print(gridmet_var_df[\"Latitude\"].describe())\n    #print(gridmet_var_df[\"Longitude\"].describe())\n    print(result_var_df[var_name].describe())\n\n    colormaplist, value_ranges = create_color_maps_with_value_range(result_var_df[var_name], fixed_value_ranges)\n\n    # Create a scatter plot\n    plt.scatter(result_var_df[\"lon\"].values, \n                result_var_df[\"lat\"].values, \n                label='Predicted SWE', \n                #color=colormaplist, \n                c=result_var_df['predicted_swe'], \n                cmap='viridis', \n                s=50, \n                edgecolor='none')\n\n    # Add a colorbar\n    cbar = plt.colorbar()\n    cbar.set_label('Predicted SWE')  # Label for the colorbar\n    \n    # Add labels and a legend\n    plt.xlabel('Longitude')\n    plt.ylabel('Latitude')\n    plt.title(f'SWE Prediction Map {test_start_date}')\n    plt.legend()\n\n    res_png_path = f\"{work_dir}/testing_output/{str(selected_date.year)}_{var_name}_{test_start_date}.png\"\n    plt.savefig(res_png_path)\n    print(f\"test image is saved at {res_png_path}\")\n    \n#convert_csvs_to_images()\n\nconvert_csvs_to_images_simple()\n",
  "history_output" : "today date = 2023-09-24\ntest start date:  2022-10-16\ntest end date:  2023-09-24\n/home/chetana\n     date   lat      lon  SWE  ...     aspect  eastness  northness  predicted_swe\n69  44848  49.0 -122.516    0  ...   91.84747  0.785138  -0.032228         0.0170\n70  44848  49.0 -122.480    0  ...   90.00000  0.785398   0.000000         0.0320\n71  44848  49.0 -122.444    0  ...  329.53427 -0.469250   0.711381         0.0680\n72  44848  49.0 -122.408    0  ...  270.00000 -0.785398   0.000000         0.0205\n73  44848  49.0 -122.372    0  ...   83.99069  0.782643   0.104310         0.0170\n[5 rows x 20 columns]\ncount    288650.000000\nmean          0.130403\nstd           0.174323\nmin           0.000000\n25%           0.011000\n50%           0.081000\n75%           0.181500\nmax           2.103500\nName: predicted_swe, dtype: float64\nnew_value_ranges:  [1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 30]\ntest image is saved at /home/chetana/gridmet_test_run/testing_output/2022_predicted_swe_2022-10-16.png\n",
  "history_begin_time" : 1695577387869,
  "history_end_time" : 1695577394216,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "uKMIpFVwZb7a",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport uuid\nfrom snowcast_utils import day_index\nimport matplotlib.colors as mcolors\nfrom matplotlib.patches import Patch\nfrom snowcast_utils import day_index, work_dir, test_start_date\n\n# Define the custom colormap with specified colors and ranges\ncolors = [\n    (0.8627, 0.8627, 0.8627),  # #DCDCDC - 0 - 1\n    (0.8627, 1.0000, 1.0000),  # #DCFFFF - 1 - 2\n    (0.6000, 1.0000, 1.0000),  # #99FFFF - 2 - 4\n    (0.5569, 0.8235, 1.0000),  # #8ED2FF - 4 - 6\n    (0.4509, 0.6196, 0.8745),  # #739EDF - 6 - 8\n    (0.4157, 0.4706, 1.0000),  # #6A78FF - 8 - 10\n    (0.4235, 0.2784, 1.0000),  # #6C47FF - 10 - 12\n    (0.5529, 0.0980, 1.0000),  # #8D19FF - 12 - 14\n    (0.7333, 0.0000, 0.9176),  # #BB00EA - 14 - 16\n    (0.8392, 0.0000, 0.7490),  # #D600BF - 16 - 18\n    (0.7569, 0.0039, 0.4549),  # #C10074 - 18 - 20\n    (0.6784, 0.0000, 0.1961),  # #AD0032 - 20 - 30\n    (0.5020, 0.0000, 0.0000)   # #800000 - > 30\n]\n\ncmap_name = 'custom_snow_colormap'\ncustom_cmap = mcolors.ListedColormap(colors)\n\n# Define the lat_lon_to_map_coordinates function\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\n# Define your value ranges for color mapping\nfixed_value_ranges = [1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 30]\n#value_ranges = [0.1, 0.2, 0.4, 0.6, 0.8, 1.0, 1.2, 1.5, 1.8, 2, 2.5, 3]\n\ndef create_color_maps_with_value_range(df_col, value_ranges=None):\n  new_value_ranges = value_ranges\n  if value_ranges == None:\n    max_value = df_col.max()\n    min_value = df_col.min()\n    if min_value < 0:\n      min_value = 0\n    step_size = (max_value - min_value) / 12\n\n    # Create 10 periods\n    new_value_ranges = [min_value + i * step_size for i in range(12)]\n    \n  print(\"new_value_ranges: \", new_value_ranges)\n  \n  # Define your custom function to map data values to colors\n  def map_value_to_color(value):\n    # Iterate through the value ranges to find the appropriate color index\n    for i, range_max in enumerate(new_value_ranges):\n      if value <= range_max:\n        return colors[i]\n\n      # If the value is greater than the largest range, return the last color\n      return colors[-1]\n\n    # Map predicted_swe values to colors using the custom function\n  color_mapping = [map_value_to_color(value) for value in df_col.values]\n  return color_mapping, new_value_ranges\n\ndef convert_csvs_to_images():\n    global fixed_value_ranges\n    data = pd.read_csv(\"/home/chetana/gridmet_test_run/test_data_predicted.csv\")\n#     print(data.head())\n    print(\"statistic of predicted_swe: \", data['predicted_swe'].describe())\n    data['predicted_swe'].fillna(0, inplace=True)\n    #data['predicted_swe'] = data['predicted_swe'].apply(lambda x: 0 if x < 2 else x)\n    \n    for column in data.columns:\n      column_data = data[column]\n      print(column_data.describe())\n\n#       # Print or process the description as needed\n#       print(f\"Column: {column}\")\n#       print(description)\n    \n    # Create a figure with a white background\n    fig = plt.figure(facecolor='white')\n\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    print(\"data['lon'].values = \", data['lon'].values)\n    x, y = m(data['lon'].values, data['lat'].values)\n#     print(\"x = \", x)\n#     print(\"y = \", y)\n#     print(\"v = \", data['predicted_swe'].values)\n    print(data.columns)\n\n    color_mapping, value_ranges = create_color_maps_with_value_range(data[\"predicted_swe\"], fixed_value_ranges)\n    \n    # Plot the data using the custom colormap\n    plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\n    \n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_date = datetime(1900, 1, 1)\n    day_value = day_index\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    timestamp_string = result_date.strftime(\"%Y-%m-%d\")\n    \n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    # Create custom legend elements using the same colormap\n    legend_elements = [Patch(color=colors[i], label=f\"{value_ranges[i]} - {value_ranges[i+1]-1}\" if i < len(value_ranges) - 1 else f\"> {value_ranges[-1]}\") for i in range(len(value_ranges))]\n\n    # Create the legend outside the map\n    legend = plt.legend(handles=legend_elements, loc='upper left', title='Legend', fontsize=8)\n    legend.set_bbox_to_anchor((1.01, 1)) \n\n    # Remove the color bar\n    #plt.colorbar().remove()\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Set the aspect ratio to 'equal' to keep the plot at the center\n    plt.gca().set_aspect('equal', adjustable='box')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15, right=0.80)  # Adjust right margin to accommodate the legend\n    # Show the plot or save it to a file\n    new_plot_path = f'/home/chetana/gridmet_test_run/predicted_swe-{test_start_date}.png'\n    print(f\"The new plot is saved to {new_plot_path}\")\n    plt.savefig(new_plot_path)\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\ndef convert_csvs_to_images_simple():\n    selected_date = datetime.strptime(test_start_date, \"%Y-%m-%d\")\n    var_name = \"predicted_swe\"\n    test_csv = \"/home/chetana/gridmet_test_run/test_data_predicted.csv\"\n    result_var_df = pd.read_csv(test_csv)\n    result_var_df.replace('--', pd.NA, inplace=True)\n    result_var_df.dropna(inplace=True)\n    result_var_df[var_name] = pd.to_numeric(result_var_df[var_name], errors='coerce')\n    print(result_var_df.head())\n    #print(gridmet_var_df[\"Latitude\"].describe())\n    #print(gridmet_var_df[\"Longitude\"].describe())\n    print(result_var_df[var_name].describe())\n\n    colormaplist, value_ranges = create_color_maps_with_value_range(result_var_df[var_name], fixed_value_ranges)\n\n    # Create a scatter plot\n    plt.scatter(result_var_df[\"lon\"].values, \n                result_var_df[\"lat\"].values, \n                label='Predicted SWE', \n                #color=colormaplist, \n                c=result_var_df['predicted_swe'], \n                cmap='viridis', \n                s=50, \n                edgecolor='none')\n\n    # Add a colorbar\n    cbar = plt.colorbar()\n    cbar.set_label('Predicted SWE')  # Label for the colorbar\n    \n    # Add labels and a legend\n    plt.xlabel('Longitude')\n    plt.ylabel('Latitude')\n    plt.title(f'SWE Prediction Map {test_start_date}')\n    plt.legend()\n\n    res_png_path = f\"{work_dir}/testing_output/{str(selected_date.year)}_{var_name}_{test_start_date}.png\"\n    plt.savefig(res_png_path)\n    print(f\"test image is saved at {res_png_path}\")\n    \n#convert_csvs_to_images()\n\nconvert_csvs_to_images_simple()\n",
  "history_output" : "today date = 2023-09-24\ntest start date:  2022-10-16\ntest end date:  2023-09-24\n/home/chetana\nTraceback (most recent call last):\n  File \"/home/chetana/anaconda3/lib/python3.9/site-packages/pandas/core/indexes/base.py\", line 3802, in get_loc\n    return self._engine.get_loc(casted_key)\n  File \"pandas/_libs/index.pyx\", line 138, in pandas._libs.index.IndexEngine.get_loc\n  File \"pandas/_libs/index.pyx\", line 165, in pandas._libs.index.IndexEngine.get_loc\n  File \"pandas/_libs/hashtable_class_helper.pxi\", line 5745, in pandas._libs.hashtable.PyObjectHashTable.get_item\n  File \"pandas/_libs/hashtable_class_helper.pxi\", line 5753, in pandas._libs.hashtable.PyObjectHashTable.get_item\nKeyError: 'predicted_swe'\nThe above exception was the direct cause of the following exception:\nTraceback (most recent call last):\n  File \"/home/chetana/gw-workspace/uKMIpFVwZb7a/convert_results_to_images.py\", line 210, in <module>\n    convert_csvs_to_images_simple()\n  File \"/home/chetana/gw-workspace/uKMIpFVwZb7a/convert_results_to_images.py\", line 176, in convert_csvs_to_images_simple\n    result_var_df[var_name] = pd.to_numeric(result_var_df[var_name], errors='coerce')\n  File \"/home/chetana/anaconda3/lib/python3.9/site-packages/pandas/core/frame.py\", line 3807, in __getitem__\n    indexer = self.columns.get_loc(key)\n  File \"/home/chetana/anaconda3/lib/python3.9/site-packages/pandas/core/indexes/base.py\", line 3804, in get_loc\n    raise KeyError(key) from err\nKeyError: 'predicted_swe'\n",
  "history_begin_time" : 1695577304917,
  "history_end_time" : 1695577307000,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Failed"
},{
  "history_id" : "ru7c90c47b8",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport uuid\nfrom snowcast_utils import day_index\nimport matplotlib.colors as mcolors\nfrom matplotlib.patches import Patch\nfrom snowcast_utils import day_index, work_dir, test_start_date\n\n# Define the custom colormap with specified colors and ranges\ncolors = [\n    (0.8627, 0.8627, 0.8627),  # #DCDCDC - 0 - 1\n    (0.8627, 1.0000, 1.0000),  # #DCFFFF - 1 - 2\n    (0.6000, 1.0000, 1.0000),  # #99FFFF - 2 - 4\n    (0.5569, 0.8235, 1.0000),  # #8ED2FF - 4 - 6\n    (0.4509, 0.6196, 0.8745),  # #739EDF - 6 - 8\n    (0.4157, 0.4706, 1.0000),  # #6A78FF - 8 - 10\n    (0.4235, 0.2784, 1.0000),  # #6C47FF - 10 - 12\n    (0.5529, 0.0980, 1.0000),  # #8D19FF - 12 - 14\n    (0.7333, 0.0000, 0.9176),  # #BB00EA - 14 - 16\n    (0.8392, 0.0000, 0.7490),  # #D600BF - 16 - 18\n    (0.7569, 0.0039, 0.4549),  # #C10074 - 18 - 20\n    (0.6784, 0.0000, 0.1961),  # #AD0032 - 20 - 30\n    (0.5020, 0.0000, 0.0000)   # #800000 - > 30\n]\n\ncmap_name = 'custom_snow_colormap'\ncustom_cmap = mcolors.ListedColormap(colors)\n\n# Define the lat_lon_to_map_coordinates function\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\n# Define your value ranges for color mapping\nfixed_value_ranges = [1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 30]\n#value_ranges = [0.1, 0.2, 0.4, 0.6, 0.8, 1.0, 1.2, 1.5, 1.8, 2, 2.5, 3]\n\ndef create_color_maps_with_value_range(df_col, value_ranges=None):\n  new_value_ranges = value_ranges\n  if value_ranges == None:\n    max_value = df_col.max()\n    min_value = df_col.min()\n    if min_value < 0:\n      min_value = 0\n    step_size = (max_value - min_value) / 12\n\n    # Create 10 periods\n    new_value_ranges = [min_value + i * step_size for i in range(12)]\n    \n  print(\"new_value_ranges: \", new_value_ranges)\n  \n  # Define your custom function to map data values to colors\n  def map_value_to_color(value):\n    # Iterate through the value ranges to find the appropriate color index\n    for i, range_max in enumerate(new_value_ranges):\n      if value <= range_max:\n        return colors[i]\n\n      # If the value is greater than the largest range, return the last color\n      return colors[-1]\n\n    # Map predicted_swe values to colors using the custom function\n  color_mapping = [map_value_to_color(value) for value in df_col.values]\n  return color_mapping, new_value_ranges\n\ndef convert_csvs_to_images():\n    global fixed_value_ranges\n    data = pd.read_csv(\"/home/chetana/gridmet_test_run/test_data_predicted.csv\")\n#     print(data.head())\n    print(\"statistic of predicted_swe: \", data['predicted_swe'].describe())\n    data['predicted_swe'].fillna(0, inplace=True)\n    #data['predicted_swe'] = data['predicted_swe'].apply(lambda x: 0 if x < 2 else x)\n    \n    for column in data.columns:\n      column_data = data[column]\n      print(column_data.describe())\n\n#       # Print or process the description as needed\n#       print(f\"Column: {column}\")\n#       print(description)\n    \n    # Create a figure with a white background\n    fig = plt.figure(facecolor='white')\n\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    print(\"data['lon'].values = \", data['lon'].values)\n    x, y = m(data['lon'].values, data['lat'].values)\n#     print(\"x = \", x)\n#     print(\"y = \", y)\n#     print(\"v = \", data['predicted_swe'].values)\n    print(data.columns)\n\n    color_mapping, value_ranges = create_color_maps_with_value_range(data[\"predicted_swe\"], fixed_value_ranges)\n    \n    # Plot the data using the custom colormap\n    plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\n    \n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_date = datetime(1900, 1, 1)\n    day_value = day_index\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    timestamp_string = result_date.strftime(\"%Y-%m-%d\")\n    \n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    # Create custom legend elements using the same colormap\n    legend_elements = [Patch(color=colors[i], label=f\"{value_ranges[i]} - {value_ranges[i+1]-1}\" if i < len(value_ranges) - 1 else f\"> {value_ranges[-1]}\") for i in range(len(value_ranges))]\n\n    # Create the legend outside the map\n    legend = plt.legend(handles=legend_elements, loc='upper left', title='Legend', fontsize=8)\n    legend.set_bbox_to_anchor((1.01, 1)) \n\n    # Remove the color bar\n    #plt.colorbar().remove()\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Set the aspect ratio to 'equal' to keep the plot at the center\n    plt.gca().set_aspect('equal', adjustable='box')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15, right=0.80)  # Adjust right margin to accommodate the legend\n    # Show the plot or save it to a file\n    new_plot_path = f'/home/chetana/gridmet_test_run/predicted_swe-{test_start_date}.png'\n    print(f\"The new plot is saved to {new_plot_path}\")\n    plt.savefig(new_plot_path)\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\ndef convert_csvs_to_images_simple():\n    selected_date = datetime.strptime(test_start_date, \"%Y-%m-%d\")\n    var_name = \"predicted_swe\"\n    test_csv = \"/home/chetana/gridmet_test_run/test_data_predicted.csv\"\n    result_var_df = pd.read_csv(test_csv)\n    result_var_df.replace('--', pd.NA, inplace=True)\n    result_var_df.dropna(inplace=True)\n    result_var_df[var_name] = pd.to_numeric(result_var_df[var_name], errors='coerce')\n    print(result_var_df.head())\n    #print(gridmet_var_df[\"Latitude\"].describe())\n    #print(gridmet_var_df[\"Longitude\"].describe())\n    print(result_var_df[var_name].describe())\n\n    colormaplist, value_ranges = create_color_maps_with_value_range(result_var_df[var_name], fixed_value_ranges)\n\n    # Create a scatter plot\n    plt.scatter(result_var_df[\"lon\"].values, \n                result_var_df[\"lat\"].values, \n                label='Predicted SWE', \n                #color=colormaplist, \n                c=result_var_df['predicted_swe'], \n                cmap='viridis', \n                s=50, \n                edgecolor='none')\n\n    # Add a colorbar\n    cbar = plt.colorbar()\n    cbar.set_label('Predicted SWE')  # Label for the colorbar\n    \n    # Add labels and a legend\n    plt.xlabel('Longitude')\n    plt.ylabel('Latitude')\n    plt.title(f'SWE Prediction Map {test_start_date}')\n    plt.legend()\n\n    res_png_path = f\"{work_dir}/testing_output/{str(selected_date.year)}_{var_name}_{test_start_date}.png\"\n    plt.savefig(res_png_path)\n    print(f\"test image is saved at {res_png_path}\")\n    \n#convert_csvs_to_images()\n\nconvert_csvs_to_images_simple()\n",
  "history_output" : "today date = 2023-09-24\ntest start date:  2022-10-16\ntest end date:  2023-09-24\n/home/chetana\n     date   lat      lon  SWE  ...     aspect  eastness  northness  predicted_swe\n69  44848  49.0 -122.516    0  ...   91.84747  0.785138  -0.032228          0.034\n70  44848  49.0 -122.480    0  ...   90.00000  0.785398   0.000000          0.064\n71  44848  49.0 -122.444    0  ...  329.53427 -0.469250   0.711381          0.136\n72  44848  49.0 -122.408    0  ...  270.00000 -0.785398   0.000000          0.041\n73  44848  49.0 -122.372    0  ...   83.99069  0.782643   0.104310          0.034\n[5 rows x 20 columns]\ncount    288650.000000\nmean          0.129196\nstd           0.184185\nmin           0.000000\n25%           0.004000\n50%           0.069000\n75%           0.183000\nmax           2.200000\nName: predicted_swe, dtype: float64\nnew_value_ranges:  [1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 30]\ntest image is saved at /home/chetana/gridmet_test_run/testing_output/2022_predicted_swe_2022-10-16.png\n",
  "history_begin_time" : 1695576466567,
  "history_end_time" : 1695576474427,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "100001",
  "indicator" : "Done"
},{
  "history_id" : "swh7en7p9ka",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport uuid\nfrom snowcast_utils import day_index\nimport matplotlib.colors as mcolors\nfrom matplotlib.patches import Patch\nfrom snowcast_utils import day_index, work_dir, test_start_date\n\n# Define the custom colormap with specified colors and ranges\ncolors = [\n    (0.8627, 0.8627, 0.8627),  # #DCDCDC - 0 - 1\n    (0.8627, 1.0000, 1.0000),  # #DCFFFF - 1 - 2\n    (0.6000, 1.0000, 1.0000),  # #99FFFF - 2 - 4\n    (0.5569, 0.8235, 1.0000),  # #8ED2FF - 4 - 6\n    (0.4509, 0.6196, 0.8745),  # #739EDF - 6 - 8\n    (0.4157, 0.4706, 1.0000),  # #6A78FF - 8 - 10\n    (0.4235, 0.2784, 1.0000),  # #6C47FF - 10 - 12\n    (0.5529, 0.0980, 1.0000),  # #8D19FF - 12 - 14\n    (0.7333, 0.0000, 0.9176),  # #BB00EA - 14 - 16\n    (0.8392, 0.0000, 0.7490),  # #D600BF - 16 - 18\n    (0.7569, 0.0039, 0.4549),  # #C10074 - 18 - 20\n    (0.6784, 0.0000, 0.1961),  # #AD0032 - 20 - 30\n    (0.5020, 0.0000, 0.0000)   # #800000 - > 30\n]\n\ncmap_name = 'custom_snow_colormap'\ncustom_cmap = mcolors.ListedColormap(colors)\n\n# Define the lat_lon_to_map_coordinates function\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\n# Define your value ranges for color mapping\nfixed_value_ranges = [1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 30]\n#value_ranges = [0.1, 0.2, 0.4, 0.6, 0.8, 1.0, 1.2, 1.5, 1.8, 2, 2.5, 3]\n\ndef create_color_maps_with_value_range(df_col, value_ranges=None):\n  new_value_ranges = value_ranges\n  if value_ranges == None:\n    max_value = df_col.max()\n    min_value = df_col.min()\n    if min_value < 0:\n      min_value = 0\n    step_size = (max_value - min_value) / 12\n\n    # Create 10 periods\n    new_value_ranges = [min_value + i * step_size for i in range(12)]\n    \n  print(\"new_value_ranges: \", new_value_ranges)\n  \n  # Define your custom function to map data values to colors\n  def map_value_to_color(value):\n    # Iterate through the value ranges to find the appropriate color index\n    for i, range_max in enumerate(new_value_ranges):\n      if value <= range_max:\n        return colors[i]\n\n      # If the value is greater than the largest range, return the last color\n      return colors[-1]\n\n    # Map predicted_swe values to colors using the custom function\n  color_mapping = [map_value_to_color(value) for value in df_col.values]\n  return color_mapping, new_value_ranges\n\ndef convert_csvs_to_images():\n    global fixed_value_ranges\n    data = pd.read_csv(\"/home/chetana/gridmet_test_run/test_data_predicted.csv\")\n#     print(data.head())\n    print(\"statistic of predicted_swe: \", data['predicted_swe'].describe())\n    data['predicted_swe'].fillna(0, inplace=True)\n    #data['predicted_swe'] = data['predicted_swe'].apply(lambda x: 0 if x < 2 else x)\n    \n    for column in data.columns:\n      column_data = data[column]\n      print(column_data.describe())\n\n#       # Print or process the description as needed\n#       print(f\"Column: {column}\")\n#       print(description)\n    \n    # Create a figure with a white background\n    fig = plt.figure(facecolor='white')\n\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    print(\"data['lon'].values = \", data['lon'].values)\n    x, y = m(data['lon'].values, data['lat'].values)\n#     print(\"x = \", x)\n#     print(\"y = \", y)\n#     print(\"v = \", data['predicted_swe'].values)\n    print(data.columns)\n\n    color_mapping, value_ranges = create_color_maps_with_value_range(data[\"predicted_swe\"], fixed_value_ranges)\n    \n    # Plot the data using the custom colormap\n    plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\n    \n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_date = datetime(1900, 1, 1)\n    day_value = day_index\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    timestamp_string = result_date.strftime(\"%Y-%m-%d\")\n    \n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    # Create custom legend elements using the same colormap\n    legend_elements = [Patch(color=colors[i], label=f\"{value_ranges[i]} - {value_ranges[i+1]-1}\" if i < len(value_ranges) - 1 else f\"> {value_ranges[-1]}\") for i in range(len(value_ranges))]\n\n    # Create the legend outside the map\n    legend = plt.legend(handles=legend_elements, loc='upper left', title='Legend', fontsize=8)\n    legend.set_bbox_to_anchor((1.01, 1)) \n\n    # Remove the color bar\n    #plt.colorbar().remove()\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Set the aspect ratio to 'equal' to keep the plot at the center\n    plt.gca().set_aspect('equal', adjustable='box')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15, right=0.80)  # Adjust right margin to accommodate the legend\n    # Show the plot or save it to a file\n    new_plot_path = f'/home/chetana/gridmet_test_run/predicted_swe-{test_start_date}.png'\n    print(f\"The new plot is saved to {new_plot_path}\")\n    plt.savefig(new_plot_path)\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\ndef convert_csvs_to_images_simple():\n    selected_date = datetime.strptime(test_start_date, \"%Y-%m-%d\")\n    var_name = \"predicted_swe\"\n    test_csv = \"/home/chetana/gridmet_test_run/test_data_predicted.csv\"\n    result_var_df = pd.read_csv(test_csv)\n    result_var_df.replace('--', pd.NA, inplace=True)\n    result_var_df.dropna(inplace=True)\n    result_var_df[var_name] = pd.to_numeric(result_var_df[var_name], errors='coerce')\n    print(result_var_df.head())\n    #print(gridmet_var_df[\"Latitude\"].describe())\n    #print(gridmet_var_df[\"Longitude\"].describe())\n    print(result_var_df[var_name].describe())\n\n    colormaplist, value_ranges = create_color_maps_with_value_range(result_var_df[var_name], fixed_value_ranges)\n\n    # Create a scatter plot\n    plt.scatter(result_var_df[\"lon\"].values, \n                result_var_df[\"lat\"].values, \n                label='Predicted SWE', \n                #color=colormaplist, \n                c=result_var_df['predicted_swe'], \n                cmap='viridis', \n                s=50, \n                edgecolor='none')\n\n    # Add a colorbar\n    cbar = plt.colorbar()\n    cbar.set_label('Predicted SWE')  # Label for the colorbar\n    \n    # Add labels and a legend\n    plt.xlabel('Longitude')\n    plt.ylabel('Latitude')\n    plt.title(f'SWE Prediction Map {test_start_date}')\n    plt.legend()\n\n    res_png_path = f\"{work_dir}/testing_output/{str(selected_date.year)}_{var_name}_{test_start_date}.png\"\n    plt.savefig(res_png_path)\n    print(f\"test image is saved at {res_png_path}\")\n    \n#convert_csvs_to_images()\n\nconvert_csvs_to_images_simple()\n",
  "history_output" : "today date = 2023-09-24\ntest start date:  2022-12-29\ntest end date:  2023-09-24\n/home/chetana\n     date   lat      lon  SWE  ...     aspect  eastness  northness  predicted_swe\n69  44922  49.0 -122.516  255  ...   91.84747  0.785138  -0.032228          4.410\n70  44922  49.0 -122.480  255  ...   90.00000  0.785398   0.000000          4.381\n71  44922  49.0 -122.444  255  ...  329.53427 -0.469250   0.711381          4.422\n72  44922  49.0 -122.408  255  ...  270.00000 -0.785398   0.000000          4.503\n73  44922  49.0 -122.372  255  ...   83.99069  0.782643   0.104310          4.557\n[5 rows x 20 columns]\ncount    288650.000000\nmean          6.330679\nstd           1.556047\nmin           1.632000\n25%           6.152000\n50%           7.102000\n75%           7.323000\nmax           7.682000\nName: predicted_swe, dtype: float64\nnew_value_ranges:  [1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 30]\ntest image is saved at /home/chetana/gridmet_test_run/testing_output/2022_predicted_swe_2022-12-29.png\n",
  "history_begin_time" : 1695576153638,
  "history_end_time" : 1695576161435,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "100001",
  "indicator" : "Done"
},{
  "history_id" : "txevlz2bf21",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport uuid\nfrom snowcast_utils import day_index\nimport matplotlib.colors as mcolors\nfrom matplotlib.patches import Patch\nfrom snowcast_utils import day_index, work_dir, test_start_date\n\n# Define the custom colormap with specified colors and ranges\ncolors = [\n    (0.8627, 0.8627, 0.8627),  # #DCDCDC - 0 - 1\n    (0.8627, 1.0000, 1.0000),  # #DCFFFF - 1 - 2\n    (0.6000, 1.0000, 1.0000),  # #99FFFF - 2 - 4\n    (0.5569, 0.8235, 1.0000),  # #8ED2FF - 4 - 6\n    (0.4509, 0.6196, 0.8745),  # #739EDF - 6 - 8\n    (0.4157, 0.4706, 1.0000),  # #6A78FF - 8 - 10\n    (0.4235, 0.2784, 1.0000),  # #6C47FF - 10 - 12\n    (0.5529, 0.0980, 1.0000),  # #8D19FF - 12 - 14\n    (0.7333, 0.0000, 0.9176),  # #BB00EA - 14 - 16\n    (0.8392, 0.0000, 0.7490),  # #D600BF - 16 - 18\n    (0.7569, 0.0039, 0.4549),  # #C10074 - 18 - 20\n    (0.6784, 0.0000, 0.1961),  # #AD0032 - 20 - 30\n    (0.5020, 0.0000, 0.0000)   # #800000 - > 30\n]\n\ncmap_name = 'custom_snow_colormap'\ncustom_cmap = mcolors.ListedColormap(colors)\n\n# Define the lat_lon_to_map_coordinates function\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\n# Define your value ranges for color mapping\nfixed_value_ranges = [1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 30]\n#value_ranges = [0.1, 0.2, 0.4, 0.6, 0.8, 1.0, 1.2, 1.5, 1.8, 2, 2.5, 3]\n\ndef create_color_maps_with_value_range(df_col, value_ranges=None):\n  new_value_ranges = value_ranges\n  if value_ranges == None:\n    max_value = df_col.max()\n    min_value = df_col.min()\n    if min_value < 0:\n      min_value = 0\n    step_size = (max_value - min_value) / 12\n\n    # Create 10 periods\n    new_value_ranges = [min_value + i * step_size for i in range(12)]\n    \n  print(\"new_value_ranges: \", new_value_ranges)\n  \n  # Define your custom function to map data values to colors\n  def map_value_to_color(value):\n    # Iterate through the value ranges to find the appropriate color index\n    for i, range_max in enumerate(new_value_ranges):\n      if value <= range_max:\n        return colors[i]\n\n      # If the value is greater than the largest range, return the last color\n      return colors[-1]\n\n    # Map predicted_swe values to colors using the custom function\n  color_mapping = [map_value_to_color(value) for value in df_col.values]\n  return color_mapping, new_value_ranges\n\ndef convert_csvs_to_images():\n    global fixed_value_ranges\n    data = pd.read_csv(\"/home/chetana/gridmet_test_run/test_data_predicted.csv\")\n#     print(data.head())\n    print(\"statistic of predicted_swe: \", data['predicted_swe'].describe())\n    data['predicted_swe'].fillna(0, inplace=True)\n    #data['predicted_swe'] = data['predicted_swe'].apply(lambda x: 0 if x < 2 else x)\n    \n    for column in data.columns:\n      column_data = data[column]\n      print(column_data.describe())\n\n#       # Print or process the description as needed\n#       print(f\"Column: {column}\")\n#       print(description)\n    \n    # Create a figure with a white background\n    fig = plt.figure(facecolor='white')\n\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    print(\"data['lon'].values = \", data['lon'].values)\n    x, y = m(data['lon'].values, data['lat'].values)\n#     print(\"x = \", x)\n#     print(\"y = \", y)\n#     print(\"v = \", data['predicted_swe'].values)\n    print(data.columns)\n\n    color_mapping, value_ranges = create_color_maps_with_value_range(data[\"predicted_swe\"], fixed_value_ranges)\n    \n    # Plot the data using the custom colormap\n    plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\n    \n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_date = datetime(1900, 1, 1)\n    day_value = day_index\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    timestamp_string = result_date.strftime(\"%Y-%m-%d\")\n    \n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    # Create custom legend elements using the same colormap\n    legend_elements = [Patch(color=colors[i], label=f\"{value_ranges[i]} - {value_ranges[i+1]-1}\" if i < len(value_ranges) - 1 else f\"> {value_ranges[-1]}\") for i in range(len(value_ranges))]\n\n    # Create the legend outside the map\n    legend = plt.legend(handles=legend_elements, loc='upper left', title='Legend', fontsize=8)\n    legend.set_bbox_to_anchor((1.01, 1)) \n\n    # Remove the color bar\n    #plt.colorbar().remove()\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Set the aspect ratio to 'equal' to keep the plot at the center\n    plt.gca().set_aspect('equal', adjustable='box')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15, right=0.80)  # Adjust right margin to accommodate the legend\n    # Show the plot or save it to a file\n    new_plot_path = f'/home/chetana/gridmet_test_run/predicted_swe-{test_start_date}.png'\n    print(f\"The new plot is saved to {new_plot_path}\")\n    plt.savefig(new_plot_path)\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\ndef convert_csvs_to_images_simple():\n    selected_date = datetime.strptime(test_start_date, \"%Y-%m-%d\")\n    var_name = \"predicted_swe\"\n    test_csv = \"/home/chetana/gridmet_test_run/test_data_predicted.csv\"\n    result_var_df = pd.read_csv(test_csv)\n    result_var_df.replace('--', pd.NA, inplace=True)\n    result_var_df.dropna(inplace=True)\n    result_var_df[var_name] = pd.to_numeric(result_var_df[var_name], errors='coerce')\n    print(result_var_df.head())\n    #print(gridmet_var_df[\"Latitude\"].describe())\n    #print(gridmet_var_df[\"Longitude\"].describe())\n    print(result_var_df[var_name].describe())\n\n    colormaplist, value_ranges = create_color_maps_with_value_range(result_var_df[var_name], fixed_value_ranges)\n\n    # Create a scatter plot\n    plt.scatter(result_var_df[\"lon\"].values, \n                result_var_df[\"lat\"].values, \n                label='Predicted SWE', \n                #color=colormaplist, \n                c=result_var_df['predicted_swe'], \n                cmap='viridis', \n                s=50, \n                edgecolor='none')\n\n    # Add a colorbar\n    cbar = plt.colorbar()\n    cbar.set_label('Predicted SWE')  # Label for the colorbar\n    \n    # Add labels and a legend\n    plt.xlabel('X-axis')\n    plt.ylabel('Y-axis')\n    plt.title(f'Scatter Plot Example {test_start_date}')\n    plt.legend()\n\n    res_png_path = f\"{work_dir}/testing_output/{str(selected_date.year)}_{var_name}_{test_start_date}.png\"\n    plt.savefig(res_png_path)\n    print(f\"test image is saved at {res_png_path}\")\n    \n#convert_csvs_to_images()\n\nconvert_csvs_to_images_simple()\n",
  "history_output" : "today date = 2023-09-24\ntest start date:  2022-12-30\ntest end date:  2023-09-24\n/home/chetana\n     date   lat      lon  SWE  ...     aspect  eastness  northness  predicted_swe\n69  44923  49.0 -122.516    0  ...   91.84747  0.785138  -0.032228          3.339\n70  44923  49.0 -122.480    0  ...   90.00000  0.785398   0.000000          3.356\n71  44923  49.0 -122.444    0  ...  329.53427 -0.469250   0.711381          3.517\n72  44923  49.0 -122.408    0  ...  270.00000 -0.785398   0.000000          3.476\n73  44923  49.0 -122.372    0  ...   83.99069  0.782643   0.104310          3.419\n[5 rows x 20 columns]\ncount    288650.000000\nmean          5.907517\nstd           1.611880\nmin           1.582000\n25%           4.939250\n50%           6.638000\n75%           7.169000\nmax           7.689000\nName: predicted_swe, dtype: float64\nnew_value_ranges:  [1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 30]\ntest image is saved at /home/chetana/gridmet_test_run/testing_output/2022_predicted_swe_2022-12-30.png\n",
  "history_begin_time" : 1695535967682,
  "history_end_time" : 1695535975856,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "100001",
  "indicator" : "Done"
},{
  "history_id" : "3p7peht5pzy",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport uuid\nfrom snowcast_utils import day_index\nimport matplotlib.colors as mcolors\nfrom matplotlib.patches import Patch\nfrom snowcast_utils import day_index, work_dir, test_start_date\n\n# Define the custom colormap with specified colors and ranges\ncolors = [\n    (0.8627, 0.8627, 0.8627),  # #DCDCDC - 0 - 1\n    (0.8627, 1.0000, 1.0000),  # #DCFFFF - 1 - 2\n    (0.6000, 1.0000, 1.0000),  # #99FFFF - 2 - 4\n    (0.5569, 0.8235, 1.0000),  # #8ED2FF - 4 - 6\n    (0.4509, 0.6196, 0.8745),  # #739EDF - 6 - 8\n    (0.4157, 0.4706, 1.0000),  # #6A78FF - 8 - 10\n    (0.4235, 0.2784, 1.0000),  # #6C47FF - 10 - 12\n    (0.5529, 0.0980, 1.0000),  # #8D19FF - 12 - 14\n    (0.7333, 0.0000, 0.9176),  # #BB00EA - 14 - 16\n    (0.8392, 0.0000, 0.7490),  # #D600BF - 16 - 18\n    (0.7569, 0.0039, 0.4549),  # #C10074 - 18 - 20\n    (0.6784, 0.0000, 0.1961),  # #AD0032 - 20 - 30\n    (0.5020, 0.0000, 0.0000)   # #800000 - > 30\n]\n\ncmap_name = 'custom_snow_colormap'\ncustom_cmap = mcolors.ListedColormap(colors)\n\n# Define the lat_lon_to_map_coordinates function\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\n# Define your value ranges for color mapping\nfixed_value_ranges = [1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 30]\n#value_ranges = [0.1, 0.2, 0.4, 0.6, 0.8, 1.0, 1.2, 1.5, 1.8, 2, 2.5, 3]\n\ndef create_color_maps_with_value_range(df_col, value_ranges=None):\n  new_value_ranges = value_ranges\n  if value_ranges == None:\n    max_value = df_col.max()\n    min_value = df_col.min()\n    if min_value < 0:\n      min_value = 0\n    step_size = (max_value - min_value) / 12\n\n    # Create 10 periods\n    new_value_ranges = [min_value + i * step_size for i in range(12)]\n    \n  print(\"new_value_ranges: \", new_value_ranges)\n  \n  # Define your custom function to map data values to colors\n  def map_value_to_color(value):\n    # Iterate through the value ranges to find the appropriate color index\n    for i, range_max in enumerate(new_value_ranges):\n      if value <= range_max:\n        return colors[i]\n\n      # If the value is greater than the largest range, return the last color\n      return colors[-1]\n\n    # Map predicted_swe values to colors using the custom function\n  color_mapping = [map_value_to_color(value) for value in df_col.values]\n  return color_mapping, new_value_ranges\n\ndef convert_csvs_to_images():\n    global fixed_value_ranges\n    data = pd.read_csv(\"/home/chetana/gridmet_test_run/test_data_predicted.csv\")\n#     print(data.head())\n    print(\"statistic of predicted_swe: \", data['predicted_swe'].describe())\n    data['predicted_swe'].fillna(0, inplace=True)\n    #data['predicted_swe'] = data['predicted_swe'].apply(lambda x: 0 if x < 2 else x)\n    \n    for column in data.columns:\n      column_data = data[column]\n      print(column_data.describe())\n\n#       # Print or process the description as needed\n#       print(f\"Column: {column}\")\n#       print(description)\n    \n    # Create a figure with a white background\n    fig = plt.figure(facecolor='white')\n\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    print(\"data['lon'].values = \", data['lon'].values)\n    x, y = m(data['lon'].values, data['lat'].values)\n#     print(\"x = \", x)\n#     print(\"y = \", y)\n#     print(\"v = \", data['predicted_swe'].values)\n    print(data.columns)\n\n    color_mapping, value_ranges = create_color_maps_with_value_range(data[\"predicted_swe\"], fixed_value_ranges)\n    \n    # Plot the data using the custom colormap\n    plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\n    \n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_date = datetime(1900, 1, 1)\n    day_value = day_index\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    timestamp_string = result_date.strftime(\"%Y-%m-%d\")\n    \n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    # Create custom legend elements using the same colormap\n    legend_elements = [Patch(color=colors[i], label=f\"{value_ranges[i]} - {value_ranges[i+1]-1}\" if i < len(value_ranges) - 1 else f\"> {value_ranges[-1]}\") for i in range(len(value_ranges))]\n\n    # Create the legend outside the map\n    legend = plt.legend(handles=legend_elements, loc='upper left', title='Legend', fontsize=8)\n    legend.set_bbox_to_anchor((1.01, 1)) \n\n    # Remove the color bar\n    #plt.colorbar().remove()\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Set the aspect ratio to 'equal' to keep the plot at the center\n    plt.gca().set_aspect('equal', adjustable='box')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15, right=0.80)  # Adjust right margin to accommodate the legend\n    # Show the plot or save it to a file\n    new_plot_path = f'/home/chetana/gridmet_test_run/predicted_swe-{test_start_date}.png'\n    print(f\"The new plot is saved to {new_plot_path}\")\n    plt.savefig(new_plot_path)\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\ndef convert_csvs_to_images_simple():\n    selected_date = datetime.strptime(test_start_date, \"%Y-%m-%d\")\n    var_name = \"predicted_swe\"\n    test_csv = \"/home/chetana/gridmet_test_run/test_data_predicted.csv\"\n    result_var_df = pd.read_csv(test_csv)\n    result_var_df.replace('--', pd.NA, inplace=True)\n    result_var_df.dropna(inplace=True)\n    result_var_df[var_name] = pd.to_numeric(result_var_df[var_name], errors='coerce')\n    print(result_var_df.head())\n    #print(gridmet_var_df[\"Latitude\"].describe())\n    #print(gridmet_var_df[\"Longitude\"].describe())\n    print(result_var_df[var_name].describe())\n\n    colormaplist, value_ranges = create_color_maps_with_value_range(result_var_df[var_name], fixed_value_ranges)\n\n    # Create a scatter plot\n    plt.scatter(result_var_df[\"lon\"].values, \n                result_var_df[\"lat\"].values, \n                label='Predicted SWE', \n                #color=colormaplist, \n                c=result_var_df['predicted_swe'], \n                cmap='viridis', \n                s=50, \n                edgecolor='none')\n\n    # Add a colorbar\n    cbar = plt.colorbar()\n    cbar.set_label('Predicted SWE')  # Label for the colorbar\n    \n    # Add labels and a legend\n    plt.xlabel('X-axis')\n    plt.ylabel('Y-axis')\n    plt.title(f'Scatter Plot Example {test_start_date}')\n    plt.legend()\n\n    res_png_path = f\"{work_dir}/testing_output/{str(selected_date.year)}_{var_name}_{test_start_date}.png\"\n    plt.savefig(res_png_path)\n    print(f\"test image is saved at {res_png_path}\")\n    \n#convert_csvs_to_images()\n\nconvert_csvs_to_images_simple()\n",
  "history_output" : "today date = 2023-09-24\ntest start date:  2022-10-15\ntest end date:  2023-09-24\n/home/chetana\n     date   lat      lon  SWE  ...     aspect  eastness  northness  predicted_swe\n69  44847  49.0 -122.516    0  ...   91.84747  0.785138  -0.032228          0.034\n70  44847  49.0 -122.480    0  ...   90.00000  0.785398   0.000000          0.064\n71  44847  49.0 -122.444    0  ...  329.53427 -0.469250   0.711381          0.041\n72  44847  49.0 -122.408    0  ...  270.00000 -0.785398   0.000000          0.040\n73  44847  49.0 -122.372    0  ...   83.99069  0.782643   0.104310          0.032\n[5 rows x 20 columns]\ncount    288650.000000\nmean          0.083027\nstd           0.114130\nmin           0.000000\n25%           0.002000\n50%           0.030000\n75%           0.128000\nmax           1.650000\nName: predicted_swe, dtype: float64\nnew_value_ranges:  [1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 30]\ntest image is saved at /home/chetana/gridmet_test_run/testing_output/2022_predicted_swe_2022-10-15.png\n",
  "history_begin_time" : 1695535661099,
  "history_end_time" : 1695535668907,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "100001",
  "indicator" : "Done"
},{
  "history_id" : "urgt0yu9xts",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport uuid\nfrom snowcast_utils import day_index\nimport matplotlib.colors as mcolors\nfrom matplotlib.patches import Patch\nfrom snowcast_utils import day_index, work_dir, test_start_date\n\n# Define the custom colormap with specified colors and ranges\ncolors = [\n    (0.8627, 0.8627, 0.8627),  # #DCDCDC - 0 - 1\n    (0.8627, 1.0000, 1.0000),  # #DCFFFF - 1 - 2\n    (0.6000, 1.0000, 1.0000),  # #99FFFF - 2 - 4\n    (0.5569, 0.8235, 1.0000),  # #8ED2FF - 4 - 6\n    (0.4509, 0.6196, 0.8745),  # #739EDF - 6 - 8\n    (0.4157, 0.4706, 1.0000),  # #6A78FF - 8 - 10\n    (0.4235, 0.2784, 1.0000),  # #6C47FF - 10 - 12\n    (0.5529, 0.0980, 1.0000),  # #8D19FF - 12 - 14\n    (0.7333, 0.0000, 0.9176),  # #BB00EA - 14 - 16\n    (0.8392, 0.0000, 0.7490),  # #D600BF - 16 - 18\n    (0.7569, 0.0039, 0.4549),  # #C10074 - 18 - 20\n    (0.6784, 0.0000, 0.1961),  # #AD0032 - 20 - 30\n    (0.5020, 0.0000, 0.0000)   # #800000 - > 30\n]\n\ncmap_name = 'custom_snow_colormap'\ncustom_cmap = mcolors.ListedColormap(colors)\n\n# Define the lat_lon_to_map_coordinates function\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\n# Define your value ranges for color mapping\nfixed_value_ranges = [1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 30]\n#value_ranges = [0.1, 0.2, 0.4, 0.6, 0.8, 1.0, 1.2, 1.5, 1.8, 2, 2.5, 3]\n\ndef create_color_maps_with_value_range(df_col, value_ranges=None):\n  new_value_ranges = value_ranges\n  if value_ranges == None:\n    max_value = df_col.max()\n    min_value = df_col.min()\n    if min_value < 0:\n      min_value = 0\n    step_size = (max_value - min_value) / 12\n\n    # Create 10 periods\n    new_value_ranges = [min_value + i * step_size for i in range(12)]\n    \n  print(\"new_value_ranges: \", new_value_ranges)\n  \n  # Define your custom function to map data values to colors\n  def map_value_to_color(value):\n    # Iterate through the value ranges to find the appropriate color index\n    for i, range_max in enumerate(new_value_ranges):\n      if value <= range_max:\n        return colors[i]\n\n      # If the value is greater than the largest range, return the last color\n      return colors[-1]\n\n    # Map predicted_swe values to colors using the custom function\n  color_mapping = [map_value_to_color(value) for value in df_col.values]\n  return color_mapping, new_value_ranges\n\ndef convert_csvs_to_images():\n    global fixed_value_ranges\n    data = pd.read_csv(\"/home/chetana/gridmet_test_run/test_data_predicted.csv\")\n#     print(data.head())\n    print(\"statistic of predicted_swe: \", data['predicted_swe'].describe())\n    data['predicted_swe'].fillna(0, inplace=True)\n    #data['predicted_swe'] = data['predicted_swe'].apply(lambda x: 0 if x < 2 else x)\n    \n    for column in data.columns:\n      column_data = data[column]\n      print(column_data.describe())\n\n#       # Print or process the description as needed\n#       print(f\"Column: {column}\")\n#       print(description)\n    \n    # Create a figure with a white background\n    fig = plt.figure(facecolor='white')\n\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    print(\"data['lon'].values = \", data['lon'].values)\n    x, y = m(data['lon'].values, data['lat'].values)\n#     print(\"x = \", x)\n#     print(\"y = \", y)\n#     print(\"v = \", data['predicted_swe'].values)\n    print(data.columns)\n\n    color_mapping, value_ranges = create_color_maps_with_value_range(data[\"predicted_swe\"], fixed_value_ranges)\n    \n    # Plot the data using the custom colormap\n    plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\n    \n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_date = datetime(1900, 1, 1)\n    day_value = day_index\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    timestamp_string = result_date.strftime(\"%Y-%m-%d\")\n    \n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    # Create custom legend elements using the same colormap\n    legend_elements = [Patch(color=colors[i], label=f\"{value_ranges[i]} - {value_ranges[i+1]-1}\" if i < len(value_ranges) - 1 else f\"> {value_ranges[-1]}\") for i in range(len(value_ranges))]\n\n    # Create the legend outside the map\n    legend = plt.legend(handles=legend_elements, loc='upper left', title='Legend', fontsize=8)\n    legend.set_bbox_to_anchor((1.01, 1)) \n\n    # Remove the color bar\n    #plt.colorbar().remove()\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Set the aspect ratio to 'equal' to keep the plot at the center\n    plt.gca().set_aspect('equal', adjustable='box')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15, right=0.80)  # Adjust right margin to accommodate the legend\n    # Show the plot or save it to a file\n    new_plot_path = f'/home/chetana/gridmet_test_run/predicted_swe-{test_start_date}.png'\n    print(f\"The new plot is saved to {new_plot_path}\")\n    plt.savefig(new_plot_path)\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\ndef convert_csvs_to_images_simple():\n    selected_date = datetime.strptime(test_start_date, \"%Y-%m-%d\")\n    var_name = \"predicted_swe\"\n    test_csv = \"/home/chetana/gridmet_test_run/test_data_predicted.csv\"\n    result_var_df = pd.read_csv(test_csv)\n    result_var_df.replace('--', pd.NA, inplace=True)\n    result_var_df.dropna(inplace=True)\n    result_var_df[var_name] = pd.to_numeric(result_var_df[var_name], errors='coerce')\n    print(result_var_df.head())\n    #print(gridmet_var_df[\"Latitude\"].describe())\n    #print(gridmet_var_df[\"Longitude\"].describe())\n    print(result_var_df[var_name].describe())\n\n    colormaplist, value_ranges = create_color_maps_with_value_range(result_var_df[var_name], fixed_value_ranges)\n\n    # Create a scatter plot\n    plt.scatter(result_var_df[\"lon\"].values, \n                result_var_df[\"lat\"].values, \n                label='Predicted SWE', \n                #color=colormaplist, \n                c=result_var_df['predicted_swe'], \n                cmap='viridis', \n                s=50, \n                edgecolor='none')\n\n    # Add a colorbar\n    cbar = plt.colorbar()\n    cbar.set_label('Predicted SWE')  # Label for the colorbar\n    \n    # Add labels and a legend\n    plt.xlabel('X-axis')\n    plt.ylabel('Y-axis')\n    plt.title(f'Scatter Plot Example {test_start_date}')\n    plt.legend()\n\n    res_png_path = f\"{work_dir}/testing_output/{str(selected_date.year)}_{var_name}_{test_start_date}.png\"\n    plt.savefig(res_png_path)\n    print(f\"test image is saved at {res_png_path}\")\n    \n#convert_csvs_to_images()\n\nconvert_csvs_to_images_simple()\n",
  "history_output" : "today date = 2023-09-24\ntest start date:  2022-06-15\ntest end date:  2023-09-24\n/home/chetana\n     date   lat      lon  SWE  ...     aspect  eastness  northness  predicted_swe\n69  44725  49.0 -122.516    0  ...   91.84747  0.785138  -0.032228          0.076\n70  44725  49.0 -122.480    0  ...   90.00000  0.785398   0.000000          0.079\n71  44725  49.0 -122.444    0  ...  329.53427 -0.469250   0.711381          0.073\n72  44725  49.0 -122.408    0  ...  270.00000 -0.785398   0.000000          0.084\n73  44725  49.0 -122.372    0  ...   83.99069  0.782643   0.104310          0.069\n[5 rows x 20 columns]\ncount    288650.000000\nmean          0.053317\nstd           0.091985\nmin           0.000000\n25%           0.000000\n50%           0.005000\n75%           0.074000\nmax           1.110000\nName: predicted_swe, dtype: float64\nnew_value_ranges:  [1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 30]\ntest image is saved at /home/chetana/gridmet_test_run/testing_output/2022_predicted_swe_2022-06-15.png\n",
  "history_begin_time" : 1695535396852,
  "history_end_time" : 1695535404562,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "100001",
  "indicator" : "Done"
},{
  "history_id" : "yw1rgzkvfce",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport uuid\nfrom snowcast_utils import day_index\nimport matplotlib.colors as mcolors\nfrom matplotlib.patches import Patch\nfrom snowcast_utils import day_index, work_dir, test_start_date\n\n# Define the custom colormap with specified colors and ranges\ncolors = [\n    (0.8627, 0.8627, 0.8627),  # #DCDCDC - 0 - 1\n    (0.8627, 1.0000, 1.0000),  # #DCFFFF - 1 - 2\n    (0.6000, 1.0000, 1.0000),  # #99FFFF - 2 - 4\n    (0.5569, 0.8235, 1.0000),  # #8ED2FF - 4 - 6\n    (0.4509, 0.6196, 0.8745),  # #739EDF - 6 - 8\n    (0.4157, 0.4706, 1.0000),  # #6A78FF - 8 - 10\n    (0.4235, 0.2784, 1.0000),  # #6C47FF - 10 - 12\n    (0.5529, 0.0980, 1.0000),  # #8D19FF - 12 - 14\n    (0.7333, 0.0000, 0.9176),  # #BB00EA - 14 - 16\n    (0.8392, 0.0000, 0.7490),  # #D600BF - 16 - 18\n    (0.7569, 0.0039, 0.4549),  # #C10074 - 18 - 20\n    (0.6784, 0.0000, 0.1961),  # #AD0032 - 20 - 30\n    (0.5020, 0.0000, 0.0000)   # #800000 - > 30\n]\n\ncmap_name = 'custom_snow_colormap'\ncustom_cmap = mcolors.ListedColormap(colors)\n\n# Define the lat_lon_to_map_coordinates function\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\n# Define your value ranges for color mapping\nfixed_value_ranges = [1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 30]\n#value_ranges = [0.1, 0.2, 0.4, 0.6, 0.8, 1.0, 1.2, 1.5, 1.8, 2, 2.5, 3]\n\ndef create_color_maps_with_value_range(df_col, value_ranges=None):\n  new_value_ranges = value_ranges\n  if value_ranges == None:\n    max_value = df_col.max()\n    min_value = df_col.min()\n    if min_value < 0:\n      min_value = 0\n    step_size = (max_value - min_value) / 12\n\n    # Create 10 periods\n    new_value_ranges = [min_value + i * step_size for i in range(12)]\n    \n  print(\"new_value_ranges: \", new_value_ranges)\n  \n  # Define your custom function to map data values to colors\n  def map_value_to_color(value):\n    # Iterate through the value ranges to find the appropriate color index\n    for i, range_max in enumerate(new_value_ranges):\n      if value <= range_max:\n        return colors[i]\n\n      # If the value is greater than the largest range, return the last color\n      return colors[-1]\n\n    # Map predicted_swe values to colors using the custom function\n  color_mapping = [map_value_to_color(value) for value in df_col.values]\n  return color_mapping, new_value_ranges\n\ndef convert_csvs_to_images():\n    global fixed_value_ranges\n    data = pd.read_csv(\"/home/chetana/gridmet_test_run/test_data_predicted.csv\")\n#     print(data.head())\n    print(\"statistic of predicted_swe: \", data['predicted_swe'].describe())\n    data['predicted_swe'].fillna(0, inplace=True)\n    #data['predicted_swe'] = data['predicted_swe'].apply(lambda x: 0 if x < 2 else x)\n    \n    for column in data.columns:\n      column_data = data[column]\n      print(column_data.describe())\n\n#       # Print or process the description as needed\n#       print(f\"Column: {column}\")\n#       print(description)\n    \n    # Create a figure with a white background\n    fig = plt.figure(facecolor='white')\n\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    print(\"data['lon'].values = \", data['lon'].values)\n    x, y = m(data['lon'].values, data['lat'].values)\n#     print(\"x = \", x)\n#     print(\"y = \", y)\n#     print(\"v = \", data['predicted_swe'].values)\n    print(data.columns)\n\n    color_mapping, value_ranges = create_color_maps_with_value_range(data[\"predicted_swe\"], fixed_value_ranges)\n    \n    # Plot the data using the custom colormap\n    plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\n    \n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_date = datetime(1900, 1, 1)\n    day_value = day_index\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    timestamp_string = result_date.strftime(\"%Y-%m-%d\")\n    \n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    # Create custom legend elements using the same colormap\n    legend_elements = [Patch(color=colors[i], label=f\"{value_ranges[i]} - {value_ranges[i+1]-1}\" if i < len(value_ranges) - 1 else f\"> {value_ranges[-1]}\") for i in range(len(value_ranges))]\n\n    # Create the legend outside the map\n    legend = plt.legend(handles=legend_elements, loc='upper left', title='Legend', fontsize=8)\n    legend.set_bbox_to_anchor((1.01, 1)) \n\n    # Remove the color bar\n    #plt.colorbar().remove()\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Set the aspect ratio to 'equal' to keep the plot at the center\n    plt.gca().set_aspect('equal', adjustable='box')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15, right=0.80)  # Adjust right margin to accommodate the legend\n    # Show the plot or save it to a file\n    new_plot_path = f'/home/chetana/gridmet_test_run/predicted_swe-{test_start_date}.png'\n    print(f\"The new plot is saved to {new_plot_path}\")\n    plt.savefig(new_plot_path)\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\ndef convert_csvs_to_images_simple():\n    selected_date = datetime.strptime(test_start_date, \"%Y-%m-%d\")\n    var_name = \"predicted_swe\"\n    test_csv = \"/home/chetana/gridmet_test_run/test_data_predicted.csv\"\n    result_var_df = pd.read_csv(test_csv)\n    result_var_df.replace('--', pd.NA, inplace=True)\n    result_var_df.dropna(inplace=True)\n    result_var_df[var_name] = pd.to_numeric(result_var_df[var_name], errors='coerce')\n    print(result_var_df.head())\n    #print(gridmet_var_df[\"Latitude\"].describe())\n    #print(gridmet_var_df[\"Longitude\"].describe())\n    print(result_var_df[var_name].describe())\n\n    colormaplist, value_ranges = create_color_maps_with_value_range(result_var_df[var_name], fixed_value_ranges)\n\n    # Create a scatter plot\n    plt.scatter(result_var_df[\"lon\"].values, \n                result_var_df[\"lat\"].values, \n                label='Predicted SWE', \n                #color=colormaplist, \n                c=result_var_df['predicted_swe'], \n                cmap='viridis', \n                s=50, \n                edgecolor='none')\n\n    # Add a colorbar\n    cbar = plt.colorbar()\n    cbar.set_label('Predicted SWE')  # Label for the colorbar\n    \n    # Add labels and a legend\n    plt.xlabel('X-axis')\n    plt.ylabel('Y-axis')\n    plt.title(f'Scatter Plot Example {test_start_date}')\n    plt.legend()\n\n    res_png_path = f\"{work_dir}/testing_output/{str(selected_date.year)}_{var_name}_{test_start_date}.png\"\n    plt.savefig(res_png_path)\n    print(f\"test image is saved at {res_png_path}\")\n    \n#convert_csvs_to_images()\n\nconvert_csvs_to_images_simple()\n",
  "history_output" : "today date = 2023-09-24\ntest start date:  2022-03-15\ntest end date:  2023-09-24\n/home/chetana\n     date   lat      lon  SWE  ...     aspect  eastness  northness  predicted_swe\n69  44633  49.0 -122.516    0  ...   91.84747  0.785138  -0.032228          7.333\n70  44633  49.0 -122.480    0  ...   90.00000  0.785398   0.000000          7.605\n71  44633  49.0 -122.444    0  ...  329.53427 -0.469250   0.711381          7.248\n72  44633  49.0 -122.408    0  ...  270.00000 -0.785398   0.000000          6.907\n73  44633  49.0 -122.372    0  ...   83.99069  0.782643   0.104310          6.837\n[5 rows x 20 columns]\ncount    288650.000000\nmean          6.767984\nstd           2.080818\nmin           1.589000\n25%           5.387000\n50%           6.846000\n75%           8.484000\nmax          10.432000\nName: predicted_swe, dtype: float64\nnew_value_ranges:  [1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 30]\ntest image is saved at /home/chetana/gridmet_test_run/testing_output/2022_predicted_swe_2022-03-15.png\n",
  "history_begin_time" : 1695535125371,
  "history_end_time" : 1695535133089,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "100001",
  "indicator" : "Done"
},{
  "history_id" : "wubt1akuhoh",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport uuid\nfrom snowcast_utils import day_index\nimport matplotlib.colors as mcolors\nfrom matplotlib.patches import Patch\nfrom snowcast_utils import day_index, work_dir, test_start_date\n\n# Define the custom colormap with specified colors and ranges\ncolors = [\n    (0.8627, 0.8627, 0.8627),  # #DCDCDC - 0 - 1\n    (0.8627, 1.0000, 1.0000),  # #DCFFFF - 1 - 2\n    (0.6000, 1.0000, 1.0000),  # #99FFFF - 2 - 4\n    (0.5569, 0.8235, 1.0000),  # #8ED2FF - 4 - 6\n    (0.4509, 0.6196, 0.8745),  # #739EDF - 6 - 8\n    (0.4157, 0.4706, 1.0000),  # #6A78FF - 8 - 10\n    (0.4235, 0.2784, 1.0000),  # #6C47FF - 10 - 12\n    (0.5529, 0.0980, 1.0000),  # #8D19FF - 12 - 14\n    (0.7333, 0.0000, 0.9176),  # #BB00EA - 14 - 16\n    (0.8392, 0.0000, 0.7490),  # #D600BF - 16 - 18\n    (0.7569, 0.0039, 0.4549),  # #C10074 - 18 - 20\n    (0.6784, 0.0000, 0.1961),  # #AD0032 - 20 - 30\n    (0.5020, 0.0000, 0.0000)   # #800000 - > 30\n]\n\ncmap_name = 'custom_snow_colormap'\ncustom_cmap = mcolors.ListedColormap(colors)\n\n# Define the lat_lon_to_map_coordinates function\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\n# Define your value ranges for color mapping\nfixed_value_ranges = [1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 30]\n#value_ranges = [0.1, 0.2, 0.4, 0.6, 0.8, 1.0, 1.2, 1.5, 1.8, 2, 2.5, 3]\n\ndef create_color_maps_with_value_range(df_col, value_ranges=None):\n  new_value_ranges = value_ranges\n  if value_ranges == None:\n    max_value = df_col.max()\n    min_value = df_col.min()\n    if min_value < 0:\n      min_value = 0\n    step_size = (max_value - min_value) / 12\n\n    # Create 10 periods\n    new_value_ranges = [min_value + i * step_size for i in range(12)]\n    \n  print(\"new_value_ranges: \", new_value_ranges)\n  \n  # Define your custom function to map data values to colors\n  def map_value_to_color(value):\n    # Iterate through the value ranges to find the appropriate color index\n    for i, range_max in enumerate(new_value_ranges):\n      if value <= range_max:\n        return colors[i]\n\n      # If the value is greater than the largest range, return the last color\n      return colors[-1]\n\n    # Map predicted_swe values to colors using the custom function\n  color_mapping = [map_value_to_color(value) for value in df_col.values]\n  return color_mapping, new_value_ranges\n\ndef convert_csvs_to_images():\n    global fixed_value_ranges\n    data = pd.read_csv(\"/home/chetana/gridmet_test_run/test_data_predicted.csv\")\n#     print(data.head())\n    print(\"statistic of predicted_swe: \", data['predicted_swe'].describe())\n    data['predicted_swe'].fillna(0, inplace=True)\n    #data['predicted_swe'] = data['predicted_swe'].apply(lambda x: 0 if x < 2 else x)\n    \n    for column in data.columns:\n      column_data = data[column]\n      print(column_data.describe())\n\n#       # Print or process the description as needed\n#       print(f\"Column: {column}\")\n#       print(description)\n    \n    # Create a figure with a white background\n    fig = plt.figure(facecolor='white')\n\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    print(\"data['lon'].values = \", data['lon'].values)\n    x, y = m(data['lon'].values, data['lat'].values)\n#     print(\"x = \", x)\n#     print(\"y = \", y)\n#     print(\"v = \", data['predicted_swe'].values)\n    print(data.columns)\n\n    color_mapping, value_ranges = create_color_maps_with_value_range(data[\"predicted_swe\"], fixed_value_ranges)\n    \n    # Plot the data using the custom colormap\n    plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\n    \n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_date = datetime(1900, 1, 1)\n    day_value = day_index\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    timestamp_string = result_date.strftime(\"%Y-%m-%d\")\n    \n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    # Create custom legend elements using the same colormap\n    legend_elements = [Patch(color=colors[i], label=f\"{value_ranges[i]} - {value_ranges[i+1]-1}\" if i < len(value_ranges) - 1 else f\"> {value_ranges[-1]}\") for i in range(len(value_ranges))]\n\n    # Create the legend outside the map\n    legend = plt.legend(handles=legend_elements, loc='upper left', title='Legend', fontsize=8)\n    legend.set_bbox_to_anchor((1.01, 1)) \n\n    # Remove the color bar\n    #plt.colorbar().remove()\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Set the aspect ratio to 'equal' to keep the plot at the center\n    plt.gca().set_aspect('equal', adjustable='box')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15, right=0.80)  # Adjust right margin to accommodate the legend\n    # Show the plot or save it to a file\n    new_plot_path = f'/home/chetana/gridmet_test_run/predicted_swe-{test_start_date}.png'\n    print(f\"The new plot is saved to {new_plot_path}\")\n    plt.savefig(new_plot_path)\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\ndef convert_csvs_to_images_simple():\n    selected_date = datetime.strptime(test_start_date, \"%Y-%m-%d\")\n    var_name = \"predicted_swe\"\n    test_csv = \"/home/chetana/gridmet_test_run/test_data_predicted.csv\"\n    result_var_df = pd.read_csv(test_csv)\n    result_var_df.replace('--', pd.NA, inplace=True)\n    result_var_df.dropna(inplace=True)\n    result_var_df[var_name] = pd.to_numeric(result_var_df[var_name], errors='coerce')\n    print(result_var_df.head())\n    #print(gridmet_var_df[\"Latitude\"].describe())\n    #print(gridmet_var_df[\"Longitude\"].describe())\n    print(result_var_df[var_name].describe())\n\n    colormaplist, value_ranges = create_color_maps_with_value_range(result_var_df[var_name], fixed_value_ranges)\n\n    # Create a scatter plot\n    plt.scatter(result_var_df[\"lon\"].values, \n                result_var_df[\"lat\"].values, \n                label='Predicted SWE', \n                #color=colormaplist, \n                c=result_var_df['predicted_swe'], \n                cmap='viridis', \n                s=50, \n                edgecolor='none')\n\n    # Add a colorbar\n    cbar = plt.colorbar()\n    cbar.set_label('Predicted SWE')  # Label for the colorbar\n    \n    # Add labels and a legend\n    plt.xlabel('X-axis')\n    plt.ylabel('Y-axis')\n    plt.title(f'Scatter Plot Example {test_start_date}')\n    plt.legend()\n\n    res_png_path = f\"{work_dir}/testing_output/{str(selected_date.year)}_{var_name}_{test_start_date}.png\"\n    plt.savefig(res_png_path)\n    print(f\"test image is saved at {res_png_path}\")\n    \n#convert_csvs_to_images()\n\nconvert_csvs_to_images_simple()\n",
  "history_output" : "today date = 2023-09-24\ntest start date:  2022-02-28\ntest end date:  2023-09-24\n/home/chetana\n     date   lat      lon  SWE  ...     aspect  eastness  northness  predicted_swe\n69  44618  49.0 -122.516  255  ...   91.84747  0.785138  -0.032228          6.444\n70  44618  49.0 -122.480  255  ...   90.00000  0.785398   0.000000          6.834\n71  44618  49.0 -122.444  255  ...  329.53427 -0.469250   0.711381          7.076\n72  44618  49.0 -122.408  255  ...  270.00000 -0.785398   0.000000          6.947\n73  44618  49.0 -122.372  255  ...   83.99069  0.782643   0.104310          6.904\n[5 rows x 20 columns]\ncount    288650.000000\nmean          7.193008\nstd           1.998720\nmin           1.535000\n25%           6.041000\n50%           7.337000\n75%           8.868000\nmax          10.172000\nName: predicted_swe, dtype: float64\nnew_value_ranges:  [1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 30]\ntest image is saved at /home/chetana/gridmet_test_run/testing_output/2022_predicted_swe_2022-02-28.png\n",
  "history_begin_time" : 1695534849018,
  "history_end_time" : 1695534856794,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "100001",
  "indicator" : "Done"
},{
  "history_id" : "6CsWNIJHTg8s",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport uuid\nfrom snowcast_utils import day_index\nimport matplotlib.colors as mcolors\nfrom matplotlib.patches import Patch\nfrom snowcast_utils import day_index, work_dir, test_start_date\n\n# Define the custom colormap with specified colors and ranges\ncolors = [\n    (0.8627, 0.8627, 0.8627),  # #DCDCDC - 0 - 1\n    (0.8627, 1.0000, 1.0000),  # #DCFFFF - 1 - 2\n    (0.6000, 1.0000, 1.0000),  # #99FFFF - 2 - 4\n    (0.5569, 0.8235, 1.0000),  # #8ED2FF - 4 - 6\n    (0.4509, 0.6196, 0.8745),  # #739EDF - 6 - 8\n    (0.4157, 0.4706, 1.0000),  # #6A78FF - 8 - 10\n    (0.4235, 0.2784, 1.0000),  # #6C47FF - 10 - 12\n    (0.5529, 0.0980, 1.0000),  # #8D19FF - 12 - 14\n    (0.7333, 0.0000, 0.9176),  # #BB00EA - 14 - 16\n    (0.8392, 0.0000, 0.7490),  # #D600BF - 16 - 18\n    (0.7569, 0.0039, 0.4549),  # #C10074 - 18 - 20\n    (0.6784, 0.0000, 0.1961),  # #AD0032 - 20 - 30\n    (0.5020, 0.0000, 0.0000)   # #800000 - > 30\n]\n\ncmap_name = 'custom_snow_colormap'\ncustom_cmap = mcolors.ListedColormap(colors)\n\n# Define the lat_lon_to_map_coordinates function\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\n# Define your value ranges for color mapping\nfixed_value_ranges = [1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 30]\n#value_ranges = [0.1, 0.2, 0.4, 0.6, 0.8, 1.0, 1.2, 1.5, 1.8, 2, 2.5, 3]\n\ndef create_color_maps_with_value_range(df_col, value_ranges=None):\n  new_value_ranges = value_ranges\n  if value_ranges == None:\n    max_value = df_col.max()\n    min_value = df_col.min()\n    if min_value < 0:\n      min_value = 0\n    step_size = (max_value - min_value) / 12\n\n    # Create 10 periods\n    new_value_ranges = [min_value + i * step_size for i in range(12)]\n    \n  print(\"new_value_ranges: \", new_value_ranges)\n  \n  # Define your custom function to map data values to colors\n  def map_value_to_color(value):\n    # Iterate through the value ranges to find the appropriate color index\n    for i, range_max in enumerate(new_value_ranges):\n      if value <= range_max:\n        return colors[i]\n\n      # If the value is greater than the largest range, return the last color\n      return colors[-1]\n\n    # Map predicted_swe values to colors using the custom function\n  color_mapping = [map_value_to_color(value) for value in df_col.values]\n  return color_mapping, new_value_ranges\n\ndef convert_csvs_to_images():\n    global fixed_value_ranges\n    data = pd.read_csv(\"/home/chetana/gridmet_test_run/test_data_predicted.csv\")\n#     print(data.head())\n    print(\"statistic of predicted_swe: \", data['predicted_swe'].describe())\n    data['predicted_swe'].fillna(0, inplace=True)\n    #data['predicted_swe'] = data['predicted_swe'].apply(lambda x: 0 if x < 2 else x)\n    \n    for column in data.columns:\n      column_data = data[column]\n      print(column_data.describe())\n\n#       # Print or process the description as needed\n#       print(f\"Column: {column}\")\n#       print(description)\n    \n    # Create a figure with a white background\n    fig = plt.figure(facecolor='white')\n\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    print(\"data['lon'].values = \", data['lon'].values)\n    x, y = m(data['lon'].values, data['lat'].values)\n#     print(\"x = \", x)\n#     print(\"y = \", y)\n#     print(\"v = \", data['predicted_swe'].values)\n    print(data.columns)\n\n    color_mapping, value_ranges = create_color_maps_with_value_range(data[\"predicted_swe\"], fixed_value_ranges)\n    \n    # Plot the data using the custom colormap\n    plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\n    \n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_date = datetime(1900, 1, 1)\n    day_value = day_index\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    timestamp_string = result_date.strftime(\"%Y-%m-%d\")\n    \n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    # Create custom legend elements using the same colormap\n    legend_elements = [Patch(color=colors[i], label=f\"{value_ranges[i]} - {value_ranges[i+1]-1}\" if i < len(value_ranges) - 1 else f\"> {value_ranges[-1]}\") for i in range(len(value_ranges))]\n\n    # Create the legend outside the map\n    legend = plt.legend(handles=legend_elements, loc='upper left', title='Legend', fontsize=8)\n    legend.set_bbox_to_anchor((1.01, 1)) \n\n    # Remove the color bar\n    #plt.colorbar().remove()\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Set the aspect ratio to 'equal' to keep the plot at the center\n    plt.gca().set_aspect('equal', adjustable='box')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15, right=0.80)  # Adjust right margin to accommodate the legend\n    # Show the plot or save it to a file\n    new_plot_path = f'/home/chetana/gridmet_test_run/predicted_swe-{test_start_date}.png'\n    print(f\"The new plot is saved to {new_plot_path}\")\n    plt.savefig(new_plot_path)\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\ndef convert_csvs_to_images_simple():\n    selected_date = datetime.strptime(test_start_date, \"%Y-%m-%d\")\n    var_name = \"predicted_swe\"\n    test_csv = \"/home/chetana/gridmet_test_run/test_data_predicted.csv\"\n    result_var_df = pd.read_csv(test_csv)\n    result_var_df.replace('--', pd.NA, inplace=True)\n    result_var_df.dropna(inplace=True)\n    result_var_df[var_name] = pd.to_numeric(result_var_df[var_name], errors='coerce')\n    print(result_var_df.head())\n    #print(gridmet_var_df[\"Latitude\"].describe())\n    #print(gridmet_var_df[\"Longitude\"].describe())\n    print(result_var_df[var_name].describe())\n\n    colormaplist, value_ranges = create_color_maps_with_value_range(result_var_df[var_name], fixed_value_ranges)\n\n    # Create a scatter plot\n    plt.scatter(result_var_df[\"lon\"].values, \n                result_var_df[\"lat\"].values, \n                label='Predicted SWE', \n                #color=colormaplist, \n                c=result_var_df['predicted_swe'], \n                cmap='viridis', \n                s=50, \n                edgecolor='none')\n\n    # Add a colorbar\n    cbar = plt.colorbar()\n    cbar.set_label('Predicted SWE')  # Label for the colorbar\n    \n    # Add labels and a legend\n    plt.xlabel('X-axis')\n    plt.ylabel('Y-axis')\n    plt.title(f'Scatter Plot Example {test_start_date}')\n    plt.legend()\n\n    res_png_path = f\"{work_dir}/testing_output/{str(selected_date.year)}_{var_name}_{test_start_date}.png\"\n    plt.savefig(res_png_path)\n    print(f\"test image is saved at {res_png_path}\")\n    \n#convert_csvs_to_images()\n\nconvert_csvs_to_images_simple()\n",
  "history_output" : "today date = 2023-09-24\ntest start date:  2022-02-22\ntest end date:  2023-09-24\n/home/chetana\n     date   lat      lon  SWE  ...     aspect  eastness  northness  predicted_swe\n69  44612  49.0 -122.516    0  ...   91.84747  0.785138  -0.032228          9.390\n70  44612  49.0 -122.480    0  ...   90.00000  0.785398   0.000000          9.211\n71  44612  49.0 -122.444    0  ...  329.53427 -0.469250   0.711381          9.027\n72  44612  49.0 -122.408    0  ...  270.00000 -0.785398   0.000000          8.953\n73  44612  49.0 -122.372    0  ...   83.99069  0.782643   0.104310          8.954\n[5 rows x 20 columns]\ncount    288650.000000\nmean          9.032466\nstd           1.379009\nmin           1.537000\n25%           9.260000\n50%           9.534000\n75%           9.725000\nmax           9.972000\nName: predicted_swe, dtype: float64\nnew_value_ranges:  [1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 30]\ntest image is saved at /home/chetana/gridmet_test_run/testing_output/2022_predicted_swe_2022-02-22.png\n",
  "history_begin_time" : 1695534569649,
  "history_end_time" : 1695534576081,
  "history_notes" : "this one works and the figure has color bar and can distinguish 2-10",
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "YIhrBaJRp9cL",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport uuid\nfrom snowcast_utils import day_index\nimport matplotlib.colors as mcolors\nfrom matplotlib.patches import Patch\nfrom snowcast_utils import day_index, work_dir, test_start_date\n\n# Define the custom colormap with specified colors and ranges\ncolors = [\n    (0.8627, 0.8627, 0.8627),  # #DCDCDC - 0 - 1\n    (0.8627, 1.0000, 1.0000),  # #DCFFFF - 1 - 2\n    (0.6000, 1.0000, 1.0000),  # #99FFFF - 2 - 4\n    (0.5569, 0.8235, 1.0000),  # #8ED2FF - 4 - 6\n    (0.4509, 0.6196, 0.8745),  # #739EDF - 6 - 8\n    (0.4157, 0.4706, 1.0000),  # #6A78FF - 8 - 10\n    (0.4235, 0.2784, 1.0000),  # #6C47FF - 10 - 12\n    (0.5529, 0.0980, 1.0000),  # #8D19FF - 12 - 14\n    (0.7333, 0.0000, 0.9176),  # #BB00EA - 14 - 16\n    (0.8392, 0.0000, 0.7490),  # #D600BF - 16 - 18\n    (0.7569, 0.0039, 0.4549),  # #C10074 - 18 - 20\n    (0.6784, 0.0000, 0.1961),  # #AD0032 - 20 - 30\n    (0.5020, 0.0000, 0.0000)   # #800000 - > 30\n]\n\ncmap_name = 'custom_snow_colormap'\ncustom_cmap = mcolors.ListedColormap(colors)\n\n# Define the lat_lon_to_map_coordinates function\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\n# Define your value ranges for color mapping\nfixed_value_ranges = [1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 30]\n#value_ranges = [0.1, 0.2, 0.4, 0.6, 0.8, 1.0, 1.2, 1.5, 1.8, 2, 2.5, 3]\n\ndef create_color_maps_with_value_range(df_col, value_ranges=None):\n  new_value_ranges = value_ranges\n  if value_ranges == None:\n    max_value = df_col.max()\n    min_value = df_col.min()\n    if min_value < 0:\n      min_value = 0\n    step_size = (max_value - min_value) / 12\n\n    # Create 10 periods\n    new_value_ranges = [min_value + i * step_size for i in range(12)]\n    \n  print(\"new_value_ranges: \", new_value_ranges)\n  \n  # Define your custom function to map data values to colors\n  def map_value_to_color(value):\n    # Iterate through the value ranges to find the appropriate color index\n    for i, range_max in enumerate(new_value_ranges):\n      if value <= range_max:\n        return colors[i]\n\n      # If the value is greater than the largest range, return the last color\n      return colors[-1]\n\n    # Map predicted_swe values to colors using the custom function\n  color_mapping = [map_value_to_color(value) for value in df_col.values]\n  return color_mapping, new_value_ranges\n\ndef convert_csvs_to_images():\n    global fixed_value_ranges\n    data = pd.read_csv(\"/home/chetana/gridmet_test_run/test_data_predicted.csv\")\n#     print(data.head())\n    print(\"statistic of predicted_swe: \", data['predicted_swe'].describe())\n    data['predicted_swe'].fillna(0, inplace=True)\n    #data['predicted_swe'] = data['predicted_swe'].apply(lambda x: 0 if x < 2 else x)\n    \n    for column in data.columns:\n      column_data = data[column]\n      print(column_data.describe())\n\n#       # Print or process the description as needed\n#       print(f\"Column: {column}\")\n#       print(description)\n    \n    # Create a figure with a white background\n    fig = plt.figure(facecolor='white')\n\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    print(\"data['lon'].values = \", data['lon'].values)\n    x, y = m(data['lon'].values, data['lat'].values)\n#     print(\"x = \", x)\n#     print(\"y = \", y)\n#     print(\"v = \", data['predicted_swe'].values)\n    print(data.columns)\n\n    color_mapping, value_ranges = create_color_maps_with_value_range(data[\"predicted_swe\"], fixed_value_ranges)\n    \n    # Plot the data using the custom colormap\n    plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\n    \n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_date = datetime(1900, 1, 1)\n    day_value = day_index\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    timestamp_string = result_date.strftime(\"%Y-%m-%d\")\n    \n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    # Create custom legend elements using the same colormap\n    legend_elements = [Patch(color=colors[i], label=f\"{value_ranges[i]} - {value_ranges[i+1]-1}\" if i < len(value_ranges) - 1 else f\"> {value_ranges[-1]}\") for i in range(len(value_ranges))]\n\n    # Create the legend outside the map\n    legend = plt.legend(handles=legend_elements, loc='upper left', title='Legend', fontsize=8)\n    legend.set_bbox_to_anchor((1.01, 1)) \n\n    # Remove the color bar\n    #plt.colorbar().remove()\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Set the aspect ratio to 'equal' to keep the plot at the center\n    plt.gca().set_aspect('equal', adjustable='box')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15, right=0.80)  # Adjust right margin to accommodate the legend\n    # Show the plot or save it to a file\n    new_plot_path = f'/home/chetana/gridmet_test_run/predicted_swe-{test_start_date}.png'\n    print(f\"The new plot is saved to {new_plot_path}\")\n    plt.savefig(new_plot_path)\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\ndef convert_csvs_to_images_simple():\n    selected_date = datetime.strptime(test_start_date, \"%Y-%m-%d\")\n    var_name = \"predicted_swe\"\n    test_csv = \"/home/chetana/gridmet_test_run/test_data_predicted.csv\"\n    result_var_df = pd.read_csv(test_csv)\n    result_var_df.replace('--', pd.NA, inplace=True)\n    result_var_df.dropna(inplace=True)\n    result_var_df[var_name] = pd.to_numeric(result_var_df[var_name], errors='coerce')\n    print(result_var_df.head())\n    #print(gridmet_var_df[\"Latitude\"].describe())\n    #print(gridmet_var_df[\"Longitude\"].describe())\n    print(result_var_df[var_name].describe())\n\n    colormaplist, value_ranges = create_color_maps_with_value_range(result_var_df[var_name], fixed_value_ranges)\n\n    # Create a scatter plot\n    plt.scatter(result_var_df[\"lon\"].values, \n                result_var_df[\"lat\"].values, \n                label='Predicted SWE', \n                #color=colormaplist, \n                c=result_var_df['predicted_swe'], \n                cmap='viridis', \n                s=50, \n                edgecolor='none')\n\n    # Add labels and a legend\n    plt.xlabel('X-axis')\n    plt.ylabel('Y-axis')\n    plt.title(f'Scatter Plot Example {test_start_date}')\n    plt.legend()\n\n    res_png_path = f\"{work_dir}/testing_output/{str(selected_date.year)}_{var_name}_{test_start_date}.png\"\n    plt.savefig(res_png_path)\n    print(f\"test image is saved at {res_png_path}\")\n    \n#convert_csvs_to_images()\n\nconvert_csvs_to_images_simple()\n",
  "history_output" : "today date = 2023-09-24\ntest start date:  2022-02-22\ntest end date:  2023-09-24\n/home/chetana\n     date   lat      lon  SWE  ...     aspect  eastness  northness  predicted_swe\n69  44612  49.0 -122.516    0  ...   91.84747  0.785138  -0.032228          9.390\n70  44612  49.0 -122.480    0  ...   90.00000  0.785398   0.000000          9.211\n71  44612  49.0 -122.444    0  ...  329.53427 -0.469250   0.711381          9.027\n72  44612  49.0 -122.408    0  ...  270.00000 -0.785398   0.000000          8.953\n73  44612  49.0 -122.372    0  ...   83.99069  0.782643   0.104310          8.954\n[5 rows x 20 columns]\ncount    288650.000000\nmean          9.032466\nstd           1.379009\nmin           1.537000\n25%           9.260000\n50%           9.534000\n75%           9.725000\nmax           9.972000\nName: predicted_swe, dtype: float64\nnew_value_ranges:  [1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 30]\ntest image is saved at /home/chetana/gridmet_test_run/testing_output/2022_predicted_swe_2022-02-22.png\n",
  "history_begin_time" : 1695534488331,
  "history_end_time" : 1695534494638,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "rFEvcoG3gvIF",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport uuid\nfrom snowcast_utils import day_index\nimport matplotlib.colors as mcolors\nfrom matplotlib.patches import Patch\nfrom snowcast_utils import day_index, work_dir, test_start_date\n\n# Define the custom colormap with specified colors and ranges\ncolors = [\n    (0.8627, 0.8627, 0.8627),  # #DCDCDC - 0 - 1\n    (0.8627, 1.0000, 1.0000),  # #DCFFFF - 1 - 2\n    (0.6000, 1.0000, 1.0000),  # #99FFFF - 2 - 4\n    (0.5569, 0.8235, 1.0000),  # #8ED2FF - 4 - 6\n    (0.4509, 0.6196, 0.8745),  # #739EDF - 6 - 8\n    (0.4157, 0.4706, 1.0000),  # #6A78FF - 8 - 10\n    (0.4235, 0.2784, 1.0000),  # #6C47FF - 10 - 12\n    (0.5529, 0.0980, 1.0000),  # #8D19FF - 12 - 14\n    (0.7333, 0.0000, 0.9176),  # #BB00EA - 14 - 16\n    (0.8392, 0.0000, 0.7490),  # #D600BF - 16 - 18\n    (0.7569, 0.0039, 0.4549),  # #C10074 - 18 - 20\n    (0.6784, 0.0000, 0.1961),  # #AD0032 - 20 - 30\n    (0.5020, 0.0000, 0.0000)   # #800000 - > 30\n]\n\ncmap_name = 'custom_snow_colormap'\ncustom_cmap = mcolors.ListedColormap(colors)\n\n# Define the lat_lon_to_map_coordinates function\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\n# Define your value ranges for color mapping\nfixed_value_ranges = [1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 30]\n#value_ranges = [0.1, 0.2, 0.4, 0.6, 0.8, 1.0, 1.2, 1.5, 1.8, 2, 2.5, 3]\n\ndef create_color_maps_with_value_range(df_col, value_ranges=None):\n  new_value_ranges = value_ranges\n  if value_ranges == None:\n    max_value = df_col.max()\n    min_value = df_col.min()\n    if min_value < 0:\n      min_value = 0\n    step_size = (max_value - min_value) / 12\n\n    # Create 10 periods\n    new_value_ranges = [min_value + i * step_size for i in range(12)]\n    \n  print(\"new_value_ranges: \", new_value_ranges)\n  \n  # Define your custom function to map data values to colors\n  def map_value_to_color(value):\n    # Iterate through the value ranges to find the appropriate color index\n    for i, range_max in enumerate(new_value_ranges):\n      if value <= range_max:\n        return colors[i]\n\n      # If the value is greater than the largest range, return the last color\n      return colors[-1]\n\n    # Map predicted_swe values to colors using the custom function\n  color_mapping = [map_value_to_color(value) for value in df_col.values]\n  return color_mapping, new_value_ranges\n\ndef convert_csvs_to_images():\n    global fixed_value_ranges\n    data = pd.read_csv(\"/home/chetana/gridmet_test_run/test_data_predicted.csv\")\n#     print(data.head())\n    print(\"statistic of predicted_swe: \", data['predicted_swe'].describe())\n    data['predicted_swe'].fillna(0, inplace=True)\n    #data['predicted_swe'] = data['predicted_swe'].apply(lambda x: 0 if x < 2 else x)\n    \n    for column in data.columns:\n      column_data = data[column]\n      print(column_data.describe())\n\n#       # Print or process the description as needed\n#       print(f\"Column: {column}\")\n#       print(description)\n    \n    # Create a figure with a white background\n    fig = plt.figure(facecolor='white')\n\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    print(\"data['lon'].values = \", data['lon'].values)\n    x, y = m(data['lon'].values, data['lat'].values)\n#     print(\"x = \", x)\n#     print(\"y = \", y)\n#     print(\"v = \", data['predicted_swe'].values)\n    print(data.columns)\n\n    color_mapping, value_ranges = create_color_maps_with_value_range(data[\"predicted_swe\"], fixed_value_ranges)\n    \n    # Plot the data using the custom colormap\n    plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\n    \n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_date = datetime(1900, 1, 1)\n    day_value = day_index\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    timestamp_string = result_date.strftime(\"%Y-%m-%d\")\n    \n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    # Create custom legend elements using the same colormap\n    legend_elements = [Patch(color=colors[i], label=f\"{value_ranges[i]} - {value_ranges[i+1]-1}\" if i < len(value_ranges) - 1 else f\"> {value_ranges[-1]}\") for i in range(len(value_ranges))]\n\n    # Create the legend outside the map\n    legend = plt.legend(handles=legend_elements, loc='upper left', title='Legend', fontsize=8)\n    legend.set_bbox_to_anchor((1.01, 1)) \n\n    # Remove the color bar\n    #plt.colorbar().remove()\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Set the aspect ratio to 'equal' to keep the plot at the center\n    plt.gca().set_aspect('equal', adjustable='box')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15, right=0.80)  # Adjust right margin to accommodate the legend\n    # Show the plot or save it to a file\n    new_plot_path = f'/home/chetana/gridmet_test_run/predicted_swe-{test_start_date}.png'\n    print(f\"The new plot is saved to {new_plot_path}\")\n    plt.savefig(new_plot_path)\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\ndef convert_csvs_to_images_simple():\n    selected_date = datetime.strptime(test_start_date, \"%Y-%m-%d\")\n    var_name = \"predicted_swe\"\n    test_csv = \"/home/chetana/gridmet_test_run/test_data_predicted.csv\"\n    result_var_df = pd.read_csv(test_csv)\n    result_var_df.replace('--', pd.NA, inplace=True)\n    result_var_df.dropna(inplace=True)\n    result_var_df[var_name] = pd.to_numeric(result_var_df[var_name], errors='coerce')\n    print(result_var_df.head())\n    #print(gridmet_var_df[\"Latitude\"].describe())\n    #print(gridmet_var_df[\"Longitude\"].describe())\n    print(result_var_df[var_name].describe())\n\n    colormaplist, value_ranges = create_color_maps_with_value_range(result_var_df[var_name], fixed_value_ranges)\n\n    \n\t\n    # Create a Basemap instance (adjust parameters as needed)\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    # Convert lat/lon to map coordinates\n    x, y = m(result_var_df['lon'].values, result_var_df['lat'].values)\n\n    # Create a scatter plot with swe values as color\n    plt.figure(figsize=(10, 8))\n    # Create a scatter plot\n    sc = m.scatter(result_var_df[\"lon\"].values, \n                   result_var_df[\"lat\"].values, \n                   label='Predicted SWE', \n                   #color=colormaplist, \n                   c=result_var_df['predicted_swe'], \n                   cmap='viridis', \n                   s=50, \n                   edgecolor='none')\n\n    # Add a colorbar\n    cbar = plt.colorbar(sc, orientation='vertical')\n    cbar.set_label('SWE (Snow Water Equivalent)')\n\n    # Add map features (coastlines, states, etc.) if needed\n    m.drawcoastlines()\n    m.drawstates()\n\n    # Add a title and show the plot\n    plt.title(f'SWE Map {test_start_date}')\n\n    res_png_path = f\"{work_dir}/testing_output/{str(selected_date.year)}_{var_name}_{test_start_date}.png\"\n    plt.savefig(res_png_path)\n    print(f\"test image is saved at {res_png_path}\")\n    \n#convert_csvs_to_images()\n\nconvert_csvs_to_images_simple()\n",
  "history_output" : "today date = 2023-09-24\ntest start date:  2022-02-22\ntest end date:  2023-09-24\n/home/chetana\n     date   lat      lon  SWE  ...     aspect  eastness  northness  predicted_swe\n69  44612  49.0 -122.516    0  ...   91.84747  0.785138  -0.032228          9.390\n70  44612  49.0 -122.480    0  ...   90.00000  0.785398   0.000000          9.211\n71  44612  49.0 -122.444    0  ...  329.53427 -0.469250   0.711381          9.027\n72  44612  49.0 -122.408    0  ...  270.00000 -0.785398   0.000000          8.953\n73  44612  49.0 -122.372    0  ...   83.99069  0.782643   0.104310          8.954\n[5 rows x 20 columns]\ncount    288650.000000\nmean          9.032466\nstd           1.379009\nmin           1.537000\n25%           9.260000\n50%           9.534000\n75%           9.725000\nmax           9.972000\nName: predicted_swe, dtype: float64\nnew_value_ranges:  [1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 30]\ntest image is saved at /home/chetana/gridmet_test_run/testing_output/2022_predicted_swe_2022-02-22.png\n",
  "history_begin_time" : 1695534406192,
  "history_end_time" : 1695534412499,
  "history_notes" : "good for trouble shooting plot with legend bar for 9 - 9.8 but doesn't work",
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "dVwPeZF2eyQO",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport uuid\nfrom snowcast_utils import day_index\nimport matplotlib.colors as mcolors\nfrom matplotlib.patches import Patch\nfrom snowcast_utils import day_index, work_dir, test_start_date\n\n# Define the custom colormap with specified colors and ranges\ncolors = [\n    (0.8627, 0.8627, 0.8627),  # #DCDCDC - 0 - 1\n    (0.8627, 1.0000, 1.0000),  # #DCFFFF - 1 - 2\n    (0.6000, 1.0000, 1.0000),  # #99FFFF - 2 - 4\n    (0.5569, 0.8235, 1.0000),  # #8ED2FF - 4 - 6\n    (0.4509, 0.6196, 0.8745),  # #739EDF - 6 - 8\n    (0.4157, 0.4706, 1.0000),  # #6A78FF - 8 - 10\n    (0.4235, 0.2784, 1.0000),  # #6C47FF - 10 - 12\n    (0.5529, 0.0980, 1.0000),  # #8D19FF - 12 - 14\n    (0.7333, 0.0000, 0.9176),  # #BB00EA - 14 - 16\n    (0.8392, 0.0000, 0.7490),  # #D600BF - 16 - 18\n    (0.7569, 0.0039, 0.4549),  # #C10074 - 18 - 20\n    (0.6784, 0.0000, 0.1961),  # #AD0032 - 20 - 30\n    (0.5020, 0.0000, 0.0000)   # #800000 - > 30\n]\n\ncmap_name = 'custom_snow_colormap'\ncustom_cmap = mcolors.ListedColormap(colors)\n\n# Define the lat_lon_to_map_coordinates function\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\n# Define your value ranges for color mapping\nfixed_value_ranges = [1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 30]\n#value_ranges = [0.1, 0.2, 0.4, 0.6, 0.8, 1.0, 1.2, 1.5, 1.8, 2, 2.5, 3]\n\ndef create_color_maps_with_value_range(df_col, value_ranges=None):\n  new_value_ranges = value_ranges\n  if value_ranges == None:\n    max_value = df_col.max()\n    min_value = df_col.min()\n    if min_value < 0:\n      min_value = 0\n    step_size = (max_value - min_value) / 12\n\n    # Create 10 periods\n    new_value_ranges = [min_value + i * step_size for i in range(12)]\n    \n  print(\"new_value_ranges: \", new_value_ranges)\n  \n  # Define your custom function to map data values to colors\n  def map_value_to_color(value):\n    # Iterate through the value ranges to find the appropriate color index\n    for i, range_max in enumerate(new_value_ranges):\n      if value <= range_max:\n        return colors[i]\n\n      # If the value is greater than the largest range, return the last color\n      return colors[-1]\n\n    # Map predicted_swe values to colors using the custom function\n  color_mapping = [map_value_to_color(value) for value in df_col.values]\n  return color_mapping, new_value_ranges\n\ndef convert_csvs_to_images():\n    global fixed_value_ranges\n    data = pd.read_csv(\"/home/chetana/gridmet_test_run/test_data_predicted.csv\")\n#     print(data.head())\n    print(\"statistic of predicted_swe: \", data['predicted_swe'].describe())\n    data['predicted_swe'].fillna(0, inplace=True)\n    #data['predicted_swe'] = data['predicted_swe'].apply(lambda x: 0 if x < 2 else x)\n    \n    for column in data.columns:\n      column_data = data[column]\n      print(column_data.describe())\n\n#       # Print or process the description as needed\n#       print(f\"Column: {column}\")\n#       print(description)\n    \n    # Create a figure with a white background\n    fig = plt.figure(facecolor='white')\n\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    print(\"data['lon'].values = \", data['lon'].values)\n    x, y = m(data['lon'].values, data['lat'].values)\n#     print(\"x = \", x)\n#     print(\"y = \", y)\n#     print(\"v = \", data['predicted_swe'].values)\n    print(data.columns)\n\n    color_mapping, value_ranges = create_color_maps_with_value_range(data[\"predicted_swe\"], fixed_value_ranges)\n    \n    # Plot the data using the custom colormap\n    plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\n    \n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_date = datetime(1900, 1, 1)\n    day_value = day_index\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    timestamp_string = result_date.strftime(\"%Y-%m-%d\")\n    \n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    # Create custom legend elements using the same colormap\n    legend_elements = [Patch(color=colors[i], label=f\"{value_ranges[i]} - {value_ranges[i+1]-1}\" if i < len(value_ranges) - 1 else f\"> {value_ranges[-1]}\") for i in range(len(value_ranges))]\n\n    # Create the legend outside the map\n    legend = plt.legend(handles=legend_elements, loc='upper left', title='Legend', fontsize=8)\n    legend.set_bbox_to_anchor((1.01, 1)) \n\n    # Remove the color bar\n    #plt.colorbar().remove()\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Set the aspect ratio to 'equal' to keep the plot at the center\n    plt.gca().set_aspect('equal', adjustable='box')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15, right=0.80)  # Adjust right margin to accommodate the legend\n    # Show the plot or save it to a file\n    new_plot_path = f'/home/chetana/gridmet_test_run/predicted_swe-{test_start_date}.png'\n    print(f\"The new plot is saved to {new_plot_path}\")\n    plt.savefig(new_plot_path)\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\ndef convert_csvs_to_images_simple():\n    selected_date = datetime.strptime(test_start_date, \"%Y-%m-%d\")\n    var_name = \"predicted_swe\"\n    test_csv = \"/home/chetana/gridmet_test_run/test_data_predicted.csv\"\n    result_var_df = pd.read_csv(test_csv)\n    result_var_df.replace('--', pd.NA, inplace=True)\n    result_var_df.dropna(inplace=True)\n    result_var_df[var_name] = pd.to_numeric(result_var_df[var_name], errors='coerce')\n    print(result_var_df.head())\n    #print(gridmet_var_df[\"Latitude\"].describe())\n    #print(gridmet_var_df[\"Longitude\"].describe())\n    print(result_var_df[var_name].describe())\n\n    colormaplist, value_ranges = create_color_maps_with_value_range(result_var_df[var_name], fixed_value_ranges)\n\n    \n\t\n    # Create a Basemap instance (adjust parameters as needed)\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    # Convert lat/lon to map coordinates\n    x, y = m(data['lon'].values, data['lat'].values)\n\n    # Create a scatter plot with swe values as color\n    plt.figure(figsize=(10, 8))\n    # Create a scatter plot\n    sc = m.scatter(result_var_df[\"lon\"].values, \n                   result_var_df[\"lat\"].values, \n                   label='Predicted SWE', \n                   #color=colormaplist, \n                   c=result_var_df['predicted_swe'], \n                   cmap='viridis', \n                   s=50, \n                   edgecolor='none')\n\n    # Add a colorbar\n    cbar = plt.colorbar(sc, orientation='vertical')\n    cbar.set_label('SWE (Snow Water Equivalent)')\n\n    # Add map features (coastlines, states, etc.) if needed\n    m.drawcoastlines()\n    m.drawstates()\n\n    # Add a title and show the plot\n    plt.title(f'SWE Map {test_start_date}')\n\n    res_png_path = f\"{work_dir}/testing_output/{str(selected_date.year)}_{var_name}_{test_start_date}.png\"\n    plt.savefig(res_png_path)\n    print(f\"test image is saved at {res_png_path}\")\n    \n#convert_csvs_to_images()\n\nconvert_csvs_to_images_simple()\n",
  "history_output" : "today date = 2023-09-24\ntest start date:  2022-02-22\ntest end date:  2023-09-24\n/home/chetana\n     date   lat      lon  SWE  ...     aspect  eastness  northness  predicted_swe\n69  44612  49.0 -122.516    0  ...   91.84747  0.785138  -0.032228          9.390\n70  44612  49.0 -122.480    0  ...   90.00000  0.785398   0.000000          9.211\n71  44612  49.0 -122.444    0  ...  329.53427 -0.469250   0.711381          9.027\n72  44612  49.0 -122.408    0  ...  270.00000 -0.785398   0.000000          8.953\n73  44612  49.0 -122.372    0  ...   83.99069  0.782643   0.104310          8.954\n[5 rows x 20 columns]\ncount    288650.000000\nmean          9.032466\nstd           1.379009\nmin           1.537000\n25%           9.260000\n50%           9.534000\n75%           9.725000\nmax           9.972000\nName: predicted_swe, dtype: float64\nnew_value_ranges:  [1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 30]\nTraceback (most recent call last):\n  File \"/home/chetana/gw-workspace/dVwPeZF2eyQO/convert_results_to_images.py\", line 225, in <module>\n    convert_csvs_to_images_simple()\n  File \"/home/chetana/gw-workspace/dVwPeZF2eyQO/convert_results_to_images.py\", line 194, in convert_csvs_to_images_simple\n    x, y = m(data['lon'].values, data['lat'].values)\nNameError: name 'data' is not defined\n",
  "history_begin_time" : 1695534340282,
  "history_end_time" : 1695534344338,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Failed"
},{
  "history_id" : "rpgbYUls1w7c",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport uuid\nfrom snowcast_utils import day_index\nimport matplotlib.colors as mcolors\nfrom matplotlib.patches import Patch\nfrom snowcast_utils import day_index, work_dir, test_start_date\n\n# Define the custom colormap with specified colors and ranges\ncolors = [\n    (0.8627, 0.8627, 0.8627),  # #DCDCDC - 0 - 1\n    (0.8627, 1.0000, 1.0000),  # #DCFFFF - 1 - 2\n    (0.6000, 1.0000, 1.0000),  # #99FFFF - 2 - 4\n    (0.5569, 0.8235, 1.0000),  # #8ED2FF - 4 - 6\n    (0.4509, 0.6196, 0.8745),  # #739EDF - 6 - 8\n    (0.4157, 0.4706, 1.0000),  # #6A78FF - 8 - 10\n    (0.4235, 0.2784, 1.0000),  # #6C47FF - 10 - 12\n    (0.5529, 0.0980, 1.0000),  # #8D19FF - 12 - 14\n    (0.7333, 0.0000, 0.9176),  # #BB00EA - 14 - 16\n    (0.8392, 0.0000, 0.7490),  # #D600BF - 16 - 18\n    (0.7569, 0.0039, 0.4549),  # #C10074 - 18 - 20\n    (0.6784, 0.0000, 0.1961),  # #AD0032 - 20 - 30\n    (0.5020, 0.0000, 0.0000)   # #800000 - > 30\n]\n\ncmap_name = 'custom_snow_colormap'\ncustom_cmap = mcolors.ListedColormap(colors)\n\n# Define the lat_lon_to_map_coordinates function\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\n# Define your value ranges for color mapping\nfixed_value_ranges = [1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 30]\n#value_ranges = [0.1, 0.2, 0.4, 0.6, 0.8, 1.0, 1.2, 1.5, 1.8, 2, 2.5, 3]\n\ndef create_color_maps_with_value_range(df_col, value_ranges=None):\n  new_value_ranges = value_ranges\n  if value_ranges == None:\n    max_value = df_col.max()\n    min_value = df_col.min()\n    if min_value < 0:\n      min_value = 0\n    step_size = (max_value - min_value) / 12\n\n    # Create 10 periods\n    new_value_ranges = [min_value + i * step_size for i in range(12)]\n    \n  print(\"new_value_ranges: \", new_value_ranges)\n  \n  # Define your custom function to map data values to colors\n  def map_value_to_color(value):\n    # Iterate through the value ranges to find the appropriate color index\n    for i, range_max in enumerate(new_value_ranges):\n      if value <= range_max:\n        return colors[i]\n\n      # If the value is greater than the largest range, return the last color\n      return colors[-1]\n\n    # Map predicted_swe values to colors using the custom function\n  color_mapping = [map_value_to_color(value) for value in df_col.values]\n  return color_mapping, new_value_ranges\n\ndef convert_csvs_to_images():\n    global fixed_value_ranges\n    data = pd.read_csv(\"/home/chetana/gridmet_test_run/test_data_predicted.csv\")\n#     print(data.head())\n    print(\"statistic of predicted_swe: \", data['predicted_swe'].describe())\n    data['predicted_swe'].fillna(0, inplace=True)\n    #data['predicted_swe'] = data['predicted_swe'].apply(lambda x: 0 if x < 2 else x)\n    \n    for column in data.columns:\n      column_data = data[column]\n      print(column_data.describe())\n\n#       # Print or process the description as needed\n#       print(f\"Column: {column}\")\n#       print(description)\n    \n    # Create a figure with a white background\n    fig = plt.figure(facecolor='white')\n\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    print(\"data['lon'].values = \", data['lon'].values)\n    x, y = m(data['lon'].values, data['lat'].values)\n#     print(\"x = \", x)\n#     print(\"y = \", y)\n#     print(\"v = \", data['predicted_swe'].values)\n    print(data.columns)\n\n    color_mapping, value_ranges = create_color_maps_with_value_range(data[\"predicted_swe\"], fixed_value_ranges)\n    \n    # Plot the data using the custom colormap\n    plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\n    \n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_date = datetime(1900, 1, 1)\n    day_value = day_index\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    timestamp_string = result_date.strftime(\"%Y-%m-%d\")\n    \n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    # Create custom legend elements using the same colormap\n    legend_elements = [Patch(color=colors[i], label=f\"{value_ranges[i]} - {value_ranges[i+1]-1}\" if i < len(value_ranges) - 1 else f\"> {value_ranges[-1]}\") for i in range(len(value_ranges))]\n\n    # Create the legend outside the map\n    legend = plt.legend(handles=legend_elements, loc='upper left', title='Legend', fontsize=8)\n    legend.set_bbox_to_anchor((1.01, 1)) \n\n    # Remove the color bar\n    #plt.colorbar().remove()\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Set the aspect ratio to 'equal' to keep the plot at the center\n    plt.gca().set_aspect('equal', adjustable='box')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15, right=0.80)  # Adjust right margin to accommodate the legend\n    # Show the plot or save it to a file\n    new_plot_path = f'/home/chetana/gridmet_test_run/predicted_swe-{test_start_date}.png'\n    print(f\"The new plot is saved to {new_plot_path}\")\n    plt.savefig(new_plot_path)\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\ndef convert_csvs_to_images_simple():\n    selected_date = datetime.strptime(test_start_date, \"%Y-%m-%d\")\n    var_name = \"predicted_swe\"\n    test_csv = \"/home/chetana/gridmet_test_run/test_data_predicted.csv\"\n    result_var_df = pd.read_csv(test_csv)\n    result_var_df.replace('--', pd.NA, inplace=True)\n    result_var_df.dropna(inplace=True)\n    result_var_df[var_name] = pd.to_numeric(result_var_df[var_name], errors='coerce')\n    print(result_var_df.head())\n    #print(gridmet_var_df[\"Latitude\"].describe())\n    #print(gridmet_var_df[\"Longitude\"].describe())\n    print(result_var_df[var_name].describe())\n\n    colormaplist, value_ranges = create_color_maps_with_value_range(result_var_df[var_name], fixed_value_ranges)\n\n    # Create a scatter plot\n    plt.scatter(result_var_df[\"lon\"].values, \n                result_var_df[\"lat\"].values, \n                label='Predicted SWE', \n                #color=colormaplist, \n                c=result_var_df['predicted_swe'], \n                cmap='viridis', \n                s=50, \n                edgecolor='none')\n\n    # Add labels and a legend\n    plt.xlabel('X-axis')\n    plt.ylabel('Y-axis')\n    plt.title(f'Scatter Plot Example {test_start_date}')\n    plt.legend()\n\n    res_png_path = f\"{work_dir}/testing_output/{str(selected_date.year)}_{var_name}_{test_start_date}.png\"\n    plt.savefig(res_png_path)\n    print(f\"test image is saved at {res_png_path}\")\n    \n#convert_csvs_to_images()\n\nconvert_csvs_to_images_simple()\n",
  "history_output" : "today date = 2023-09-24\ntest start date:  2022-02-22\ntest end date:  2023-09-24\n/home/chetana\n     date   lat      lon  SWE  ...     aspect  eastness  northness  predicted_swe\n69  44612  49.0 -122.516    0  ...   91.84747  0.785138  -0.032228          9.390\n70  44612  49.0 -122.480    0  ...   90.00000  0.785398   0.000000          9.211\n71  44612  49.0 -122.444    0  ...  329.53427 -0.469250   0.711381          9.027\n72  44612  49.0 -122.408    0  ...  270.00000 -0.785398   0.000000          8.953\n73  44612  49.0 -122.372    0  ...   83.99069  0.782643   0.104310          8.954\n[5 rows x 20 columns]\ncount    288650.000000\nmean          9.032466\nstd           1.379009\nmin           1.537000\n25%           9.260000\n50%           9.534000\n75%           9.725000\nmax           9.972000\nName: predicted_swe, dtype: float64\nnew_value_ranges:  [1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 30]\ntest image is saved at /home/chetana/gridmet_test_run/testing_output/2022_predicted_swe_2022-02-22.png\n",
  "history_begin_time" : 1695534143371,
  "history_end_time" : 1695534149778,
  "history_notes" : "very simple plotting works for 9-9.8",
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "vf6Y6Hx0t127",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport uuid\nfrom snowcast_utils import day_index\nimport matplotlib.colors as mcolors\nfrom matplotlib.patches import Patch\nfrom snowcast_utils import day_index, work_dir, test_start_date\n\n# Define the custom colormap with specified colors and ranges\ncolors = [\n    (0.8627, 0.8627, 0.8627),  # #DCDCDC - 0 - 1\n    (0.8627, 1.0000, 1.0000),  # #DCFFFF - 1 - 2\n    (0.6000, 1.0000, 1.0000),  # #99FFFF - 2 - 4\n    (0.5569, 0.8235, 1.0000),  # #8ED2FF - 4 - 6\n    (0.4509, 0.6196, 0.8745),  # #739EDF - 6 - 8\n    (0.4157, 0.4706, 1.0000),  # #6A78FF - 8 - 10\n    (0.4235, 0.2784, 1.0000),  # #6C47FF - 10 - 12\n    (0.5529, 0.0980, 1.0000),  # #8D19FF - 12 - 14\n    (0.7333, 0.0000, 0.9176),  # #BB00EA - 14 - 16\n    (0.8392, 0.0000, 0.7490),  # #D600BF - 16 - 18\n    (0.7569, 0.0039, 0.4549),  # #C10074 - 18 - 20\n    (0.6784, 0.0000, 0.1961),  # #AD0032 - 20 - 30\n    (0.5020, 0.0000, 0.0000)   # #800000 - > 30\n]\n\ncmap_name = 'custom_snow_colormap'\ncustom_cmap = mcolors.ListedColormap(colors)\n\n# Define the lat_lon_to_map_coordinates function\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\n# Define your value ranges for color mapping\nfixed_value_ranges = [1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 30]\n#value_ranges = [0.1, 0.2, 0.4, 0.6, 0.8, 1.0, 1.2, 1.5, 1.8, 2, 2.5, 3]\n\ndef create_color_maps_with_value_range(df_col, value_ranges=None):\n  new_value_ranges = value_ranges\n  if value_ranges == None:\n    max_value = df_col.max()\n    min_value = df_col.min()\n    if min_value < 0:\n      min_value = 0\n    step_size = (max_value - min_value) / 12\n\n    # Create 10 periods\n    new_value_ranges = [min_value + i * step_size for i in range(12)]\n    \n  print(\"new_value_ranges: \", new_value_ranges)\n  \n  # Define your custom function to map data values to colors\n  def map_value_to_color(value):\n    # Iterate through the value ranges to find the appropriate color index\n    for i, range_max in enumerate(new_value_ranges):\n      if value <= range_max:\n        return colors[i]\n\n      # If the value is greater than the largest range, return the last color\n      return colors[-1]\n\n    # Map predicted_swe values to colors using the custom function\n  color_mapping = [map_value_to_color(value) for value in df_col.values]\n  return color_mapping, new_value_ranges\n\ndef convert_csvs_to_images():\n    global fixed_value_ranges\n    data = pd.read_csv(\"/home/chetana/gridmet_test_run/test_data_predicted.csv\")\n#     print(data.head())\n    print(\"statistic of predicted_swe: \", data['predicted_swe'].describe())\n    data['predicted_swe'].fillna(0, inplace=True)\n    #data['predicted_swe'] = data['predicted_swe'].apply(lambda x: 0 if x < 2 else x)\n    \n    for column in data.columns:\n      column_data = data[column]\n      print(column_data.describe())\n\n#       # Print or process the description as needed\n#       print(f\"Column: {column}\")\n#       print(description)\n    \n    # Create a figure with a white background\n    fig = plt.figure(facecolor='white')\n\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    print(\"data['lon'].values = \", data['lon'].values)\n    x, y = m(data['lon'].values, data['lat'].values)\n#     print(\"x = \", x)\n#     print(\"y = \", y)\n#     print(\"v = \", data['predicted_swe'].values)\n    print(data.columns)\n\n    color_mapping, value_ranges = create_color_maps_with_value_range(data[\"predicted_swe\"], fixed_value_ranges)\n    \n    # Plot the data using the custom colormap\n    plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\n    \n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_date = datetime(1900, 1, 1)\n    day_value = day_index\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    timestamp_string = result_date.strftime(\"%Y-%m-%d\")\n    \n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    # Create custom legend elements using the same colormap\n    legend_elements = [Patch(color=colors[i], label=f\"{value_ranges[i]} - {value_ranges[i+1]-1}\" if i < len(value_ranges) - 1 else f\"> {value_ranges[-1]}\") for i in range(len(value_ranges))]\n\n    # Create the legend outside the map\n    legend = plt.legend(handles=legend_elements, loc='upper left', title='Legend', fontsize=8)\n    legend.set_bbox_to_anchor((1.01, 1)) \n\n    # Remove the color bar\n    #plt.colorbar().remove()\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Set the aspect ratio to 'equal' to keep the plot at the center\n    plt.gca().set_aspect('equal', adjustable='box')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15, right=0.80)  # Adjust right margin to accommodate the legend\n    # Show the plot or save it to a file\n    new_plot_path = f'/home/chetana/gridmet_test_run/predicted_swe-{test_start_date}.png'\n    print(f\"The new plot is saved to {new_plot_path}\")\n    plt.savefig(new_plot_path)\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\ndef convert_csvs_to_images_simple():\n    selected_date = datetime.strptime(test_start_date, \"%Y-%m-%d\")\n    var_name = \"predicted_swe\"\n    test_csv = \"/home/chetana/gridmet_test_run/test_data_predicted.csv\"\n    result_var_df = pd.read_csv(test_csv)\n    result_var_df.replace('--', pd.NA, inplace=True)\n    result_var_df.dropna(inplace=True)\n    result_var_df[var_name] = pd.to_numeric(result_var_df[var_name], errors='coerce')\n    print(result_var_df.head())\n    #print(gridmet_var_df[\"Latitude\"].describe())\n    #print(gridmet_var_df[\"Longitude\"].describe())\n    print(result_var_df[var_name].describe())\n\n    colormaplist, value_ranges = create_color_maps_with_value_range(result_var_df[var_name], fixed_value_ranges)\n\n    # Create a scatter plot\n    plt.scatter(result_var_df[\"lon\"].values, \n                result_var_df[\"lat\"].values, \n                label='Predicted SWE', \n                #color=colormaplist, \n                c=result_var_df['predicted_swe'], \n                cmap='viridis', \n                s=50, \n                edgecolor='none',\n                marker='o')\n\n    # Add labels and a legend\n    plt.xlabel('X-axis')\n    plt.ylabel('Y-axis')\n    plt.title(f'Scatter Plot Example {test_start_date}')\n    plt.legend()\n\n    res_png_path = f\"{work_dir}/testing_output/{str(selected_date.year)}_{var_name}_{test_start_date}.png\"\n    plt.savefig(res_png_path)\n    print(f\"test image is saved at {res_png_path}\")\n    \n#convert_csvs_to_images()\n\nconvert_csvs_to_images_simple()\n",
  "history_output" : "today date = 2023-09-24\ntest start date:  2022-02-22\ntest end date:  2023-09-24\n/home/chetana\n     date   lat      lon  SWE  ...     aspect  eastness  northness  predicted_swe\n69  44612  49.0 -122.516    0  ...   91.84747  0.785138  -0.032228          9.390\n70  44612  49.0 -122.480    0  ...   90.00000  0.785398   0.000000          9.211\n71  44612  49.0 -122.444    0  ...  329.53427 -0.469250   0.711381          9.027\n72  44612  49.0 -122.408    0  ...  270.00000 -0.785398   0.000000          8.953\n73  44612  49.0 -122.372    0  ...   83.99069  0.782643   0.104310          8.954\n[5 rows x 20 columns]\ncount    288650.000000\nmean          9.032466\nstd           1.379009\nmin           1.537000\n25%           9.260000\n50%           9.534000\n75%           9.725000\nmax           9.972000\nName: predicted_swe, dtype: float64\nnew_value_ranges:  [1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 30]\ntest image is saved at /home/chetana/gridmet_test_run/testing_output/2022_predicted_swe_2022-02-22.png\n",
  "history_begin_time" : 1695534054314,
  "history_end_time" : 1695534060578,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "q5ORmRzSiPz8",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport uuid\nfrom snowcast_utils import day_index\nimport matplotlib.colors as mcolors\nfrom matplotlib.patches import Patch\nfrom snowcast_utils import day_index, work_dir, test_start_date\n\n# Define the custom colormap with specified colors and ranges\ncolors = [\n    (0.8627, 0.8627, 0.8627),  # #DCDCDC - 0 - 1\n    (0.8627, 1.0000, 1.0000),  # #DCFFFF - 1 - 2\n    (0.6000, 1.0000, 1.0000),  # #99FFFF - 2 - 4\n    (0.5569, 0.8235, 1.0000),  # #8ED2FF - 4 - 6\n    (0.4509, 0.6196, 0.8745),  # #739EDF - 6 - 8\n    (0.4157, 0.4706, 1.0000),  # #6A78FF - 8 - 10\n    (0.4235, 0.2784, 1.0000),  # #6C47FF - 10 - 12\n    (0.5529, 0.0980, 1.0000),  # #8D19FF - 12 - 14\n    (0.7333, 0.0000, 0.9176),  # #BB00EA - 14 - 16\n    (0.8392, 0.0000, 0.7490),  # #D600BF - 16 - 18\n    (0.7569, 0.0039, 0.4549),  # #C10074 - 18 - 20\n    (0.6784, 0.0000, 0.1961),  # #AD0032 - 20 - 30\n    (0.5020, 0.0000, 0.0000)   # #800000 - > 30\n]\n\ncmap_name = 'custom_snow_colormap'\ncustom_cmap = mcolors.ListedColormap(colors)\n\n# Define the lat_lon_to_map_coordinates function\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\n# Define your value ranges for color mapping\nfixed_value_ranges = [1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 30]\n#value_ranges = [0.1, 0.2, 0.4, 0.6, 0.8, 1.0, 1.2, 1.5, 1.8, 2, 2.5, 3]\n\ndef create_color_maps_with_value_range(df_col, value_ranges=None):\n  new_value_ranges = value_ranges\n  if value_ranges == None:\n    max_value = df_col.max()\n    min_value = df_col.min()\n    if min_value < 0:\n      min_value = 0\n    step_size = (max_value - min_value) / 12\n\n    # Create 10 periods\n    new_value_ranges = [min_value + i * step_size for i in range(12)]\n    \n  print(\"new_value_ranges: \", new_value_ranges)\n  \n  # Define your custom function to map data values to colors\n  def map_value_to_color(value):\n    # Iterate through the value ranges to find the appropriate color index\n    for i, range_max in enumerate(new_value_ranges):\n      if value <= range_max:\n        return colors[i]\n\n      # If the value is greater than the largest range, return the last color\n      return colors[-1]\n\n    # Map predicted_swe values to colors using the custom function\n  color_mapping = [map_value_to_color(value) for value in df_col.values]\n  return color_mapping, new_value_ranges\n\ndef convert_csvs_to_images():\n    global fixed_value_ranges\n    data = pd.read_csv(\"/home/chetana/gridmet_test_run/test_data_predicted.csv\")\n#     print(data.head())\n    print(\"statistic of predicted_swe: \", data['predicted_swe'].describe())\n    data['predicted_swe'].fillna(0, inplace=True)\n    #data['predicted_swe'] = data['predicted_swe'].apply(lambda x: 0 if x < 2 else x)\n    \n    for column in data.columns:\n      column_data = data[column]\n      print(column_data.describe())\n\n#       # Print or process the description as needed\n#       print(f\"Column: {column}\")\n#       print(description)\n    \n    # Create a figure with a white background\n    fig = plt.figure(facecolor='white')\n\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    print(\"data['lon'].values = \", data['lon'].values)\n    x, y = m(data['lon'].values, data['lat'].values)\n#     print(\"x = \", x)\n#     print(\"y = \", y)\n#     print(\"v = \", data['predicted_swe'].values)\n    print(data.columns)\n\n    color_mapping, value_ranges = create_color_maps_with_value_range(data[\"predicted_swe\"], fixed_value_ranges)\n    \n    # Plot the data using the custom colormap\n    plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\n    \n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_date = datetime(1900, 1, 1)\n    day_value = day_index\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    timestamp_string = result_date.strftime(\"%Y-%m-%d\")\n    \n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    # Create custom legend elements using the same colormap\n    legend_elements = [Patch(color=colors[i], label=f\"{value_ranges[i]} - {value_ranges[i+1]-1}\" if i < len(value_ranges) - 1 else f\"> {value_ranges[-1]}\") for i in range(len(value_ranges))]\n\n    # Create the legend outside the map\n    legend = plt.legend(handles=legend_elements, loc='upper left', title='Legend', fontsize=8)\n    legend.set_bbox_to_anchor((1.01, 1)) \n\n    # Remove the color bar\n    #plt.colorbar().remove()\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Set the aspect ratio to 'equal' to keep the plot at the center\n    plt.gca().set_aspect('equal', adjustable='box')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15, right=0.80)  # Adjust right margin to accommodate the legend\n    # Show the plot or save it to a file\n    new_plot_path = f'/home/chetana/gridmet_test_run/predicted_swe-{test_start_date}.png'\n    print(f\"The new plot is saved to {new_plot_path}\")\n    plt.savefig(new_plot_path)\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\ndef convert_csvs_to_images_simple():\n    selected_date = datetime.strptime(test_start_date, \"%Y-%m-%d\")\n    var_name = \"predicted_swe\"\n    test_csv = \"/home/chetana/gridmet_test_run/test_data_predicted.csv\"\n    result_var_df = pd.read_csv(test_csv)\n    result_var_df.replace('--', pd.NA, inplace=True)\n    result_var_df.dropna(inplace=True)\n    result_var_df[var_name] = pd.to_numeric(result_var_df[var_name], errors='coerce')\n    print(result_var_df.head())\n    #print(gridmet_var_df[\"Latitude\"].describe())\n    #print(gridmet_var_df[\"Longitude\"].describe())\n    print(result_var_df[var_name].describe())\n\n    colormaplist, value_ranges = create_color_maps_with_value_range(result_var_df[var_name], fixed_value_ranges)\n\n    # Create a scatter plot\n    plt.scatter(result_var_df[\"lon\"].values, \n                result_var_df[\"lat\"].values, \n                label='Predicted SWE', \n                #color=colormaplist, \n                c=result_var_df['predicted_swe'], \n                cmap='viridis', \n                s=50, \n                edgecolor='none',\n                marker='o')\n\n    # Add labels and a legend\n    plt.xlabel('X-axis')\n    plt.ylabel('Y-axis')\n    plt.title('Scatter Plot Example')\n    plt.legend()\n\n    res_png_path = f\"{work_dir}/testing_output/{str(selected_date.year)}_{var_name}_{test_start_date}.png\"\n    plt.savefig(res_png_path)\n    print(f\"test image is saved at {res_png_path}\")\n    \n#convert_csvs_to_images()\n\nconvert_csvs_to_images_simple()\n",
  "history_output" : "today date = 2023-09-24\ntest start date:  2022-02-22\ntest end date:  2023-09-24\n/home/chetana\n     date   lat      lon  SWE  ...     aspect  eastness  northness  predicted_swe\n69  44612  49.0 -122.516    0  ...   91.84747  0.785138  -0.032228          9.390\n70  44612  49.0 -122.480    0  ...   90.00000  0.785398   0.000000          9.211\n71  44612  49.0 -122.444    0  ...  329.53427 -0.469250   0.711381          9.027\n72  44612  49.0 -122.408    0  ...  270.00000 -0.785398   0.000000          8.953\n73  44612  49.0 -122.372    0  ...   83.99069  0.782643   0.104310          8.954\n[5 rows x 20 columns]\ncount    288650.000000\nmean          9.032466\nstd           1.379009\nmin           1.537000\n25%           9.260000\n50%           9.534000\n75%           9.725000\nmax           9.972000\nName: predicted_swe, dtype: float64\nnew_value_ranges:  [1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 30]\ntest image is saved at /home/chetana/gridmet_test_run/testing_output/2022_predicted_swe_2022-02-22.png\n",
  "history_begin_time" : 1695533944327,
  "history_end_time" : 1695533950509,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "JwMMm03ahWlx",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport uuid\nfrom snowcast_utils import day_index\nimport matplotlib.colors as mcolors\nfrom matplotlib.patches import Patch\nfrom snowcast_utils import day_index, work_dir, test_start_date\n\n# Define the custom colormap with specified colors and ranges\ncolors = [\n    (0.8627, 0.8627, 0.8627),  # #DCDCDC - 0 - 1\n    (0.8627, 1.0000, 1.0000),  # #DCFFFF - 1 - 2\n    (0.6000, 1.0000, 1.0000),  # #99FFFF - 2 - 4\n    (0.5569, 0.8235, 1.0000),  # #8ED2FF - 4 - 6\n    (0.4509, 0.6196, 0.8745),  # #739EDF - 6 - 8\n    (0.4157, 0.4706, 1.0000),  # #6A78FF - 8 - 10\n    (0.4235, 0.2784, 1.0000),  # #6C47FF - 10 - 12\n    (0.5529, 0.0980, 1.0000),  # #8D19FF - 12 - 14\n    (0.7333, 0.0000, 0.9176),  # #BB00EA - 14 - 16\n    (0.8392, 0.0000, 0.7490),  # #D600BF - 16 - 18\n    (0.7569, 0.0039, 0.4549),  # #C10074 - 18 - 20\n    (0.6784, 0.0000, 0.1961),  # #AD0032 - 20 - 30\n    (0.5020, 0.0000, 0.0000)   # #800000 - > 30\n]\n\ncmap_name = 'custom_snow_colormap'\ncustom_cmap = mcolors.ListedColormap(colors)\n\n# Define the lat_lon_to_map_coordinates function\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\n# Define your value ranges for color mapping\nfixed_value_ranges = [1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 30]\n#value_ranges = [0.1, 0.2, 0.4, 0.6, 0.8, 1.0, 1.2, 1.5, 1.8, 2, 2.5, 3]\n\ndef create_color_maps_with_value_range(df_col, value_ranges=None):\n  new_value_ranges = value_ranges\n  if value_ranges == None:\n    max_value = df_col.max()\n    min_value = df_col.min()\n    if min_value < 0:\n      min_value = 0\n    step_size = (max_value - min_value) / 12\n\n    # Create 10 periods\n    new_value_ranges = [min_value + i * step_size for i in range(12)]\n    \n  print(\"new_value_ranges: \", new_value_ranges)\n  \n  # Define your custom function to map data values to colors\n  def map_value_to_color(value):\n    # Iterate through the value ranges to find the appropriate color index\n    for i, range_max in enumerate(new_value_ranges):\n      if value <= range_max:\n        return colors[i]\n\n      # If the value is greater than the largest range, return the last color\n      return colors[-1]\n\n    # Map predicted_swe values to colors using the custom function\n  color_mapping = [map_value_to_color(value) for value in df_col.values]\n  return color_mapping, new_value_ranges\n\ndef convert_csvs_to_images():\n    global fixed_value_ranges\n    data = pd.read_csv(\"/home/chetana/gridmet_test_run/test_data_predicted.csv\")\n#     print(data.head())\n    print(\"statistic of predicted_swe: \", data['predicted_swe'].describe())\n    data['predicted_swe'].fillna(0, inplace=True)\n    #data['predicted_swe'] = data['predicted_swe'].apply(lambda x: 0 if x < 2 else x)\n    \n    for column in data.columns:\n      column_data = data[column]\n      print(column_data.describe())\n\n#       # Print or process the description as needed\n#       print(f\"Column: {column}\")\n#       print(description)\n    \n    # Create a figure with a white background\n    fig = plt.figure(facecolor='white')\n\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    print(\"data['lon'].values = \", data['lon'].values)\n    x, y = m(data['lon'].values, data['lat'].values)\n#     print(\"x = \", x)\n#     print(\"y = \", y)\n#     print(\"v = \", data['predicted_swe'].values)\n    print(data.columns)\n\n    color_mapping, value_ranges = create_color_maps_with_value_range(data[\"predicted_swe\"], fixed_value_ranges)\n    \n    # Plot the data using the custom colormap\n    plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\n    \n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_date = datetime(1900, 1, 1)\n    day_value = day_index\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    timestamp_string = result_date.strftime(\"%Y-%m-%d\")\n    \n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    # Create custom legend elements using the same colormap\n    legend_elements = [Patch(color=colors[i], label=f\"{value_ranges[i]} - {value_ranges[i+1]-1}\" if i < len(value_ranges) - 1 else f\"> {value_ranges[-1]}\") for i in range(len(value_ranges))]\n\n    # Create the legend outside the map\n    legend = plt.legend(handles=legend_elements, loc='upper left', title='Legend', fontsize=8)\n    legend.set_bbox_to_anchor((1.01, 1)) \n\n    # Remove the color bar\n    #plt.colorbar().remove()\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Set the aspect ratio to 'equal' to keep the plot at the center\n    plt.gca().set_aspect('equal', adjustable='box')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15, right=0.80)  # Adjust right margin to accommodate the legend\n    # Show the plot or save it to a file\n    new_plot_path = f'/home/chetana/gridmet_test_run/predicted_swe-{test_start_date}.png'\n    print(f\"The new plot is saved to {new_plot_path}\")\n    plt.savefig(new_plot_path)\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\ndef convert_csvs_to_images_simple():\n    selected_date = datetime.strptime(test_start_date, \"%Y-%m-%d\")\n    var_name = \"predicted_swe\"\n    test_csv = \"/home/chetana/gridmet_test_run/test_data_predicted.csv\"\n    result_var_df = pd.read_csv(test_csv)\n    result_var_df.replace('--', pd.NA, inplace=True)\n    result_var_df.dropna(inplace=True)\n    result_var_df[var_name] = pd.to_numeric(result_var_df[var_name], errors='coerce')\n    print(result_var_df.head())\n    #print(gridmet_var_df[\"Latitude\"].describe())\n    #print(gridmet_var_df[\"Longitude\"].describe())\n    print(result_var_df[var_name].describe())\n\n    colormaplist, value_ranges = create_color_maps_with_value_range(result_var_df[var_name], fixed_value_ranges)\n\n    # Create a scatter plot\n    plt.scatter(result_var_df[\"lon\"].values, \n                result_var_df[\"lat\"].values, \n                label='Predicted SWE', \n                #color=colormaplist, \n                c=result_var_df['predicted_swe'], \n                cmap='viridis', \n                s=50, \n                edgecolor='none'\n                marker='o')\n\n    # Add labels and a legend\n    plt.xlabel('X-axis')\n    plt.ylabel('Y-axis')\n    plt.title('Scatter Plot Example')\n    plt.legend()\n\n    res_png_path = f\"{work_dir}/testing_output/{str(selected_date.year)}_{var_name}_{test_start_date}.png\"\n    plt.savefig(res_png_path)\n    print(f\"test image is saved at {res_png_path}\")\n    \n#convert_csvs_to_images()\n\nconvert_csvs_to_images_simple()\n",
  "history_output" : "  File \"/home/chetana/gw-workspace/JwMMm03ahWlx/convert_results_to_images.py\", line 193\n    marker='o')\n    ^\nSyntaxError: invalid syntax\n",
  "history_begin_time" : 1695533935477,
  "history_end_time" : 1695533935532,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Failed"
},{
  "history_id" : "gGOfAQMqFbun",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport uuid\nfrom snowcast_utils import day_index\nimport matplotlib.colors as mcolors\nfrom matplotlib.patches import Patch\nfrom snowcast_utils import day_index, work_dir, test_start_date\n\n# Define the custom colormap with specified colors and ranges\ncolors = [\n    (0.8627, 0.8627, 0.8627),  # #DCDCDC - 0 - 1\n    (0.8627, 1.0000, 1.0000),  # #DCFFFF - 1 - 2\n    (0.6000, 1.0000, 1.0000),  # #99FFFF - 2 - 4\n    (0.5569, 0.8235, 1.0000),  # #8ED2FF - 4 - 6\n    (0.4509, 0.6196, 0.8745),  # #739EDF - 6 - 8\n    (0.4157, 0.4706, 1.0000),  # #6A78FF - 8 - 10\n    (0.4235, 0.2784, 1.0000),  # #6C47FF - 10 - 12\n    (0.5529, 0.0980, 1.0000),  # #8D19FF - 12 - 14\n    (0.7333, 0.0000, 0.9176),  # #BB00EA - 14 - 16\n    (0.8392, 0.0000, 0.7490),  # #D600BF - 16 - 18\n    (0.7569, 0.0039, 0.4549),  # #C10074 - 18 - 20\n    (0.6784, 0.0000, 0.1961),  # #AD0032 - 20 - 30\n    (0.5020, 0.0000, 0.0000)   # #800000 - > 30\n]\n\ncmap_name = 'custom_snow_colormap'\ncustom_cmap = mcolors.ListedColormap(colors)\n\n# Define the lat_lon_to_map_coordinates function\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\n# Define your value ranges for color mapping\nfixed_value_ranges = [1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 30]\n#value_ranges = [0.1, 0.2, 0.4, 0.6, 0.8, 1.0, 1.2, 1.5, 1.8, 2, 2.5, 3]\n\ndef create_color_maps_with_value_range(df_col, value_ranges=None):\n  new_value_ranges = value_ranges\n  if value_ranges == None:\n    max_value = df_col.max()\n    min_value = df_col.min()\n    if min_value < 0:\n      min_value = 0\n    step_size = (max_value - min_value) / 12\n\n    # Create 10 periods\n    new_value_ranges = [min_value + i * step_size for i in range(12)]\n    \n  print(\"new_value_ranges: \", new_value_ranges)\n  \n  # Define your custom function to map data values to colors\n  def map_value_to_color(value):\n    # Iterate through the value ranges to find the appropriate color index\n    for i, range_max in enumerate(new_value_ranges):\n      if value <= range_max:\n        return colors[i]\n\n      # If the value is greater than the largest range, return the last color\n      return colors[-1]\n\n    # Map predicted_swe values to colors using the custom function\n  color_mapping = [map_value_to_color(value) for value in df_col.values]\n  return color_mapping, new_value_ranges\n\ndef convert_csvs_to_images():\n    global fixed_value_ranges\n    data = pd.read_csv(\"/home/chetana/gridmet_test_run/test_data_predicted.csv\")\n#     print(data.head())\n    print(\"statistic of predicted_swe: \", data['predicted_swe'].describe())\n    data['predicted_swe'].fillna(0, inplace=True)\n    #data['predicted_swe'] = data['predicted_swe'].apply(lambda x: 0 if x < 2 else x)\n    \n    for column in data.columns:\n      column_data = data[column]\n      print(column_data.describe())\n\n#       # Print or process the description as needed\n#       print(f\"Column: {column}\")\n#       print(description)\n    \n    # Create a figure with a white background\n    fig = plt.figure(facecolor='white')\n\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    print(\"data['lon'].values = \", data['lon'].values)\n    x, y = m(data['lon'].values, data['lat'].values)\n#     print(\"x = \", x)\n#     print(\"y = \", y)\n#     print(\"v = \", data['predicted_swe'].values)\n    print(data.columns)\n\n    color_mapping, value_ranges = create_color_maps_with_value_range(data[\"predicted_swe\"], fixed_value_ranges)\n    \n    # Plot the data using the custom colormap\n    plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\n    \n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_date = datetime(1900, 1, 1)\n    day_value = day_index\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    timestamp_string = result_date.strftime(\"%Y-%m-%d\")\n    \n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    # Create custom legend elements using the same colormap\n    legend_elements = [Patch(color=colors[i], label=f\"{value_ranges[i]} - {value_ranges[i+1]-1}\" if i < len(value_ranges) - 1 else f\"> {value_ranges[-1]}\") for i in range(len(value_ranges))]\n\n    # Create the legend outside the map\n    legend = plt.legend(handles=legend_elements, loc='upper left', title='Legend', fontsize=8)\n    legend.set_bbox_to_anchor((1.01, 1)) \n\n    # Remove the color bar\n    #plt.colorbar().remove()\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Set the aspect ratio to 'equal' to keep the plot at the center\n    plt.gca().set_aspect('equal', adjustable='box')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15, right=0.80)  # Adjust right margin to accommodate the legend\n    # Show the plot or save it to a file\n    new_plot_path = f'/home/chetana/gridmet_test_run/predicted_swe-{test_start_date}.png'\n    print(f\"The new plot is saved to {new_plot_path}\")\n    plt.savefig(new_plot_path)\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\ndef convert_csvs_to_images_simple():\n    selected_date = datetime.strptime(test_start_date, \"%Y-%m-%d\")\n    var_name = \"predicted_swe\"\n    test_csv = \"/home/chetana/gridmet_test_run/test_data_predicted.csv\"\n    result_var_df = pd.read_csv(test_csv)\n    result_var_df.replace('--', pd.NA, inplace=True)\n    result_var_df.dropna(inplace=True)\n    result_var_df[var_name] = pd.to_numeric(result_var_df[var_name], errors='coerce')\n    print(result_var_df.head())\n    #print(gridmet_var_df[\"Latitude\"].describe())\n    #print(gridmet_var_df[\"Longitude\"].describe())\n    print(result_var_df[var_name].describe())\n\n    colormaplist, value_ranges = create_color_maps_with_value_range(result_var_df[var_name], fixed_value_ranges)\n\n    # Create a scatter plot\n    plt.scatter(result_var_df[\"lon\"].values, \n                result_var_df[\"lat\"].values, \n                label='Predicted SWE', \n                color=colormaplist, \n                marker='o')\n\n    # Add labels and a legend\n    plt.xlabel('X-axis')\n    plt.ylabel('Y-axis')\n    plt.title('Scatter Plot Example')\n    plt.legend()\n\n    res_png_path = f\"{work_dir}/testing_output/{str(selected_date.year)}_{var_name}_{test_start_date}.png\"\n    plt.savefig(res_png_path)\n    print(f\"test image is saved at {res_png_path}\")\n    \n#convert_csvs_to_images()\n\nconvert_csvs_to_images_simple()\n",
  "history_output" : "today date = 2023-09-24\ntest start date:  2022-02-22\ntest end date:  2023-09-24\n/home/chetana\n     date   lat      lon  SWE  ...     aspect  eastness  northness  predicted_swe\n69  44612  49.0 -122.516    0  ...   91.84747  0.785138  -0.032228          9.390\n70  44612  49.0 -122.480    0  ...   90.00000  0.785398   0.000000          9.211\n71  44612  49.0 -122.444    0  ...  329.53427 -0.469250   0.711381          9.027\n72  44612  49.0 -122.408    0  ...  270.00000 -0.785398   0.000000          8.953\n73  44612  49.0 -122.372    0  ...   83.99069  0.782643   0.104310          8.954\n[5 rows x 20 columns]\ncount    288650.000000\nmean          9.032466\nstd           1.379009\nmin           1.537000\n25%           9.260000\n50%           9.534000\n75%           9.725000\nmax           9.972000\nName: predicted_swe, dtype: float64\nnew_value_ranges:  [1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 30]\ntest image is saved at /home/chetana/gridmet_test_run/testing_output/2022_predicted_swe_2022-02-22.png\n",
  "history_begin_time" : 1695533747816,
  "history_end_time" : 1695533760349,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "3KunifqP1Dn8",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport uuid\nfrom snowcast_utils import day_index\nimport matplotlib.colors as mcolors\nfrom matplotlib.patches import Patch\nfrom snowcast_utils import day_index, work_dir, test_start_date\n\n# Define the custom colormap with specified colors and ranges\ncolors = [\n    (0.8627, 0.8627, 0.8627),  # #DCDCDC - 0 - 1\n    (0.8627, 1.0000, 1.0000),  # #DCFFFF - 1 - 2\n    (0.6000, 1.0000, 1.0000),  # #99FFFF - 2 - 4\n    (0.5569, 0.8235, 1.0000),  # #8ED2FF - 4 - 6\n    (0.4509, 0.6196, 0.8745),  # #739EDF - 6 - 8\n    (0.4157, 0.4706, 1.0000),  # #6A78FF - 8 - 10\n    (0.4235, 0.2784, 1.0000),  # #6C47FF - 10 - 12\n    (0.5529, 0.0980, 1.0000),  # #8D19FF - 12 - 14\n    (0.7333, 0.0000, 0.9176),  # #BB00EA - 14 - 16\n    (0.8392, 0.0000, 0.7490),  # #D600BF - 16 - 18\n    (0.7569, 0.0039, 0.4549),  # #C10074 - 18 - 20\n    (0.6784, 0.0000, 0.1961),  # #AD0032 - 20 - 30\n    (0.5020, 0.0000, 0.0000)   # #800000 - > 30\n]\n\ncmap_name = 'custom_snow_colormap'\ncustom_cmap = mcolors.ListedColormap(colors)\n\n# Define the lat_lon_to_map_coordinates function\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\n# Define your value ranges for color mapping\nfixed_value_ranges = [1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 30]\n#value_ranges = [0.1, 0.2, 0.4, 0.6, 0.8, 1.0, 1.2, 1.5, 1.8, 2, 2.5, 3]\n\ndef create_color_maps_with_value_range(df_col, value_ranges=None):\n  new_value_ranges = value_ranges\n  if value_ranges == None:\n    max_value = df_col.max()\n    min_value = df_col.min()\n    if min_value < 0:\n      min_value = 0\n    step_size = (max_value - min_value) / 12\n\n    # Create 10 periods\n    new_value_ranges = [min_value + i * step_size for i in range(12)]\n    \n  print(\"new_value_ranges: \", new_value_ranges)\n  \n  # Define your custom function to map data values to colors\n  def map_value_to_color(value):\n    # Iterate through the value ranges to find the appropriate color index\n    for i, range_max in enumerate(new_value_ranges):\n      if value <= range_max:\n        return colors[i]\n\n      # If the value is greater than the largest range, return the last color\n      return colors[-1]\n\n    # Map predicted_swe values to colors using the custom function\n  color_mapping = [map_value_to_color(value) for value in df_col.values]\n  return color_mapping, new_value_ranges\n\ndef convert_csvs_to_images():\n    global fixed_value_ranges\n    data = pd.read_csv(\"/home/chetana/gridmet_test_run/test_data_predicted.csv\")\n#     print(data.head())\n    print(\"statistic of predicted_swe: \", data['predicted_swe'].describe())\n    data['predicted_swe'].fillna(0, inplace=True)\n    #data['predicted_swe'] = data['predicted_swe'].apply(lambda x: 0 if x < 2 else x)\n    \n    for column in data.columns:\n      column_data = data[column]\n      print(column_data.describe())\n\n#       # Print or process the description as needed\n#       print(f\"Column: {column}\")\n#       print(description)\n    \n    # Create a figure with a white background\n    fig = plt.figure(facecolor='white')\n\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    print(\"data['lon'].values = \", data['lon'].values)\n    x, y = m(data['lon'].values, data['lat'].values)\n#     print(\"x = \", x)\n#     print(\"y = \", y)\n#     print(\"v = \", data['predicted_swe'].values)\n    print(data.columns)\n\n    color_mapping, value_ranges = create_color_maps_with_value_range(data[\"predicted_swe\"], fixed_value_ranges)\n    \n    # Plot the data using the custom colormap\n    plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\n    \n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_date = datetime(1900, 1, 1)\n    day_value = day_index\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    timestamp_string = result_date.strftime(\"%Y-%m-%d\")\n    \n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    # Create custom legend elements using the same colormap\n    legend_elements = [Patch(color=colors[i], label=f\"{value_ranges[i]} - {value_ranges[i+1]-1}\" if i < len(value_ranges) - 1 else f\"> {value_ranges[-1]}\") for i in range(len(value_ranges))]\n\n    # Create the legend outside the map\n    legend = plt.legend(handles=legend_elements, loc='upper left', title='Legend', fontsize=8)\n    legend.set_bbox_to_anchor((1.01, 1)) \n\n    # Remove the color bar\n    #plt.colorbar().remove()\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Set the aspect ratio to 'equal' to keep the plot at the center\n    plt.gca().set_aspect('equal', adjustable='box')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15, right=0.80)  # Adjust right margin to accommodate the legend\n    # Show the plot or save it to a file\n    new_plot_path = f'/home/chetana/gridmet_test_run/predicted_swe-{test_start_date}.png'\n    print(f\"The new plot is saved to {new_plot_path}\")\n    plt.savefig(new_plot_path)\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\ndef convert_csvs_to_images_simple():\n    selected_date = datetime.strptime(test_start_date, \"%Y-%m-%d\")\n    var_name = \"predicted_swe\"\n    test_csv = \"/home/chetana/gridmet_test_run/test_data_predicted.csv\"\n    result_var_df = pd.read_csv(test_csv)\n    result_var_df.replace('--', pd.NA, inplace=True)\n    result_var_df.dropna(inplace=True)\n    result_var_df[var_name] = pd.to_numeric(result_var_df[var_name], errors='coerce')\n    print(result_var_df.head())\n    #print(gridmet_var_df[\"Latitude\"].describe())\n    #print(gridmet_var_df[\"Longitude\"].describe())\n    print(result_var_df[var_name].describe())\n\n    colormaplist, value_ranges = create_color_maps_with_value_range(result_var_df[var_name])\n\n    # Create a scatter plot\n    plt.scatter(result_var_df[\"lon\"].values, \n                result_var_df[\"lat\"].values, \n                label='Predicted SWE', \n                color=colormaplist, \n                marker='o')\n\n    # Add labels and a legend\n    plt.xlabel('X-axis')\n    plt.ylabel('Y-axis')\n    plt.title('Scatter Plot Example')\n    plt.legend()\n\n    res_png_path = f\"{work_dir}/testing_output/{str(selected_date.year)}_{var_name}_{test_start_date}.png\"\n    plt.savefig(res_png_path)\n    print(f\"test image is saved at {res_png_path}\")\n    \n#convert_csvs_to_images()\n\nconvert_csvs_to_images_simple()\n",
  "history_output" : "today date = 2023-09-24\ntest start date:  2022-02-22\ntest end date:  2023-09-24\n/home/chetana\n     date   lat      lon  SWE  ...     aspect  eastness  northness  predicted_swe\n69  44612  49.0 -122.516    0  ...   91.84747  0.785138  -0.032228          9.390\n70  44612  49.0 -122.480    0  ...   90.00000  0.785398   0.000000          9.211\n71  44612  49.0 -122.444    0  ...  329.53427 -0.469250   0.711381          9.027\n72  44612  49.0 -122.408    0  ...  270.00000 -0.785398   0.000000          8.953\n73  44612  49.0 -122.372    0  ...   83.99069  0.782643   0.104310          8.954\n[5 rows x 20 columns]\ncount    288650.000000\nmean          9.032466\nstd           1.379009\nmin           1.537000\n25%           9.260000\n50%           9.534000\n75%           9.725000\nmax           9.972000\nName: predicted_swe, dtype: float64\nnew_value_ranges:  [1.537, 2.2399166666666663, 2.9428333333333327, 3.6457499999999996, 4.3486666666666665, 5.051583333333332, 5.754499999999999, 6.457416666666665, 7.160333333333332, 7.863249999999999, 8.566166666666664, 9.269083333333331]\ntest image is saved at /home/chetana/gridmet_test_run/testing_output/2022_predicted_swe_2022-02-22.png\n",
  "history_begin_time" : 1695533616782,
  "history_end_time" : 1695533629468,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "cAFBeVekn4JA",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport uuid\nfrom snowcast_utils import day_index\nimport matplotlib.colors as mcolors\nfrom matplotlib.patches import Patch\nfrom snowcast_utils import day_index, work_dir, test_start_date\n\n# Define the custom colormap with specified colors and ranges\ncolors = [\n    (0.8627, 0.8627, 0.8627),  # #DCDCDC - 0 - 1\n    (0.8627, 1.0000, 1.0000),  # #DCFFFF - 1 - 2\n    (0.6000, 1.0000, 1.0000),  # #99FFFF - 2 - 4\n    (0.5569, 0.8235, 1.0000),  # #8ED2FF - 4 - 6\n    (0.4509, 0.6196, 0.8745),  # #739EDF - 6 - 8\n    (0.4157, 0.4706, 1.0000),  # #6A78FF - 8 - 10\n    (0.4235, 0.2784, 1.0000),  # #6C47FF - 10 - 12\n    (0.5529, 0.0980, 1.0000),  # #8D19FF - 12 - 14\n    (0.7333, 0.0000, 0.9176),  # #BB00EA - 14 - 16\n    (0.8392, 0.0000, 0.7490),  # #D600BF - 16 - 18\n    (0.7569, 0.0039, 0.4549),  # #C10074 - 18 - 20\n    (0.6784, 0.0000, 0.1961),  # #AD0032 - 20 - 30\n    (0.5020, 0.0000, 0.0000)   # #800000 - > 30\n]\n\ncmap_name = 'custom_snow_colormap'\ncustom_cmap = mcolors.ListedColormap(colors)\n\n# Define the lat_lon_to_map_coordinates function\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\n# Define your value ranges for color mapping\nfixed_value_ranges = [1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 30]\n#value_ranges = [0.1, 0.2, 0.4, 0.6, 0.8, 1.0, 1.2, 1.5, 1.8, 2, 2.5, 3]\n\ndef create_color_maps_with_value_range(df_col, value_ranges=None):\n  new_value_ranges = value_ranges\n  if value_ranges == None:\n    max_value = df_col.max()\n    min_value = df_col.min()\n    if min_value < 0:\n      min_value = 0\n    step_size = (max_value - min_value) / 12\n\n    # Create 10 periods\n    new_value_ranges = [min_value + i * step_size for i in range(12)]\n    \n  print(\"new_value_ranges: \", new_value_ranges)\n  \n  # Define your custom function to map data values to colors\n  def map_value_to_color(value):\n    # Iterate through the value ranges to find the appropriate color index\n    for i, range_max in enumerate(new_value_ranges):\n      if value <= range_max:\n        return colors[i]\n\n      # If the value is greater than the largest range, return the last color\n      return colors[-1]\n\n    # Map predicted_swe values to colors using the custom function\n  color_mapping = [map_value_to_color(value) for value in df_col.values]\n  return color_mapping, new_value_ranges\n\ndef convert_csvs_to_images():\n    global fixed_value_ranges\n    data = pd.read_csv(\"/home/chetana/gridmet_test_run/test_data_predicted.csv\")\n#     print(data.head())\n    print(\"statistic of predicted_swe: \", data['predicted_swe'].describe())\n    data['predicted_swe'].fillna(0, inplace=True)\n    #data['predicted_swe'] = data['predicted_swe'].apply(lambda x: 0 if x < 2 else x)\n    \n    for column in data.columns:\n      column_data = data[column]\n      print(column_data.describe())\n\n#       # Print or process the description as needed\n#       print(f\"Column: {column}\")\n#       print(description)\n    \n    # Create a figure with a white background\n    fig = plt.figure(facecolor='white')\n\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    print(\"data['lon'].values = \", data['lon'].values)\n    x, y = m(data['lon'].values, data['lat'].values)\n#     print(\"x = \", x)\n#     print(\"y = \", y)\n#     print(\"v = \", data['predicted_swe'].values)\n    print(data.columns)\n\n    color_mapping, value_ranges = create_color_maps_with_value_range(data[\"predicted_swe\"], fixed_value_ranges)\n    \n    # Plot the data using the custom colormap\n    plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\n    \n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_date = datetime(1900, 1, 1)\n    day_value = day_index\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    timestamp_string = result_date.strftime(\"%Y-%m-%d\")\n    \n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    # Create custom legend elements using the same colormap\n    legend_elements = [Patch(color=colors[i], label=f\"{value_ranges[i]} - {value_ranges[i+1]-1}\" if i < len(value_ranges) - 1 else f\"> {value_ranges[-1]}\") for i in range(len(value_ranges))]\n\n    # Create the legend outside the map\n    legend = plt.legend(handles=legend_elements, loc='upper left', title='Legend', fontsize=8)\n    legend.set_bbox_to_anchor((1.01, 1)) \n\n    # Remove the color bar\n    #plt.colorbar().remove()\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Set the aspect ratio to 'equal' to keep the plot at the center\n    plt.gca().set_aspect('equal', adjustable='box')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15, right=0.80)  # Adjust right margin to accommodate the legend\n    # Show the plot or save it to a file\n    new_plot_path = f'/home/chetana/gridmet_test_run/predicted_swe-{test_start_date}.png'\n    print(f\"The new plot is saved to {new_plot_path}\")\n    plt.savefig(new_plot_path)\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\ndef convert_csvs_to_images_simple():\n    selected_date = datetime.strptime(test_start_date, \"%Y-%m-%d\")\n    var_name = \"predicted_swe\"\n    test_csv_ = \"/home/chetana/gridmet_test_run/test_data_predicted.csv\"\n    result_var_df = pd.read_csv(test_csv)\n    result_var_df.replace('--', pd.NA, inplace=True)\n    result_var_df.dropna(inplace=True)\n    result_var_df[var_name] = pd.to_numeric(result_var_df[var_name], errors='coerce')\n    print(result_var_df.head())\n    #print(gridmet_var_df[\"Latitude\"].describe())\n    #print(gridmet_var_df[\"Longitude\"].describe())\n    print(result_var_df[var_name].describe())\n\n    colormaplist, value_ranges = create_color_maps_with_value_range(result_var_df[var_name])\n\n    # Create a scatter plot\n    plt.scatter(result_var_df[\"lon\"].values, \n                result_var_df[\"lat\"].values, \n                label='Predicted SWE', \n                color=colormaplist, \n                marker='o')\n\n    # Add labels and a legend\n    plt.xlabel('X-axis')\n    plt.ylabel('Y-axis')\n    plt.title('Scatter Plot Example')\n    plt.legend()\n\n    res_png_path = f\"{work_dir}/testing_output/{str(selected_date.year)}_{var_name}_{test_start_date}.png\"\n    plt.savefig(res_png_path)\n    print(f\"test image is saved at {res_png_path}\")\n    \n#convert_csvs_to_images()\n\nconvert_csvs_to_images_simple()\n",
  "history_output" : "today date = 2023-09-24\ntest start date:  2022-02-22\ntest end date:  2023-09-24\n/home/chetana\nTraceback (most recent call last):\n  File \"/home/chetana/gw-workspace/cAFBeVekn4JA/convert_results_to_images.py\", line 203, in <module>\n    convert_csvs_to_images_simple()\n  File \"/home/chetana/gw-workspace/cAFBeVekn4JA/convert_results_to_images.py\", line 173, in convert_csvs_to_images_simple\n    result_var_df = pd.read_csv(test_csv)\nNameError: name 'test_csv' is not defined\n",
  "history_begin_time" : 1695533594498,
  "history_end_time" : 1695533595488,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Failed"
},{
  "history_id" : "MLz7JjqNJphp",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport uuid\nfrom snowcast_utils import day_index\nimport matplotlib.colors as mcolors\nfrom matplotlib.patches import Patch\nfrom snowcast_utils import day_index, work_dir, test_start_date\n\n# Define the custom colormap with specified colors and ranges\ncolors = [\n    (0.8627, 0.8627, 0.8627),  # #DCDCDC - 0 - 1\n    (0.8627, 1.0000, 1.0000),  # #DCFFFF - 1 - 2\n    (0.6000, 1.0000, 1.0000),  # #99FFFF - 2 - 4\n    (0.5569, 0.8235, 1.0000),  # #8ED2FF - 4 - 6\n    (0.4509, 0.6196, 0.8745),  # #739EDF - 6 - 8\n    (0.4157, 0.4706, 1.0000),  # #6A78FF - 8 - 10\n    (0.4235, 0.2784, 1.0000),  # #6C47FF - 10 - 12\n    (0.5529, 0.0980, 1.0000),  # #8D19FF - 12 - 14\n    (0.7333, 0.0000, 0.9176),  # #BB00EA - 14 - 16\n    (0.8392, 0.0000, 0.7490),  # #D600BF - 16 - 18\n    (0.7569, 0.0039, 0.4549),  # #C10074 - 18 - 20\n    (0.6784, 0.0000, 0.1961),  # #AD0032 - 20 - 30\n    (0.5020, 0.0000, 0.0000)   # #800000 - > 30\n]\n\ncmap_name = 'custom_snow_colormap'\ncustom_cmap = mcolors.ListedColormap(colors)\n\n# Define the lat_lon_to_map_coordinates function\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\n# Define your value ranges for color mapping\nfixed_value_ranges = [1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 30]\n#value_ranges = [0.1, 0.2, 0.4, 0.6, 0.8, 1.0, 1.2, 1.5, 1.8, 2, 2.5, 3]\n\ndef create_color_maps_with_value_range(df_col, value_ranges=None):\n  new_value_ranges = value_ranges\n  if value_ranges == None:\n    max_value = df_col.max()\n    min_value = df_col.min()\n    if min_value < 0:\n      min_value = 0\n    step_size = (max_value - min_value) / 12\n\n    # Create 10 periods\n    new_value_ranges = [min_value + i * step_size for i in range(12)]\n    \n  print(\"new_value_ranges: \", new_value_ranges)\n  \n  # Define your custom function to map data values to colors\n  def map_value_to_color(value):\n    # Iterate through the value ranges to find the appropriate color index\n    for i, range_max in enumerate(new_value_ranges):\n      if value <= range_max:\n        return colors[i]\n\n      # If the value is greater than the largest range, return the last color\n      return colors[-1]\n\n    # Map predicted_swe values to colors using the custom function\n  color_mapping = [map_value_to_color(value) for value in df_col.values]\n  return color_mapping, new_value_ranges\n\ndef convert_csvs_to_images():\n    global fixed_value_ranges\n    data = pd.read_csv(\"/home/chetana/gridmet_test_run/test_data_predicted.csv\")\n#     print(data.head())\n    print(\"statistic of predicted_swe: \", data['predicted_swe'].describe())\n    data['predicted_swe'].fillna(0, inplace=True)\n    #data['predicted_swe'] = data['predicted_swe'].apply(lambda x: 0 if x < 2 else x)\n    \n    for column in data.columns:\n      column_data = data[column]\n      print(column_data.describe())\n\n#       # Print or process the description as needed\n#       print(f\"Column: {column}\")\n#       print(description)\n    \n    # Create a figure with a white background\n    fig = plt.figure(facecolor='white')\n\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    print(\"data['lon'].values = \", data['lon'].values)\n    x, y = m(data['lon'].values, data['lat'].values)\n#     print(\"x = \", x)\n#     print(\"y = \", y)\n#     print(\"v = \", data['predicted_swe'].values)\n    print(data.columns)\n\n    color_mapping, value_ranges = create_color_maps_with_value_range(data[\"predicted_swe\"], fixed_value_ranges)\n    \n    # Plot the data using the custom colormap\n    plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\n    \n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_date = datetime(1900, 1, 1)\n    day_value = day_index\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    timestamp_string = result_date.strftime(\"%Y-%m-%d\")\n    \n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    # Create custom legend elements using the same colormap\n    legend_elements = [Patch(color=colors[i], label=f\"{value_ranges[i]} - {value_ranges[i+1]-1}\" if i < len(value_ranges) - 1 else f\"> {value_ranges[-1]}\") for i in range(len(value_ranges))]\n\n    # Create the legend outside the map\n    legend = plt.legend(handles=legend_elements, loc='upper left', title='Legend', fontsize=8)\n    legend.set_bbox_to_anchor((1.01, 1)) \n\n    # Remove the color bar\n    #plt.colorbar().remove()\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Set the aspect ratio to 'equal' to keep the plot at the center\n    plt.gca().set_aspect('equal', adjustable='box')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15, right=0.80)  # Adjust right margin to accommodate the legend\n    # Show the plot or save it to a file\n    new_plot_path = f'/home/chetana/gridmet_test_run/predicted_swe-{test_start_date}.png'\n    print(f\"The new plot is saved to {new_plot_path}\")\n    plt.savefig(new_plot_path)\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\ndef convert_csvs_to_images_simple():\n    selected_date = datetime.strptime(test_start_date, \"%Y-%m-%d\")\n    var_name = \"predicted_swe\"\n    test_csv = pd.read_csv(\"/home/chetana/gridmet_test_run/test_data_predicted.csv\")\n    result_var_df = pd.read_csv(test_csv)\n    result_var_df.replace('--', pd.NA, inplace=True)\n    result_var_df.dropna(inplace=True)\n    result_var_df[var_name] = pd.to_numeric(result_var_df[var_name], errors='coerce')\n    print(result_var_df.head())\n    #print(gridmet_var_df[\"Latitude\"].describe())\n    #print(gridmet_var_df[\"Longitude\"].describe())\n    print(result_var_df[var_name].describe())\n\n    colormaplist, value_ranges = create_color_maps_with_value_range(result_var_df[var_name])\n\n    # Create a scatter plot\n    plt.scatter(result_var_df[\"lon\"].values, \n                result_var_df[\"lat\"].values, \n                label='Predicted SWE', \n                color=colormaplist, \n                marker='o')\n\n    # Add labels and a legend\n    plt.xlabel('X-axis')\n    plt.ylabel('Y-axis')\n    plt.title('Scatter Plot Example')\n    plt.legend()\n\n    res_png_path = f\"{work_dir}/testing_output/{str(selected_date.year)}_{var_name}_{test_start_date}.png\"\n    plt.savefig(res_png_path)\n    print(f\"test image is saved at {res_png_path}\")\n    \n#convert_csvs_to_images()\n\nconvert_csvs_to_images_simple()\n",
  "history_output" : "today date = 2023-09-24\ntest start date:  2022-02-22\ntest end date:  2023-09-24\n/home/chetana\nTraceback (most recent call last):\n  File \"/home/chetana/gw-workspace/MLz7JjqNJphp/convert_results_to_images.py\", line 203, in <module>\n    convert_csvs_to_images_simple()\n  File \"/home/chetana/gw-workspace/MLz7JjqNJphp/convert_results_to_images.py\", line 173, in convert_csvs_to_images_simple\n    result_var_df = pd.read_csv(test_csv)\n  File \"/home/chetana/anaconda3/lib/python3.9/site-packages/pandas/util/_decorators.py\", line 211, in wrapper\n    return func(*args, **kwargs)\n  File \"/home/chetana/anaconda3/lib/python3.9/site-packages/pandas/util/_decorators.py\", line 331, in wrapper\n    return func(*args, **kwargs)\n  File \"/home/chetana/anaconda3/lib/python3.9/site-packages/pandas/io/parsers/readers.py\", line 950, in read_csv\n    return _read(filepath_or_buffer, kwds)\n  File \"/home/chetana/anaconda3/lib/python3.9/site-packages/pandas/io/parsers/readers.py\", line 605, in _read\n    parser = TextFileReader(filepath_or_buffer, **kwds)\n  File \"/home/chetana/anaconda3/lib/python3.9/site-packages/pandas/io/parsers/readers.py\", line 1442, in __init__\n    self._engine = self._make_engine(f, self.engine)\n  File \"/home/chetana/anaconda3/lib/python3.9/site-packages/pandas/io/parsers/readers.py\", line 1735, in _make_engine\n    self.handles = get_handle(\n  File \"/home/chetana/anaconda3/lib/python3.9/site-packages/pandas/io/common.py\", line 704, in get_handle\n    if _is_binary_mode(path_or_buf, mode) and \"b\" not in mode:\n  File \"/home/chetana/anaconda3/lib/python3.9/site-packages/pandas/io/common.py\", line 1163, in _is_binary_mode\n    return isinstance(handle, _get_binary_io_classes()) or \"b\" in getattr(\nTypeError: argument of type 'method' is not iterable\n",
  "history_begin_time" : 1695533548615,
  "history_end_time" : 1695533550446,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Failed"
},{
  "history_id" : "p7vwpzciela",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport uuid\nfrom snowcast_utils import day_index\nimport matplotlib.colors as mcolors\nfrom matplotlib.patches import Patch\nfrom snowcast_utils import day_index, work_dir, test_start_date\n\n# Define the custom colormap with specified colors and ranges\ncolors = [\n    (0.8627, 0.8627, 0.8627),  # #DCDCDC - 0 - 1\n    (0.8627, 1.0000, 1.0000),  # #DCFFFF - 1 - 2\n    (0.6000, 1.0000, 1.0000),  # #99FFFF - 2 - 4\n    (0.5569, 0.8235, 1.0000),  # #8ED2FF - 4 - 6\n    (0.4509, 0.6196, 0.8745),  # #739EDF - 6 - 8\n    (0.4157, 0.4706, 1.0000),  # #6A78FF - 8 - 10\n    (0.4235, 0.2784, 1.0000),  # #6C47FF - 10 - 12\n    (0.5529, 0.0980, 1.0000),  # #8D19FF - 12 - 14\n    (0.7333, 0.0000, 0.9176),  # #BB00EA - 14 - 16\n    (0.8392, 0.0000, 0.7490),  # #D600BF - 16 - 18\n    (0.7569, 0.0039, 0.4549),  # #C10074 - 18 - 20\n    (0.6784, 0.0000, 0.1961),  # #AD0032 - 20 - 30\n    (0.5020, 0.0000, 0.0000)   # #800000 - > 30\n]\n\ncmap_name = 'custom_snow_colormap'\ncustom_cmap = mcolors.ListedColormap(colors)\n\n# Define the lat_lon_to_map_coordinates function\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\n# Define your value ranges for color mapping\nfixed_value_ranges = [1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 30]\n#value_ranges = [0.1, 0.2, 0.4, 0.6, 0.8, 1.0, 1.2, 1.5, 1.8, 2, 2.5, 3]\n\ndef create_color_maps_with_value_range(df_col, value_ranges=None):\n  new_value_ranges = value_ranges\n  if value_ranges == None:\n    max_value = df_col.max()\n    min_value = df_col.min()\n    if min_value < 0:\n      min_value = 0\n    step_size = (max_value - min_value) / 12\n\n    # Create 10 periods\n    new_value_ranges = [min_value + i * step_size for i in range(12)]\n    \n  print(\"new_value_ranges: \", new_value_ranges)\n  \n  # Define your custom function to map data values to colors\n  def map_value_to_color(value):\n    # Iterate through the value ranges to find the appropriate color index\n    for i, range_max in enumerate(new_value_ranges):\n      if value <= range_max:\n        return colors[i]\n\n      # If the value is greater than the largest range, return the last color\n      return colors[-1]\n\n    # Map predicted_swe values to colors using the custom function\n  color_mapping = [map_value_to_color(value) for value in df_col.values]\n  return color_mapping, new_value_ranges\n\ndef convert_csvs_to_images():\n    global fixed_value_ranges\n    data = pd.read_csv(\"/home/chetana/gridmet_test_run/test_data_predicted.csv\")\n#     print(data.head())\n    print(\"statistic of predicted_swe: \", data['predicted_swe'].describe())\n    data['predicted_swe'].fillna(0, inplace=True)\n    #data['predicted_swe'] = data['predicted_swe'].apply(lambda x: 0 if x < 2 else x)\n    \n    for column in data.columns:\n      column_data = data[column]\n      print(column_data.describe())\n\n#       # Print or process the description as needed\n#       print(f\"Column: {column}\")\n#       print(description)\n    \n    # Create a figure with a white background\n    fig = plt.figure(facecolor='white')\n\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    print(\"data['lon'].values = \", data['lon'].values)\n    x, y = m(data['lon'].values, data['lat'].values)\n#     print(\"x = \", x)\n#     print(\"y = \", y)\n#     print(\"v = \", data['predicted_swe'].values)\n    print(data.columns)\n\n    color_mapping, value_ranges = create_color_maps_with_value_range(data[\"predicted_swe\"], fixed_value_ranges)\n    \n    # Plot the data using the custom colormap\n    plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\n    \n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_date = datetime(1900, 1, 1)\n    day_value = day_index\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    timestamp_string = result_date.strftime(\"%Y-%m-%d\")\n    \n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    # Create custom legend elements using the same colormap\n    legend_elements = [Patch(color=colors[i], label=f\"{value_ranges[i]} - {value_ranges[i+1]-1}\" if i < len(value_ranges) - 1 else f\"> {value_ranges[-1]}\") for i in range(len(value_ranges))]\n\n    # Create the legend outside the map\n    legend = plt.legend(handles=legend_elements, loc='upper left', title='Legend', fontsize=8)\n    legend.set_bbox_to_anchor((1.01, 1)) \n\n    # Remove the color bar\n    #plt.colorbar().remove()\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Set the aspect ratio to 'equal' to keep the plot at the center\n    plt.gca().set_aspect('equal', adjustable='box')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15, right=0.80)  # Adjust right margin to accommodate the legend\n    # Show the plot or save it to a file\n    new_plot_path = f'/home/chetana/gridmet_test_run/predicted_swe-{test_start_date}.png'\n    print(f\"The new plot is saved to {new_plot_path}\")\n    plt.savefig(new_plot_path)\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "/home/chetana/gw-workspace/p7vwpzciela/convert_results_to_images.py:104: UserWarning: No data for colormapping provided via 'c'. Parameters 'cmap' will be ignored\n  plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\ntoday date = 2023-09-24\ntest start date:  2022-02-22\ntest end date:  2023-09-24\n/home/chetana\nstatistic of predicted_swe:  count    288650.000000\nmean          9.032466\nstd           1.379009\nmin           1.537000\n25%           9.260000\n50%           9.534000\n75%           9.725000\nmax           9.972000\nName: predicted_swe, dtype: float64\ncount    462204.0\nmean      44612.0\nstd           0.0\nmin       44612.0\n25%       44612.0\n50%       44612.0\n75%       44612.0\nmax       44612.0\nName: date, dtype: float64\ncount    462204.000000\nmean         37.030000\nstd           6.921275\nmin          25.060000\n25%          31.036000\n50%          37.030000\n75%          43.024000\nmax          49.000000\nName: lat, dtype: float64\ncount    462204.00000\nmean       -112.52600\nstd           7.21226\nmin        -125.00000\n25%        -118.77200\n50%        -112.52600\n75%        -106.28000\nmax        -100.05200\nName: lon, dtype: float64\ncount    462204.000000\nmean        121.006203\nstd         121.228018\nmin           0.000000\n25%           0.000000\n50%          50.000000\n75%         254.000000\nmax         255.000000\nName: SWE, dtype: float64\ncount    462204.000000\nmean        246.895299\nstd           6.595276\nmin         241.000000\n25%         241.000000\n50%         241.000000\n75%         254.000000\nmax         255.000000\nName: Flag, dtype: float64\ncount    310570.000000\nmean        259.267669\nstd          10.964659\nmin         235.200000\n25%         250.600000\n50%         259.600000\n75%         268.100000\nmax         289.300000\nName: air_temperature_tmmn, dtype: float64\ncount    310570.000000\nmean          1.931404\nstd           2.057502\nmin           0.100000\n25%           0.400000\n50%           1.100000\n75%           2.400000\nmax          12.300000\nName: potential_evapotranspiration, dtype: float64\ncount    310570.000000\nmean          0.236234\nstd           0.337510\nmin           0.000000\n25%           0.030000\n50%           0.110000\n75%           0.260000\nmax           2.650000\nName: mean_vapor_pressure_deficit, dtype: float64\ncount    310570.000000\nmean         89.371899\nstd          13.676319\nmin          33.000000\n25%          79.900000\n50%          98.200000\n75%         100.000000\nmax         100.000000\nName: relative_humidity_rmax, dtype: float64\ncount    310570.000000\nmean         47.201641\nstd          17.885694\nmin           5.000000\n25%          34.800000\n50%          48.600000\n75%          58.800000\nmax         100.000000\nName: relative_humidity_rmin, dtype: float64\ncount    310570.000000\nmean          1.381115\nstd           3.199411\nmin           0.000000\n25%           0.000000\n50%           0.000000\n75%           1.200000\nmax          57.100000\nName: precipitation_amount, dtype: float64\ncount    310570.000000\nmean        270.584089\nstd          12.704646\nmin         246.900000\n25%         259.500000\n50%         269.700000\n75%         279.600000\nmax         308.600000\nName: air_temperature_tmmx, dtype: float64\ncount    310570.000000\nmean          5.170607\nstd           2.024362\nmin           0.900000\n25%           3.600000\n50%           4.900000\n75%           6.500000\nmax          15.400000\nName: wind_speed, dtype: float64\ncount    309830.000000\nmean       2561.017903\nstd         376.542591\nmin        1691.416300\n25%        2286.872000\n50%        2471.946300\n75%        2776.111600\nmax        4115.082000\nName: elevation, dtype: float64\ncount    308251.000000\nmean         54.006650\nstd          20.681525\nmin           0.000000\n25%          44.149170\n50%          58.931244\n75%          69.586060\nmax          86.687220\nName: slope, dtype: float64\ncount    295965.000000\nmean       -186.538634\nstd        3215.498709\nmin      -40479.438000\n25%       -1488.354700\n50%          29.660137\n75%        1457.598300\nmax       18450.988000\nName: curvature, dtype: float64\ncount    308251.000000\nmean        170.498344\nstd         106.428245\nmin           0.000000\n25%          83.157240\n50%         176.729480\n75%         266.423680\nmax         359.906980\nName: aspect, dtype: float64\ncount    300725.000000\nmean         -0.002146\nstd           0.577707\nmin          -0.785398\n25%          -0.615480\n50%           0.000000\n75%           0.612676\nmax           0.785398\nName: eastness, dtype: float64\ncount    300725.000000\nmean         -0.007756\nstd           0.590930\nmin          -0.785398\n25%          -0.620971\n50%           0.000000\n75%           0.615480\nmax           0.785398\nName: northness, dtype: float64\ncount    462204.000000\nmean          5.640846\nstd           4.507688\nmin           0.000000\n25%           0.000000\n50%           8.987000\n75%           9.615000\nmax           9.972000\nName: predicted_swe, dtype: float64\ndata['lon'].values =  [-125.    -124.964 -124.928 ... -100.124 -100.088 -100.052]\nIndex(['date', 'lat', 'lon', 'SWE', 'Flag', 'air_temperature_tmmn',\n       'potential_evapotranspiration', 'mean_vapor_pressure_deficit',\n       'relative_humidity_rmax', 'relative_humidity_rmin',\n       'precipitation_amount', 'air_temperature_tmmx', 'wind_speed',\n       'elevation', 'slope', 'curvature', 'aspect', 'eastness', 'northness',\n       'predicted_swe'],\n      dtype='object')\nnew_value_ranges:  [1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 30]\nThe new plot is saved to /home/chetana/gridmet_test_run/predicted_swe-2022-02-22.png\n",
  "history_begin_time" : 1695533187852,
  "history_end_time" : 1695533198257,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "100001",
  "indicator" : "Done"
},{
  "history_id" : "dvCgyg8u11As",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport uuid\nfrom snowcast_utils import day_index\nimport matplotlib.colors as mcolors\nfrom matplotlib.patches import Patch\nfrom snowcast_utils import day_index, work_dir, test_start_date\n\n# Define the custom colormap with specified colors and ranges\ncolors = [\n    (0.8627, 0.8627, 0.8627),  # #DCDCDC - 0 - 1\n    (0.8627, 1.0000, 1.0000),  # #DCFFFF - 1 - 2\n    (0.6000, 1.0000, 1.0000),  # #99FFFF - 2 - 4\n    (0.5569, 0.8235, 1.0000),  # #8ED2FF - 4 - 6\n    (0.4509, 0.6196, 0.8745),  # #739EDF - 6 - 8\n    (0.4157, 0.4706, 1.0000),  # #6A78FF - 8 - 10\n    (0.4235, 0.2784, 1.0000),  # #6C47FF - 10 - 12\n    (0.5529, 0.0980, 1.0000),  # #8D19FF - 12 - 14\n    (0.7333, 0.0000, 0.9176),  # #BB00EA - 14 - 16\n    (0.8392, 0.0000, 0.7490),  # #D600BF - 16 - 18\n    (0.7569, 0.0039, 0.4549),  # #C10074 - 18 - 20\n    (0.6784, 0.0000, 0.1961),  # #AD0032 - 20 - 30\n    (0.5020, 0.0000, 0.0000)   # #800000 - > 30\n]\n\ncmap_name = 'custom_snow_colormap'\ncustom_cmap = mcolors.ListedColormap(colors)\n\n# Define the lat_lon_to_map_coordinates function\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\n# Define your value ranges for color mapping\nfixed_value_ranges = [1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 30]\n#value_ranges = [0.1, 0.2, 0.4, 0.6, 0.8, 1.0, 1.2, 1.5, 1.8, 2, 2.5, 3]\n\ndef create_color_maps_with_value_range(df_col, value_ranges=None):\n  new_value_ranges = value_ranges\n  if value_ranges == None:\n    max_value = df_col.max()\n    min_value = df_col.min()\n    if min_value < 0:\n      min_value = 0\n    step_size = (max_value - min_value) / 12\n\n    # Create 10 periods\n    new_value_ranges = [min_value + i * step_size for i in range(12)]\n    \n  print(\"new_value_ranges: \", new_value_ranges)\n  \n  # Define your custom function to map data values to colors\n  def map_value_to_color(value):\n    # Iterate through the value ranges to find the appropriate color index\n    for i, range_max in enumerate(new_value_ranges):\n      if value <= range_max:\n        return colors[i]\n\n      # If the value is greater than the largest range, return the last color\n      return colors[-1]\n\n    # Map predicted_swe values to colors using the custom function\n  color_mapping = [map_value_to_color(value) for value in df_col.values]\n  return color_mapping, new_value_ranges\n\ndef convert_csvs_to_images():\n    global fixed_value_ranges\n    data = pd.read_csv(\"/home/chetana/gridmet_test_run/test_data_predicted.csv\")\n#     print(data.head())\n    print(\"statistic of predicted_swe: \", data['predicted_swe'].describe())\n    data['predicted_swe'].fillna(0, inplace=True)\n    #data['predicted_swe'] = data['predicted_swe'].apply(lambda x: 0 if x < 2 else x)\n    \n#     for column in data.columns:\n#       column_data = data[column]\n#       description = column_data.describe()\n\n#       # Print or process the description as needed\n#       print(f\"Column: {column}\")\n#       print(description)\n    \n    # Create a figure with a white background\n    fig = plt.figure(facecolor='white')\n\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    print(\"data['lon'].values = \", data['lon'].values)\n    x, y = m(data['lon'].values, data['lat'].values)\n#     print(\"x = \", x)\n#     print(\"y = \", y)\n#     print(\"v = \", data['predicted_swe'].values)\n    print(data.columns)\n\n    color_mapping, value_ranges = create_color_maps_with_value_range(data[\"predicted_swe\"], fixed_value_ranges)\n    \n    # Plot the data using the custom colormap\n    plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\n    \n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_date = datetime(1900, 1, 1)\n    day_value = day_index\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    timestamp_string = result_date.strftime(\"%Y-%m-%d\")\n    \n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    # Create custom legend elements using the same colormap\n    legend_elements = [Patch(color=colors[i], label=f\"{value_ranges[i]} - {value_ranges[i+1]-1}\" if i < len(value_ranges) - 1 else f\"> {value_ranges[-1]}\") for i in range(len(value_ranges))]\n\n    # Create the legend outside the map\n    legend = plt.legend(handles=legend_elements, loc='upper left', title='Legend', fontsize=8)\n    legend.set_bbox_to_anchor((1.01, 1)) \n\n    # Remove the color bar\n    #plt.colorbar().remove()\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Set the aspect ratio to 'equal' to keep the plot at the center\n    plt.gca().set_aspect('equal', adjustable='box')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15, right=0.80)  # Adjust right margin to accommodate the legend\n    # Show the plot or save it to a file\n    new_plot_path = f'/home/chetana/gridmet_test_run/predicted_swe-{test_start_date}.png'\n    print(f\"The new plot is saved to {new_plot_path}\")\n    plt.savefig(new_plot_path)\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "/home/chetana/gw-workspace/dvCgyg8u11As/convert_results_to_images.py:104: UserWarning: No data for colormapping provided via 'c'. Parameters 'cmap' will be ignored\n  plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\ntoday date = 2023-09-24\ntest start date:  2022-02-22\ntest end date:  2023-09-24\n/home/chetana\nstatistic of predicted_swe:  count    288650.000000\nmean          9.091466\nstd           1.400055\nmin           1.532000\n25%           9.317000\n50%           9.648000\n75%           9.790000\nmax           9.964000\nName: predicted_swe, dtype: float64\ndata['lon'].values =  [-125.    -124.964 -124.928 ... -100.124 -100.088 -100.052]\nIndex(['date', 'lat', 'lon', 'SWE', 'Flag', 'air_temperature_tmmn',\n       'potential_evapotranspiration', 'mean_vapor_pressure_deficit',\n       'relative_humidity_rmax', 'relative_humidity_rmin',\n       'precipitation_amount', 'air_temperature_tmmx', 'wind_speed',\n       'elevation', 'slope', 'curvature', 'aspect', 'eastness', 'northness',\n       'predicted_swe'],\n      dtype='object')\nnew_value_ranges:  [1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 30]\nThe new plot is saved to /home/chetana/gridmet_test_run/predicted_swe-2022-02-22.png\n",
  "history_begin_time" : 1695531227153,
  "history_end_time" : 1695531235773,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "Pz7LF7gtc9sx",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport uuid\nfrom snowcast_utils import day_index\nimport matplotlib.colors as mcolors\nfrom matplotlib.patches import Patch\nfrom snowcast_utils import day_index, work_dir, test_start_date\n\n# Define the custom colormap with specified colors and ranges\ncolors = [\n    (0.8627, 0.8627, 0.8627),  # #DCDCDC - 0 - 1\n    (0.8627, 1.0000, 1.0000),  # #DCFFFF - 1 - 2\n    (0.6000, 1.0000, 1.0000),  # #99FFFF - 2 - 4\n    (0.5569, 0.8235, 1.0000),  # #8ED2FF - 4 - 6\n    (0.4509, 0.6196, 0.8745),  # #739EDF - 6 - 8\n    (0.4157, 0.4706, 1.0000),  # #6A78FF - 8 - 10\n    (0.4235, 0.2784, 1.0000),  # #6C47FF - 10 - 12\n    (0.5529, 0.0980, 1.0000),  # #8D19FF - 12 - 14\n    (0.7333, 0.0000, 0.9176),  # #BB00EA - 14 - 16\n    (0.8392, 0.0000, 0.7490),  # #D600BF - 16 - 18\n    (0.7569, 0.0039, 0.4549),  # #C10074 - 18 - 20\n    (0.6784, 0.0000, 0.1961),  # #AD0032 - 20 - 30\n    (0.5020, 0.0000, 0.0000)   # #800000 - > 30\n]\n\ncmap_name = 'custom_snow_colormap'\ncustom_cmap = mcolors.ListedColormap(colors)\n\n# Define the lat_lon_to_map_coordinates function\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\n# Define your value ranges for color mapping\nfixed_value_ranges = [1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 30]\n#value_ranges = [0.1, 0.2, 0.4, 0.6, 0.8, 1.0, 1.2, 1.5, 1.8, 2, 2.5, 3]\n\ndef create_color_maps_with_value_range(df_col, value_ranges=None):\n  new_value_ranges = fixed_value_ranges\n  if value_ranges == None:\n    max_value = df_col.max()\n    min_value = df_col.min()\n    if min_value < 0:\n      min_value = 0\n    step_size = (max_value - min_value) / 12\n\n    # Create 10 periods\n    new_value_ranges = [min_value + i * step_size for i in range(12)]\n  # Define your custom function to map data values to colors\n  def map_value_to_color(value):\n    # Iterate through the value ranges to find the appropriate color index\n    for i, range_max in enumerate(new_value_ranges):\n      if value <= range_max:\n        return colors[i]\n\n      # If the value is greater than the largest range, return the last color\n      return colors[-1]\n\n    # Map predicted_swe values to colors using the custom function\n  color_mapping = [map_value_to_color(value) for value in df_col.values]\n  return color_mapping, new_value_ranges\n\ndef convert_csvs_to_images():\n    global fixed_value_ranges\n    data = pd.read_csv(\"/home/chetana/gridmet_test_run/test_data_predicted.csv\")\n#     print(data.head())\n    print(\"statistic of predicted_swe: \", data['predicted_swe'].describe())\n    data['predicted_swe'].fillna(0, inplace=True)\n    #data['predicted_swe'] = data['predicted_swe'].apply(lambda x: 0 if x < 2 else x)\n    \n#     for column in data.columns:\n#       column_data = data[column]\n#       description = column_data.describe()\n\n#       # Print or process the description as needed\n#       print(f\"Column: {column}\")\n#       print(description)\n    \n    # Create a figure with a white background\n    fig = plt.figure(facecolor='white')\n\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    print(\"data['lon'].values = \", data['lon'].values)\n    x, y = m(data['lon'].values, data['lat'].values)\n#     print(\"x = \", x)\n#     print(\"y = \", y)\n#     print(\"v = \", data['predicted_swe'].values)\n    print(data.columns)\n\n    color_mapping, value_ranges = create_color_maps_with_value_range(data[\"predicted_swe\"], fixed_value_ranges)\n    \n    # Plot the data using the custom colormap\n    plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\n    \n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_date = datetime(1900, 1, 1)\n    day_value = day_index\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    timestamp_string = result_date.strftime(\"%Y-%m-%d\")\n    \n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    # Create custom legend elements using the same colormap\n    legend_elements = [Patch(color=colors[i], label=f\"{value_ranges[i]} - {value_ranges[i+1]-1}\" if i < len(value_ranges) - 1 else f\"> {value_ranges[-1]}\") for i in range(len(value_ranges))]\n\n    # Create the legend outside the map\n    legend = plt.legend(handles=legend_elements, loc='upper left', title='Legend', fontsize=8)\n    legend.set_bbox_to_anchor((1.01, 1)) \n\n    # Remove the color bar\n    #plt.colorbar().remove()\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Set the aspect ratio to 'equal' to keep the plot at the center\n    plt.gca().set_aspect('equal', adjustable='box')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15, right=0.80)  # Adjust right margin to accommodate the legend\n    # Show the plot or save it to a file\n    new_plot_path = f'/home/chetana/gridmet_test_run/predicted_swe-{test_start_date}.png'\n    print(f\"The new plot is saved to {new_plot_path}\")\n    plt.savefig(new_plot_path)\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "/home/chetana/gw-workspace/Pz7LF7gtc9sx/convert_results_to_images.py:101: UserWarning: No data for colormapping provided via 'c'. Parameters 'cmap' will be ignored\n  plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\ntoday date = 2023-09-24\ntest start date:  2022-02-22\ntest end date:  2023-09-24\n/home/chetana\nstatistic of predicted_swe:  count    288650.000000\nmean          9.091466\nstd           1.400055\nmin           1.532000\n25%           9.317000\n50%           9.648000\n75%           9.790000\nmax           9.964000\nName: predicted_swe, dtype: float64\ndata['lon'].values =  [-125.    -124.964 -124.928 ... -100.124 -100.088 -100.052]\nIndex(['date', 'lat', 'lon', 'SWE', 'Flag', 'air_temperature_tmmn',\n       'potential_evapotranspiration', 'mean_vapor_pressure_deficit',\n       'relative_humidity_rmax', 'relative_humidity_rmin',\n       'precipitation_amount', 'air_temperature_tmmx', 'wind_speed',\n       'elevation', 'slope', 'curvature', 'aspect', 'eastness', 'northness',\n       'predicted_swe'],\n      dtype='object')\nThe new plot is saved to /home/chetana/gridmet_test_run/predicted_swe-2022-02-22.png\n",
  "history_begin_time" : 1695530478449,
  "history_end_time" : 1695530487389,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "N9eu5xKdNaJa",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport uuid\nfrom snowcast_utils import day_index\nimport matplotlib.colors as mcolors\nfrom matplotlib.patches import Patch\nfrom snowcast_utils import day_index, work_dir, test_start_date\n\n# Define the custom colormap with specified colors and ranges\ncolors = [\n    (0.8627, 0.8627, 0.8627),  # #DCDCDC - 0 - 1\n    (0.8627, 1.0000, 1.0000),  # #DCFFFF - 1 - 2\n    (0.6000, 1.0000, 1.0000),  # #99FFFF - 2 - 4\n    (0.5569, 0.8235, 1.0000),  # #8ED2FF - 4 - 6\n    (0.4509, 0.6196, 0.8745),  # #739EDF - 6 - 8\n    (0.4157, 0.4706, 1.0000),  # #6A78FF - 8 - 10\n    (0.4235, 0.2784, 1.0000),  # #6C47FF - 10 - 12\n    (0.5529, 0.0980, 1.0000),  # #8D19FF - 12 - 14\n    (0.7333, 0.0000, 0.9176),  # #BB00EA - 14 - 16\n    (0.8392, 0.0000, 0.7490),  # #D600BF - 16 - 18\n    (0.7569, 0.0039, 0.4549),  # #C10074 - 18 - 20\n    (0.6784, 0.0000, 0.1961),  # #AD0032 - 20 - 30\n    (0.5020, 0.0000, 0.0000)   # #800000 - > 30\n]\n\ncmap_name = 'custom_snow_colormap'\ncustom_cmap = mcolors.ListedColormap(colors)\n\n# Define the lat_lon_to_map_coordinates function\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\n# Define your value ranges for color mapping\nfixed_value_ranges = [1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 30]\n#value_ranges = [0.1, 0.2, 0.4, 0.6, 0.8, 1.0, 1.2, 1.5, 1.8, 2, 2.5, 3]\n\ndef create_color_maps_with_value_range(df_col, value_ranges=None):\n  new_value_ranges = fixed_value_ranges\n  if value_ranges == None:\n    max_value = df_col.max()\n    min_value = df_col.min()\n    if min_value < 0:\n      min_value = 0\n    step_size = (max_value - min_value) / 12\n\n    # Create 10 periods\n    new_value_ranges = [min_value + i * step_size for i in range(12)]\n  # Define your custom function to map data values to colors\n  def map_value_to_color(value):\n    # Iterate through the value ranges to find the appropriate color index\n    for i, range_max in enumerate(new_value_ranges):\n      if value <= range_max:\n        return colors[i]\n\n      # If the value is greater than the largest range, return the last color\n      return colors[-1]\n\n    # Map predicted_swe values to colors using the custom function\n  color_mapping = [map_value_to_color(value) for value in df_col.values]\n  return color_mapping, new_value_ranges\n\ndef convert_csvs_to_images():\n    global fixed_value_ranges\n    data = pd.read_csv(\"/home/chetana/gridmet_test_run/test_data_predicted.csv\")\n#     print(data.head())\n    print(\"statistic of predicted_swe: \", data['predicted_swe'].describe())\n    data['predicted_swe'].fillna(0, inplace=True)\n    #data['predicted_swe'] = data['predicted_swe'].apply(lambda x: 0 if x < 2 else x)\n    \n#     for column in data.columns:\n#       column_data = data[column]\n#       description = column_data.describe()\n\n#       # Print or process the description as needed\n#       print(f\"Column: {column}\")\n#       print(description)\n    \n    # Create a figure with a white background\n    fig = plt.figure(facecolor='white')\n\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    print(\"data['lon'].values = \", data['lon'].values)\n    x, y = m(data['lon'].values, data['lat'].values)\n#     print(\"x = \", x)\n#     print(\"y = \", y)\n#     print(\"v = \", data['predicted_swe'].values)\n    print(data.columns)\n\n    color_mapping, value_ranges = create_color_maps_with_value_range(data[\"predicted_swe\"])\n    \n    # Plot the data using the custom colormap\n    plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\n    \n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_date = datetime(1900, 1, 1)\n    day_value = day_index\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    timestamp_string = result_date.strftime(\"%Y-%m-%d\")\n    \n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    # Create custom legend elements using the same colormap\n    legend_elements = [Patch(color=colors[i], label=f\"{value_ranges[i]} - {value_ranges[i+1]-1}\" if i < len(value_ranges) - 1 else f\"> {value_ranges[-1]}\") for i in range(len(value_ranges))]\n\n    # Create the legend outside the map\n    legend = plt.legend(handles=legend_elements, loc='upper left', title='Legend', fontsize=8)\n    legend.set_bbox_to_anchor((1.01, 1)) \n\n    # Remove the color bar\n    #plt.colorbar().remove()\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Set the aspect ratio to 'equal' to keep the plot at the center\n    plt.gca().set_aspect('equal', adjustable='box')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15, right=0.80)  # Adjust right margin to accommodate the legend\n    # Show the plot or save it to a file\n    new_plot_path = f'/home/chetana/gridmet_test_run/predicted_swe-{test_start_date}.png'\n    print(f\"The new plot is saved to {new_plot_path}\")\n    plt.savefig(new_plot_path)\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "/home/chetana/gw-workspace/N9eu5xKdNaJa/convert_results_to_images.py:101: UserWarning: No data for colormapping provided via 'c'. Parameters 'cmap' will be ignored\n  plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\ntoday date = 2023-09-24\ntest start date:  2022-02-22\ntest end date:  2023-09-24\n/home/chetana\nstatistic of predicted_swe:  count    288650.000000\nmean          9.091466\nstd           1.400055\nmin           1.532000\n25%           9.317000\n50%           9.648000\n75%           9.790000\nmax           9.964000\nName: predicted_swe, dtype: float64\ndata['lon'].values =  [-125.    -124.964 -124.928 ... -100.124 -100.088 -100.052]\nIndex(['date', 'lat', 'lon', 'SWE', 'Flag', 'air_temperature_tmmn',\n       'potential_evapotranspiration', 'mean_vapor_pressure_deficit',\n       'relative_humidity_rmax', 'relative_humidity_rmin',\n       'precipitation_amount', 'air_temperature_tmmx', 'wind_speed',\n       'elevation', 'slope', 'curvature', 'aspect', 'eastness', 'northness',\n       'predicted_swe'],\n      dtype='object')\nThe new plot is saved to /home/chetana/gridmet_test_run/predicted_swe-2022-02-22.png\n",
  "history_begin_time" : 1695530361298,
  "history_end_time" : 1695530370035,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "t0vUVia6U1Qz",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport uuid\nfrom snowcast_utils import day_index\nimport matplotlib.colors as mcolors\nfrom matplotlib.patches import Patch\nfrom snowcast_utils import day_index, work_dir, test_start_date\n\n# Define the custom colormap with specified colors and ranges\ncolors = [\n    (0.8627, 0.8627, 0.8627),  # #DCDCDC - 0 - 1\n    (0.8627, 1.0000, 1.0000),  # #DCFFFF - 1 - 2\n    (0.6000, 1.0000, 1.0000),  # #99FFFF - 2 - 4\n    (0.5569, 0.8235, 1.0000),  # #8ED2FF - 4 - 6\n    (0.4509, 0.6196, 0.8745),  # #739EDF - 6 - 8\n    (0.4157, 0.4706, 1.0000),  # #6A78FF - 8 - 10\n    (0.4235, 0.2784, 1.0000),  # #6C47FF - 10 - 12\n    (0.5529, 0.0980, 1.0000),  # #8D19FF - 12 - 14\n    (0.7333, 0.0000, 0.9176),  # #BB00EA - 14 - 16\n    (0.8392, 0.0000, 0.7490),  # #D600BF - 16 - 18\n    (0.7569, 0.0039, 0.4549),  # #C10074 - 18 - 20\n    (0.6784, 0.0000, 0.1961),  # #AD0032 - 20 - 30\n    (0.5020, 0.0000, 0.0000)   # #800000 - > 30\n]\n\ncmap_name = 'custom_snow_colormap'\ncustom_cmap = mcolors.ListedColormap(colors)\n\n# Define the lat_lon_to_map_coordinates function\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\n# Define your value ranges for color mapping\nfixed_value_ranges = [1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 30]\n#value_ranges = [0.1, 0.2, 0.4, 0.6, 0.8, 1.0, 1.2, 1.5, 1.8, 2, 2.5, 3]\n\ndef create_color_maps_with_value_range(df_col, value_ranges=None):\n  new_value_ranges = fixed_value_ranges\n  if value_ranges == None:\n    max_value = df_col.max()\n    min_value = df_col.min()\n    if min_value < 0:\n      min_value = 0\n    step_size = (max_value - min_value) / 12\n\n    # Create 10 periods\n    new_value_ranges = [min_value + i * step_size for i in range(12)]\n  # Define your custom function to map data values to colors\n  def map_value_to_color(value):\n    # Iterate through the value ranges to find the appropriate color index\n    for i, range_max in enumerate(new_value_ranges):\n      if value <= range_max:\n        return colors[i]\n\n      # If the value is greater than the largest range, return the last color\n      return colors[-1]\n\n    # Map predicted_swe values to colors using the custom function\n  color_mapping = [map_value_to_color(value) for value in df_col.values]\n  return color_mapping, new_value_ranges\n\ndef convert_csvs_to_images():\n    global fixed_value_ranges\n    data = pd.read_csv(\"/home/chetana/gridmet_test_run/test_data_predicted.csv\")\n#     print(data.head())\n    print(\"statistic of predicted_swe: \", data['predicted_swe'].describe())\n    data['predicted_swe'].fillna(0, inplace=True)\n    #data['predicted_swe'] = data['predicted_swe'].apply(lambda x: 0 if x < 2 else x)\n    \n#     for column in data.columns:\n#       column_data = data[column]\n#       description = column_data.describe()\n\n#       # Print or process the description as needed\n#       print(f\"Column: {column}\")\n#       print(description)\n    \n    # Create a figure with a white background\n    fig = plt.figure(facecolor='white')\n\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    print(\"data['lon'].values = \", data['lon'].values)\n    x, y = m(data['lon'].values, data['lat'].values)\n#     print(\"x = \", x)\n#     print(\"y = \", y)\n#     print(\"v = \", data['predicted_swe'].values)\n    print(data.columns)\n\n    color_mapping, value_ranges = create_color_maps_with_value_range(data[\"air_temperature_tmmn\"])\n    \n    # Plot the data using the custom colormap\n    plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\n    \n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_date = datetime(1900, 1, 1)\n    day_value = day_index\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    timestamp_string = result_date.strftime(\"%Y-%m-%d\")\n    \n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    # Create custom legend elements using the same colormap\n    legend_elements = [Patch(color=colors[i], label=f\"{value_ranges[i]} - {value_ranges[i+1]-1}\" if i < len(value_ranges) - 1 else f\"> {value_ranges[-1]}\") for i in range(len(value_ranges))]\n\n    # Create the legend outside the map\n    legend = plt.legend(handles=legend_elements, loc='upper left', title='Legend', fontsize=8)\n    legend.set_bbox_to_anchor((1.01, 1)) \n\n    # Remove the color bar\n    #plt.colorbar().remove()\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Set the aspect ratio to 'equal' to keep the plot at the center\n    plt.gca().set_aspect('equal', adjustable='box')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15, right=0.80)  # Adjust right margin to accommodate the legend\n    # Show the plot or save it to a file\n    new_plot_path = f'/home/chetana/gridmet_test_run/predicted_swe-{test_start_date}.png'\n    print(f\"The new plot is saved to {new_plot_path}\")\n    plt.savefig(new_plot_path)\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "/home/chetana/gw-workspace/t0vUVia6U1Qz/convert_results_to_images.py:101: UserWarning: No data for colormapping provided via 'c'. Parameters 'cmap' will be ignored\n  plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\ntoday date = 2023-09-24\ntest start date:  2022-02-22\ntest end date:  2023-09-24\n/home/chetana\nstatistic of predicted_swe:  count    288650.000000\nmean          9.091466\nstd           1.400055\nmin           1.532000\n25%           9.317000\n50%           9.648000\n75%           9.790000\nmax           9.964000\nName: predicted_swe, dtype: float64\ndata['lon'].values =  [-125.    -124.964 -124.928 ... -100.124 -100.088 -100.052]\nIndex(['date', 'lat', 'lon', 'SWE', 'Flag', 'air_temperature_tmmn',\n       'potential_evapotranspiration', 'mean_vapor_pressure_deficit',\n       'relative_humidity_rmax', 'relative_humidity_rmin',\n       'precipitation_amount', 'air_temperature_tmmx', 'wind_speed',\n       'elevation', 'slope', 'curvature', 'aspect', 'eastness', 'northness',\n       'predicted_swe'],\n      dtype='object')\nThe new plot is saved to /home/chetana/gridmet_test_run/predicted_swe-2022-02-22.png\n",
  "history_begin_time" : 1695529874132,
  "history_end_time" : 1695529883163,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "1scx9adsqqt",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport uuid\nfrom snowcast_utils import day_index\nimport matplotlib.colors as mcolors\nfrom matplotlib.patches import Patch\nfrom snowcast_utils import day_index, work_dir, test_start_date\n\n# Define the custom colormap with specified colors and ranges\ncolors = [\n    (0.8627, 0.8627, 0.8627),  # #DCDCDC - 0 - 1\n    (0.8627, 1.0000, 1.0000),  # #DCFFFF - 1 - 2\n    (0.6000, 1.0000, 1.0000),  # #99FFFF - 2 - 4\n    (0.5569, 0.8235, 1.0000),  # #8ED2FF - 4 - 6\n    (0.4509, 0.6196, 0.8745),  # #739EDF - 6 - 8\n    (0.4157, 0.4706, 1.0000),  # #6A78FF - 8 - 10\n    (0.4235, 0.2784, 1.0000),  # #6C47FF - 10 - 12\n    (0.5529, 0.0980, 1.0000),  # #8D19FF - 12 - 14\n    (0.7333, 0.0000, 0.9176),  # #BB00EA - 14 - 16\n    (0.8392, 0.0000, 0.7490),  # #D600BF - 16 - 18\n    (0.7569, 0.0039, 0.4549),  # #C10074 - 18 - 20\n    (0.6784, 0.0000, 0.1961),  # #AD0032 - 20 - 30\n    (0.5020, 0.0000, 0.0000)   # #800000 - > 30\n]\n\ncmap_name = 'custom_snow_colormap'\ncustom_cmap = mcolors.ListedColormap(colors)\n\n# Define the lat_lon_to_map_coordinates function\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\n# Define your value ranges for color mapping\nfixed_value_ranges = [1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 30]\n#value_ranges = [0.1, 0.2, 0.4, 0.6, 0.8, 1.0, 1.2, 1.5, 1.8, 2, 2.5, 3]\n\ndef create_color_maps_with_value_range(df_col, value_ranges=None):\n  new_value_ranges = fixed_value_ranges\n  if value_ranges == None:\n    max_value = df_col.max()\n    min_value = df_col.min()\n    if min_value < 0:\n      min_value = 0\n    step_size = (max_value - min_value) / 12\n\n    # Create 10 periods\n    new_value_ranges = [min_value + i * step_size for i in range(12)]\n  # Define your custom function to map data values to colors\n  def map_value_to_color(value):\n    # Iterate through the value ranges to find the appropriate color index\n    for i, range_max in enumerate(new_value_ranges):\n      if value <= range_max:\n        return colors[i]\n\n      # If the value is greater than the largest range, return the last color\n      return colors[-1]\n\n    # Map predicted_swe values to colors using the custom function\n  color_mapping = [map_value_to_color(value) for value in df_col.values]\n  return color_mapping, new_value_ranges\n\ndef convert_csvs_to_images():\n    global fixed_value_ranges\n    data = pd.read_csv(\"/home/chetana/gridmet_test_run/test_data_predicted.csv\")\n#     print(data.head())\n    print(\"statistic of predicted_swe: \", data['predicted_swe'].describe())\n    data['predicted_swe'].fillna(0, inplace=True)\n    #data['predicted_swe'] = data['predicted_swe'].apply(lambda x: 0 if x < 2 else x)\n    \n#     for column in data.columns:\n#       column_data = data[column]\n#       description = column_data.describe()\n\n#       # Print or process the description as needed\n#       print(f\"Column: {column}\")\n#       print(description)\n    \n    # Create a figure with a white background\n    fig = plt.figure(facecolor='white')\n\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    print(\"data['lon'].values = \", data['lon'].values)\n    x, y = m(data['lon'].values, data['lat'].values)\n#     print(\"x = \", x)\n#     print(\"y = \", y)\n#     print(\"v = \", data['predicted_swe'].values)\n    print(data.columns)\n\n    color_mapping, value_ranges = create_color_maps_with_value_range(data[\"predicted_swe\"], fixed_value_ranges)\n    \n    # Plot the data using the custom colormap\n    plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\n    \n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_date = datetime(1900, 1, 1)\n    day_value = day_index\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    timestamp_string = result_date.strftime(\"%Y-%m-%d\")\n    \n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    # Create custom legend elements using the same colormap\n    legend_elements = [Patch(color=colors[i], label=f\"{value_ranges[i]} - {value_ranges[i+1]-1}\" if i < len(value_ranges) - 1 else f\"> {value_ranges[-1]}\") for i in range(len(value_ranges))]\n\n    # Create the legend outside the map\n    legend = plt.legend(handles=legend_elements, loc='upper left', title='Legend', fontsize=8)\n    legend.set_bbox_to_anchor((1.01, 1)) \n\n    # Remove the color bar\n    #plt.colorbar().remove()\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Set the aspect ratio to 'equal' to keep the plot at the center\n    plt.gca().set_aspect('equal', adjustable='box')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15, right=0.80)  # Adjust right margin to accommodate the legend\n    # Show the plot or save it to a file\n    new_plot_path = f'/home/chetana/gridmet_test_run/predicted_swe-{test_start_date}.png'\n    print(f\"The new plot is saved to {new_plot_path}\")\n    plt.savefig(new_plot_path)\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "/home/chetana/gw-workspace/1scx9adsqqt/convert_results_to_images.py:101: UserWarning: No data for colormapping provided via 'c'. Parameters 'cmap' will be ignored\n  plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\ntoday date = 2023-09-24\ntest start date:  2022-02-22\ntest end date:  2023-09-24\n/home/chetana\nstatistic of predicted_swe:  count    288650.000000\nmean          9.091466\nstd           1.400055\nmin           1.532000\n25%           9.317000\n50%           9.648000\n75%           9.790000\nmax           9.964000\nName: predicted_swe, dtype: float64\ndata['lon'].values =  [-125.    -124.964 -124.928 ... -100.124 -100.088 -100.052]\nIndex(['date', 'lat', 'lon', 'SWE', 'Flag', 'air_temperature_tmmn',\n       'potential_evapotranspiration', 'mean_vapor_pressure_deficit',\n       'relative_humidity_rmax', 'relative_humidity_rmin',\n       'precipitation_amount', 'air_temperature_tmmx', 'wind_speed',\n       'elevation', 'slope', 'curvature', 'aspect', 'eastness', 'northness',\n       'predicted_swe'],\n      dtype='object')\nThe new plot is saved to /home/chetana/gridmet_test_run/predicted_swe-2022-02-22.png\n",
  "history_begin_time" : 1695529364403,
  "history_end_time" : 1695529374548,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "100001",
  "indicator" : "Done"
},{
  "history_id" : "vaE0w13auGWC",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport uuid\nfrom snowcast_utils import day_index\nimport matplotlib.colors as mcolors\nfrom matplotlib.patches import Patch\nfrom snowcast_utils import day_index, work_dir, test_start_date\n\n# Define the custom colormap with specified colors and ranges\ncolors = [\n    (0.8627, 0.8627, 0.8627),  # #DCDCDC - 0 - 1\n    (0.8627, 1.0000, 1.0000),  # #DCFFFF - 1 - 2\n    (0.6000, 1.0000, 1.0000),  # #99FFFF - 2 - 4\n    (0.5569, 0.8235, 1.0000),  # #8ED2FF - 4 - 6\n    (0.4509, 0.6196, 0.8745),  # #739EDF - 6 - 8\n    (0.4157, 0.4706, 1.0000),  # #6A78FF - 8 - 10\n    (0.4235, 0.2784, 1.0000),  # #6C47FF - 10 - 12\n    (0.5529, 0.0980, 1.0000),  # #8D19FF - 12 - 14\n    (0.7333, 0.0000, 0.9176),  # #BB00EA - 14 - 16\n    (0.8392, 0.0000, 0.7490),  # #D600BF - 16 - 18\n    (0.7569, 0.0039, 0.4549),  # #C10074 - 18 - 20\n    (0.6784, 0.0000, 0.1961),  # #AD0032 - 20 - 30\n    (0.5020, 0.0000, 0.0000)   # #800000 - > 30\n]\n\ncmap_name = 'custom_snow_colormap'\ncustom_cmap = mcolors.ListedColormap(colors)\n\n# Define the lat_lon_to_map_coordinates function\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\n# Define your value ranges for color mapping\nfixed_value_ranges = [1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 30]\n#value_ranges = [0.1, 0.2, 0.4, 0.6, 0.8, 1.0, 1.2, 1.5, 1.8, 2, 2.5, 3]\n\ndef create_color_maps_with_value_range(df_col, value_ranges=None):\n  new_value_ranges = fixed_value_ranges\n  if value_ranges == None:\n    max_value = df_col.max()\n    min_value = df_col.min()\n    if min_value < 0:\n      min_value = 0\n    step_size = (max_value - min_value) / 12\n\n    # Create 10 periods\n    new_value_ranges = [min_value + i * step_size for i in range(12)]\n  # Define your custom function to map data values to colors\n  def map_value_to_color(value):\n    # Iterate through the value ranges to find the appropriate color index\n    for i, range_max in enumerate(new_value_ranges):\n      if value <= range_max:\n        return colors[i]\n\n      # If the value is greater than the largest range, return the last color\n      return colors[-1]\n\n    # Map predicted_swe values to colors using the custom function\n  color_mapping = [map_value_to_color(value) for value in df_col.values]\n  return color_mapping, new_value_ranges\n\ndef convert_csvs_to_images():\n    global fixed_value_ranges\n    data = pd.read_csv(\"/home/chetana/gridmet_test_run/test_data_predicted.csv\")\n#     print(data.head())\n    print(\"statistic of predicted_swe: \", data['predicted_swe'].describe())\n    data['predicted_swe'].fillna(0, inplace=True)\n    #data['predicted_swe'] = data['predicted_swe'].apply(lambda x: 0 if x < 2 else x)\n    \n#     for column in data.columns:\n#       column_data = data[column]\n#       description = column_data.describe()\n\n#       # Print or process the description as needed\n#       print(f\"Column: {column}\")\n#       print(description)\n    \n    # Create a figure with a white background\n    fig = plt.figure(facecolor='white')\n\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    print(\"data['lon'].values = \", data['lon'].values)\n    x, y = m(data['lon'].values, data['lat'].values)\n#     print(\"x = \", x)\n#     print(\"y = \", y)\n#     print(\"v = \", data['predicted_swe'].values)\n    print(data.columns)\n\n    color_mapping, value_ranges = create_color_maps_with_value_range(data[\"predicted_swe\"], fixed_value_ranges)\n    \n    # Plot the data using the custom colormap\n    plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\n    \n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_date = datetime(1900, 1, 1)\n    day_value = day_index\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    timestamp_string = result_date.strftime(\"%Y-%m-%d\")\n    \n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    # Create custom legend elements using the same colormap\n    legend_elements = [Patch(color=colors[i], label=f\"{value_ranges[i]} - {value_ranges[i+1]-1}\" if i < len(value_ranges) - 1 else f\"> {value_ranges[-1]}\") for i in range(len(value_ranges))]\n\n    # Create the legend outside the map\n    legend = plt.legend(handles=legend_elements, loc='upper left', title='Legend', fontsize=8)\n    legend.set_bbox_to_anchor((1.01, 1)) \n\n    # Remove the color bar\n    #plt.colorbar().remove()\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Set the aspect ratio to 'equal' to keep the plot at the center\n    plt.gca().set_aspect('equal', adjustable='box')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15, right=0.80)  # Adjust right margin to accommodate the legend\n    # Show the plot or save it to a file\n    new_plot_path = f'/home/chetana/gridmet_test_run/predicted_swe-{test_start_date}.png'\n    print(f\"The new plot is saved to {new_plot_path}\")\n    plt.savefig(new_plot_path)\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "/home/chetana/gw-workspace/vaE0w13auGWC/convert_results_to_images.py:101: UserWarning: No data for colormapping provided via 'c'. Parameters 'cmap' will be ignored\n  plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\ntoday date = 2023-09-24\ntest start date:  2022-08-22\ntest end date:  2023-09-24\n/home/chetana\nstatistic of predicted_swe:  count    288650.000000\nmean          0.003739\nstd           0.022082\nmin           0.000000\n25%           0.000000\n50%           0.000000\n75%           0.000000\nmax           1.141000\nName: predicted_swe, dtype: float64\ndata['lon'].values =  [-125.    -124.964 -124.928 ... -100.124 -100.088 -100.052]\nIndex(['date', 'lat', 'lon', 'SWE', 'Flag', 'air_temperature_tmmn',\n       'potential_evapotranspiration', 'mean_vapor_pressure_deficit',\n       'relative_humidity_rmax', 'relative_humidity_rmin',\n       'precipitation_amount', 'air_temperature_tmmx', 'wind_speed',\n       'elevation', 'slope', 'curvature', 'aspect', 'eastness', 'northness',\n       'predicted_swe'],\n      dtype='object')\nThe new plot is saved to /home/chetana/gridmet_test_run/predicted_swe-2022-08-22.png\n",
  "history_begin_time" : 1695529050438,
  "history_end_time" : 1695529059159,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "8sq1vgLA0hzz",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport uuid\nfrom snowcast_utils import day_index\nimport matplotlib.colors as mcolors\nfrom matplotlib.patches import Patch\nfrom snowcast_utils import day_index, work_dir, test_start_date\n\n# Define the custom colormap with specified colors and ranges\ncolors = [\n    (0.8627, 0.8627, 0.8627),  # #DCDCDC - 0 - 1\n    (0.8627, 1.0000, 1.0000),  # #DCFFFF - 1 - 2\n    (0.6000, 1.0000, 1.0000),  # #99FFFF - 2 - 4\n    (0.5569, 0.8235, 1.0000),  # #8ED2FF - 4 - 6\n    (0.4509, 0.6196, 0.8745),  # #739EDF - 6 - 8\n    (0.4157, 0.4706, 1.0000),  # #6A78FF - 8 - 10\n    (0.4235, 0.2784, 1.0000),  # #6C47FF - 10 - 12\n    (0.5529, 0.0980, 1.0000),  # #8D19FF - 12 - 14\n    (0.7333, 0.0000, 0.9176),  # #BB00EA - 14 - 16\n    (0.8392, 0.0000, 0.7490),  # #D600BF - 16 - 18\n    (0.7569, 0.0039, 0.4549),  # #C10074 - 18 - 20\n    (0.6784, 0.0000, 0.1961),  # #AD0032 - 20 - 30\n    (0.5020, 0.0000, 0.0000)   # #800000 - > 30\n]\n\ncmap_name = 'custom_snow_colormap'\ncustom_cmap = mcolors.ListedColormap(colors)\n\n# Define the lat_lon_to_map_coordinates function\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\n# Define your value ranges for color mapping\nfixed_value_ranges = [1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 30]\n#value_ranges = [0.1, 0.2, 0.4, 0.6, 0.8, 1.0, 1.2, 1.5, 1.8, 2, 2.5, 3]\n\ndef create_color_maps_with_value_range(df_col, value_ranges=None):\n  if value_ranges == None:\n    max_value = df_col.max()\n    min_value = df_col.min()\n    if min_value < 0:\n      min_value = 0\n    step_size = (max_value - min_value) / 12\n\n    # Create 10 periods\n    new_value_ranges = [min_value + i * step_size for i in range(12)]\n  # Define your custom function to map data values to colors\n  def map_value_to_color(value, new_value_ranges):\n    # Iterate through the value ranges to find the appropriate color index\n    for i, range_max in enumerate(new_value_ranges):\n      if value <= range_max:\n        return colors[i]\n\n      # If the value is greater than the largest range, return the last color\n      return colors[-1]\n\n    # Map predicted_swe values to colors using the custom function\n  color_mapping = [map_value_to_color(value, new_value_ranges) for value in df_col.values]\n  return color_mapping, new_value_ranges\n\ndef convert_csvs_to_images():\n    global fixed_value_ranges\n    data = pd.read_csv(\"/home/chetana/gridmet_test_run/test_data_predicted.csv\")\n#     print(data.head())\n    print(\"statistic of predicted_swe: \", data['predicted_swe'].describe())\n    data['predicted_swe'].fillna(0, inplace=True)\n    #data['predicted_swe'] = data['predicted_swe'].apply(lambda x: 0 if x < 2 else x)\n    \n#     for column in data.columns:\n#       column_data = data[column]\n#       description = column_data.describe()\n\n#       # Print or process the description as needed\n#       print(f\"Column: {column}\")\n#       print(description)\n    \n    # Create a figure with a white background\n    fig = plt.figure(facecolor='white')\n\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    print(\"data['lon'].values = \", data['lon'].values)\n    x, y = m(data['lon'].values, data['lat'].values)\n#     print(\"x = \", x)\n#     print(\"y = \", y)\n#     print(\"v = \", data['predicted_swe'].values)\n    print(data.columns)\n\n    color_mapping, value_ranges = create_color_maps_with_value_range(data[\"predicted_swe\"], fixed_value_ranges)\n    \n    # Plot the data using the custom colormap\n    plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\n    \n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_date = datetime(1900, 1, 1)\n    day_value = day_index\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    timestamp_string = result_date.strftime(\"%Y-%m-%d\")\n    \n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    # Create custom legend elements using the same colormap\n    legend_elements = [Patch(color=colors[i], label=f\"{value_ranges[i]} - {value_ranges[i+1]-1}\" if i < len(value_ranges) - 1 else f\"> {value_ranges[-1]}\") for i in range(len(value_ranges))]\n\n    # Create the legend outside the map\n    legend = plt.legend(handles=legend_elements, loc='upper left', title='Legend', fontsize=8)\n    legend.set_bbox_to_anchor((1.01, 1)) \n\n    # Remove the color bar\n    #plt.colorbar().remove()\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Set the aspect ratio to 'equal' to keep the plot at the center\n    plt.gca().set_aspect('equal', adjustable='box')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15, right=0.80)  # Adjust right margin to accommodate the legend\n    # Show the plot or save it to a file\n    new_plot_path = f'/home/chetana/gridmet_test_run/predicted_swe-{test_start_date}.png'\n    print(f\"The new plot is saved to {new_plot_path}\")\n    plt.savefig(new_plot_path)\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "today date = 2023-09-24\ntest start date:  2022-08-22\ntest end date:  2023-09-24\n/home/chetana\nstatistic of predicted_swe:  count    288650.000000\nmean          0.003739\nstd           0.022082\nmin           0.000000\n25%           0.000000\n50%           0.000000\n75%           0.000000\nmax           1.141000\nName: predicted_swe, dtype: float64\ndata['lon'].values =  [-125.    -124.964 -124.928 ... -100.124 -100.088 -100.052]\nIndex(['date', 'lat', 'lon', 'SWE', 'Flag', 'air_temperature_tmmn',\n       'potential_evapotranspiration', 'mean_vapor_pressure_deficit',\n       'relative_humidity_rmax', 'relative_humidity_rmin',\n       'precipitation_amount', 'air_temperature_tmmx', 'wind_speed',\n       'elevation', 'slope', 'curvature', 'aspect', 'eastness', 'northness',\n       'predicted_swe'],\n      dtype='object')\nTraceback (most recent call last):\n  File \"/home/chetana/gw-workspace/8sq1vgLA0hzz/convert_results_to_images.py\", line 165, in <module>\n    convert_csvs_to_images()\n  File \"/home/chetana/gw-workspace/8sq1vgLA0hzz/convert_results_to_images.py\", line 97, in convert_csvs_to_images\n    color_mapping, value_ranges = create_color_maps_with_value_range(data[\"predicted_swe\"], fixed_value_ranges)\n  File \"/home/chetana/gw-workspace/8sq1vgLA0hzz/convert_results_to_images.py\", line 62, in create_color_maps_with_value_range\n    color_mapping = [map_value_to_color(value, new_value_ranges) for value in df_col.values]\n  File \"/home/chetana/gw-workspace/8sq1vgLA0hzz/convert_results_to_images.py\", line 62, in <listcomp>\n    color_mapping = [map_value_to_color(value, new_value_ranges) for value in df_col.values]\nNameError: free variable 'new_value_ranges' referenced before assignment in enclosing scope\n",
  "history_begin_time" : 1695528954697,
  "history_end_time" : 1695528958536,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Failed"
},{
  "history_id" : "WFHzHcwYY1FZ",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport uuid\nfrom snowcast_utils import day_index\nimport matplotlib.colors as mcolors\nfrom matplotlib.patches import Patch\nfrom snowcast_utils import day_index, work_dir, test_start_date\n\n# Define the custom colormap with specified colors and ranges\ncolors = [\n    (0.8627, 0.8627, 0.8627),  # #DCDCDC - 0 - 1\n    (0.8627, 1.0000, 1.0000),  # #DCFFFF - 1 - 2\n    (0.6000, 1.0000, 1.0000),  # #99FFFF - 2 - 4\n    (0.5569, 0.8235, 1.0000),  # #8ED2FF - 4 - 6\n    (0.4509, 0.6196, 0.8745),  # #739EDF - 6 - 8\n    (0.4157, 0.4706, 1.0000),  # #6A78FF - 8 - 10\n    (0.4235, 0.2784, 1.0000),  # #6C47FF - 10 - 12\n    (0.5529, 0.0980, 1.0000),  # #8D19FF - 12 - 14\n    (0.7333, 0.0000, 0.9176),  # #BB00EA - 14 - 16\n    (0.8392, 0.0000, 0.7490),  # #D600BF - 16 - 18\n    (0.7569, 0.0039, 0.4549),  # #C10074 - 18 - 20\n    (0.6784, 0.0000, 0.1961),  # #AD0032 - 20 - 30\n    (0.5020, 0.0000, 0.0000)   # #800000 - > 30\n]\n\ncmap_name = 'custom_snow_colormap'\ncustom_cmap = mcolors.ListedColormap(colors)\n\n# Define the lat_lon_to_map_coordinates function\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\n# Define your value ranges for color mapping\nfixed_value_ranges = [1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 30]\n#value_ranges = [0.1, 0.2, 0.4, 0.6, 0.8, 1.0, 1.2, 1.5, 1.8, 2, 2.5, 3]\n\ndef create_color_maps_with_value_range(df_col, value_ranges=None):\n  if value_ranges == None:\n    max_value = df_col.max()\n    min_value = df_col.min()\n    if min_value < 0:\n      min_value = 0\n    step_size = (max_value - min_value) / 12\n\n    # Create 10 periods\n    new_value_ranges = [min_value + i * step_size for i in range(12)]\n  # Define your custom function to map data values to colors\n  def map_value_to_color(value):\n    global new_value_ranges\n    # Iterate through the value ranges to find the appropriate color index\n    for i, range_max in enumerate(new_value_ranges):\n      if value <= range_max:\n        return colors[i]\n\n      # If the value is greater than the largest range, return the last color\n      return colors[-1]\n\n    # Map predicted_swe values to colors using the custom function\n  color_mapping = [map_value_to_color(value) for value in df_col.values]\n  return color_mapping, new_value_ranges\n\ndef convert_csvs_to_images():\n    global fixed_value_ranges\n    data = pd.read_csv(\"/home/chetana/gridmet_test_run/test_data_predicted.csv\")\n#     print(data.head())\n    print(\"statistic of predicted_swe: \", data['predicted_swe'].describe())\n    data['predicted_swe'].fillna(0, inplace=True)\n    #data['predicted_swe'] = data['predicted_swe'].apply(lambda x: 0 if x < 2 else x)\n    \n#     for column in data.columns:\n#       column_data = data[column]\n#       description = column_data.describe()\n\n#       # Print or process the description as needed\n#       print(f\"Column: {column}\")\n#       print(description)\n    \n    # Create a figure with a white background\n    fig = plt.figure(facecolor='white')\n\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    print(\"data['lon'].values = \", data['lon'].values)\n    x, y = m(data['lon'].values, data['lat'].values)\n#     print(\"x = \", x)\n#     print(\"y = \", y)\n#     print(\"v = \", data['predicted_swe'].values)\n    print(data.columns)\n\n    color_mapping, value_ranges = create_color_maps_with_value_range(data[\"predicted_swe\"], fixed_value_ranges)\n    \n    # Plot the data using the custom colormap\n    plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\n    \n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_date = datetime(1900, 1, 1)\n    day_value = day_index\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    timestamp_string = result_date.strftime(\"%Y-%m-%d\")\n    \n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    # Create custom legend elements using the same colormap\n    legend_elements = [Patch(color=colors[i], label=f\"{value_ranges[i]} - {value_ranges[i+1]-1}\" if i < len(value_ranges) - 1 else f\"> {value_ranges[-1]}\") for i in range(len(value_ranges))]\n\n    # Create the legend outside the map\n    legend = plt.legend(handles=legend_elements, loc='upper left', title='Legend', fontsize=8)\n    legend.set_bbox_to_anchor((1.01, 1)) \n\n    # Remove the color bar\n    #plt.colorbar().remove()\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Set the aspect ratio to 'equal' to keep the plot at the center\n    plt.gca().set_aspect('equal', adjustable='box')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15, right=0.80)  # Adjust right margin to accommodate the legend\n    # Show the plot or save it to a file\n    new_plot_path = f'/home/chetana/gridmet_test_run/predicted_swe-{test_start_date}.png'\n    print(f\"The new plot is saved to {new_plot_path}\")\n    plt.savefig(new_plot_path)\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "today date = 2023-09-24\ntest start date:  2022-08-22\ntest end date:  2023-09-24\n/home/chetana\nstatistic of predicted_swe:  count    288650.000000\nmean          0.003739\nstd           0.022082\nmin           0.000000\n25%           0.000000\n50%           0.000000\n75%           0.000000\nmax           1.141000\nName: predicted_swe, dtype: float64\ndata['lon'].values =  [-125.    -124.964 -124.928 ... -100.124 -100.088 -100.052]\nIndex(['date', 'lat', 'lon', 'SWE', 'Flag', 'air_temperature_tmmn',\n       'potential_evapotranspiration', 'mean_vapor_pressure_deficit',\n       'relative_humidity_rmax', 'relative_humidity_rmin',\n       'precipitation_amount', 'air_temperature_tmmx', 'wind_speed',\n       'elevation', 'slope', 'curvature', 'aspect', 'eastness', 'northness',\n       'predicted_swe'],\n      dtype='object')\nTraceback (most recent call last):\n  File \"/home/chetana/gw-workspace/WFHzHcwYY1FZ/convert_results_to_images.py\", line 166, in <module>\n    convert_csvs_to_images()\n  File \"/home/chetana/gw-workspace/WFHzHcwYY1FZ/convert_results_to_images.py\", line 98, in convert_csvs_to_images\n    color_mapping, value_ranges = create_color_maps_with_value_range(data[\"predicted_swe\"], fixed_value_ranges)\n  File \"/home/chetana/gw-workspace/WFHzHcwYY1FZ/convert_results_to_images.py\", line 63, in create_color_maps_with_value_range\n    color_mapping = [map_value_to_color(value) for value in df_col.values]\n  File \"/home/chetana/gw-workspace/WFHzHcwYY1FZ/convert_results_to_images.py\", line 63, in <listcomp>\n    color_mapping = [map_value_to_color(value) for value in df_col.values]\n  File \"/home/chetana/gw-workspace/WFHzHcwYY1FZ/convert_results_to_images.py\", line 55, in map_value_to_color\n    for i, range_max in enumerate(new_value_ranges):\nNameError: name 'new_value_ranges' is not defined\n",
  "history_begin_time" : 1695528905159,
  "history_end_time" : 1695528908992,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Failed"
},{
  "history_id" : "mwZfB1hFVObm",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport uuid\nfrom snowcast_utils import day_index\nimport matplotlib.colors as mcolors\nfrom matplotlib.patches import Patch\nfrom snowcast_utils import day_index, work_dir, test_start_date\n\n# Define the custom colormap with specified colors and ranges\ncolors = [\n    (0.8627, 0.8627, 0.8627),  # #DCDCDC - 0 - 1\n    (0.8627, 1.0000, 1.0000),  # #DCFFFF - 1 - 2\n    (0.6000, 1.0000, 1.0000),  # #99FFFF - 2 - 4\n    (0.5569, 0.8235, 1.0000),  # #8ED2FF - 4 - 6\n    (0.4509, 0.6196, 0.8745),  # #739EDF - 6 - 8\n    (0.4157, 0.4706, 1.0000),  # #6A78FF - 8 - 10\n    (0.4235, 0.2784, 1.0000),  # #6C47FF - 10 - 12\n    (0.5529, 0.0980, 1.0000),  # #8D19FF - 12 - 14\n    (0.7333, 0.0000, 0.9176),  # #BB00EA - 14 - 16\n    (0.8392, 0.0000, 0.7490),  # #D600BF - 16 - 18\n    (0.7569, 0.0039, 0.4549),  # #C10074 - 18 - 20\n    (0.6784, 0.0000, 0.1961),  # #AD0032 - 20 - 30\n    (0.5020, 0.0000, 0.0000)   # #800000 - > 30\n]\n\ncmap_name = 'custom_snow_colormap'\ncustom_cmap = mcolors.ListedColormap(colors)\n\n# Define the lat_lon_to_map_coordinates function\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\n# Define your value ranges for color mapping\nfixed_value_ranges = [1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 30]\n#value_ranges = [0.1, 0.2, 0.4, 0.6, 0.8, 1.0, 1.2, 1.5, 1.8, 2, 2.5, 3]\n\ndef create_color_maps_with_value_range(df_col, value_ranges=None):\n  if value_ranges == None:\n    max_value = df_col.max()\n    min_value = df_col.min()\n    if min_value < 0:\n      min_value = 0\n    step_size = (max_value - min_value) / 12\n\n    # Create 10 periods\n    new_value_ranges = [min_value + i * step_size for i in range(12)]\n  # Define your custom function to map data values to colors\n  def map_value_to_color(value):\n    # Iterate through the value ranges to find the appropriate color index\n    for i, range_max in enumerate(new_value_ranges):\n      if value <= range_max:\n        return colors[i]\n\n      # If the value is greater than the largest range, return the last color\n      return colors[-1]\n\n    # Map predicted_swe values to colors using the custom function\n  color_mapping = [map_value_to_color(value) for value in df_col.values]\n  return color_mapping, new_value_ranges\n\ndef convert_csvs_to_images():\n    global fixed_value_ranges\n    data = pd.read_csv(\"/home/chetana/gridmet_test_run/test_data_predicted.csv\")\n#     print(data.head())\n    print(\"statistic of predicted_swe: \", data['predicted_swe'].describe())\n    data['predicted_swe'].fillna(0, inplace=True)\n    #data['predicted_swe'] = data['predicted_swe'].apply(lambda x: 0 if x < 2 else x)\n    \n#     for column in data.columns:\n#       column_data = data[column]\n#       description = column_data.describe()\n\n#       # Print or process the description as needed\n#       print(f\"Column: {column}\")\n#       print(description)\n    \n    # Create a figure with a white background\n    fig = plt.figure(facecolor='white')\n\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    print(\"data['lon'].values = \", data['lon'].values)\n    x, y = m(data['lon'].values, data['lat'].values)\n#     print(\"x = \", x)\n#     print(\"y = \", y)\n#     print(\"v = \", data['predicted_swe'].values)\n    print(data.columns)\n\n    color_mapping, value_ranges = create_color_maps_with_value_range(data[\"predicted_swe\"], fixed_value_ranges)\n    \n    # Plot the data using the custom colormap\n    plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\n    \n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_date = datetime(1900, 1, 1)\n    day_value = day_index\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    timestamp_string = result_date.strftime(\"%Y-%m-%d\")\n    \n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    # Create custom legend elements using the same colormap\n    legend_elements = [Patch(color=colors[i], label=f\"{value_ranges[i]} - {value_ranges[i+1]-1}\" if i < len(value_ranges) - 1 else f\"> {value_ranges[-1]}\") for i in range(len(value_ranges))]\n\n    # Create the legend outside the map\n    legend = plt.legend(handles=legend_elements, loc='upper left', title='Legend', fontsize=8)\n    legend.set_bbox_to_anchor((1.01, 1)) \n\n    # Remove the color bar\n    #plt.colorbar().remove()\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Set the aspect ratio to 'equal' to keep the plot at the center\n    plt.gca().set_aspect('equal', adjustable='box')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15, right=0.80)  # Adjust right margin to accommodate the legend\n    # Show the plot or save it to a file\n    new_plot_path = f'/home/chetana/gridmet_test_run/predicted_swe-{test_start_date}.png'\n    print(f\"The new plot is saved to {new_plot_path}\")\n    plt.savefig(new_plot_path)\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "today date = 2023-09-24\ntest start date:  2022-08-22\ntest end date:  2023-09-24\n/home/chetana\nstatistic of predicted_swe:  count    288650.000000\nmean          0.003739\nstd           0.022082\nmin           0.000000\n25%           0.000000\n50%           0.000000\n75%           0.000000\nmax           1.141000\nName: predicted_swe, dtype: float64\ndata['lon'].values =  [-125.    -124.964 -124.928 ... -100.124 -100.088 -100.052]\nIndex(['date', 'lat', 'lon', 'SWE', 'Flag', 'air_temperature_tmmn',\n       'potential_evapotranspiration', 'mean_vapor_pressure_deficit',\n       'relative_humidity_rmax', 'relative_humidity_rmin',\n       'precipitation_amount', 'air_temperature_tmmx', 'wind_speed',\n       'elevation', 'slope', 'curvature', 'aspect', 'eastness', 'northness',\n       'predicted_swe'],\n      dtype='object')\nTraceback (most recent call last):\n  File \"/home/chetana/gw-workspace/mwZfB1hFVObm/convert_results_to_images.py\", line 165, in <module>\n    convert_csvs_to_images()\n  File \"/home/chetana/gw-workspace/mwZfB1hFVObm/convert_results_to_images.py\", line 97, in convert_csvs_to_images\n    color_mapping, value_ranges = create_color_maps_with_value_range(data[\"predicted_swe\"], fixed_value_ranges)\n  File \"/home/chetana/gw-workspace/mwZfB1hFVObm/convert_results_to_images.py\", line 62, in create_color_maps_with_value_range\n    color_mapping = [map_value_to_color(value) for value in df_col.values]\n  File \"/home/chetana/gw-workspace/mwZfB1hFVObm/convert_results_to_images.py\", line 62, in <listcomp>\n    color_mapping = [map_value_to_color(value) for value in df_col.values]\n  File \"/home/chetana/gw-workspace/mwZfB1hFVObm/convert_results_to_images.py\", line 54, in map_value_to_color\n    for i, range_max in enumerate(new_value_ranges):\nNameError: free variable 'new_value_ranges' referenced before assignment in enclosing scope\n",
  "history_begin_time" : 1695528758263,
  "history_end_time" : 1695528762125,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Failed"
},{
  "history_id" : "tHSHKIe3L8jo",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport uuid\nfrom snowcast_utils import day_index\nimport matplotlib.colors as mcolors\nfrom matplotlib.patches import Patch\nfrom snowcast_utils import day_index, work_dir, test_start_date\n\n# Define the custom colormap with specified colors and ranges\ncolors = [\n    (0.8627, 0.8627, 0.8627),  # #DCDCDC - 0 - 1\n    (0.8627, 1.0000, 1.0000),  # #DCFFFF - 1 - 2\n    (0.6000, 1.0000, 1.0000),  # #99FFFF - 2 - 4\n    (0.5569, 0.8235, 1.0000),  # #8ED2FF - 4 - 6\n    (0.4509, 0.6196, 0.8745),  # #739EDF - 6 - 8\n    (0.4157, 0.4706, 1.0000),  # #6A78FF - 8 - 10\n    (0.4235, 0.2784, 1.0000),  # #6C47FF - 10 - 12\n    (0.5529, 0.0980, 1.0000),  # #8D19FF - 12 - 14\n    (0.7333, 0.0000, 0.9176),  # #BB00EA - 14 - 16\n    (0.8392, 0.0000, 0.7490),  # #D600BF - 16 - 18\n    (0.7569, 0.0039, 0.4549),  # #C10074 - 18 - 20\n    (0.6784, 0.0000, 0.1961),  # #AD0032 - 20 - 30\n    (0.5020, 0.0000, 0.0000)   # #800000 - > 30\n]\n\ncmap_name = 'custom_snow_colormap'\ncustom_cmap = mcolors.ListedColormap(colors)\n\n# Define the lat_lon_to_map_coordinates function\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\n# Define your value ranges for color mapping\nvalue_ranges = [1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 30]\n#value_ranges = [0.1, 0.2, 0.4, 0.6, 0.8, 1.0, 1.2, 1.5, 1.8, 2, 2.5, 3]\n\ndef create_color_maps_with_value_range(df_col, value_ranges=None):\n  if value_ranges == None:\n    max_value = df_col.max()\n    min_value = df_col.min()\n    if min_value < 0:\n      min_value = 0\n    step_size = (max_value - min_value) / 12\n\n    # Create 10 periods\n    new_value_ranges = [min_value + i * step_size for i in range(12)]\n  # Define your custom function to map data values to colors\n  def map_value_to_color(value):\n    # Iterate through the value ranges to find the appropriate color index\n    for i, range_max in enumerate(new_value_ranges):\n      if value <= range_max:\n        return colors[i]\n\n      # If the value is greater than the largest range, return the last color\n      return colors[-1]\n\n    # Map predicted_swe values to colors using the custom function\n  color_mapping = [map_value_to_color(value) for value in df_col.values]\n  return color_mapping, new_value_ranges\n\ndef convert_csvs_to_images():\n    data = pd.read_csv(\"/home/chetana/gridmet_test_run/test_data_predicted.csv\")\n#     print(data.head())\n    print(\"statistic of predicted_swe: \", data['predicted_swe'].describe())\n    data['predicted_swe'].fillna(0, inplace=True)\n    #data['predicted_swe'] = data['predicted_swe'].apply(lambda x: 0 if x < 2 else x)\n    \n#     for column in data.columns:\n#       column_data = data[column]\n#       description = column_data.describe()\n\n#       # Print or process the description as needed\n#       print(f\"Column: {column}\")\n#       print(description)\n    \n    # Create a figure with a white background\n    fig = plt.figure(facecolor='white')\n\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    print(\"data['lon'].values = \", data['lon'].values)\n    x, y = m(data['lon'].values, data['lat'].values)\n#     print(\"x = \", x)\n#     print(\"y = \", y)\n#     print(\"v = \", data['predicted_swe'].values)\n    print(data.columns)\n\n    color_mapping, value_ranges = create_color_maps_with_value_range(data[\"predicted_swe\"], value_ranges)\n    \n    # Plot the data using the custom colormap\n    plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\n    \n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_date = datetime(1900, 1, 1)\n    day_value = day_index\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    timestamp_string = result_date.strftime(\"%Y-%m-%d\")\n    \n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    # Create custom legend elements using the same colormap\n    legend_elements = [Patch(color=colors[i], label=f\"{value_ranges[i]} - {value_ranges[i+1]-1}\" if i < len(value_ranges) - 1 else f\"> {value_ranges[-1]}\") for i in range(len(value_ranges))]\n\n    # Create the legend outside the map\n    legend = plt.legend(handles=legend_elements, loc='upper left', title='Legend', fontsize=8)\n    legend.set_bbox_to_anchor((1.01, 1)) \n\n    # Remove the color bar\n    #plt.colorbar().remove()\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Set the aspect ratio to 'equal' to keep the plot at the center\n    plt.gca().set_aspect('equal', adjustable='box')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15, right=0.80)  # Adjust right margin to accommodate the legend\n    # Show the plot or save it to a file\n    new_plot_path = f'/home/chetana/gridmet_test_run/predicted_swe-{test_start_date}.png'\n    print(f\"The new plot is saved to {new_plot_path}\")\n    plt.savefig(new_plot_path)\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "today date = 2023-09-24\ntest start date:  2022-08-22\ntest end date:  2023-09-24\n/home/chetana\nstatistic of predicted_swe:  count    288650.000000\nmean          0.003739\nstd           0.022082\nmin           0.000000\n25%           0.000000\n50%           0.000000\n75%           0.000000\nmax           1.141000\nName: predicted_swe, dtype: float64\ndata['lon'].values =  [-125.    -124.964 -124.928 ... -100.124 -100.088 -100.052]\nIndex(['date', 'lat', 'lon', 'SWE', 'Flag', 'air_temperature_tmmn',\n       'potential_evapotranspiration', 'mean_vapor_pressure_deficit',\n       'relative_humidity_rmax', 'relative_humidity_rmin',\n       'precipitation_amount', 'air_temperature_tmmx', 'wind_speed',\n       'elevation', 'slope', 'curvature', 'aspect', 'eastness', 'northness',\n       'predicted_swe'],\n      dtype='object')\nTraceback (most recent call last):\n  File \"/home/chetana/gw-workspace/tHSHKIe3L8jo/convert_results_to_images.py\", line 164, in <module>\n    convert_csvs_to_images()\n  File \"/home/chetana/gw-workspace/tHSHKIe3L8jo/convert_results_to_images.py\", line 96, in convert_csvs_to_images\n    color_mapping, value_ranges = create_color_maps_with_value_range(data[\"predicted_swe\"], value_ranges)\nUnboundLocalError: local variable 'value_ranges' referenced before assignment\n",
  "history_begin_time" : 1695528705943,
  "history_end_time" : 1695528709834,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Failed"
},{
  "history_id" : "x1eop25pthy",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport uuid\nfrom snowcast_utils import day_index\nimport matplotlib.colors as mcolors\nfrom matplotlib.patches import Patch\nfrom snowcast_utils import day_index, work_dir, test_start_date\n\n# Define the custom colormap with specified colors and ranges\ncolors = [\n    (0.8627, 0.8627, 0.8627),  # #DCDCDC - 0 - 1\n    (0.8627, 1.0000, 1.0000),  # #DCFFFF - 1 - 2\n    (0.6000, 1.0000, 1.0000),  # #99FFFF - 2 - 4\n    (0.5569, 0.8235, 1.0000),  # #8ED2FF - 4 - 6\n    (0.4509, 0.6196, 0.8745),  # #739EDF - 6 - 8\n    (0.4157, 0.4706, 1.0000),  # #6A78FF - 8 - 10\n    (0.4235, 0.2784, 1.0000),  # #6C47FF - 10 - 12\n    (0.5529, 0.0980, 1.0000),  # #8D19FF - 12 - 14\n    (0.7333, 0.0000, 0.9176),  # #BB00EA - 14 - 16\n    (0.8392, 0.0000, 0.7490),  # #D600BF - 16 - 18\n    (0.7569, 0.0039, 0.4549),  # #C10074 - 18 - 20\n    (0.6784, 0.0000, 0.1961),  # #AD0032 - 20 - 30\n    (0.5020, 0.0000, 0.0000)   # #800000 - > 30\n]\n\ncmap_name = 'custom_snow_colormap'\ncustom_cmap = mcolors.ListedColormap(colors)\n\n# Define the lat_lon_to_map_coordinates function\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\n# Define your value ranges for color mapping\n#value_ranges = [1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 30]\n#value_ranges = [0.1, 0.2, 0.4, 0.6, 0.8, 1.0, 1.2, 1.5, 1.8, 2, 2.5, 3]\n\ndef create_color_maps_with_value_range(df_col, value_ranges=None):\n  if value_ranges == None:\n    max_value = df_col.max()\n    min_value = df_col.min()\n    if min_value < 0:\n      min_value = 0\n    step_size = (max_value - min_value) / 12\n\n    # Create 10 periods\n    new_value_ranges = [min_value + i * step_size for i in range(12)]\n  # Define your custom function to map data values to colors\n  def map_value_to_color(value):\n    # Iterate through the value ranges to find the appropriate color index\n    for i, range_max in enumerate(new_value_ranges):\n      if value <= range_max:\n        return colors[i]\n\n      # If the value is greater than the largest range, return the last color\n      return colors[-1]\n\n    # Map predicted_swe values to colors using the custom function\n  color_mapping = [map_value_to_color(value) for value in df_col.values]\n  return color_mapping, new_value_ranges\n\ndef convert_csvs_to_images():\n    data = pd.read_csv(\"/home/chetana/gridmet_test_run/test_data_predicted.csv\")\n#     print(data.head())\n    print(\"statistic of predicted_swe: \", data['predicted_swe'].describe())\n    data['predicted_swe'].fillna(0, inplace=True)\n    #data['predicted_swe'] = data['predicted_swe'].apply(lambda x: 0 if x < 2 else x)\n    \n#     for column in data.columns:\n#       column_data = data[column]\n#       description = column_data.describe()\n\n#       # Print or process the description as needed\n#       print(f\"Column: {column}\")\n#       print(description)\n    \n    # Create a figure with a white background\n    fig = plt.figure(facecolor='white')\n\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    print(\"data['lon'].values = \", data['lon'].values)\n    x, y = m(data['lon'].values, data['lat'].values)\n#     print(\"x = \", x)\n#     print(\"y = \", y)\n#     print(\"v = \", data['predicted_swe'].values)\n    print(data.columns)\n\n    color_mapping, value_ranges = create_color_maps_with_value_range(data[\"mean_vapor_pressure_deficit\"])\n    \n    # Plot the data using the custom colormap\n    plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\n    \n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_date = datetime(1900, 1, 1)\n    day_value = day_index\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    timestamp_string = result_date.strftime(\"%Y-%m-%d\")\n    \n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    # Create custom legend elements using the same colormap\n    legend_elements = [Patch(color=colors[i], label=f\"{value_ranges[i]} - {value_ranges[i+1]-1}\" if i < len(value_ranges) - 1 else f\"> {value_ranges[-1]}\") for i in range(len(value_ranges))]\n\n    # Create the legend outside the map\n    legend = plt.legend(handles=legend_elements, loc='upper left', title='Legend', fontsize=8)\n    legend.set_bbox_to_anchor((1.01, 1)) \n\n    # Remove the color bar\n    #plt.colorbar().remove()\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Set the aspect ratio to 'equal' to keep the plot at the center\n    plt.gca().set_aspect('equal', adjustable='box')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15, right=0.80)  # Adjust right margin to accommodate the legend\n    # Show the plot or save it to a file\n    new_plot_path = f'/home/chetana/gridmet_test_run/predicted_swe-{test_start_date}.png'\n    print(f\"The new plot is saved to {new_plot_path}\")\n    plt.savefig(new_plot_path)\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "/home/chetana/gw-workspace/x1eop25pthy/convert_results_to_images.py:99: UserWarning: No data for colormapping provided via 'c'. Parameters 'cmap' will be ignored\n  plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\ntoday date = 2023-09-24\ntest start date:  2022-08-22\ntest end date:  2023-09-24\n/home/chetana\nstatistic of predicted_swe:  count    288650.000000\nmean          0.003739\nstd           0.022082\nmin           0.000000\n25%           0.000000\n50%           0.000000\n75%           0.000000\nmax           1.141000\nName: predicted_swe, dtype: float64\ndata['lon'].values =  [-125.    -124.964 -124.928 ... -100.124 -100.088 -100.052]\nIndex(['date', 'lat', 'lon', 'SWE', 'Flag', 'air_temperature_tmmn',\n       'potential_evapotranspiration', 'mean_vapor_pressure_deficit',\n       'relative_humidity_rmax', 'relative_humidity_rmin',\n       'precipitation_amount', 'air_temperature_tmmx', 'wind_speed',\n       'elevation', 'slope', 'curvature', 'aspect', 'eastness', 'northness',\n       'predicted_swe'],\n      dtype='object')\nThe new plot is saved to /home/chetana/gridmet_test_run/predicted_swe-2022-08-22.png\n",
  "history_begin_time" : 1695528559929,
  "history_end_time" : 1695528570256,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "100001",
  "indicator" : "Done"
},{
  "history_id" : "PKkFAkVkq9li",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport uuid\nfrom snowcast_utils import day_index\nimport matplotlib.colors as mcolors\nfrom matplotlib.patches import Patch\nfrom snowcast_utils import day_index, work_dir, test_start_date\n\n# Define the custom colormap with specified colors and ranges\ncolors = [\n    (0.8627, 0.8627, 0.8627),  # #DCDCDC - 0 - 1\n    (0.8627, 1.0000, 1.0000),  # #DCFFFF - 1 - 2\n    (0.6000, 1.0000, 1.0000),  # #99FFFF - 2 - 4\n    (0.5569, 0.8235, 1.0000),  # #8ED2FF - 4 - 6\n    (0.4509, 0.6196, 0.8745),  # #739EDF - 6 - 8\n    (0.4157, 0.4706, 1.0000),  # #6A78FF - 8 - 10\n    (0.4235, 0.2784, 1.0000),  # #6C47FF - 10 - 12\n    (0.5529, 0.0980, 1.0000),  # #8D19FF - 12 - 14\n    (0.7333, 0.0000, 0.9176),  # #BB00EA - 14 - 16\n    (0.8392, 0.0000, 0.7490),  # #D600BF - 16 - 18\n    (0.7569, 0.0039, 0.4549),  # #C10074 - 18 - 20\n    (0.6784, 0.0000, 0.1961),  # #AD0032 - 20 - 30\n    (0.5020, 0.0000, 0.0000)   # #800000 - > 30\n]\n\ncmap_name = 'custom_snow_colormap'\ncustom_cmap = mcolors.ListedColormap(colors)\n\n# Define the lat_lon_to_map_coordinates function\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\n# Define your value ranges for color mapping\n#value_ranges = [1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 30]\n#value_ranges = [0.1, 0.2, 0.4, 0.6, 0.8, 1.0, 1.2, 1.5, 1.8, 2, 2.5, 3]\n\ndef create_color_maps_with_value_range(df_col, value_ranges=None):\n  if value_ranges == None:\n    max_value = df_col.max()\n    min_value = df_col.min()\n    if min_value < 0:\n      min_value = 0\n    step_size = (max_value - min_value) / 12\n\n    # Create 10 periods\n    new_value_ranges = [min_value + i * step_size for i in range(12)]\n  # Define your custom function to map data values to colors\n  def map_value_to_color(value):\n    # Iterate through the value ranges to find the appropriate color index\n    for i, range_max in enumerate(new_value_ranges):\n      if value <= range_max:\n        return colors[i]\n\n      # If the value is greater than the largest range, return the last color\n      return colors[-1]\n\n    # Map predicted_swe values to colors using the custom function\n  color_mapping = [map_value_to_color(value) for value in df_col.values]\n  return color_mapping, new_value_ranges\n\ndef convert_csvs_to_images():\n    data = pd.read_csv(\"/home/chetana/gridmet_test_run/test_data_predicted.csv\")\n#     print(data.head())\n    print(\"statistic of predicted_swe: \", data['predicted_swe'].describe())\n    data['predicted_swe'].fillna(0, inplace=True)\n    #data['predicted_swe'] = data['predicted_swe'].apply(lambda x: 0 if x < 2 else x)\n    \n#     for column in data.columns:\n#       column_data = data[column]\n#       description = column_data.describe()\n\n#       # Print or process the description as needed\n#       print(f\"Column: {column}\")\n#       print(description)\n    \n    # Create a figure with a white background\n    fig = plt.figure(facecolor='white')\n\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    print(\"data['lon'].values = \", data['lon'].values)\n    x, y = m(data['lon'].values, data['lat'].values)\n#     print(\"x = \", x)\n#     print(\"y = \", y)\n#     print(\"v = \", data['predicted_swe'].values)\n    print(data.columns)\n\n    color_mapping, value_ranges = create_color_maps_with_value_range(data[\"mean_vapor_pressure_deficit\"])\n    \n    # Plot the data using the custom colormap\n    plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\n    \n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_date = datetime(1900, 1, 1)\n    day_value = day_index\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    timestamp_string = result_date.strftime(\"%Y-%m-%d\")\n    \n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    # Create custom legend elements using the same colormap\n    legend_elements = [Patch(color=colors[i], label=f\"{value_ranges[i]} - {value_ranges[i+1]-1}\" if i < len(value_ranges) - 1 else f\"> {value_ranges[-1]}\") for i in range(len(value_ranges))]\n\n    # Create the legend outside the map\n    legend = plt.legend(handles=legend_elements, loc='upper left', title='Legend', fontsize=8)\n    legend.set_bbox_to_anchor((1.01, 1)) \n\n    # Remove the color bar\n    #plt.colorbar().remove()\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Set the aspect ratio to 'equal' to keep the plot at the center\n    plt.gca().set_aspect('equal', adjustable='box')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15, right=0.80)  # Adjust right margin to accommodate the legend\n    # Show the plot or save it to a file\n    new_plot_path = f'/home/chetana/gridmet_test_run/predicted_swe-{test_start_date}.png'\n    print(f\"The new plot is saved to {new_plot_path}\")\n    plt.savefig(new_plot_path)\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "/home/chetana/gw-workspace/PKkFAkVkq9li/convert_results_to_images.py:99: UserWarning: No data for colormapping provided via 'c'. Parameters 'cmap' will be ignored\n  plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\ntoday date = 2023-09-24\ntest start date:  2022-08-22\ntest end date:  2023-09-24\n/home/chetana\nstatistic of predicted_swe:  count    267444.000000\nmean          0.001844\nstd           0.014155\nmin           0.000000\n25%           0.000000\n50%           0.000000\n75%           0.000000\nmax           0.339000\nName: predicted_swe, dtype: float64\ndata['lon'].values =  [-125.    -124.964 -124.928 ... -100.124 -100.088 -100.052]\nIndex(['date', 'lat', 'lon', 'SWE', 'Flag', 'air_temperature_tmmn',\n       'potential_evapotranspiration', 'mean_vapor_pressure_deficit',\n       'relative_humidity_rmax', 'relative_humidity_rmin',\n       'precipitation_amount', 'air_temperature_tmmx', 'wind_speed',\n       'elevation', 'slope', 'curvature', 'aspect', 'eastness', 'northness',\n       'predicted_swe'],\n      dtype='object')\nThe new plot is saved to /home/chetana/gridmet_test_run/predicted_swe-2022-08-22.png\n",
  "history_begin_time" : 1695521075036,
  "history_end_time" : 1695521084051,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "YuVVidfF68dE",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport uuid\nfrom snowcast_utils import day_index\nimport matplotlib.colors as mcolors\nfrom matplotlib.patches import Patch\nfrom snowcast_utils import day_index, work_dir, test_start_date\n\n# Define the custom colormap with specified colors and ranges\ncolors = [\n    (0.8627, 0.8627, 0.8627),  # #DCDCDC - 0 - 1\n    (0.8627, 1.0000, 1.0000),  # #DCFFFF - 1 - 2\n    (0.6000, 1.0000, 1.0000),  # #99FFFF - 2 - 4\n    (0.5569, 0.8235, 1.0000),  # #8ED2FF - 4 - 6\n    (0.4509, 0.6196, 0.8745),  # #739EDF - 6 - 8\n    (0.4157, 0.4706, 1.0000),  # #6A78FF - 8 - 10\n    (0.4235, 0.2784, 1.0000),  # #6C47FF - 10 - 12\n    (0.5529, 0.0980, 1.0000),  # #8D19FF - 12 - 14\n    (0.7333, 0.0000, 0.9176),  # #BB00EA - 14 - 16\n    (0.8392, 0.0000, 0.7490),  # #D600BF - 16 - 18\n    (0.7569, 0.0039, 0.4549),  # #C10074 - 18 - 20\n    (0.6784, 0.0000, 0.1961),  # #AD0032 - 20 - 30\n    (0.5020, 0.0000, 0.0000)   # #800000 - > 30\n]\n\ncmap_name = 'custom_snow_colormap'\ncustom_cmap = mcolors.ListedColormap(colors)\n\n# Define the lat_lon_to_map_coordinates function\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\n# Define your value ranges for color mapping\n#value_ranges = [1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 30]\n#value_ranges = [0.1, 0.2, 0.4, 0.6, 0.8, 1.0, 1.2, 1.5, 1.8, 2, 2.5, 3]\n\ndef create_color_maps_with_value_range(df_col, value_ranges=None):\n  if value_ranges == None:\n    max_value = df_col.max()\n    min_value = df_col.min()\n    if min_value < 0:\n      min_value = 0\n    step_size = (max_value - min_value) / 12\n\n    # Create 10 periods\n    new_value_ranges = [min_value + i * step_size for i in range(12)]\n  # Define your custom function to map data values to colors\n  def map_value_to_color(value):\n    # Iterate through the value ranges to find the appropriate color index\n    for i, range_max in enumerate(new_value_ranges):\n      if value <= range_max:\n        return colors[i]\n\n      # If the value is greater than the largest range, return the last color\n      return colors[-1]\n\n    # Map predicted_swe values to colors using the custom function\n  color_mapping = [map_value_to_color(value) for value in df_col.values]\n  return color_mapping, new_value_ranges\n\ndef convert_csvs_to_images():\n    data = pd.read_csv(\"/home/chetana/gridmet_test_run/test_data_predicted.csv\")\n#     print(data.head())\n    print(\"statistic of predicted_swe: \", data['predicted_swe'].describe())\n    data['predicted_swe'].fillna(0, inplace=True)\n    #data['predicted_swe'] = data['predicted_swe'].apply(lambda x: 0 if x < 2 else x)\n    \n#     for column in data.columns:\n#       column_data = data[column]\n#       description = column_data.describe()\n\n#       # Print or process the description as needed\n#       print(f\"Column: {column}\")\n#       print(description)\n    \n    # Create a figure with a white background\n    fig = plt.figure(facecolor='white')\n\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    print(\"data['lon'].values = \", data['lon'].values)\n    x, y = m(data['lon'].values, data['lat'].values)\n#     print(\"x = \", x)\n#     print(\"y = \", y)\n#     print(\"v = \", data['predicted_swe'].values)\n    print(data.columns)\n\n    color_mapping, value_ranges = create_color_maps_with_value_range(data[\"mean_vapor_pressure_deficit\"])\n    \n    # Plot the data using the custom colormap\n    plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\n    \n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_date = datetime(1900, 1, 1)\n    day_value = day_index\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    timestamp_string = result_date.strftime(\"%Y-%m-%d\")\n    \n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    # Create custom legend elements using the same colormap\n    legend_elements = [Patch(color=colors[i], label=f\"{value_ranges[i]} - {value_ranges[i+1]-1}\" if i < len(value_ranges) - 1 else f\"> {value_ranges[-1]}\") for i in range(len(value_ranges))]\n\n    # Create the legend outside the map\n    legend = plt.legend(handles=legend_elements, loc='upper left', title='Legend', fontsize=8)\n    legend.set_bbox_to_anchor((1.01, 1)) \n\n    # Remove the color bar\n    #plt.colorbar().remove()\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Set the aspect ratio to 'equal' to keep the plot at the center\n    plt.gca().set_aspect('equal', adjustable='box')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15, right=0.80)  # Adjust right margin to accommodate the legend\n    # Show the plot or save it to a file\n    new_plot_path = f'/home/chetana/gridmet_test_run/predicted_swe-{test_start_date}.png'\n    print(f\"The new plot is saved to {new_plot_path}\")\n    plt.savefig(new_plot_path)\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "/home/chetana/gw-workspace/YuVVidfF68dE/convert_results_to_images.py:99: UserWarning: No data for colormapping provided via 'c'. Parameters 'cmap' will be ignored\n  plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\ntoday date = 2023-09-24\ntest start date:  2022-08-22\ntest end date:  2023-09-24\n/home/chetana\nstatistic of predicted_swe:  count    267444.000000\nmean          0.001844\nstd           0.014155\nmin           0.000000\n25%           0.000000\n50%           0.000000\n75%           0.000000\nmax           0.339000\nName: predicted_swe, dtype: float64\ndata['lon'].values =  [-125.    -124.964 -124.928 ... -100.124 -100.088 -100.052]\nIndex(['date', 'lat', 'lon', 'SWE', 'Flag', 'air_temperature_tmmn',\n       'potential_evapotranspiration', 'mean_vapor_pressure_deficit',\n       'relative_humidity_rmax', 'relative_humidity_rmin',\n       'precipitation_amount', 'air_temperature_tmmx', 'wind_speed',\n       'elevation', 'slope', 'curvature', 'aspect', 'eastness', 'northness',\n       'predicted_swe'],\n      dtype='object')\nThe new plot is saved to /home/chetana/gridmet_test_run/predicted_swe-2022-08-22.png\n",
  "history_begin_time" : 1695521055054,
  "history_end_time" : 1695521063923,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "udRqMh1mV1CR",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport uuid\nfrom snowcast_utils import day_index\nimport matplotlib.colors as mcolors\nfrom matplotlib.patches import Patch\nfrom snowcast_utils import day_index, work_dir, test_start_date\n\n# Define the custom colormap with specified colors and ranges\ncolors = [\n    (0.8627, 0.8627, 0.8627),  # #DCDCDC - 0 - 1\n    (0.8627, 1.0000, 1.0000),  # #DCFFFF - 1 - 2\n    (0.6000, 1.0000, 1.0000),  # #99FFFF - 2 - 4\n    (0.5569, 0.8235, 1.0000),  # #8ED2FF - 4 - 6\n    (0.4509, 0.6196, 0.8745),  # #739EDF - 6 - 8\n    (0.4157, 0.4706, 1.0000),  # #6A78FF - 8 - 10\n    (0.4235, 0.2784, 1.0000),  # #6C47FF - 10 - 12\n    (0.5529, 0.0980, 1.0000),  # #8D19FF - 12 - 14\n    (0.7333, 0.0000, 0.9176),  # #BB00EA - 14 - 16\n    (0.8392, 0.0000, 0.7490),  # #D600BF - 16 - 18\n    (0.7569, 0.0039, 0.4549),  # #C10074 - 18 - 20\n    (0.6784, 0.0000, 0.1961),  # #AD0032 - 20 - 30\n    (0.5020, 0.0000, 0.0000)   # #800000 - > 30\n]\n\ncmap_name = 'custom_snow_colormap'\ncustom_cmap = mcolors.ListedColormap(colors)\n\n# Define the lat_lon_to_map_coordinates function\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\n# Define your value ranges for color mapping\n#value_ranges = [1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 30]\n#value_ranges = [0.1, 0.2, 0.4, 0.6, 0.8, 1.0, 1.2, 1.5, 1.8, 2, 2.5, 3]\n\ndef create_color_maps_with_value_range(df_col, value_ranges=None):\n  if value_ranges == None:\n    max_value = df_col.max()\n    min_value = df_col.min()\n    if min_value < 0:\n      min_value = 0\n    step_size = (max_value - min_value) / 12\n\n    # Create 10 periods\n    new_value_ranges = [min_value + i * step_size for i in range(12)]\n  # Define your custom function to map data values to colors\n  def map_value_to_color(value):\n    # Iterate through the value ranges to find the appropriate color index\n    for i, range_max in enumerate(new_value_ranges):\n      if value <= range_max:\n        return colors[i]\n\n      # If the value is greater than the largest range, return the last color\n      return colors[-1]\n\n    # Map predicted_swe values to colors using the custom function\n  color_mapping = [map_value_to_color(value) for value in df_col.values]\n  return color_mapping, new_value_ranges\n\ndef convert_csvs_to_images():\n    data = pd.read_csv(\"/home/chetana/gridmet_test_run/test_data_predicted.csv\")\n#     print(data.head())\n    print(\"statistic of predicted_swe: \", data['predicted_swe'].describe())\n    data['predicted_swe'].fillna(0, inplace=True)\n    #data['predicted_swe'] = data['predicted_swe'].apply(lambda x: 0 if x < 2 else x)\n    \n#     for column in data.columns:\n#       column_data = data[column]\n#       description = column_data.describe()\n\n#       # Print or process the description as needed\n#       print(f\"Column: {column}\")\n#       print(description)\n    \n    # Create a figure with a white background\n    fig = plt.figure(facecolor='white')\n\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    print(\"data['lon'].values = \", data['lon'].values)\n    x, y = m(data['lon'].values, data['lat'].values)\n#     print(\"x = \", x)\n#     print(\"y = \", y)\n#     print(\"v = \", data['predicted_swe'].values)\n    print(data.columns)\n\n    color_mapping, value_ranges = create_color_maps_with_value_range(data[\"potential_evapotranspiration\"])\n    \n    # Plot the data using the custom colormap\n    plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\n    \n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_date = datetime(1900, 1, 1)\n    day_value = day_index\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    timestamp_string = result_date.strftime(\"%Y-%m-%d\")\n    \n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    # Create custom legend elements using the same colormap\n    legend_elements = [Patch(color=colors[i], label=f\"{value_ranges[i]} - {value_ranges[i+1]-1}\" if i < len(value_ranges) - 1 else f\"> {value_ranges[-1]}\") for i in range(len(value_ranges))]\n\n    # Create the legend outside the map\n    legend = plt.legend(handles=legend_elements, loc='upper left', title='Legend', fontsize=8)\n    legend.set_bbox_to_anchor((1.01, 1)) \n\n    # Remove the color bar\n    #plt.colorbar().remove()\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Set the aspect ratio to 'equal' to keep the plot at the center\n    plt.gca().set_aspect('equal', adjustable='box')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15, right=0.80)  # Adjust right margin to accommodate the legend\n    # Show the plot or save it to a file\n    new_plot_path = f'/home/chetana/gridmet_test_run/predicted_swe-{test_start_date}.png'\n    print(f\"The new plot is saved to {new_plot_path}\")\n    plt.savefig(new_plot_path)\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "/home/chetana/gw-workspace/udRqMh1mV1CR/convert_results_to_images.py:99: UserWarning: No data for colormapping provided via 'c'. Parameters 'cmap' will be ignored\n  plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\ntoday date = 2023-09-24\ntest start date:  2022-08-22\ntest end date:  2023-09-24\n/home/chetana\nstatistic of predicted_swe:  count    267444.000000\nmean          0.001844\nstd           0.014155\nmin           0.000000\n25%           0.000000\n50%           0.000000\n75%           0.000000\nmax           0.339000\nName: predicted_swe, dtype: float64\ndata['lon'].values =  [-125.    -124.964 -124.928 ... -100.124 -100.088 -100.052]\nIndex(['date', 'lat', 'lon', 'SWE', 'Flag', 'air_temperature_tmmn',\n       'potential_evapotranspiration', 'mean_vapor_pressure_deficit',\n       'relative_humidity_rmax', 'relative_humidity_rmin',\n       'precipitation_amount', 'air_temperature_tmmx', 'wind_speed',\n       'elevation', 'slope', 'curvature', 'aspect', 'eastness', 'northness',\n       'predicted_swe'],\n      dtype='object')\nThe new plot is saved to /home/chetana/gridmet_test_run/predicted_swe-2022-08-22.png\n",
  "history_begin_time" : 1695520620067,
  "history_end_time" : 1695520628791,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "Jd8nkMASCJLn",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport uuid\nfrom snowcast_utils import day_index\nimport matplotlib.colors as mcolors\nfrom matplotlib.patches import Patch\nfrom snowcast_utils import day_index, work_dir, test_start_date\n\n# Define the custom colormap with specified colors and ranges\ncolors = [\n    (0.8627, 0.8627, 0.8627),  # #DCDCDC - 0 - 1\n    (0.8627, 1.0000, 1.0000),  # #DCFFFF - 1 - 2\n    (0.6000, 1.0000, 1.0000),  # #99FFFF - 2 - 4\n    (0.5569, 0.8235, 1.0000),  # #8ED2FF - 4 - 6\n    (0.4509, 0.6196, 0.8745),  # #739EDF - 6 - 8\n    (0.4157, 0.4706, 1.0000),  # #6A78FF - 8 - 10\n    (0.4235, 0.2784, 1.0000),  # #6C47FF - 10 - 12\n    (0.5529, 0.0980, 1.0000),  # #8D19FF - 12 - 14\n    (0.7333, 0.0000, 0.9176),  # #BB00EA - 14 - 16\n    (0.8392, 0.0000, 0.7490),  # #D600BF - 16 - 18\n    (0.7569, 0.0039, 0.4549),  # #C10074 - 18 - 20\n    (0.6784, 0.0000, 0.1961),  # #AD0032 - 20 - 30\n    (0.5020, 0.0000, 0.0000)   # #800000 - > 30\n]\n\ncmap_name = 'custom_snow_colormap'\ncustom_cmap = mcolors.ListedColormap(colors)\n\n# Define the lat_lon_to_map_coordinates function\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\n# Define your value ranges for color mapping\n#value_ranges = [1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 30]\n#value_ranges = [0.1, 0.2, 0.4, 0.6, 0.8, 1.0, 1.2, 1.5, 1.8, 2, 2.5, 3]\n\ndef create_color_maps_with_value_range(df_col, value_ranges=None):\n  if value_ranges == None:\n    max_value = df_col.max()\n    min_value = df_col.min()\n    if min_value < 0:\n      min_value = 0\n    step_size = (max_value - min_value) / 12\n\n    # Create 10 periods\n    new_value_ranges = [min_value + i * step_size for i in range(12)]\n  # Define your custom function to map data values to colors\n  def map_value_to_color(value):\n    # Iterate through the value ranges to find the appropriate color index\n    for i, range_max in enumerate(new_value_ranges):\n      if value <= range_max:\n        return colors[i]\n\n      # If the value is greater than the largest range, return the last color\n      return colors[-1]\n\n    # Map predicted_swe values to colors using the custom function\n  color_mapping = [map_value_to_color(value) for value in df_col.values]\n  return color_mapping, new_value_ranges\n\ndef convert_csvs_to_images():\n    data = pd.read_csv(\"/home/chetana/gridmet_test_run/test_data_predicted.csv\")\n#     print(data.head())\n    print(\"statistic of predicted_swe: \", data['predicted_swe'].describe())\n    data['predicted_swe'].fillna(0, inplace=True)\n    #data['predicted_swe'] = data['predicted_swe'].apply(lambda x: 0 if x < 2 else x)\n    \n#     for column in data.columns:\n#       column_data = data[column]\n#       description = column_data.describe()\n\n#       # Print or process the description as needed\n#       print(f\"Column: {column}\")\n#       print(description)\n    \n    # Create a figure with a white background\n    fig = plt.figure(facecolor='white')\n\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    print(\"data['lon'].values = \", data['lon'].values)\n    x, y = m(data['lon'].values, data['lat'].values)\n#     print(\"x = \", x)\n#     print(\"y = \", y)\n#     print(\"v = \", data['predicted_swe'].values)\n    print(data.columns)\n\n    color_mapping, value_ranges = create_color_maps_with_value_range(data[\"air_temperature_tmmn\"])\n    \n    # Plot the data using the custom colormap\n    plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\n    \n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_date = datetime(1900, 1, 1)\n    day_value = day_index\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    timestamp_string = result_date.strftime(\"%Y-%m-%d\")\n    \n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    # Create custom legend elements using the same colormap\n    legend_elements = [Patch(color=colors[i], label=f\"{value_ranges[i]} - {value_ranges[i+1]-1}\" if i < len(value_ranges) - 1 else f\"> {value_ranges[-1]}\") for i in range(len(value_ranges))]\n\n    # Create the legend outside the map\n    legend = plt.legend(handles=legend_elements, loc='upper left', title='Legend', fontsize=8)\n    legend.set_bbox_to_anchor((1.01, 1)) \n\n    # Remove the color bar\n    #plt.colorbar().remove()\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Set the aspect ratio to 'equal' to keep the plot at the center\n    plt.gca().set_aspect('equal', adjustable='box')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15, right=0.80)  # Adjust right margin to accommodate the legend\n    # Show the plot or save it to a file\n    new_plot_path = f'/home/chetana/gridmet_test_run/predicted_swe-{test_start_date}.png'\n    print(f\"The new plot is saved to {new_plot_path}\")\n    plt.savefig(new_plot_path)\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "/home/chetana/gw-workspace/Jd8nkMASCJLn/convert_results_to_images.py:99: UserWarning: No data for colormapping provided via 'c'. Parameters 'cmap' will be ignored\n  plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\ntoday date = 2023-09-24\ntest start date:  2022-08-22\ntest end date:  2023-09-24\n/home/chetana\nstatistic of predicted_swe:  count    267444.000000\nmean          0.001844\nstd           0.014155\nmin           0.000000\n25%           0.000000\n50%           0.000000\n75%           0.000000\nmax           0.339000\nName: predicted_swe, dtype: float64\ndata['lon'].values =  [-125.    -124.964 -124.928 ... -100.124 -100.088 -100.052]\nIndex(['date', 'lat', 'lon', 'SWE', 'Flag', 'air_temperature_tmmn',\n       'potential_evapotranspiration', 'mean_vapor_pressure_deficit',\n       'relative_humidity_rmax', 'relative_humidity_rmin',\n       'precipitation_amount', 'air_temperature_tmmx', 'wind_speed',\n       'elevation', 'slope', 'curvature', 'aspect', 'eastness', 'northness',\n       'predicted_swe'],\n      dtype='object')\nThe new plot is saved to /home/chetana/gridmet_test_run/predicted_swe-2022-08-22.png\n",
  "history_begin_time" : 1695520533583,
  "history_end_time" : 1695520542301,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "ZdiZWtGyFqxO",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport uuid\nfrom snowcast_utils import day_index\nimport matplotlib.colors as mcolors\nfrom matplotlib.patches import Patch\nfrom snowcast_utils import day_index, work_dir, test_start_date\n\n# Define the custom colormap with specified colors and ranges\ncolors = [\n    (0.8627, 0.8627, 0.8627),  # #DCDCDC - 0 - 1\n    (0.8627, 1.0000, 1.0000),  # #DCFFFF - 1 - 2\n    (0.6000, 1.0000, 1.0000),  # #99FFFF - 2 - 4\n    (0.5569, 0.8235, 1.0000),  # #8ED2FF - 4 - 6\n    (0.4509, 0.6196, 0.8745),  # #739EDF - 6 - 8\n    (0.4157, 0.4706, 1.0000),  # #6A78FF - 8 - 10\n    (0.4235, 0.2784, 1.0000),  # #6C47FF - 10 - 12\n    (0.5529, 0.0980, 1.0000),  # #8D19FF - 12 - 14\n    (0.7333, 0.0000, 0.9176),  # #BB00EA - 14 - 16\n    (0.8392, 0.0000, 0.7490),  # #D600BF - 16 - 18\n    (0.7569, 0.0039, 0.4549),  # #C10074 - 18 - 20\n    (0.6784, 0.0000, 0.1961),  # #AD0032 - 20 - 30\n    (0.5020, 0.0000, 0.0000)   # #800000 - > 30\n]\n\ncmap_name = 'custom_snow_colormap'\ncustom_cmap = mcolors.ListedColormap(colors)\n\n# Define the lat_lon_to_map_coordinates function\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\n# Define your value ranges for color mapping\n#value_ranges = [1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 30]\n#value_ranges = [0.1, 0.2, 0.4, 0.6, 0.8, 1.0, 1.2, 1.5, 1.8, 2, 2.5, 3]\n\ndef create_color_maps_with_value_range(df_col, value_ranges=None):\n  if value_ranges == None:\n    max_value = df_col.max()\n    min_value = df_col.min()\n    if min_value < 0:\n      min_value = 0\n    step_size = (max_value - min_value) / 12\n\n    # Create 10 periods\n    value_ranges = [min_value + i * step_size for i in range(12)]\n  # Define your custom function to map data values to colors\n  def map_value_to_color(value):\n    # Iterate through the value ranges to find the appropriate color index\n    for i, range_max in enumerate(value_ranges):\n      if value <= range_max:\n        return colors[i]\n\n      # If the value is greater than the largest range, return the last color\n      return colors[-1]\n\n    # Map predicted_swe values to colors using the custom function\n  color_mapping = [map_value_to_color(value) for value in df_col.values]\n  return color_mapping, value_ranges\n\ndef convert_csvs_to_images():\n    data = pd.read_csv(\"/home/chetana/gridmet_test_run/test_data_predicted.csv\")\n#     print(data.head())\n    print(\"statistic of predicted_swe: \", data['predicted_swe'].describe())\n    data['predicted_swe'].fillna(0, inplace=True)\n    #data['predicted_swe'] = data['predicted_swe'].apply(lambda x: 0 if x < 2 else x)\n    \n#     for column in data.columns:\n#       column_data = data[column]\n#       description = column_data.describe()\n\n#       # Print or process the description as needed\n#       print(f\"Column: {column}\")\n#       print(description)\n    \n    # Create a figure with a white background\n    fig = plt.figure(facecolor='white')\n\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    print(\"data['lon'].values = \", data['lon'].values)\n    x, y = m(data['lon'].values, data['lat'].values)\n#     print(\"x = \", x)\n#     print(\"y = \", y)\n#     print(\"v = \", data['predicted_swe'].values)\n    print(data.columns)\n\n    color_mapping, value_ranges = create_color_maps_with_value_range(data[\"air_temperature_tmmn\"])\n    \n    # Plot the data using the custom colormap\n    plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\n    \n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_date = datetime(1900, 1, 1)\n    day_value = day_index\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    timestamp_string = result_date.strftime(\"%Y-%m-%d\")\n    \n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    # Create custom legend elements using the same colormap\n    legend_elements = [Patch(color=colors[i], label=f\"{value_ranges[i]} - {value_ranges[i+1]-1}\" if i < len(value_ranges) - 1 else f\"> {value_ranges[-1]}\") for i in range(len(value_ranges))]\n\n    # Create the legend outside the map\n    legend = plt.legend(handles=legend_elements, loc='upper left', title='Legend', fontsize=8)\n    legend.set_bbox_to_anchor((1.01, 1)) \n\n    # Remove the color bar\n    #plt.colorbar().remove()\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Set the aspect ratio to 'equal' to keep the plot at the center\n    plt.gca().set_aspect('equal', adjustable='box')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15, right=0.80)  # Adjust right margin to accommodate the legend\n    # Show the plot or save it to a file\n    new_plot_path = f'/home/chetana/gridmet_test_run/predicted_swe-{test_start_date}.png'\n    print(f\"The new plot is saved to {new_plot_path}\")\n    plt.savefig(new_plot_path)\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "/home/chetana/gw-workspace/ZdiZWtGyFqxO/convert_results_to_images.py:99: UserWarning: No data for colormapping provided via 'c'. Parameters 'cmap' will be ignored\n  plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\ntoday date = 2023-09-24\ntest start date:  2022-08-22\ntest end date:  2023-09-24\n/home/chetana\nstatistic of predicted_swe:  count    267444.000000\nmean          0.001844\nstd           0.014155\nmin           0.000000\n25%           0.000000\n50%           0.000000\n75%           0.000000\nmax           0.339000\nName: predicted_swe, dtype: float64\ndata['lon'].values =  [-125.    -124.964 -124.928 ... -100.124 -100.088 -100.052]\nIndex(['date', 'lat', 'lon', 'SWE', 'Flag', 'air_temperature_tmmn',\n       'potential_evapotranspiration', 'mean_vapor_pressure_deficit',\n       'relative_humidity_rmax', 'relative_humidity_rmin',\n       'precipitation_amount', 'air_temperature_tmmx', 'wind_speed',\n       'elevation', 'slope', 'curvature', 'aspect', 'eastness', 'northness',\n       'predicted_swe'],\n      dtype='object')\nThe new plot is saved to /home/chetana/gridmet_test_run/predicted_swe-2022-08-22.png\n",
  "history_begin_time" : 1695520254927,
  "history_end_time" : 1695520263744,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "R1sDNdyWco67",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport uuid\nfrom snowcast_utils import day_index\nimport matplotlib.colors as mcolors\nfrom matplotlib.patches import Patch\nfrom snowcast_utils import day_index, work_dir, test_start_date\n\n# Define the custom colormap with specified colors and ranges\ncolors = [\n    (0.8627, 0.8627, 0.8627),  # #DCDCDC - 0 - 1\n    (0.8627, 1.0000, 1.0000),  # #DCFFFF - 1 - 2\n    (0.6000, 1.0000, 1.0000),  # #99FFFF - 2 - 4\n    (0.5569, 0.8235, 1.0000),  # #8ED2FF - 4 - 6\n    (0.4509, 0.6196, 0.8745),  # #739EDF - 6 - 8\n    (0.4157, 0.4706, 1.0000),  # #6A78FF - 8 - 10\n    (0.4235, 0.2784, 1.0000),  # #6C47FF - 10 - 12\n    (0.5529, 0.0980, 1.0000),  # #8D19FF - 12 - 14\n    (0.7333, 0.0000, 0.9176),  # #BB00EA - 14 - 16\n    (0.8392, 0.0000, 0.7490),  # #D600BF - 16 - 18\n    (0.7569, 0.0039, 0.4549),  # #C10074 - 18 - 20\n    (0.6784, 0.0000, 0.1961),  # #AD0032 - 20 - 30\n    (0.5020, 0.0000, 0.0000)   # #800000 - > 30\n]\n\ncmap_name = 'custom_snow_colormap'\ncustom_cmap = mcolors.ListedColormap(colors)\n\n# Define the lat_lon_to_map_coordinates function\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\n# Define your value ranges for color mapping\n#value_ranges = [1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 30]\n#value_ranges = [0.1, 0.2, 0.4, 0.6, 0.8, 1.0, 1.2, 1.5, 1.8, 2, 2.5, 3]\n\ndef create_color_maps_with_value_range(df_col, value_ranges=None):\n  if value_ranges == None:\n    max_value = df_col.max()\n    min_value = df_col.min()\n    if min_value < 0:\n      min_value = 0\n    step_size = (max_value - min_value) / 12\n\n    # Create 10 periods\n    value_ranges = [min_value + i * step_size for i in range(12)]\n  # Define your custom function to map data values to colors\n  def map_value_to_color(value):\n    # Iterate through the value ranges to find the appropriate color index\n    for i, range_max in enumerate(value_ranges):\n      if value <= range_max:\n        return colors[i]\n\n      # If the value is greater than the largest range, return the last color\n      return colors[-1]\n\n    # Map predicted_swe values to colors using the custom function\n  color_mapping = [map_value_to_color(value) for value in df_col.values]\n  return color_mapping, value_ranges\n\ndef convert_csvs_to_images():\n    data = pd.read_csv(\"/home/chetana/gridmet_test_run/test_data_predicted.csv\")\n    print(data.head())\n    print(\"statistic of predicted_swe: \", data['predicted_swe'].describe())\n    data['predicted_swe'].fillna(0, inplace=True)\n    #data['predicted_swe'] = data['predicted_swe'].apply(lambda x: 0 if x < 2 else x)\n    \n#     for column in data.columns:\n#       column_data = data[column]\n#       description = column_data.describe()\n\n#       # Print or process the description as needed\n#       print(f\"Column: {column}\")\n#       print(description)\n    \n    # Create a figure with a white background\n    fig = plt.figure(facecolor='white')\n\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    print(\"data['lon'].values = \", data['lon'].values)\n    x, y = m(data['lon'].values, data['lat'].values)\n#     print(\"x = \", x)\n#     print(\"y = \", y)\n#     print(\"v = \", data['predicted_swe'].values)\n    print(data.columns)\n\n    color_mapping, value_ranges = create_color_maps_with_value_range(data[\"SWE\"])\n    \n    # Plot the data using the custom colormap\n    plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\n    \n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_date = datetime(1900, 1, 1)\n    day_value = day_index\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    timestamp_string = result_date.strftime(\"%Y-%m-%d\")\n    \n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    # Create custom legend elements using the same colormap\n    legend_elements = [Patch(color=colors[i], label=f\"{value_ranges[i]} - {value_ranges[i+1]-1}\" if i < len(value_ranges) - 1 else f\"> {value_ranges[-1]}\") for i in range(len(value_ranges))]\n\n    # Create the legend outside the map\n    legend = plt.legend(handles=legend_elements, loc='upper left', title='Legend', fontsize=8)\n    legend.set_bbox_to_anchor((1.01, 1)) \n\n    # Remove the color bar\n    #plt.colorbar().remove()\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Set the aspect ratio to 'equal' to keep the plot at the center\n    plt.gca().set_aspect('equal', adjustable='box')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15, right=0.80)  # Adjust right margin to accommodate the legend\n    # Show the plot or save it to a file\n    new_plot_path = f'/home/chetana/gridmet_test_run/predicted_swe-{test_start_date}.png'\n    print(f\"The new plot is saved to {new_plot_path}\")\n    plt.savefig(new_plot_path)\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "/home/chetana/gw-workspace/R1sDNdyWco67/convert_results_to_images.py:99: UserWarning: No data for colormapping provided via 'c'. Parameters 'cmap' will be ignored\n  plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\ntoday date = 2023-09-24\ntest start date:  2022-08-22\ntest end date:  2023-09-24\n/home/chetana\n    date   lat      lon  SWE  ...  aspect  eastness  northness  predicted_swe\n0  44793  49.0 -125.000    0  ...     NaN       NaN        NaN            NaN\n1  44793  49.0 -124.964    0  ...     NaN       NaN        NaN            NaN\n2  44793  49.0 -124.928    0  ...     NaN       NaN        NaN            NaN\n3  44793  49.0 -124.892    0  ...     NaN       NaN        NaN            NaN\n4  44793  49.0 -124.856    0  ...     NaN       NaN        NaN            NaN\n[5 rows x 20 columns]\nstatistic of predicted_swe:  count    267444.000000\nmean          0.001844\nstd           0.014155\nmin           0.000000\n25%           0.000000\n50%           0.000000\n75%           0.000000\nmax           0.339000\nName: predicted_swe, dtype: float64\ndata['lon'].values =  [-125.    -124.964 -124.928 ... -100.124 -100.088 -100.052]\nIndex(['date', 'lat', 'lon', 'SWE', 'Flag', 'air_temperature_tmmn',\n       'potential_evapotranspiration', 'mean_vapor_pressure_deficit',\n       'relative_humidity_rmax', 'relative_humidity_rmin',\n       'precipitation_amount', 'air_temperature_tmmx', 'wind_speed',\n       'elevation', 'slope', 'curvature', 'aspect', 'eastness', 'northness',\n       'predicted_swe'],\n      dtype='object')\nThe new plot is saved to /home/chetana/gridmet_test_run/predicted_swe-2022-08-22.png\n",
  "history_begin_time" : 1695520158812,
  "history_end_time" : 1695520168205,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "diwQooQ8kYR1",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport uuid\nfrom snowcast_utils import day_index\nimport matplotlib.colors as mcolors\nfrom matplotlib.patches import Patch\nfrom snowcast_utils import day_index, work_dir, test_start_date\n\n# Define the custom colormap with specified colors and ranges\ncolors = [\n    (0.8627, 0.8627, 0.8627),  # #DCDCDC - 0 - 1\n    (0.8627, 1.0000, 1.0000),  # #DCFFFF - 1 - 2\n    (0.6000, 1.0000, 1.0000),  # #99FFFF - 2 - 4\n    (0.5569, 0.8235, 1.0000),  # #8ED2FF - 4 - 6\n    (0.4509, 0.6196, 0.8745),  # #739EDF - 6 - 8\n    (0.4157, 0.4706, 1.0000),  # #6A78FF - 8 - 10\n    (0.4235, 0.2784, 1.0000),  # #6C47FF - 10 - 12\n    (0.5529, 0.0980, 1.0000),  # #8D19FF - 12 - 14\n    (0.7333, 0.0000, 0.9176),  # #BB00EA - 14 - 16\n    (0.8392, 0.0000, 0.7490),  # #D600BF - 16 - 18\n    (0.7569, 0.0039, 0.4549),  # #C10074 - 18 - 20\n    (0.6784, 0.0000, 0.1961),  # #AD0032 - 20 - 30\n    (0.5020, 0.0000, 0.0000)   # #800000 - > 30\n]\n\ncmap_name = 'custom_snow_colormap'\ncustom_cmap = mcolors.ListedColormap(colors)\n\n# Define the lat_lon_to_map_coordinates function\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\n# Define your value ranges for color mapping\n#value_ranges = [1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 30]\n#value_ranges = [0.1, 0.2, 0.4, 0.6, 0.8, 1.0, 1.2, 1.5, 1.8, 2, 2.5, 3]\n\ndef create_color_maps_with_value_range(df_col, value_ranges=None):\n  if value_ranges == None:\n    max_value = df_col.max()\n    min_value = df_col.min()\n    if min_value < 0:\n      min_value = 0\n    step_size = (max_value - min_value) / 12\n\n    # Create 10 periods\n    value_ranges = [min_value + i * step_size for i in range(12)]\n  # Define your custom function to map data values to colors\n  def map_value_to_color(value):\n    # Iterate through the value ranges to find the appropriate color index\n    for i, range_max in enumerate(value_ranges):\n      if value <= range_max:\n        return colors[i]\n\n      # If the value is greater than the largest range, return the last color\n      return colors[-1]\n\n    # Map predicted_swe values to colors using the custom function\n  color_mapping = [map_value_to_color(value) for value in df_col.values]\n  return color_mapping, value_ranges\n\ndef convert_csvs_to_images():\n    data = pd.read_csv(\"/home/chetana/gridmet_test_run/test_data_predicted.csv\")\n    print(data.head())\n    print(\"statistic of predicted_swe: \", data['predicted_swe'].describe())\n    data['predicted_swe'].fillna(0, inplace=True)\n    #data['predicted_swe'] = data['predicted_swe'].apply(lambda x: 0 if x < 2 else x)\n    \n#     for column in data.columns:\n#       column_data = data[column]\n#       description = column_data.describe()\n\n#       # Print or process the description as needed\n#       print(f\"Column: {column}\")\n#       print(description)\n    \n    # Create a figure with a white background\n    fig = plt.figure(facecolor='white')\n\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    print(\"data['lon'].values = \", data['lon'].values)\n    x, y = m(data['lon'].values, data['lat'].values)\n    print(\"x = \", x)\n    print(\"y = \", y)\n    print(\"v = \", data['predicted_swe'].values)\n    print(data.columns)\n\n    color_mapping, value_ranges = create_color_maps_with_value_range(data[\"predicted_swe\"])\n    \n    # Plot the data using the custom colormap\n    plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\n    \n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_date = datetime(1900, 1, 1)\n    day_value = day_index\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    timestamp_string = result_date.strftime(\"%Y-%m-%d\")\n    \n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    # Create custom legend elements using the same colormap\n    legend_elements = [Patch(color=colors[i], label=f\"{value_ranges[i]} - {value_ranges[i+1]-1}\" if i < len(value_ranges) - 1 else f\"> {value_ranges[-1]}\") for i in range(len(value_ranges))]\n\n    # Create the legend outside the map\n    legend = plt.legend(handles=legend_elements, loc='upper left', title='Legend', fontsize=8)\n    legend.set_bbox_to_anchor((1.01, 1)) \n\n    # Remove the color bar\n    #plt.colorbar().remove()\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Set the aspect ratio to 'equal' to keep the plot at the center\n    plt.gca().set_aspect('equal', adjustable='box')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15, right=0.80)  # Adjust right margin to accommodate the legend\n    # Show the plot or save it to a file\n    new_plot_path = f'/home/chetana/gridmet_test_run/predicted_swe-{test_start_date}.png'\n    print(f\"The new plot is saved to {new_plot_path}\")\n    plt.savefig(new_plot_path)\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "/home/chetana/gw-workspace/diwQooQ8kYR1/convert_results_to_images.py:99: UserWarning: No data for colormapping provided via 'c'. Parameters 'cmap' will be ignored\n  plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\ntoday date = 2023-09-24\ntest start date:  2022-08-22\ntest end date:  2023-09-24\n/home/chetana\n    date   lat      lon  SWE  ...  aspect  eastness  northness  predicted_swe\n0  44793  49.0 -125.000    0  ...     NaN       NaN        NaN            NaN\n1  44793  49.0 -124.964    0  ...     NaN       NaN        NaN            NaN\n2  44793  49.0 -124.928    0  ...     NaN       NaN        NaN            NaN\n3  44793  49.0 -124.892    0  ...     NaN       NaN        NaN            NaN\n4  44793  49.0 -124.856    0  ...     NaN       NaN        NaN            NaN\n[5 rows x 20 columns]\nstatistic of predicted_swe:  count    267444.000000\nmean          0.001844\nstd           0.014155\nmin           0.000000\n25%           0.000000\n50%           0.000000\n75%           0.000000\nmax           0.339000\nName: predicted_swe, dtype: float64\ndata['lon'].values =  [-125.    -124.964 -124.928 ... -100.124 -100.088 -100.052]\nx =  [      0.            4003.01547425    8006.0309485  ... 2766083.69270573\n 2770086.70817998 2774089.72365423]\ny =  [3395311.63129883 3395311.63129883 3395311.63129883 ...    7363.19741597\n    7363.19741597    7363.19741597]\nv =  [0. 0. 0. ... 0. 0. 0.]\nIndex(['date', 'lat', 'lon', 'SWE', 'Flag', 'air_temperature_tmmn',\n       'potential_evapotranspiration', 'mean_vapor_pressure_deficit',\n       'relative_humidity_rmax', 'relative_humidity_rmin',\n       'precipitation_amount', 'air_temperature_tmmx', 'wind_speed',\n       'elevation', 'slope', 'curvature', 'aspect', 'eastness', 'northness',\n       'predicted_swe'],\n      dtype='object')\nThe new plot is saved to /home/chetana/gridmet_test_run/predicted_swe-2022-08-22.png\n",
  "history_begin_time" : 1695520055018,
  "history_end_time" : 1695520064114,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "5t6q0dpd72z",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport uuid\nfrom snowcast_utils import day_index\nimport matplotlib.colors as mcolors\nfrom matplotlib.patches import Patch\nfrom snowcast_utils import day_index, work_dir, test_start_date\n\n# Define the custom colormap with specified colors and ranges\ncolors = [\n    (0.8627, 0.8627, 0.8627),  # #DCDCDC - 0 - 1\n    (0.8627, 1.0000, 1.0000),  # #DCFFFF - 1 - 2\n    (0.6000, 1.0000, 1.0000),  # #99FFFF - 2 - 4\n    (0.5569, 0.8235, 1.0000),  # #8ED2FF - 4 - 6\n    (0.4509, 0.6196, 0.8745),  # #739EDF - 6 - 8\n    (0.4157, 0.4706, 1.0000),  # #6A78FF - 8 - 10\n    (0.4235, 0.2784, 1.0000),  # #6C47FF - 10 - 12\n    (0.5529, 0.0980, 1.0000),  # #8D19FF - 12 - 14\n    (0.7333, 0.0000, 0.9176),  # #BB00EA - 14 - 16\n    (0.8392, 0.0000, 0.7490),  # #D600BF - 16 - 18\n    (0.7569, 0.0039, 0.4549),  # #C10074 - 18 - 20\n    (0.6784, 0.0000, 0.1961),  # #AD0032 - 20 - 30\n    (0.5020, 0.0000, 0.0000)   # #800000 - > 30\n]\n\ncmap_name = 'custom_snow_colormap'\ncustom_cmap = mcolors.ListedColormap(colors)\n\n# Define the lat_lon_to_map_coordinates function\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\n# Define your value ranges for color mapping\n#value_ranges = [1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 30]\n#value_ranges = [0.1, 0.2, 0.4, 0.6, 0.8, 1.0, 1.2, 1.5, 1.8, 2, 2.5, 3]\n\ndef create_color_maps_with_value_range(df_col, value_ranges=None):\n  if value_ranges == None:\n    max_value = df_col.max()\n    min_value = df_col.min()\n    if min_value < 0:\n      min_value = 0\n    step_size = (max_value - min_value) / 12\n\n    # Create 10 periods\n    value_ranges = [min_value + i * step_size for i in range(12)]\n  # Define your custom function to map data values to colors\n  def map_value_to_color(value):\n    # Iterate through the value ranges to find the appropriate color index\n    for i, range_max in enumerate(value_ranges):\n      if value <= range_max:\n        return colors[i]\n\n      # If the value is greater than the largest range, return the last color\n      return colors[-1]\n\n    # Map predicted_swe values to colors using the custom function\n  color_mapping = [map_value_to_color(value) for value in df_col.values]\n  return color_mapping, value_ranges\n\ndef convert_csvs_to_images():\n    data = pd.read_csv(\"/home/chetana/gridmet_test_run/test_data_predicted.csv\")\n    print(data.head())\n    print(\"statistic of predicted_swe: \", data['predicted_swe'].describe())\n    data['predicted_swe'].fillna(0, inplace=True)\n    #data['predicted_swe'] = data['predicted_swe'].apply(lambda x: 0 if x < 2 else x)\n    \n#     for column in data.columns:\n#       column_data = data[column]\n#       description = column_data.describe()\n\n#       # Print or process the description as needed\n#       print(f\"Column: {column}\")\n#       print(description)\n    \n    # Create a figure with a white background\n    fig = plt.figure(facecolor='white')\n\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    print(\"data['lon'].values = \", data['lon'].values)\n    x, y = m(data['lon'].values, data['lat'].values)\n    print(\"x = \", x)\n    print(\"y = \", y)\n    print(\"v = \", data['predicted_swe'].values)\n    print(data.columns)\n\n    color_mapping, value_ranges = create_color_maps_with_value_range(data[\"predicted_swe\"])\n    \n    # Plot the data using the custom colormap\n    plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\n    \n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_date = datetime(1900, 1, 1)\n    day_value = day_index\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    timestamp_string = result_date.strftime(\"%Y-%m-%d\")\n    \n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    # Create custom legend elements using the same colormap\n    legend_elements = [Patch(color=colors[i], label=f\"{value_ranges[i]} - {value_ranges[i+1]-1}\" if i < len(value_ranges) - 1 else f\"> {value_ranges[-1]}\") for i in range(len(value_ranges))]\n\n    # Create the legend outside the map\n    legend = plt.legend(handles=legend_elements, loc='upper left', title='Legend', fontsize=8)\n    legend.set_bbox_to_anchor((1.01, 1)) \n\n    # Remove the color bar\n    #plt.colorbar().remove()\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Set the aspect ratio to 'equal' to keep the plot at the center\n    plt.gca().set_aspect('equal', adjustable='box')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15, right=0.80)  # Adjust right margin to accommodate the legend\n    # Show the plot or save it to a file\n    new_plot_path = f'/home/chetana/gridmet_test_run/predicted_swe-{test_start_date}.png'\n    print(f\"The new plot is saved to {new_plot_path}\")\n    plt.savefig(new_plot_path)\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "/home/chetana/gw-workspace/5t6q0dpd72z/convert_results_to_images.py:99: UserWarning: No data for colormapping provided via 'c'. Parameters 'cmap' will be ignored\n  plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\ntoday date = 2023-09-24\ntest start date:  2022-08-22\ntest end date:  2023-09-24\n/home/chetana\n    date   lat      lon  SWE  ...  aspect  eastness  northness  predicted_swe\n0  44793  49.0 -125.000    0  ...  -999.0    -999.0     -999.0          1.609\n1  44793  49.0 -124.964    0  ...  -999.0    -999.0     -999.0          1.609\n2  44793  49.0 -124.928    0  ...  -999.0    -999.0     -999.0          1.609\n3  44793  49.0 -124.892    0  ...  -999.0    -999.0     -999.0          1.609\n4  44793  49.0 -124.856    0  ...  -999.0    -999.0     -999.0          1.609\n[5 rows x 20 columns]\nstatistic of predicted_swe:  count    462204.000000\nmean          0.466611\nstd           0.691151\nmin           0.000000\n25%           0.000000\n50%           0.000000\n75%           1.416000\nmax           1.920000\nName: predicted_swe, dtype: float64\ndata['lon'].values =  [-125.    -124.964 -124.928 ... -100.124 -100.088 -100.052]\nx =  [      0.            4003.01547425    8006.0309485  ... 2766083.69270573\n 2770086.70817998 2774089.72365423]\ny =  [3395311.63129883 3395311.63129883 3395311.63129883 ...    7363.19741597\n    7363.19741597    7363.19741597]\nv =  [1.609 1.609 1.609 ... 1.444 1.444 1.444]\nIndex(['date', 'lat', 'lon', 'SWE', 'Flag', 'air_temperature_tmmn',\n       'potential_evapotranspiration', 'mean_vapor_pressure_deficit',\n       'relative_humidity_rmax', 'relative_humidity_rmin',\n       'precipitation_amount', 'air_temperature_tmmx', 'wind_speed',\n       'elevation', 'slope', 'curvature', 'aspect', 'eastness', 'northness',\n       'predicted_swe'],\n      dtype='object')\nThe new plot is saved to /home/chetana/gridmet_test_run/predicted_swe-2022-08-22.png\n",
  "history_begin_time" : 1695515912120,
  "history_end_time" : 1695515924393,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "100001",
  "indicator" : "Done"
},{
  "history_id" : "XXQbnqwic97J",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport uuid\nfrom snowcast_utils import day_index\nimport matplotlib.colors as mcolors\nfrom matplotlib.patches import Patch\nfrom snowcast_utils import day_index, work_dir, test_start_date\n\n# Define the custom colormap with specified colors and ranges\ncolors = [\n    (0.8627, 0.8627, 0.8627),  # #DCDCDC - 0 - 1\n    (0.8627, 1.0000, 1.0000),  # #DCFFFF - 1 - 2\n    (0.6000, 1.0000, 1.0000),  # #99FFFF - 2 - 4\n    (0.5569, 0.8235, 1.0000),  # #8ED2FF - 4 - 6\n    (0.4509, 0.6196, 0.8745),  # #739EDF - 6 - 8\n    (0.4157, 0.4706, 1.0000),  # #6A78FF - 8 - 10\n    (0.4235, 0.2784, 1.0000),  # #6C47FF - 10 - 12\n    (0.5529, 0.0980, 1.0000),  # #8D19FF - 12 - 14\n    (0.7333, 0.0000, 0.9176),  # #BB00EA - 14 - 16\n    (0.8392, 0.0000, 0.7490),  # #D600BF - 16 - 18\n    (0.7569, 0.0039, 0.4549),  # #C10074 - 18 - 20\n    (0.6784, 0.0000, 0.1961),  # #AD0032 - 20 - 30\n    (0.5020, 0.0000, 0.0000)   # #800000 - > 30\n]\n\ncmap_name = 'custom_snow_colormap'\ncustom_cmap = mcolors.ListedColormap(colors)\n\n# Define the lat_lon_to_map_coordinates function\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\n# Define your value ranges for color mapping\n#value_ranges = [1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 30]\n#value_ranges = [0.1, 0.2, 0.4, 0.6, 0.8, 1.0, 1.2, 1.5, 1.8, 2, 2.5, 3]\n\ndef create_color_maps_with_value_range(df_col, value_ranges=None):\n  if value_ranges == None:\n    max_value = df_col.max()\n    min_value = df_col.min()\n    if min_value < 0:\n      min_value = 0\n    step_size = (max_value - min_value) / 12\n\n    # Create 10 periods\n    value_ranges = [min_value + i * step_size for i in range(12)]\n  # Define your custom function to map data values to colors\n  def map_value_to_color(value):\n    # Iterate through the value ranges to find the appropriate color index\n    for i, range_max in enumerate(value_ranges):\n      if value <= range_max:\n        return colors[i]\n\n      # If the value is greater than the largest range, return the last color\n      return colors[-1]\n\n    # Map predicted_swe values to colors using the custom function\n  color_mapping = [map_value_to_color(value) for value in df_col.values]\n  return color_mapping, value_ranges\n\ndef convert_csvs_to_images():\n    data = pd.read_csv(\"/home/chetana/gridmet_test_run/test_data_predicted.csv\")\n    print(data.head())\n    print(\"statistic of predicted_swe: \", data['predicted_swe'].describe())\n    data['predicted_swe'].fillna(0, inplace=True)\n    #data['predicted_swe'] = data['predicted_swe'].apply(lambda x: 0 if x < 2 else x)\n    \n#     for column in data.columns:\n#       column_data = data[column]\n#       description = column_data.describe()\n\n#       # Print or process the description as needed\n#       print(f\"Column: {column}\")\n#       print(description)\n    \n    # Create a figure with a white background\n    fig = plt.figure(facecolor='white')\n\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    print(\"data['lon'].values = \", data['lon'].values)\n    x, y = m(data['lon'].values, data['lat'].values)\n    print(\"x = \", x)\n    print(\"y = \", y)\n    print(\"v = \", data['predicted_swe'].values)\n    print(data.columns)\n\n    color_mapping, value_ranges = create_color_maps_with_value_range(data[\"predicted_swe\"])\n    \n    # Plot the data using the custom colormap\n    plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\n    \n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_date = datetime(1900, 1, 1)\n    day_value = day_index\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    timestamp_string = result_date.strftime(\"%Y-%m-%d\")\n    \n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    # Create custom legend elements using the same colormap\n    legend_elements = [Patch(color=colors[i], label=f\"{value_ranges[i]} - {value_ranges[i+1]-1}\" if i < len(value_ranges) - 1 else f\"> {value_ranges[-1]}\") for i in range(len(value_ranges))]\n\n    # Create the legend outside the map\n    legend = plt.legend(handles=legend_elements, loc='upper left', title='Legend', fontsize=8)\n    legend.set_bbox_to_anchor((1.01, 1)) \n\n    # Remove the color bar\n    #plt.colorbar().remove()\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Set the aspect ratio to 'equal' to keep the plot at the center\n    plt.gca().set_aspect('equal', adjustable='box')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15, right=0.80)  # Adjust right margin to accommodate the legend\n    # Show the plot or save it to a file\n    new_plot_path = f'/home/chetana/gridmet_test_run/predicted_swe-{test_start_date}.png'\n    print(f\"The new plot is saved to {new_plot_path}\")\n    plt.savefig(new_plot_path)\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "/home/chetana/gw-workspace/XXQbnqwic97J/convert_results_to_images.py:99: UserWarning: No data for colormapping provided via 'c'. Parameters 'cmap' will be ignored\n  plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\ntoday date = 2023-09-23\ntest start date:  2022-08-22\ntest end date:  2023-09-23\n/home/chetana\n    date   lat      lon  SWE  ...  aspect  eastness  northness  predicted_swe\n0  44793  49.0 -125.000    0  ...  -999.0    -999.0     -999.0          1.609\n1  44793  49.0 -124.964    0  ...  -999.0    -999.0     -999.0          1.609\n2  44793  49.0 -124.928    0  ...  -999.0    -999.0     -999.0          1.609\n3  44793  49.0 -124.892    0  ...  -999.0    -999.0     -999.0          1.609\n4  44793  49.0 -124.856    0  ...  -999.0    -999.0     -999.0          1.609\n[5 rows x 20 columns]\nstatistic of predicted_swe:  count    462204.000000\nmean          0.469296\nstd           0.692289\nmin           0.000000\n25%           0.000000\n50%           0.000000\n75%           1.432000\nmax           1.711000\nName: predicted_swe, dtype: float64\ndata['lon'].values =  [-125.    -124.964 -124.928 ... -100.124 -100.088 -100.052]\nx =  [      0.            4003.01547425    8006.0309485  ... 2766083.69270573\n 2770086.70817998 2774089.72365423]\ny =  [3395311.63129883 3395311.63129883 3395311.63129883 ...    7363.19741597\n    7363.19741597    7363.19741597]\nv =  [1.609 1.609 1.609 ... 1.444 1.444 1.444]\nIndex(['date', 'lat', 'lon', 'SWE', 'Flag', 'air_temperature_tmmn',\n       'potential_evapotranspiration', 'mean_vapor_pressure_deficit',\n       'relative_humidity_rmax', 'relative_humidity_rmin',\n       'precipitation_amount', 'air_temperature_tmmx', 'wind_speed',\n       'elevation', 'slope', 'curvature', 'aspect', 'eastness', 'northness',\n       'predicted_swe'],\n      dtype='object')\nThe new plot is saved to /home/chetana/gridmet_test_run/predicted_swe-2022-08-22.png\n",
  "history_begin_time" : 1695508405377,
  "history_end_time" : 1695508414652,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "3FGzxRxphxqL",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport uuid\nfrom snowcast_utils import day_index\nimport matplotlib.colors as mcolors\nfrom matplotlib.patches import Patch\nfrom snowcast_utils import day_index, work_dir, test_start_date\n\n# Define the custom colormap with specified colors and ranges\ncolors = [\n    (0.8627, 0.8627, 0.8627),  # #DCDCDC - 0 - 1\n    (0.8627, 1.0000, 1.0000),  # #DCFFFF - 1 - 2\n    (0.6000, 1.0000, 1.0000),  # #99FFFF - 2 - 4\n    (0.5569, 0.8235, 1.0000),  # #8ED2FF - 4 - 6\n    (0.4509, 0.6196, 0.8745),  # #739EDF - 6 - 8\n    (0.4157, 0.4706, 1.0000),  # #6A78FF - 8 - 10\n    (0.4235, 0.2784, 1.0000),  # #6C47FF - 10 - 12\n    (0.5529, 0.0980, 1.0000),  # #8D19FF - 12 - 14\n    (0.7333, 0.0000, 0.9176),  # #BB00EA - 14 - 16\n    (0.8392, 0.0000, 0.7490),  # #D600BF - 16 - 18\n    (0.7569, 0.0039, 0.4549),  # #C10074 - 18 - 20\n    (0.6784, 0.0000, 0.1961),  # #AD0032 - 20 - 30\n    (0.5020, 0.0000, 0.0000)   # #800000 - > 30\n]\n\ncmap_name = 'custom_snow_colormap'\ncustom_cmap = mcolors.ListedColormap(colors)\n\n# Define the lat_lon_to_map_coordinates function\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\n# Define your value ranges for color mapping\n#value_ranges = [1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 30]\n#value_ranges = [0.1, 0.2, 0.4, 0.6, 0.8, 1.0, 1.2, 1.5, 1.8, 2, 2.5, 3]\n\ndef create_color_maps_with_value_range(df_col, value_ranges=None):\n  if value_ranges == None:\n    max_value = df_col.max()\n    min_value = df_col.min()\n    if min_value < 0:\n      min_value = 0\n    step_size = (max_value - min_value) / 12\n\n    # Create 10 periods\n    value_ranges = [min_value + i * step_size for i in range(12)]\n  # Define your custom function to map data values to colors\n  def map_value_to_color(value):\n    # Iterate through the value ranges to find the appropriate color index\n    for i, range_max in enumerate(value_ranges):\n      if value <= range_max:\n        return colors[i]\n\n      # If the value is greater than the largest range, return the last color\n      return colors[-1]\n\n    # Map predicted_swe values to colors using the custom function\n  color_mapping = [map_value_to_color(value) for value in df_col.values]\n  return color_mapping, value_ranges\n\ndef convert_csvs_to_images():\n    data = pd.read_csv(\"/home/chetana/gridmet_test_run/test_data_predicted.csv\")\n    print(data.head())\n    print(\"statistic of predicted_swe: \", data['predicted_swe'].describe())\n    data['predicted_swe'].fillna(0, inplace=True)\n    data['predicted_swe'] = data['predicted_swe'].apply(lambda x: 0 if x < 2 else x)\n    \n    for column in data.columns:\n      column_data = data[column]\n      description = column_data.describe()\n\n      # Print or process the description as needed\n      print(f\"Column: {column}\")\n      print(description)\n    \n    # Create a figure with a white background\n    fig = plt.figure(facecolor='white')\n\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    print(\"data['lon'].values = \", data['lon'].values)\n    x, y = m(data['lon'].values, data['lat'].values)\n    print(\"x = \", x)\n    print(\"y = \", y)\n    print(\"v = \", data['predicted_swe'].values)\n    print(data.columns)\n\n    color_mapping, value_ranges = create_color_maps_with_value_range(data[\"predicted_swe\"])\n    \n    # Plot the data using the custom colormap\n    plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\n    \n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_date = datetime(1900, 1, 1)\n    day_value = day_index\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    timestamp_string = result_date.strftime(\"%Y-%m-%d\")\n    \n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    # Create custom legend elements using the same colormap\n    legend_elements = [Patch(color=colors[i], label=f\"{value_ranges[i]} - {value_ranges[i+1]-1}\" if i < len(value_ranges) - 1 else f\"> {value_ranges[-1]}\") for i in range(len(value_ranges))]\n\n    # Create the legend outside the map\n    legend = plt.legend(handles=legend_elements, loc='upper left', title='Legend', fontsize=8)\n    legend.set_bbox_to_anchor((1.01, 1)) \n\n    # Remove the color bar\n    #plt.colorbar().remove()\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Set the aspect ratio to 'equal' to keep the plot at the center\n    plt.gca().set_aspect('equal', adjustable='box')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15, right=0.80)  # Adjust right margin to accommodate the legend\n    # Show the plot or save it to a file\n    new_plot_path = f'/home/chetana/gridmet_test_run/predicted_swe-{test_start_date}.png'\n    print(f\"The new plot is saved to {new_plot_path}\")\n    plt.savefig(new_plot_path)\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "/home/chetana/gw-workspace/3FGzxRxphxqL/convert_results_to_images.py:99: UserWarning: No data for colormapping provided via 'c'. Parameters 'cmap' will be ignored\n  plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\ntoday date = 2023-09-23\ntest start date:  2022-08-22\ntest end date:  2023-09-23\n/home/chetana\n    date   lat      lon  SWE  ...  aspect  eastness  northness  predicted_swe\n0  44793  49.0 -125.000    0  ...  -999.0    -999.0     -999.0          1.609\n1  44793  49.0 -124.964    0  ...  -999.0    -999.0     -999.0          1.609\n2  44793  49.0 -124.928    0  ...  -999.0    -999.0     -999.0          1.609\n3  44793  49.0 -124.892    0  ...  -999.0    -999.0     -999.0          1.609\n4  44793  49.0 -124.856    0  ...  -999.0    -999.0     -999.0          1.609\n[5 rows x 20 columns]\nstatistic of predicted_swe:  count    462204.000000\nmean          0.469296\nstd           0.692289\nmin           0.000000\n25%           0.000000\n50%           0.000000\n75%           1.432000\nmax           1.711000\nName: predicted_swe, dtype: float64\nColumn: date\ncount    462204.0\nmean      44793.0\nstd           0.0\nmin       44793.0\n25%       44793.0\n50%       44793.0\n75%       44793.0\nmax       44793.0\nName: date, dtype: float64\nColumn: lat\ncount    462204.000000\nmean         37.030000\nstd           6.921275\nmin          25.060000\n25%          31.036000\n50%          37.030000\n75%          43.024000\nmax          49.000000\nName: lat, dtype: float64\nColumn: lon\ncount    462204.00000\nmean       -112.52600\nstd           7.21226\nmin        -125.00000\n25%        -118.77200\n50%        -112.52600\n75%        -106.28000\nmax        -100.05200\nName: lon, dtype: float64\nColumn: SWE\ncount    462204.000000\nmean        108.572974\nstd         125.689326\nmin           0.000000\n25%           0.000000\n50%           0.000000\n75%         254.000000\nmax         255.000000\nName: SWE, dtype: float64\nColumn: Flag\ncount    462204.000000\nmean        246.591938\nstd           6.518812\nmin         241.000000\n25%         241.000000\n50%         241.000000\n75%         254.000000\nmax         255.000000\nName: Flag, dtype: float64\nColumn: air_temperature_tmmn\ncount    462204.000000\nmean       -112.566517\nstd         595.289957\nmin        -999.000000\n25%        -999.000000\n50%         285.800000\n75%         288.000000\nmax         293.400000\nName: air_temperature_tmmn, dtype: float64\nColumn: potential_evapotranspiration\ncount    462204.000000\nmean       -305.371321\nstd         465.810243\nmin        -999.000000\n25%        -999.000000\n50%           5.950000\n75%           8.300000\nmax          11.000000\nName: potential_evapotranspiration, dtype: float64\nColumn: mean_vapor_pressure_deficit\ncount    462204.000000\nmean       -309.293393\nstd         463.173800\nmin        -999.000000\n25%        -999.000000\n50%           1.305000\n75%           2.120000\nmax           3.110000\nName: mean_vapor_pressure_deficit, dtype: float64\nColumn: relative_humidity_rmax\ncount    462204.000000\nmean       -261.386036\nstd         495.554173\nmin        -999.000000\n25%        -999.000000\n50%          60.650000\n75%          74.700000\nmax         100.000000\nName: relative_humidity_rmax, dtype: float64\nColumn: relative_humidity_rmin\ncount    462204.000000\nmean       -291.743393\nstd         475.083496\nmin        -999.000000\n25%        -999.000000\n50%          19.100000\n75%          26.100000\nmax          73.500000\nName: relative_humidity_rmin, dtype: float64\nColumn: precipitation_amount\ncount    462204.000000\nmean       -309.876426\nstd         462.788282\nmin        -999.000000\n25%        -999.000000\n50%           0.000000\n75%           0.000000\nmax          20.800000\nName: precipitation_amount, dtype: float64\nColumn: air_temperature_tmmx\ncount    462204.000000\nmean       -101.793994\nstd         602.527937\nmin        -999.000000\n25%        -999.000000\n50%         301.600000\n75%         304.700000\nmax         308.200000\nName: air_temperature_tmmx, dtype: float64\nColumn: wind_speed\ncount    462204.000000\nmean       -308.525976\nstd         463.689343\nmin        -999.000000\n25%        -999.000000\n50%           2.400000\n75%           3.100000\nmax           5.000000\nName: wind_speed, dtype: float64\nColumn: elevation\ncount    462204.000000\nmean       -328.271887\nstd         470.371193\nmin        -999.000000\n25%        -999.000000\n50%           1.423000\n75%           1.613000\nmax           2.557000\nName: elevation, dtype: float64\nColumn: slope\ncount    462204.000000\nmean       -296.733568\nstd         496.587226\nmin        -999.000000\n25%        -999.000000\n50%          44.193047\n75%          64.317660\nmax          86.687225\nName: slope, dtype: float64\nColumn: curvature\ncount    462204.000000\nmean       -359.380417\nstd         479.370074\nmin        -999.000000\n25%        -999.000000\n50%          -1.094771\n75%           0.368435\nmax          11.464941\nName: curvature, dtype: float64\nColumn: aspect\ncount    462204.000000\nmean       -219.043457\nstd         558.014747\nmin        -999.000000\n25%        -999.000000\n50%          83.290180\n75%         215.182167\nmax         359.906980\nName: aspect, dtype: float64\nColumn: eastness\ncount    462204.000000\nmean       -349.019408\nstd         476.293139\nmin        -999.000000\n25%        -999.000000\n50%          -0.622041\n75%           0.286890\nmax           0.785398\nName: eastness, dtype: float64\nColumn: northness\ncount    462204.000000\nmean       -349.023058\nstd         476.290475\nmin        -999.000000\n25%        -999.000000\n50%          -0.647724\n75%           0.306277\nmax           0.785398\nName: northness, dtype: float64\nColumn: predicted_swe\ncount    462204.0\nmean          0.0\nstd           0.0\nmin           0.0\n25%           0.0\n50%           0.0\n75%           0.0\nmax           0.0\nName: predicted_swe, dtype: float64\ndata['lon'].values =  [-125.    -124.964 -124.928 ... -100.124 -100.088 -100.052]\nx =  [      0.            4003.01547425    8006.0309485  ... 2766083.69270573\n 2770086.70817998 2774089.72365423]\ny =  [3395311.63129883 3395311.63129883 3395311.63129883 ...    7363.19741597\n    7363.19741597    7363.19741597]\nv =  [0 0 0 ... 0 0 0]\nIndex(['date', 'lat', 'lon', 'SWE', 'Flag', 'air_temperature_tmmn',\n       'potential_evapotranspiration', 'mean_vapor_pressure_deficit',\n       'relative_humidity_rmax', 'relative_humidity_rmin',\n       'precipitation_amount', 'air_temperature_tmmx', 'wind_speed',\n       'elevation', 'slope', 'curvature', 'aspect', 'eastness', 'northness',\n       'predicted_swe'],\n      dtype='object')\nThe new plot is saved to /home/chetana/gridmet_test_run/predicted_swe-2022-08-22.png\n",
  "history_begin_time" : 1695508266506,
  "history_end_time" : 1695508277129,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "scyKhsIJL7PK",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport uuid\nfrom snowcast_utils import day_index\nimport matplotlib.colors as mcolors\nfrom matplotlib.patches import Patch\nfrom snowcast_utils import day_index, work_dir, test_start_date\n\n# Define the custom colormap with specified colors and ranges\ncolors = [\n    (0.8627, 0.8627, 0.8627),  # #DCDCDC - 0 - 1\n    (0.8627, 1.0000, 1.0000),  # #DCFFFF - 1 - 2\n    (0.6000, 1.0000, 1.0000),  # #99FFFF - 2 - 4\n    (0.5569, 0.8235, 1.0000),  # #8ED2FF - 4 - 6\n    (0.4509, 0.6196, 0.8745),  # #739EDF - 6 - 8\n    (0.4157, 0.4706, 1.0000),  # #6A78FF - 8 - 10\n    (0.4235, 0.2784, 1.0000),  # #6C47FF - 10 - 12\n    (0.5529, 0.0980, 1.0000),  # #8D19FF - 12 - 14\n    (0.7333, 0.0000, 0.9176),  # #BB00EA - 14 - 16\n    (0.8392, 0.0000, 0.7490),  # #D600BF - 16 - 18\n    (0.7569, 0.0039, 0.4549),  # #C10074 - 18 - 20\n    (0.6784, 0.0000, 0.1961),  # #AD0032 - 20 - 30\n    (0.5020, 0.0000, 0.0000)   # #800000 - > 30\n]\n\ncmap_name = 'custom_snow_colormap'\ncustom_cmap = mcolors.ListedColormap(colors)\n\n# Define the lat_lon_to_map_coordinates function\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\n# Define your value ranges for color mapping\n#value_ranges = [1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 30]\n#value_ranges = [0.1, 0.2, 0.4, 0.6, 0.8, 1.0, 1.2, 1.5, 1.8, 2, 2.5, 3]\n\ndef create_color_maps_with_value_range(df_col, value_ranges=None):\n  if value_ranges == None:\n    max_value = df_col.max()\n    min_value = df_col.min()\n    if min_value < 0:\n      min_value = 0\n    step_size = (max_value - min_value) / 12\n\n    # Create 10 periods\n    value_ranges = [min_value + i * step_size for i in range(12)]\n  # Define your custom function to map data values to colors\n  def map_value_to_color(value):\n    # Iterate through the value ranges to find the appropriate color index\n    for i, range_max in enumerate(value_ranges):\n      if value <= range_max:\n        return colors[i]\n\n      # If the value is greater than the largest range, return the last color\n      return colors[-1]\n\n    # Map predicted_swe values to colors using the custom function\n  color_mapping = [map_value_to_color(value) for value in df_col.values]\n  return color_mapping, value_ranges\n\ndef convert_csvs_to_images():\n    data = pd.read_csv(\"/home/chetana/gridmet_test_run/test_data_predicted.csv\")\n    print(data.head())\n    print(\"statistic of predicted_swe: \", data['predicted_swe'].describe())\n    data['predicted_swe'].fillna(0, inplace=True)\n    data['predicted_swe'] = data['predicted_swe'].apply(lambda x: 0 if x < 2 else x)\n    \n    for column in data.columns:\n      column_data = data[column]\n      description = column_data.describe()\n\n      # Print or process the description as needed\n      print(f\"Column: {column}\")\n      print(description)\n    \n    # Create a figure with a white background\n    fig = plt.figure(facecolor='white')\n\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    print(\"data['lon'].values = \", data['lon'].values)\n    x, y = m(data['lon'].values, data['lat'].values)\n    print(\"x = \", x)\n    print(\"y = \", y)\n    print(\"v = \", data['predicted_swe'].values)\n    print(data.columns)\n\n    color_mapping, value_ranges = create_color_maps_with_value_range(data[\"predicted_swe\"])\n    \n    # Plot the data using the custom colormap\n    plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\n    \n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_date = datetime(1900, 1, 1)\n    day_value = day_index\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    timestamp_string = result_date.strftime(\"%Y-%m-%d\")\n    \n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    # Create custom legend elements using the same colormap\n    legend_elements = [Patch(color=colors[i], label=f\"{value_ranges[i]} - {value_ranges[i+1]-1}\" if i < len(value_ranges) - 1 else f\"> {value_ranges[-1]}\") for i in range(len(value_ranges))]\n\n    # Create the legend outside the map\n    legend = plt.legend(handles=legend_elements, loc='upper left', title='Legend', fontsize=8)\n    legend.set_bbox_to_anchor((1.01, 1)) \n\n    # Remove the color bar\n    #plt.colorbar().remove()\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Set the aspect ratio to 'equal' to keep the plot at the center\n    plt.gca().set_aspect('equal', adjustable='box')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15, right=0.80)  # Adjust right margin to accommodate the legend\n    # Show the plot or save it to a file\n    new_plot_path = f'/home/chetana/gridmet_test_run/predicted_swe-{test_start_date}.png'\n    print(f\"The new plot is saved to {new_plot_path}\")\n    plt.savefig(new_plot_path)\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "/home/chetana/gw-workspace/scyKhsIJL7PK/convert_results_to_images.py:99: UserWarning: No data for colormapping provided via 'c'. Parameters 'cmap' will be ignored\n  plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\ntoday date = 2023-09-23\ntest start date:  2022-08-22\ntest end date:  2023-09-23\n/home/chetana\n    date   lat      lon  SWE  ...  aspect  eastness  northness  predicted_swe\n0  44793  49.0 -125.000    0  ...  -999.0    -999.0     -999.0          1.609\n1  44793  49.0 -124.964    0  ...  -999.0    -999.0     -999.0          1.609\n2  44793  49.0 -124.928    0  ...  -999.0    -999.0     -999.0          1.609\n3  44793  49.0 -124.892    0  ...  -999.0    -999.0     -999.0          1.609\n4  44793  49.0 -124.856    0  ...  -999.0    -999.0     -999.0          1.609\n[5 rows x 20 columns]\nstatistic of predicted_swe:  count    462204.000000\nmean          0.469296\nstd           0.692289\nmin           0.000000\n25%           0.000000\n50%           0.000000\n75%           1.432000\nmax           1.711000\nName: predicted_swe, dtype: float64\nColumn: date\ncount    462204.0\nmean      44793.0\nstd           0.0\nmin       44793.0\n25%       44793.0\n50%       44793.0\n75%       44793.0\nmax       44793.0\nName: date, dtype: float64\nColumn: lat\ncount    462204.000000\nmean         37.030000\nstd           6.921275\nmin          25.060000\n25%          31.036000\n50%          37.030000\n75%          43.024000\nmax          49.000000\nName: lat, dtype: float64\nColumn: lon\ncount    462204.00000\nmean       -112.52600\nstd           7.21226\nmin        -125.00000\n25%        -118.77200\n50%        -112.52600\n75%        -106.28000\nmax        -100.05200\nName: lon, dtype: float64\nColumn: SWE\ncount    462204.000000\nmean        108.572974\nstd         125.689326\nmin           0.000000\n25%           0.000000\n50%           0.000000\n75%         254.000000\nmax         255.000000\nName: SWE, dtype: float64\nColumn: Flag\ncount    462204.000000\nmean        246.591938\nstd           6.518812\nmin         241.000000\n25%         241.000000\n50%         241.000000\n75%         254.000000\nmax         255.000000\nName: Flag, dtype: float64\nColumn: air_temperature_tmmn\ncount    462204.000000\nmean       -112.566517\nstd         595.289957\nmin        -999.000000\n25%        -999.000000\n50%         285.800000\n75%         288.000000\nmax         293.400000\nName: air_temperature_tmmn, dtype: float64\nColumn: potential_evapotranspiration\ncount    462204.000000\nmean       -305.371321\nstd         465.810243\nmin        -999.000000\n25%        -999.000000\n50%           5.950000\n75%           8.300000\nmax          11.000000\nName: potential_evapotranspiration, dtype: float64\nColumn: mean_vapor_pressure_deficit\ncount    462204.000000\nmean       -309.293393\nstd         463.173800\nmin        -999.000000\n25%        -999.000000\n50%           1.305000\n75%           2.120000\nmax           3.110000\nName: mean_vapor_pressure_deficit, dtype: float64\nColumn: relative_humidity_rmax\ncount    462204.000000\nmean       -261.386036\nstd         495.554173\nmin        -999.000000\n25%        -999.000000\n50%          60.650000\n75%          74.700000\nmax         100.000000\nName: relative_humidity_rmax, dtype: float64\nColumn: relative_humidity_rmin\ncount    462204.000000\nmean       -291.743393\nstd         475.083496\nmin        -999.000000\n25%        -999.000000\n50%          19.100000\n75%          26.100000\nmax          73.500000\nName: relative_humidity_rmin, dtype: float64\nColumn: precipitation_amount\ncount    462204.000000\nmean       -309.876426\nstd         462.788282\nmin        -999.000000\n25%        -999.000000\n50%           0.000000\n75%           0.000000\nmax          20.800000\nName: precipitation_amount, dtype: float64\nColumn: air_temperature_tmmx\ncount    462204.000000\nmean       -101.793994\nstd         602.527937\nmin        -999.000000\n25%        -999.000000\n50%         301.600000\n75%         304.700000\nmax         308.200000\nName: air_temperature_tmmx, dtype: float64\nColumn: wind_speed\ncount    462204.000000\nmean       -308.525976\nstd         463.689343\nmin        -999.000000\n25%        -999.000000\n50%           2.400000\n75%           3.100000\nmax           5.000000\nName: wind_speed, dtype: float64\nColumn: elevation\ncount    462204.000000\nmean       -328.271887\nstd         470.371193\nmin        -999.000000\n25%        -999.000000\n50%           1.423000\n75%           1.613000\nmax           2.557000\nName: elevation, dtype: float64\nColumn: slope\ncount    462204.000000\nmean       -296.733568\nstd         496.587226\nmin        -999.000000\n25%        -999.000000\n50%          44.193047\n75%          64.317660\nmax          86.687225\nName: slope, dtype: float64\nColumn: curvature\ncount    462204.000000\nmean       -359.380417\nstd         479.370074\nmin        -999.000000\n25%        -999.000000\n50%          -1.094771\n75%           0.368435\nmax          11.464941\nName: curvature, dtype: float64\nColumn: aspect\ncount    462204.000000\nmean       -219.043457\nstd         558.014747\nmin        -999.000000\n25%        -999.000000\n50%          83.290180\n75%         215.182167\nmax         359.906980\nName: aspect, dtype: float64\nColumn: eastness\ncount    462204.000000\nmean       -349.019408\nstd         476.293139\nmin        -999.000000\n25%        -999.000000\n50%          -0.622041\n75%           0.286890\nmax           0.785398\nName: eastness, dtype: float64\nColumn: northness\ncount    462204.000000\nmean       -349.023058\nstd         476.290475\nmin        -999.000000\n25%        -999.000000\n50%          -0.647724\n75%           0.306277\nmax           0.785398\nName: northness, dtype: float64\nColumn: predicted_swe\ncount    462204.0\nmean          0.0\nstd           0.0\nmin           0.0\n25%           0.0\n50%           0.0\n75%           0.0\nmax           0.0\nName: predicted_swe, dtype: float64\ndata['lon'].values =  [-125.    -124.964 -124.928 ... -100.124 -100.088 -100.052]\nx =  [      0.            4003.01547425    8006.0309485  ... 2766083.69270573\n 2770086.70817998 2774089.72365423]\ny =  [3395311.63129883 3395311.63129883 3395311.63129883 ...    7363.19741597\n    7363.19741597    7363.19741597]\nv =  [0 0 0 ... 0 0 0]\nIndex(['date', 'lat', 'lon', 'SWE', 'Flag', 'air_temperature_tmmn',\n       'potential_evapotranspiration', 'mean_vapor_pressure_deficit',\n       'relative_humidity_rmax', 'relative_humidity_rmin',\n       'precipitation_amount', 'air_temperature_tmmx', 'wind_speed',\n       'elevation', 'slope', 'curvature', 'aspect', 'eastness', 'northness',\n       'predicted_swe'],\n      dtype='object')\nThe new plot is saved to /home/chetana/gridmet_test_run/predicted_swe-2022-08-22.png\n",
  "history_begin_time" : 1695507907874,
  "history_end_time" : 1695507917870,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "SaGw6OUn1oGK",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport uuid\nfrom snowcast_utils import day_index\nimport matplotlib.colors as mcolors\nfrom matplotlib.patches import Patch\nfrom snowcast_utils import day_index, work_dir, test_start_date\n\n# Define the custom colormap with specified colors and ranges\ncolors = [\n    (0.8627, 0.8627, 0.8627),  # #DCDCDC - 0 - 1\n    (0.8627, 1.0000, 1.0000),  # #DCFFFF - 1 - 2\n    (0.6000, 1.0000, 1.0000),  # #99FFFF - 2 - 4\n    (0.5569, 0.8235, 1.0000),  # #8ED2FF - 4 - 6\n    (0.4509, 0.6196, 0.8745),  # #739EDF - 6 - 8\n    (0.4157, 0.4706, 1.0000),  # #6A78FF - 8 - 10\n    (0.4235, 0.2784, 1.0000),  # #6C47FF - 10 - 12\n    (0.5529, 0.0980, 1.0000),  # #8D19FF - 12 - 14\n    (0.7333, 0.0000, 0.9176),  # #BB00EA - 14 - 16\n    (0.8392, 0.0000, 0.7490),  # #D600BF - 16 - 18\n    (0.7569, 0.0039, 0.4549),  # #C10074 - 18 - 20\n    (0.6784, 0.0000, 0.1961),  # #AD0032 - 20 - 30\n    (0.5020, 0.0000, 0.0000)   # #800000 - > 30\n]\n\ncmap_name = 'custom_snow_colormap'\ncustom_cmap = mcolors.ListedColormap(colors)\n\n# Define the lat_lon_to_map_coordinates function\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\n# Define your value ranges for color mapping\n#value_ranges = [1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 30]\n#value_ranges = [0.1, 0.2, 0.4, 0.6, 0.8, 1.0, 1.2, 1.5, 1.8, 2, 2.5, 3]\n\ndef create_color_maps_with_value_range(df_col, value_ranges=None):\n  if value_ranges == None:\n    max_value = df_col.max()\n    min_value = df_col.min()\n    if min_value < 0:\n      min_value = 0\n    step_size = (max_value - min_value) / 12\n\n    # Create 10 periods\n    value_ranges = [min_value + i * step_size for i in range(12)]\n  # Define your custom function to map data values to colors\n  def map_value_to_color(value):\n    # Iterate through the value ranges to find the appropriate color index\n    for i, range_max in enumerate(value_ranges):\n      if value <= range_max:\n        return colors[i]\n\n      # If the value is greater than the largest range, return the last color\n      return colors[-1]\n\n    # Map predicted_swe values to colors using the custom function\n  color_mapping = [map_value_to_color(value) for value in df_col.values]\n  return color_mapping, value_ranges\n\ndef convert_csvs_to_images():\n    data = pd.read_csv(\"/home/chetana/gridmet_test_run/test_data_predicted.csv\")\n    print(data.head())\n    data['predicted_swe'].describe()\n    data['predicted_swe']..fillna(0, inplace=True)\n    data['predicted_swe'] = data['predicted_swe'].apply(lambda x: 0 if x < 2 else x)\n    \n    for column in data.columns:\n      column_data = data[column]\n      description = column_data.describe()\n\n      # Print or process the description as needed\n      print(f\"Column: {column}\")\n      print(description)\n    \n    # Create a figure with a white background\n    fig = plt.figure(facecolor='white')\n\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    print(\"data['lon'].values = \", data['lon'].values)\n    x, y = m(data['lon'].values, data['lat'].values)\n    print(\"x = \", x)\n    print(\"y = \", y)\n    print(\"v = \", data['predicted_swe'].values)\n    print(data.columns)\n\n    color_mapping, value_ranges = create_color_maps_with_value_range(data[\"predicted_swe\"])\n    \n    # Plot the data using the custom colormap\n    plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\n    \n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_date = datetime(1900, 1, 1)\n    day_value = day_index\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    timestamp_string = result_date.strftime(\"%Y-%m-%d\")\n    \n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    # Create custom legend elements using the same colormap\n    legend_elements = [Patch(color=colors[i], label=f\"{value_ranges[i]} - {value_ranges[i+1]-1}\" if i < len(value_ranges) - 1 else f\"> {value_ranges[-1]}\") for i in range(len(value_ranges))]\n\n    # Create the legend outside the map\n    legend = plt.legend(handles=legend_elements, loc='upper left', title='Legend', fontsize=8)\n    legend.set_bbox_to_anchor((1.01, 1)) \n\n    # Remove the color bar\n    #plt.colorbar().remove()\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Set the aspect ratio to 'equal' to keep the plot at the center\n    plt.gca().set_aspect('equal', adjustable='box')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15, right=0.80)  # Adjust right margin to accommodate the legend\n    # Show the plot or save it to a file\n    new_plot_path = f'/home/chetana/gridmet_test_run/predicted_swe-{test_start_date}.png'\n    print(f\"The new plot is saved to {new_plot_path}\")\n    plt.savefig(new_plot_path)\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "  File \"/home/chetana/gw-workspace/SaGw6OUn1oGK/convert_results_to_images.py\", line 69\n    data['predicted_swe']..fillna(0, inplace=True)\n                          ^\nSyntaxError: invalid syntax\n",
  "history_begin_time" : 1695507875856,
  "history_end_time" : 1695507875911,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Failed"
},{
  "history_id" : "f6IazrHNlNlZ",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport uuid\nfrom snowcast_utils import day_index\nimport matplotlib.colors as mcolors\nfrom matplotlib.patches import Patch\nfrom snowcast_utils import day_index, work_dir, test_start_date\n\n# Define the custom colormap with specified colors and ranges\ncolors = [\n    (0.8627, 0.8627, 0.8627),  # #DCDCDC - 0 - 1\n    (0.8627, 1.0000, 1.0000),  # #DCFFFF - 1 - 2\n    (0.6000, 1.0000, 1.0000),  # #99FFFF - 2 - 4\n    (0.5569, 0.8235, 1.0000),  # #8ED2FF - 4 - 6\n    (0.4509, 0.6196, 0.8745),  # #739EDF - 6 - 8\n    (0.4157, 0.4706, 1.0000),  # #6A78FF - 8 - 10\n    (0.4235, 0.2784, 1.0000),  # #6C47FF - 10 - 12\n    (0.5529, 0.0980, 1.0000),  # #8D19FF - 12 - 14\n    (0.7333, 0.0000, 0.9176),  # #BB00EA - 14 - 16\n    (0.8392, 0.0000, 0.7490),  # #D600BF - 16 - 18\n    (0.7569, 0.0039, 0.4549),  # #C10074 - 18 - 20\n    (0.6784, 0.0000, 0.1961),  # #AD0032 - 20 - 30\n    (0.5020, 0.0000, 0.0000)   # #800000 - > 30\n]\n\ncmap_name = 'custom_snow_colormap'\ncustom_cmap = mcolors.ListedColormap(colors)\n\n# Define the lat_lon_to_map_coordinates function\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\n# Define your value ranges for color mapping\n#value_ranges = [1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 30]\n#value_ranges = [0.1, 0.2, 0.4, 0.6, 0.8, 1.0, 1.2, 1.5, 1.8, 2, 2.5, 3]\n\ndef create_color_maps_with_value_range(df_col, value_ranges=None):\n  if value_ranges == None:\n    max_value = df_col.max()\n    min_value = df_col.min()\n    if min_value < 0:\n      min_value = 0\n    step_size = (max_value - min_value) / 12\n\n    # Create 10 periods\n    value_ranges = [min_value + i * step_size for i in range(12)]\n  # Define your custom function to map data values to colors\n  def map_value_to_color(value):\n    # Iterate through the value ranges to find the appropriate color index\n    for i, range_max in enumerate(value_ranges):\n      if value <= range_max:\n        return colors[i]\n\n      # If the value is greater than the largest range, return the last color\n      return colors[-1]\n\n    # Map predicted_swe values to colors using the custom function\n  color_mapping = [map_value_to_color(value) for value in df_col.values]\n  return color_mapping, value_ranges\n\ndef convert_csvs_to_images():\n    data = pd.read_csv(\"/home/chetana/gridmet_test_run/test_data_predicted.csv\")\n    print(data.head())\n    data['predicted_swe'].describe()\n    data['predicted_swe']..fillna(0, inplace=True)\n    data['predicted_swe'] = data['predicted_swe'].apply(lambda x: 0 if x < 2 else x)\n    \n    for column in data.columns:\n      column_data = data[column]\n      description = column_data.describe()\n\n      # Print or process the description as needed\n      print(f\"Column: {column}\")\n      print(description)\n    \n    # Create a figure with a white background\n    fig = plt.figure(facecolor='white')\n\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    print(\"data['lon'].values = \", data['lon'].values)\n    x, y = m(data['lon'].values, data['lat'].values)\n    print(\"x = \", x)\n    print(\"y = \", y)\n    print(\"v = \", data['predicted_swe'].values)\n    print(data.columns)\n\n    color_mapping, value_ranges = create_color_maps_with_value_range(data[\"predicted_swe\"])\n    \n    # Plot the data using the custom colormap\n    plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\n    \n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_date = datetime(1900, 1, 1)\n    day_value = day_index\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    timestamp_string = result_date.strftime(\"%Y-%m-%d\")\n    \n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    # Create custom legend elements using the same colormap\n    legend_elements = [Patch(color=colors[i], label=f\"{value_ranges[i]} - {value_ranges[i+1]-1}\" if i < len(value_ranges) - 1 else f\"> {value_ranges[-1]}\") for i in range(len(value_ranges))]\n\n    # Create the legend outside the map\n    legend = plt.legend(handles=legend_elements, loc='upper left', title='Legend', fontsize=8)\n    legend.set_bbox_to_anchor((1.01, 1)) \n\n    # Remove the color bar\n    #plt.colorbar().remove()\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Set the aspect ratio to 'equal' to keep the plot at the center\n    plt.gca().set_aspect('equal', adjustable='box')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15, right=0.80)  # Adjust right margin to accommodate the legend\n    # Show the plot or save it to a file\n    new_plot_path = f'/home/chetana/gridmet_test_run/predicted_swe-{test_start_date}.png'\n    print(f\"The new plot is saved to {new_plot_path}\")\n    plt.savefig(new_plot_path)\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "  File \"/home/chetana/gw-workspace/f6IazrHNlNlZ/convert_results_to_images.py\", line 69\n    data['predicted_swe']..fillna(0, inplace=True)\n                          ^\nSyntaxError: invalid syntax\n",
  "history_begin_time" : 1695506831479,
  "history_end_time" : 1695506831533,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Failed"
},{
  "history_id" : "2u3UH0tcaSds",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport uuid\nfrom snowcast_utils import day_index\nimport matplotlib.colors as mcolors\nfrom matplotlib.patches import Patch\nfrom snowcast_utils import day_index, work_dir, test_start_date\n\n# Define the custom colormap with specified colors and ranges\ncolors = [\n    (0.8627, 0.8627, 0.8627),  # #DCDCDC - 0 - 1\n    (0.8627, 1.0000, 1.0000),  # #DCFFFF - 1 - 2\n    (0.6000, 1.0000, 1.0000),  # #99FFFF - 2 - 4\n    (0.5569, 0.8235, 1.0000),  # #8ED2FF - 4 - 6\n    (0.4509, 0.6196, 0.8745),  # #739EDF - 6 - 8\n    (0.4157, 0.4706, 1.0000),  # #6A78FF - 8 - 10\n    (0.4235, 0.2784, 1.0000),  # #6C47FF - 10 - 12\n    (0.5529, 0.0980, 1.0000),  # #8D19FF - 12 - 14\n    (0.7333, 0.0000, 0.9176),  # #BB00EA - 14 - 16\n    (0.8392, 0.0000, 0.7490),  # #D600BF - 16 - 18\n    (0.7569, 0.0039, 0.4549),  # #C10074 - 18 - 20\n    (0.6784, 0.0000, 0.1961),  # #AD0032 - 20 - 30\n    (0.5020, 0.0000, 0.0000)   # #800000 - > 30\n]\n\ncmap_name = 'custom_snow_colormap'\ncustom_cmap = mcolors.ListedColormap(colors)\n\n# Define the lat_lon_to_map_coordinates function\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\n# Define your value ranges for color mapping\n#value_ranges = [1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 30]\n#value_ranges = [0.1, 0.2, 0.4, 0.6, 0.8, 1.0, 1.2, 1.5, 1.8, 2, 2.5, 3]\n\ndef create_color_maps_with_value_range(df_col, value_ranges=None):\n  if value_ranges == None:\n    max_value = df_col.max()\n    min_value = df_col.min()\n    if min_value < 0:\n      min_value = 0\n    step_size = (max_value - min_value) / 12\n\n    # Create 10 periods\n    value_ranges = [min_value + i * step_size for i in range(12)]\n  # Define your custom function to map data values to colors\n  def map_value_to_color(value):\n    # Iterate through the value ranges to find the appropriate color index\n    for i, range_max in enumerate(value_ranges):\n      if value <= range_max:\n        return colors[i]\n\n      # If the value is greater than the largest range, return the last color\n      return colors[-1]\n\n    # Map predicted_swe values to colors using the custom function\n  color_mapping = [map_value_to_color(value) for value in df_col.values]\n  return color_mapping, value_ranges\n\ndef convert_csvs_to_images():\n    data = pd.read_csv(\"/home/chetana/gridmet_test_run/test_data_predicted.csv\")\n    print(data.head())\n    data['predicted_swe'].fillna(0, inplace=True)\n    data['predicted_swe'] = data['predicted_swe'].apply(lambda x: 0 if x < 2 else x)\n    \n    for column in data.columns:\n      column_data = data[column]\n      description = column_data.describe()\n\n      # Print or process the description as needed\n      print(f\"Column: {column}\")\n      print(description)\n    \n    # Create a figure with a white background\n    fig = plt.figure(facecolor='white')\n\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    print(\"data['lon'].values = \", data['lon'].values)\n    x, y = m(data['lon'].values, data['lat'].values)\n    print(\"x = \", x)\n    print(\"y = \", y)\n    print(\"v = \", data['predicted_swe'].values)\n    print(data.columns)\n\n    color_mapping, value_ranges = create_color_maps_with_value_range(data[\"predicted_swe\"])\n    \n    # Plot the data using the custom colormap\n    plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\n    \n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_date = datetime(1900, 1, 1)\n    day_value = day_index\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    timestamp_string = result_date.strftime(\"%Y-%m-%d\")\n    \n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    # Create custom legend elements using the same colormap\n    legend_elements = [Patch(color=colors[i], label=f\"{value_ranges[i]} - {value_ranges[i+1]-1}\" if i < len(value_ranges) - 1 else f\"> {value_ranges[-1]}\") for i in range(len(value_ranges))]\n\n    # Create the legend outside the map\n    legend = plt.legend(handles=legend_elements, loc='upper left', title='Legend', fontsize=8)\n    legend.set_bbox_to_anchor((1.01, 1)) \n\n    # Remove the color bar\n    #plt.colorbar().remove()\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Set the aspect ratio to 'equal' to keep the plot at the center\n    plt.gca().set_aspect('equal', adjustable='box')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15, right=0.80)  # Adjust right margin to accommodate the legend\n    # Show the plot or save it to a file\n    new_plot_path = f'/home/chetana/gridmet_test_run/predicted_swe-{test_start_date}.png'\n    print(f\"The new plot is saved to {new_plot_path}\")\n    plt.savefig(new_plot_path)\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "/home/chetana/gw-workspace/2u3UH0tcaSds/convert_results_to_images.py:98: UserWarning: No data for colormapping provided via 'c'. Parameters 'cmap' will be ignored\n  plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\ntoday date = 2023-09-23\ntest start date:  2022-08-22\ntest end date:  2023-09-23\n/home/chetana\n    date   lat      lon  SWE  ...  aspect  eastness  northness  predicted_swe\n0  44793  49.0 -125.000    0  ...  -999.0    -999.0     -999.0         -9.074\n1  44793  49.0 -124.964    0  ...  -999.0    -999.0     -999.0         -9.074\n2  44793  49.0 -124.928    0  ...  -999.0    -999.0     -999.0         -9.074\n3  44793  49.0 -124.892    0  ...  -999.0    -999.0     -999.0         -9.074\n4  44793  49.0 -124.856    0  ...  -999.0    -999.0     -999.0         -9.074\n[5 rows x 20 columns]\nColumn: date\ncount    462204.0\nmean      44793.0\nstd           0.0\nmin       44793.0\n25%       44793.0\n50%       44793.0\n75%       44793.0\nmax       44793.0\nName: date, dtype: float64\nColumn: lat\ncount    462204.000000\nmean         37.030000\nstd           6.921275\nmin          25.060000\n25%          31.036000\n50%          37.030000\n75%          43.024000\nmax          49.000000\nName: lat, dtype: float64\nColumn: lon\ncount    462204.00000\nmean       -112.52600\nstd           7.21226\nmin        -125.00000\n25%        -118.77200\n50%        -112.52600\n75%        -106.28000\nmax        -100.05200\nName: lon, dtype: float64\nColumn: SWE\ncount    462204.000000\nmean        108.572974\nstd         125.689326\nmin           0.000000\n25%           0.000000\n50%           0.000000\n75%         254.000000\nmax         255.000000\nName: SWE, dtype: float64\nColumn: Flag\ncount    462204.000000\nmean        246.591938\nstd           6.518812\nmin         241.000000\n25%         241.000000\n50%         241.000000\n75%         254.000000\nmax         255.000000\nName: Flag, dtype: float64\nColumn: air_temperature_tmmn\ncount    462204.000000\nmean       -112.566517\nstd         595.289957\nmin        -999.000000\n25%        -999.000000\n50%         285.800000\n75%         288.000000\nmax         293.400000\nName: air_temperature_tmmn, dtype: float64\nColumn: potential_evapotranspiration\ncount    462204.000000\nmean       -305.371321\nstd         465.810243\nmin        -999.000000\n25%        -999.000000\n50%           5.950000\n75%           8.300000\nmax          11.000000\nName: potential_evapotranspiration, dtype: float64\nColumn: mean_vapor_pressure_deficit\ncount    462204.000000\nmean       -309.293393\nstd         463.173800\nmin        -999.000000\n25%        -999.000000\n50%           1.305000\n75%           2.120000\nmax           3.110000\nName: mean_vapor_pressure_deficit, dtype: float64\nColumn: relative_humidity_rmax\ncount    462204.000000\nmean       -261.386036\nstd         495.554173\nmin        -999.000000\n25%        -999.000000\n50%          60.650000\n75%          74.700000\nmax         100.000000\nName: relative_humidity_rmax, dtype: float64\nColumn: relative_humidity_rmin\ncount    462204.000000\nmean       -291.743393\nstd         475.083496\nmin        -999.000000\n25%        -999.000000\n50%          19.100000\n75%          26.100000\nmax          73.500000\nName: relative_humidity_rmin, dtype: float64\nColumn: precipitation_amount\ncount    462204.000000\nmean       -309.876426\nstd         462.788282\nmin        -999.000000\n25%        -999.000000\n50%           0.000000\n75%           0.000000\nmax          20.800000\nName: precipitation_amount, dtype: float64\nColumn: air_temperature_tmmx\ncount    462204.000000\nmean       -101.793994\nstd         602.527937\nmin        -999.000000\n25%        -999.000000\n50%         301.600000\n75%         304.700000\nmax         308.200000\nName: air_temperature_tmmx, dtype: float64\nColumn: wind_speed\ncount    462204.000000\nmean       -308.525976\nstd         463.689343\nmin        -999.000000\n25%        -999.000000\n50%           2.400000\n75%           3.100000\nmax           5.000000\nName: wind_speed, dtype: float64\nColumn: elevation\ncount    462204.000000\nmean       -328.271887\nstd         470.371193\nmin        -999.000000\n25%        -999.000000\n50%           1.423000\n75%           1.613000\nmax           2.557000\nName: elevation, dtype: float64\nColumn: slope\ncount    462204.000000\nmean       -296.733568\nstd         496.587226\nmin        -999.000000\n25%        -999.000000\n50%          44.193047\n75%          64.317660\nmax          86.687225\nName: slope, dtype: float64\nColumn: curvature\ncount    462204.000000\nmean       -359.380417\nstd         479.370074\nmin        -999.000000\n25%        -999.000000\n50%          -1.094771\n75%           0.368435\nmax          11.464941\nName: curvature, dtype: float64\nColumn: aspect\ncount    462204.000000\nmean       -219.043457\nstd         558.014747\nmin        -999.000000\n25%        -999.000000\n50%          83.290180\n75%         215.182167\nmax         359.906980\nName: aspect, dtype: float64\nColumn: eastness\ncount    462204.000000\nmean       -349.019408\nstd         476.293139\nmin        -999.000000\n25%        -999.000000\n50%          -0.622041\n75%           0.286890\nmax           0.785398\nName: eastness, dtype: float64\nColumn: northness\ncount    462204.000000\nmean       -349.023058\nstd         476.290475\nmin        -999.000000\n25%        -999.000000\n50%          -0.647724\n75%           0.306277\nmax           0.785398\nName: northness, dtype: float64\nColumn: predicted_swe\ncount    462204.0\nmean          0.0\nstd           0.0\nmin           0.0\n25%           0.0\n50%           0.0\n75%           0.0\nmax           0.0\nName: predicted_swe, dtype: float64\ndata['lon'].values =  [-125.    -124.964 -124.928 ... -100.124 -100.088 -100.052]\nx =  [      0.            4003.01547425    8006.0309485  ... 2766083.69270573\n 2770086.70817998 2774089.72365423]\ny =  [3395311.63129883 3395311.63129883 3395311.63129883 ...    7363.19741597\n    7363.19741597    7363.19741597]\nv =  [0 0 0 ... 0 0 0]\nIndex(['date', 'lat', 'lon', 'SWE', 'Flag', 'air_temperature_tmmn',\n       'potential_evapotranspiration', 'mean_vapor_pressure_deficit',\n       'relative_humidity_rmax', 'relative_humidity_rmin',\n       'precipitation_amount', 'air_temperature_tmmx', 'wind_speed',\n       'elevation', 'slope', 'curvature', 'aspect', 'eastness', 'northness',\n       'predicted_swe'],\n      dtype='object')\nThe new plot is saved to /home/chetana/gridmet_test_run/predicted_swe-2022-08-22.png\n",
  "history_begin_time" : 1695506757650,
  "history_end_time" : 1695506767720,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "m64o02y1sdc",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport uuid\nfrom snowcast_utils import day_index\nimport matplotlib.colors as mcolors\nfrom matplotlib.patches import Patch\nfrom snowcast_utils import day_index, work_dir, test_start_date\n\n# Define the custom colormap with specified colors and ranges\ncolors = [\n    (0.8627, 0.8627, 0.8627),  # #DCDCDC - 0 - 1\n    (0.8627, 1.0000, 1.0000),  # #DCFFFF - 1 - 2\n    (0.6000, 1.0000, 1.0000),  # #99FFFF - 2 - 4\n    (0.5569, 0.8235, 1.0000),  # #8ED2FF - 4 - 6\n    (0.4509, 0.6196, 0.8745),  # #739EDF - 6 - 8\n    (0.4157, 0.4706, 1.0000),  # #6A78FF - 8 - 10\n    (0.4235, 0.2784, 1.0000),  # #6C47FF - 10 - 12\n    (0.5529, 0.0980, 1.0000),  # #8D19FF - 12 - 14\n    (0.7333, 0.0000, 0.9176),  # #BB00EA - 14 - 16\n    (0.8392, 0.0000, 0.7490),  # #D600BF - 16 - 18\n    (0.7569, 0.0039, 0.4549),  # #C10074 - 18 - 20\n    (0.6784, 0.0000, 0.1961),  # #AD0032 - 20 - 30\n    (0.5020, 0.0000, 0.0000)   # #800000 - > 30\n]\n\ncmap_name = 'custom_snow_colormap'\ncustom_cmap = mcolors.ListedColormap(colors)\n\n# Define the lat_lon_to_map_coordinates function\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\n# Define your value ranges for color mapping\n#value_ranges = [1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 30]\n#value_ranges = [0.1, 0.2, 0.4, 0.6, 0.8, 1.0, 1.2, 1.5, 1.8, 2, 2.5, 3]\n\ndef create_color_maps_with_value_range(df_col, value_ranges=None):\n  if value_ranges == None:\n    max_value = df_col.max()\n    min_value = df_col.min()\n    if min_value < 0:\n      min_value = 0\n    step_size = (max_value - min_value) / 12\n\n    # Create 10 periods\n    value_ranges = [min_value + i * step_size for i in range(12)]\n  # Define your custom function to map data values to colors\n  def map_value_to_color(value):\n    # Iterate through the value ranges to find the appropriate color index\n    for i, range_max in enumerate(value_ranges):\n      if value <= range_max:\n        return colors[i]\n\n      # If the value is greater than the largest range, return the last color\n      return colors[-1]\n\n    # Map predicted_swe values to colors using the custom function\n  color_mapping = [map_value_to_color(value) for value in df_col.values]\n  return color_mapping, value_ranges\n\ndef convert_csvs_to_images():\n    data = pd.read_csv(\"/home/chetana/gridmet_test_run/test_data_predicted.csv\")\n    print(data.head())\n    data['predicted_swe'].fillna(0, inplace=True)\n    data['predicted_swe'] = data['predicted_swe'].apply(lambda x: 0 if x < 2 else x)\n    \n    for column in data.columns:\n      column_data = data[column]\n      description = column_data.describe()\n\n      # Print or process the description as needed\n      print(f\"Column: {column}\")\n      print(description)\n    \n    # Create a figure with a white background\n    fig = plt.figure(facecolor='white')\n\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    print(\"data['lon'].values = \", data['lon'].values)\n    x, y = m(data['lon'].values, data['lat'].values)\n    print(\"x = \", x)\n    print(\"y = \", y)\n    print(\"v = \", data['SWE'].values)\n    print(data.columns)\n\n    color_mapping, value_ranges = create_color_maps_with_value_range(data[\"SWE\"])\n    \n    # Plot the data using the custom colormap\n    plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\n    \n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_date = datetime(1900, 1, 1)\n    day_value = day_index\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    timestamp_string = result_date.strftime(\"%Y-%m-%d\")\n    \n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    # Create custom legend elements using the same colormap\n    legend_elements = [Patch(color=colors[i], label=f\"{value_ranges[i]} - {value_ranges[i+1]-1}\" if i < len(value_ranges) - 1 else f\"> {value_ranges[-1]}\") for i in range(len(value_ranges))]\n\n    # Create the legend outside the map\n    legend = plt.legend(handles=legend_elements, loc='upper left', title='Legend', fontsize=8)\n    legend.set_bbox_to_anchor((1.01, 1)) \n\n    # Remove the color bar\n    #plt.colorbar().remove()\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Set the aspect ratio to 'equal' to keep the plot at the center\n    plt.gca().set_aspect('equal', adjustable='box')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15, right=0.80)  # Adjust right margin to accommodate the legend\n    # Show the plot or save it to a file\n    new_plot_path = f'/home/chetana/gridmet_test_run/predicted_swe-{test_start_date}.png'\n    print(f\"The new plot is saved to {new_plot_path}\")\n    plt.savefig(new_plot_path)\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "/home/chetana/gw-workspace/m64o02y1sdc/convert_results_to_images.py:98: UserWarning: No data for colormapping provided via 'c'. Parameters 'cmap' will be ignored\n  plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\ntoday date = 2023-09-23\ntest start date:  2022-08-22\ntest end date:  2023-09-23\n/home/chetana\n    date   lat      lon  SWE  ...  aspect  eastness  northness  predicted_swe\n0  44793  49.0 -125.000    0  ...  -999.0    -999.0     -999.0         -9.074\n1  44793  49.0 -124.964    0  ...  -999.0    -999.0     -999.0         -9.074\n2  44793  49.0 -124.928    0  ...  -999.0    -999.0     -999.0         -9.074\n3  44793  49.0 -124.892    0  ...  -999.0    -999.0     -999.0         -9.074\n4  44793  49.0 -124.856    0  ...  -999.0    -999.0     -999.0         -9.074\n[5 rows x 20 columns]\nColumn: date\ncount    462204.0\nmean      44793.0\nstd           0.0\nmin       44793.0\n25%       44793.0\n50%       44793.0\n75%       44793.0\nmax       44793.0\nName: date, dtype: float64\nColumn: lat\ncount    462204.000000\nmean         37.030000\nstd           6.921275\nmin          25.060000\n25%          31.036000\n50%          37.030000\n75%          43.024000\nmax          49.000000\nName: lat, dtype: float64\nColumn: lon\ncount    462204.00000\nmean       -112.52600\nstd           7.21226\nmin        -125.00000\n25%        -118.77200\n50%        -112.52600\n75%        -106.28000\nmax        -100.05200\nName: lon, dtype: float64\nColumn: SWE\ncount    462204.000000\nmean        108.572974\nstd         125.689326\nmin           0.000000\n25%           0.000000\n50%           0.000000\n75%         254.000000\nmax         255.000000\nName: SWE, dtype: float64\nColumn: Flag\ncount    462204.000000\nmean        246.591938\nstd           6.518812\nmin         241.000000\n25%         241.000000\n50%         241.000000\n75%         254.000000\nmax         255.000000\nName: Flag, dtype: float64\nColumn: air_temperature_tmmn\ncount    462204.000000\nmean       -112.566517\nstd         595.289957\nmin        -999.000000\n25%        -999.000000\n50%         285.800000\n75%         288.000000\nmax         293.400000\nName: air_temperature_tmmn, dtype: float64\nColumn: potential_evapotranspiration\ncount    462204.000000\nmean       -305.371321\nstd         465.810243\nmin        -999.000000\n25%        -999.000000\n50%           5.950000\n75%           8.300000\nmax          11.000000\nName: potential_evapotranspiration, dtype: float64\nColumn: mean_vapor_pressure_deficit\ncount    462204.000000\nmean       -309.293393\nstd         463.173800\nmin        -999.000000\n25%        -999.000000\n50%           1.305000\n75%           2.120000\nmax           3.110000\nName: mean_vapor_pressure_deficit, dtype: float64\nColumn: relative_humidity_rmax\ncount    462204.000000\nmean       -261.386036\nstd         495.554173\nmin        -999.000000\n25%        -999.000000\n50%          60.650000\n75%          74.700000\nmax         100.000000\nName: relative_humidity_rmax, dtype: float64\nColumn: relative_humidity_rmin\ncount    462204.000000\nmean       -291.743393\nstd         475.083496\nmin        -999.000000\n25%        -999.000000\n50%          19.100000\n75%          26.100000\nmax          73.500000\nName: relative_humidity_rmin, dtype: float64\nColumn: precipitation_amount\ncount    462204.000000\nmean       -309.876426\nstd         462.788282\nmin        -999.000000\n25%        -999.000000\n50%           0.000000\n75%           0.000000\nmax          20.800000\nName: precipitation_amount, dtype: float64\nColumn: air_temperature_tmmx\ncount    462204.000000\nmean       -101.793994\nstd         602.527937\nmin        -999.000000\n25%        -999.000000\n50%         301.600000\n75%         304.700000\nmax         308.200000\nName: air_temperature_tmmx, dtype: float64\nColumn: wind_speed\ncount    462204.000000\nmean       -308.525976\nstd         463.689343\nmin        -999.000000\n25%        -999.000000\n50%           2.400000\n75%           3.100000\nmax           5.000000\nName: wind_speed, dtype: float64\nColumn: elevation\ncount    462204.000000\nmean       -328.271887\nstd         470.371193\nmin        -999.000000\n25%        -999.000000\n50%           1.423000\n75%           1.613000\nmax           2.557000\nName: elevation, dtype: float64\nColumn: slope\ncount    462204.000000\nmean       -296.733568\nstd         496.587226\nmin        -999.000000\n25%        -999.000000\n50%          44.193047\n75%          64.317660\nmax          86.687225\nName: slope, dtype: float64\nColumn: curvature\ncount    462204.000000\nmean       -359.380417\nstd         479.370074\nmin        -999.000000\n25%        -999.000000\n50%          -1.094771\n75%           0.368435\nmax          11.464941\nName: curvature, dtype: float64\nColumn: aspect\ncount    462204.000000\nmean       -219.043457\nstd         558.014747\nmin        -999.000000\n25%        -999.000000\n50%          83.290180\n75%         215.182167\nmax         359.906980\nName: aspect, dtype: float64\nColumn: eastness\ncount    462204.000000\nmean       -349.019408\nstd         476.293139\nmin        -999.000000\n25%        -999.000000\n50%          -0.622041\n75%           0.286890\nmax           0.785398\nName: eastness, dtype: float64\nColumn: northness\ncount    462204.000000\nmean       -349.023058\nstd         476.290475\nmin        -999.000000\n25%        -999.000000\n50%          -0.647724\n75%           0.306277\nmax           0.785398\nName: northness, dtype: float64\nColumn: predicted_swe\ncount    462204.0\nmean          0.0\nstd           0.0\nmin           0.0\n25%           0.0\n50%           0.0\n75%           0.0\nmax           0.0\nName: predicted_swe, dtype: float64\ndata['lon'].values =  [-125.    -124.964 -124.928 ... -100.124 -100.088 -100.052]\nx =  [      0.            4003.01547425    8006.0309485  ... 2766083.69270573\n 2770086.70817998 2774089.72365423]\ny =  [3395311.63129883 3395311.63129883 3395311.63129883 ...    7363.19741597\n    7363.19741597    7363.19741597]\nv =  [  0   0   0 ... 252 252 252]\nIndex(['date', 'lat', 'lon', 'SWE', 'Flag', 'air_temperature_tmmn',\n       'potential_evapotranspiration', 'mean_vapor_pressure_deficit',\n       'relative_humidity_rmax', 'relative_humidity_rmin',\n       'precipitation_amount', 'air_temperature_tmmx', 'wind_speed',\n       'elevation', 'slope', 'curvature', 'aspect', 'eastness', 'northness',\n       'predicted_swe'],\n      dtype='object')\nThe new plot is saved to /home/chetana/gridmet_test_run/predicted_swe-2022-08-22.png\n",
  "history_begin_time" : 1695506607909,
  "history_end_time" : 1695506619317,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "100001",
  "indicator" : "Done"
},{
  "history_id" : "Rj0RDjda4Vgf",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport uuid\nfrom snowcast_utils import day_index\nimport matplotlib.colors as mcolors\nfrom matplotlib.patches import Patch\nfrom snowcast_utils import day_index, work_dir, test_start_date\n\n# Define the custom colormap with specified colors and ranges\ncolors = [\n    (0.8627, 0.8627, 0.8627),  # #DCDCDC - 0 - 1\n    (0.8627, 1.0000, 1.0000),  # #DCFFFF - 1 - 2\n    (0.6000, 1.0000, 1.0000),  # #99FFFF - 2 - 4\n    (0.5569, 0.8235, 1.0000),  # #8ED2FF - 4 - 6\n    (0.4509, 0.6196, 0.8745),  # #739EDF - 6 - 8\n    (0.4157, 0.4706, 1.0000),  # #6A78FF - 8 - 10\n    (0.4235, 0.2784, 1.0000),  # #6C47FF - 10 - 12\n    (0.5529, 0.0980, 1.0000),  # #8D19FF - 12 - 14\n    (0.7333, 0.0000, 0.9176),  # #BB00EA - 14 - 16\n    (0.8392, 0.0000, 0.7490),  # #D600BF - 16 - 18\n    (0.7569, 0.0039, 0.4549),  # #C10074 - 18 - 20\n    (0.6784, 0.0000, 0.1961),  # #AD0032 - 20 - 30\n    (0.5020, 0.0000, 0.0000)   # #800000 - > 30\n]\n\ncmap_name = 'custom_snow_colormap'\ncustom_cmap = mcolors.ListedColormap(colors)\n\n# Define the lat_lon_to_map_coordinates function\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\n# Define your value ranges for color mapping\n#value_ranges = [1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 30]\n#value_ranges = [0.1, 0.2, 0.4, 0.6, 0.8, 1.0, 1.2, 1.5, 1.8, 2, 2.5, 3]\n\ndef create_color_maps_with_value_range(df_col, value_ranges=None):\n  if value_ranges == None:\n    max_value = df_col.max()\n    min_value = df_col.min()\n    if min_value < 0:\n      min_value = 0\n    step_size = (max_value - min_value) / 12\n\n    # Create 10 periods\n    value_ranges = [min_value + i * step_size for i in range(12)]\n  # Define your custom function to map data values to colors\n  def map_value_to_color(value):\n    # Iterate through the value ranges to find the appropriate color index\n    for i, range_max in enumerate(value_ranges):\n      if value <= range_max:\n        return colors[i]\n\n      # If the value is greater than the largest range, return the last color\n      return colors[-1]\n\n    # Map predicted_swe values to colors using the custom function\n  color_mapping = [map_value_to_color(value) for value in df_col.values]\n  return color_mapping, value_ranges\n\ndef convert_csvs_to_images():\n    data = pd.read_csv(\"/home/chetana/gridmet_test_run/test_data_predicted.csv\")\n    print(data.head())\n    data['predicted_swe'].fillna(0, inplace=True)\n    data['predicted_swe'] = data['predicted_swe'].apply(lambda x: 0 if x < 2 else x)\n    \n    for column in data.columns:\n      column_data = data[column]\n      description = column_data.describe()\n\n      # Print or process the description as needed\n      print(f\"Column: {column}\")\n      print(description)\n    \n    # Create a figure with a white background\n    fig = plt.figure(facecolor='white')\n\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    print(\"data['lon'].values = \", data['lon'].values)\n    x, y = m(data['lon'].values, data['lat'].values)\n    print(\"x = \", x)\n    print(\"y = \", y)\n    print(\"v = \", data['SWE'].values)\n    print(data.columns)\n\n    color_mapping, value_ranges = create_color_maps_with_value_range(data[\"SWE\"])\n    \n    # Plot the data using the custom colormap\n    plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\n    \n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_date = datetime(1900, 1, 1)\n    day_value = day_index\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    timestamp_string = result_date.strftime(\"%Y-%m-%d\")\n    \n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    # Create custom legend elements using the same colormap\n    legend_elements = [Patch(color=colors[i], label=f\"{value_ranges[i]} - {value_ranges[i+1]-1}\" if i < len(value_ranges) - 1 else f\"> {value_ranges[-1]}\") for i in range(len(value_ranges))]\n\n    # Create the legend outside the map\n    legend = plt.legend(handles=legend_elements, loc='upper left', title='Legend', fontsize=8)\n    legend.set_bbox_to_anchor((1.01, 1)) \n\n    # Remove the color bar\n    #plt.colorbar().remove()\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Set the aspect ratio to 'equal' to keep the plot at the center\n    plt.gca().set_aspect('equal', adjustable='box')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15, right=0.80)  # Adjust right margin to accommodate the legend\n    # Show the plot or save it to a file\n    new_plot_path = f'/home/chetana/gridmet_test_run/predicted_swe-{test_start_date}.png'\n    print(f\"The new plot is saved to {new_plot_path}\")\n    plt.savefig(new_plot_path)\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "/home/chetana/gw-workspace/Rj0RDjda4Vgf/convert_results_to_images.py:98: UserWarning: No data for colormapping provided via 'c'. Parameters 'cmap' will be ignored\n  plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\ntoday date = 2023-09-23\ntest start date:  2022-08-21\ntest end date:  2023-09-23\n/home/chetana\n    date   lat      lon  SWE  ...  aspect  eastness  northness  predicted_swe\n0  44792  49.0 -125.000    0  ...  -999.0    -999.0     -999.0         -9.074\n1  44792  49.0 -124.964    0  ...  -999.0    -999.0     -999.0         -9.074\n2  44792  49.0 -124.928    0  ...  -999.0    -999.0     -999.0         -9.074\n3  44792  49.0 -124.892    0  ...  -999.0    -999.0     -999.0         -9.074\n4  44792  49.0 -124.856    0  ...  -999.0    -999.0     -999.0         -9.074\n[5 rows x 20 columns]\nColumn: date\ncount    462204.0\nmean      44792.0\nstd           0.0\nmin       44792.0\n25%       44792.0\n50%       44792.0\n75%       44792.0\nmax       44792.0\nName: date, dtype: float64\nColumn: lat\ncount    462204.000000\nmean         37.030000\nstd           6.921275\nmin          25.060000\n25%          31.036000\n50%          37.030000\n75%          43.024000\nmax          49.000000\nName: lat, dtype: float64\nColumn: lon\ncount    462204.00000\nmean       -112.52600\nstd           7.21226\nmin        -125.00000\n25%        -118.77200\n50%        -112.52600\n75%        -106.28000\nmax        -100.05200\nName: lon, dtype: float64\nColumn: SWE\ncount    462204.000000\nmean        123.618482\nstd         127.035693\nmin           0.000000\n25%           0.000000\n50%           0.000000\n75%         254.000000\nmax         255.000000\nName: SWE, dtype: float64\nColumn: Flag\ncount    462204.000000\nmean        247.408900\nstd           6.622386\nmin         241.000000\n25%         241.000000\n50%         241.000000\n75%         254.000000\nmax         255.000000\nName: Flag, dtype: float64\nColumn: air_temperature_tmmn\ncount    462204.000000\nmean       -112.657808\nstd         595.228601\nmin        -999.000000\n25%        -999.000000\n50%         285.400000\n75%         288.400000\nmax         292.200000\nName: air_temperature_tmmn, dtype: float64\nColumn: potential_evapotranspiration\ncount    462204.000000\nmean       -306.167267\nstd         465.274714\nmin        -999.000000\n25%        -999.000000\n50%           5.300000\n75%           6.900000\nmax           9.800000\nName: potential_evapotranspiration, dtype: float64\nColumn: mean_vapor_pressure_deficit\ncount    462204.000000\nmean       -309.436276\nstd         463.077907\nmin        -999.000000\n25%        -999.000000\n50%           1.110000\n75%           1.780000\nmax           3.290000\nName: mean_vapor_pressure_deficit, dtype: float64\nColumn: relative_humidity_rmax\ncount    462204.000000\nmean       -256.476877\nstd         498.801965\nmin        -999.000000\n25%        -999.000000\n50%          69.300000\n75%          84.100000\nmax         100.000000\nName: relative_humidity_rmax, dtype: float64\nColumn: relative_humidity_rmin\ncount    462204.000000\nmean       -288.160961\nstd         477.524640\nmin        -999.000000\n25%        -999.000000\n50%          21.550000\n75%          32.800000\nmax          87.900000\nName: relative_humidity_rmin, dtype: float64\nColumn: precipitation_amount\ncount    462204.000000\nmean       -309.863964\nstd         462.793032\nmin        -999.000000\n25%        -999.000000\n50%           0.000000\n75%           0.000000\nmax          11.600000\nName: precipitation_amount, dtype: float64\nColumn: air_temperature_tmmx\ncount    462204.000000\nmean       -102.345646\nstd         602.159956\nmin        -999.000000\n25%        -999.000000\n50%         299.950000\n75%         303.700000\nmax         310.800000\nName: air_temperature_tmmx, dtype: float64\nColumn: wind_speed\ncount    462204.000000\nmean       -308.738138\nstd         463.546821\nmin        -999.000000\n25%        -999.000000\n50%           2.000000\n75%           2.900000\nmax           4.400000\nName: wind_speed, dtype: float64\nColumn: elevation\ncount    462204.000000\nmean       -328.271887\nstd         470.371193\nmin        -999.000000\n25%        -999.000000\n50%           1.423000\n75%           1.613000\nmax           2.557000\nName: elevation, dtype: float64\nColumn: slope\ncount    462204.000000\nmean       -296.733568\nstd         496.587226\nmin        -999.000000\n25%        -999.000000\n50%          44.193047\n75%          64.317660\nmax          86.687225\nName: slope, dtype: float64\nColumn: curvature\ncount    462204.000000\nmean       -359.380417\nstd         479.370074\nmin        -999.000000\n25%        -999.000000\n50%          -1.094771\n75%           0.368435\nmax          11.464941\nName: curvature, dtype: float64\nColumn: aspect\ncount    462204.000000\nmean       -219.043457\nstd         558.014747\nmin        -999.000000\n25%        -999.000000\n50%          83.290180\n75%         215.182167\nmax         359.906980\nName: aspect, dtype: float64\nColumn: eastness\ncount    462204.000000\nmean       -349.019408\nstd         476.293139\nmin        -999.000000\n25%        -999.000000\n50%          -0.622041\n75%           0.286890\nmax           0.785398\nName: eastness, dtype: float64\nColumn: northness\ncount    462204.000000\nmean       -349.023058\nstd         476.290475\nmin        -999.000000\n25%        -999.000000\n50%          -0.647724\n75%           0.306277\nmax           0.785398\nName: northness, dtype: float64\nColumn: predicted_swe\ncount    462204.0\nmean          0.0\nstd           0.0\nmin           0.0\n25%           0.0\n50%           0.0\n75%           0.0\nmax           0.0\nName: predicted_swe, dtype: float64\ndata['lon'].values =  [-125.    -124.964 -124.928 ... -100.124 -100.088 -100.052]\nx =  [      0.            4003.01547425    8006.0309485  ... 2766083.69270573\n 2770086.70817998 2774089.72365423]\ny =  [3395311.63129883 3395311.63129883 3395311.63129883 ...    7363.19741597\n    7363.19741597    7363.19741597]\nv =  [  0   0   0 ... 252 252 252]\nIndex(['date', 'lat', 'lon', 'SWE', 'Flag', 'air_temperature_tmmn',\n       'potential_evapotranspiration', 'mean_vapor_pressure_deficit',\n       'relative_humidity_rmax', 'relative_humidity_rmin',\n       'precipitation_amount', 'air_temperature_tmmx', 'wind_speed',\n       'elevation', 'slope', 'curvature', 'aspect', 'eastness', 'northness',\n       'predicted_swe'],\n      dtype='object')\nThe new plot is saved to /home/chetana/gridmet_test_run/predicted_swe-2022-08-21.png\n",
  "history_begin_time" : 1695506294972,
  "history_end_time" : 1695506304775,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "s15G6JoIior5",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport uuid\nfrom snowcast_utils import day_index\nimport matplotlib.colors as mcolors\nfrom matplotlib.patches import Patch\nfrom snowcast_utils import day_index, work_dir, test_start_date\n\n# Define the custom colormap with specified colors and ranges\ncolors = [\n    (0.8627, 0.8627, 0.8627),  # #DCDCDC - 0 - 1\n    (0.8627, 1.0000, 1.0000),  # #DCFFFF - 1 - 2\n    (0.6000, 1.0000, 1.0000),  # #99FFFF - 2 - 4\n    (0.5569, 0.8235, 1.0000),  # #8ED2FF - 4 - 6\n    (0.4509, 0.6196, 0.8745),  # #739EDF - 6 - 8\n    (0.4157, 0.4706, 1.0000),  # #6A78FF - 8 - 10\n    (0.4235, 0.2784, 1.0000),  # #6C47FF - 10 - 12\n    (0.5529, 0.0980, 1.0000),  # #8D19FF - 12 - 14\n    (0.7333, 0.0000, 0.9176),  # #BB00EA - 14 - 16\n    (0.8392, 0.0000, 0.7490),  # #D600BF - 16 - 18\n    (0.7569, 0.0039, 0.4549),  # #C10074 - 18 - 20\n    (0.6784, 0.0000, 0.1961),  # #AD0032 - 20 - 30\n    (0.5020, 0.0000, 0.0000)   # #800000 - > 30\n]\n\ncmap_name = 'custom_snow_colormap'\ncustom_cmap = mcolors.ListedColormap(colors)\n\n# Define the lat_lon_to_map_coordinates function\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\n# Define your value ranges for color mapping\n#value_ranges = [1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 30]\n#value_ranges = [0.1, 0.2, 0.4, 0.6, 0.8, 1.0, 1.2, 1.5, 1.8, 2, 2.5, 3]\n\ndef create_color_maps_with_value_range(df_col, value_ranges=None):\n  if value_ranges == None:\n    max_value = df_col.max()\n    min_value = df_col.min()\n    if min_value < 0:\n      min_value = 0\n    step_size = (max_value - min_value) / 12\n\n    # Create 10 periods\n    value_ranges = [min_value + i * step_size for i in range(12)]\n  # Define your custom function to map data values to colors\n  def map_value_to_color(value):\n    # Iterate through the value ranges to find the appropriate color index\n    for i, range_max in enumerate(value_ranges):\n      if value <= range_max:\n        return colors[i]\n\n      # If the value is greater than the largest range, return the last color\n      return colors[-1]\n\n    # Map predicted_swe values to colors using the custom function\n  color_mapping = [map_value_to_color(value) for value in df_col.values]\n  return color_mapping, value_ranges\n\ndef convert_csvs_to_images():\n    data = pd.read_csv(\"/home/chetana/gridmet_test_run/test_data_predicted.csv\")\n    print(data.head())\n    data['predicted_swe'].fillna(0, inplace=True)\n    data['predicted_swe'] = data['predicted_swe'].apply(lambda x: 0 if x < 2 else x)\n    \n    for column in data.columns:\n      column_data = data[column]\n      description = column_data.describe()\n\n      # Print or process the description as needed\n      print(f\"Column: {column}\")\n      print(description)\n    \n    # Create a figure with a white background\n    fig = plt.figure(facecolor='white')\n\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    print(\"data['lon'].values = \", data['lon'].values)\n    x, y = m(data['lon'].values, data['lat'].values)\n    print(\"x = \", x)\n    print(\"y = \", y)\n    print(\"v = \", data['predicted_swe'].values)\n\n    color_mapping, value_ranges = create_color_maps_with_value_range(data[\"predicted_swe\"])\n    \n    # Plot the data using the custom colormap\n    plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\n    \n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_date = datetime(1900, 1, 1)\n    day_value = day_index\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    timestamp_string = result_date.strftime(\"%Y-%m-%d\")\n    \n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    # Create custom legend elements using the same colormap\n    legend_elements = [Patch(color=colors[i], label=f\"{value_ranges[i]} - {value_ranges[i+1]-1}\" if i < len(value_ranges) - 1 else f\"> {value_ranges[-1]}\") for i in range(len(value_ranges))]\n\n    # Create the legend outside the map\n    legend = plt.legend(handles=legend_elements, loc='upper left', title='Legend', fontsize=8)\n    legend.set_bbox_to_anchor((1.01, 1)) \n\n    # Remove the color bar\n    #plt.colorbar().remove()\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Set the aspect ratio to 'equal' to keep the plot at the center\n    plt.gca().set_aspect('equal', adjustable='box')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15, right=0.80)  # Adjust right margin to accommodate the legend\n    # Show the plot or save it to a file\n    new_plot_path = f'/home/chetana/gridmet_test_run/predicted_swe-{test_start_date}.png'\n    print(f\"The new plot is saved to {new_plot_path}\")\n    plt.savefig(new_plot_path)\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "/home/chetana/gw-workspace/s15G6JoIior5/convert_results_to_images.py:97: UserWarning: No data for colormapping provided via 'c'. Parameters 'cmap' will be ignored\n  plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\ntoday date = 2023-09-23\ntest start date:  2022-08-21\ntest end date:  2023-09-23\n/home/chetana\n    date   lat      lon  SWE  ...  aspect  eastness  northness  predicted_swe\n0  44792  49.0 -125.000    0  ...  -999.0    -999.0     -999.0         -9.074\n1  44792  49.0 -124.964    0  ...  -999.0    -999.0     -999.0         -9.074\n2  44792  49.0 -124.928    0  ...  -999.0    -999.0     -999.0         -9.074\n3  44792  49.0 -124.892    0  ...  -999.0    -999.0     -999.0         -9.074\n4  44792  49.0 -124.856    0  ...  -999.0    -999.0     -999.0         -9.074\n[5 rows x 20 columns]\nColumn: date\ncount    462204.0\nmean      44792.0\nstd           0.0\nmin       44792.0\n25%       44792.0\n50%       44792.0\n75%       44792.0\nmax       44792.0\nName: date, dtype: float64\nColumn: lat\ncount    462204.000000\nmean         37.030000\nstd           6.921275\nmin          25.060000\n25%          31.036000\n50%          37.030000\n75%          43.024000\nmax          49.000000\nName: lat, dtype: float64\nColumn: lon\ncount    462204.00000\nmean       -112.52600\nstd           7.21226\nmin        -125.00000\n25%        -118.77200\n50%        -112.52600\n75%        -106.28000\nmax        -100.05200\nName: lon, dtype: float64\nColumn: SWE\ncount    462204.000000\nmean        123.618482\nstd         127.035693\nmin           0.000000\n25%           0.000000\n50%           0.000000\n75%         254.000000\nmax         255.000000\nName: SWE, dtype: float64\nColumn: Flag\ncount    462204.000000\nmean        247.408900\nstd           6.622386\nmin         241.000000\n25%         241.000000\n50%         241.000000\n75%         254.000000\nmax         255.000000\nName: Flag, dtype: float64\nColumn: air_temperature_tmmn\ncount    462204.000000\nmean       -112.657808\nstd         595.228601\nmin        -999.000000\n25%        -999.000000\n50%         285.400000\n75%         288.400000\nmax         292.200000\nName: air_temperature_tmmn, dtype: float64\nColumn: potential_evapotranspiration\ncount    462204.000000\nmean       -306.167267\nstd         465.274714\nmin        -999.000000\n25%        -999.000000\n50%           5.300000\n75%           6.900000\nmax           9.800000\nName: potential_evapotranspiration, dtype: float64\nColumn: mean_vapor_pressure_deficit\ncount    462204.000000\nmean       -309.436276\nstd         463.077907\nmin        -999.000000\n25%        -999.000000\n50%           1.110000\n75%           1.780000\nmax           3.290000\nName: mean_vapor_pressure_deficit, dtype: float64\nColumn: relative_humidity_rmax\ncount    462204.000000\nmean       -256.476877\nstd         498.801965\nmin        -999.000000\n25%        -999.000000\n50%          69.300000\n75%          84.100000\nmax         100.000000\nName: relative_humidity_rmax, dtype: float64\nColumn: relative_humidity_rmin\ncount    462204.000000\nmean       -288.160961\nstd         477.524640\nmin        -999.000000\n25%        -999.000000\n50%          21.550000\n75%          32.800000\nmax          87.900000\nName: relative_humidity_rmin, dtype: float64\nColumn: precipitation_amount\ncount    462204.000000\nmean       -309.863964\nstd         462.793032\nmin        -999.000000\n25%        -999.000000\n50%           0.000000\n75%           0.000000\nmax          11.600000\nName: precipitation_amount, dtype: float64\nColumn: air_temperature_tmmx\ncount    462204.000000\nmean       -102.345646\nstd         602.159956\nmin        -999.000000\n25%        -999.000000\n50%         299.950000\n75%         303.700000\nmax         310.800000\nName: air_temperature_tmmx, dtype: float64\nColumn: wind_speed\ncount    462204.000000\nmean       -308.738138\nstd         463.546821\nmin        -999.000000\n25%        -999.000000\n50%           2.000000\n75%           2.900000\nmax           4.400000\nName: wind_speed, dtype: float64\nColumn: elevation\ncount    462204.000000\nmean       -328.271887\nstd         470.371193\nmin        -999.000000\n25%        -999.000000\n50%           1.423000\n75%           1.613000\nmax           2.557000\nName: elevation, dtype: float64\nColumn: slope\ncount    462204.000000\nmean       -296.733568\nstd         496.587226\nmin        -999.000000\n25%        -999.000000\n50%          44.193047\n75%          64.317660\nmax          86.687225\nName: slope, dtype: float64\nColumn: curvature\ncount    462204.000000\nmean       -359.380417\nstd         479.370074\nmin        -999.000000\n25%        -999.000000\n50%          -1.094771\n75%           0.368435\nmax          11.464941\nName: curvature, dtype: float64\nColumn: aspect\ncount    462204.000000\nmean       -219.043457\nstd         558.014747\nmin        -999.000000\n25%        -999.000000\n50%          83.290180\n75%         215.182167\nmax         359.906980\nName: aspect, dtype: float64\nColumn: eastness\ncount    462204.000000\nmean       -349.019408\nstd         476.293139\nmin        -999.000000\n25%        -999.000000\n50%          -0.622041\n75%           0.286890\nmax           0.785398\nName: eastness, dtype: float64\nColumn: northness\ncount    462204.000000\nmean       -349.023058\nstd         476.290475\nmin        -999.000000\n25%        -999.000000\n50%          -0.647724\n75%           0.306277\nmax           0.785398\nName: northness, dtype: float64\nColumn: predicted_swe\ncount    462204.0\nmean          0.0\nstd           0.0\nmin           0.0\n25%           0.0\n50%           0.0\n75%           0.0\nmax           0.0\nName: predicted_swe, dtype: float64\ndata['lon'].values =  [-125.    -124.964 -124.928 ... -100.124 -100.088 -100.052]\nx =  [      0.            4003.01547425    8006.0309485  ... 2766083.69270573\n 2770086.70817998 2774089.72365423]\ny =  [3395311.63129883 3395311.63129883 3395311.63129883 ...    7363.19741597\n    7363.19741597    7363.19741597]\nv =  [0 0 0 ... 0 0 0]\nThe new plot is saved to /home/chetana/gridmet_test_run/predicted_swe-2022-08-21.png\n",
  "history_begin_time" : 1695506161378,
  "history_end_time" : 1695506171157,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "AeEMpo0w6ycv",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport uuid\nfrom snowcast_utils import day_index\nimport matplotlib.colors as mcolors\nfrom matplotlib.patches import Patch\nfrom snowcast_utils import day_index, work_dir, test_start_date\n\n# Define the custom colormap with specified colors and ranges\ncolors = [\n    (0.8627, 0.8627, 0.8627),  # #DCDCDC - 0 - 1\n    (0.8627, 1.0000, 1.0000),  # #DCFFFF - 1 - 2\n    (0.6000, 1.0000, 1.0000),  # #99FFFF - 2 - 4\n    (0.5569, 0.8235, 1.0000),  # #8ED2FF - 4 - 6\n    (0.4509, 0.6196, 0.8745),  # #739EDF - 6 - 8\n    (0.4157, 0.4706, 1.0000),  # #6A78FF - 8 - 10\n    (0.4235, 0.2784, 1.0000),  # #6C47FF - 10 - 12\n    (0.5529, 0.0980, 1.0000),  # #8D19FF - 12 - 14\n    (0.7333, 0.0000, 0.9176),  # #BB00EA - 14 - 16\n    (0.8392, 0.0000, 0.7490),  # #D600BF - 16 - 18\n    (0.7569, 0.0039, 0.4549),  # #C10074 - 18 - 20\n    (0.6784, 0.0000, 0.1961),  # #AD0032 - 20 - 30\n    (0.5020, 0.0000, 0.0000)   # #800000 - > 30\n]\n\ncmap_name = 'custom_snow_colormap'\ncustom_cmap = mcolors.ListedColormap(colors)\n\n# Define the lat_lon_to_map_coordinates function\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\n# Define your value ranges for color mapping\n#value_ranges = [1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 30]\n#value_ranges = [0.1, 0.2, 0.4, 0.6, 0.8, 1.0, 1.2, 1.5, 1.8, 2, 2.5, 3]\n\ndef create_color_maps_with_value_range(df_col, value_ranges=None):\n  if value_ranges == None:\n    max_value = df_col.max()\n    min_value = df_col.min()\n    if min_value < 0:\n      min_value = 0\n    step_size = (max_value - min_value) / 12\n\n    # Create 10 periods\n    value_ranges = [min_value + i * step_size for i in range(12)]\n  # Define your custom function to map data values to colors\n  def map_value_to_color(value):\n    # Iterate through the value ranges to find the appropriate color index\n    for i, range_max in enumerate(value_ranges):\n      if value <= range_max:\n        return colors[i]\n\n      # If the value is greater than the largest range, return the last color\n      return colors[-1]\n\n    # Map predicted_swe values to colors using the custom function\n  color_mapping = [map_value_to_color(value) for value in df_col.values]\n  return color_mapping, value_ranges\n\ndef convert_csvs_to_images():\n    data = pd.read_csv(\"/home/chetana/gridmet_test_run/test_data_predicted.csv\")\n    print(data.head())\n    data['predicted_swe'].fillna(0, inplace=True)\n    data['predicted_swe'] = data['predicted_swe'].apply(lambda x: 0 if x < 2 else x)\n    \n    for column in data.columns:\n      column_data = data[column]\n      description = column_data.describe()\n\n      # Print or process the description as needed\n      print(f\"Column: {column}\")\n      print(description)\n    \n    # Create a figure with a white background\n    fig = plt.figure(facecolor='white')\n\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    print(\"data['lon'].values = \", data['lon'].values)\n    x, y = m(data['lon'].values, data['lat'].values)\n    print(\"x = \", x)\n    print(\"y = \", y)\n    print(\"v = \", data['aspect'].values)\n\n    color_mapping, value_ranges = create_color_maps_with_value_range(data[\"eastness\"])\n    \n    # Plot the data using the custom colormap\n    plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\n    \n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_date = datetime(1900, 1, 1)\n    day_value = day_index\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    timestamp_string = result_date.strftime(\"%Y-%m-%d\")\n    \n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    # Create custom legend elements using the same colormap\n    legend_elements = [Patch(color=colors[i], label=f\"{value_ranges[i]} - {value_ranges[i+1]-1}\" if i < len(value_ranges) - 1 else f\"> {value_ranges[-1]}\") for i in range(len(value_ranges))]\n\n    # Create the legend outside the map\n    legend = plt.legend(handles=legend_elements, loc='upper left', title='Legend', fontsize=8)\n    legend.set_bbox_to_anchor((1.01, 1)) \n\n    # Remove the color bar\n    #plt.colorbar().remove()\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Set the aspect ratio to 'equal' to keep the plot at the center\n    plt.gca().set_aspect('equal', adjustable='box')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15, right=0.80)  # Adjust right margin to accommodate the legend\n    # Show the plot or save it to a file\n    new_plot_path = f'/home/chetana/gridmet_test_run/predicted_swe-{test_start_date}.png'\n    print(f\"The new plot is saved to {new_plot_path}\")\n    plt.savefig(new_plot_path)\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "/home/chetana/gw-workspace/AeEMpo0w6ycv/convert_results_to_images.py:97: UserWarning: No data for colormapping provided via 'c'. Parameters 'cmap' will be ignored\n  plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\ntoday date = 2023-09-23\ntest start date:  2022-08-21\ntest end date:  2023-09-23\n/home/chetana\n    date   lat      lon  SWE  ...  aspect  eastness  northness  predicted_swe\n0  44792  49.0 -125.000    0  ...  -999.0    -999.0     -999.0         -9.074\n1  44792  49.0 -124.964    0  ...  -999.0    -999.0     -999.0         -9.074\n2  44792  49.0 -124.928    0  ...  -999.0    -999.0     -999.0         -9.074\n3  44792  49.0 -124.892    0  ...  -999.0    -999.0     -999.0         -9.074\n4  44792  49.0 -124.856    0  ...  -999.0    -999.0     -999.0         -9.074\n[5 rows x 20 columns]\nColumn: date\ncount    462204.0\nmean      44792.0\nstd           0.0\nmin       44792.0\n25%       44792.0\n50%       44792.0\n75%       44792.0\nmax       44792.0\nName: date, dtype: float64\nColumn: lat\ncount    462204.000000\nmean         37.030000\nstd           6.921275\nmin          25.060000\n25%          31.036000\n50%          37.030000\n75%          43.024000\nmax          49.000000\nName: lat, dtype: float64\nColumn: lon\ncount    462204.00000\nmean       -112.52600\nstd           7.21226\nmin        -125.00000\n25%        -118.77200\n50%        -112.52600\n75%        -106.28000\nmax        -100.05200\nName: lon, dtype: float64\nColumn: SWE\ncount    462204.000000\nmean        123.618482\nstd         127.035693\nmin           0.000000\n25%           0.000000\n50%           0.000000\n75%         254.000000\nmax         255.000000\nName: SWE, dtype: float64\nColumn: Flag\ncount    462204.000000\nmean        247.408900\nstd           6.622386\nmin         241.000000\n25%         241.000000\n50%         241.000000\n75%         254.000000\nmax         255.000000\nName: Flag, dtype: float64\nColumn: air_temperature_tmmn\ncount    462204.000000\nmean       -112.657808\nstd         595.228601\nmin        -999.000000\n25%        -999.000000\n50%         285.400000\n75%         288.400000\nmax         292.200000\nName: air_temperature_tmmn, dtype: float64\nColumn: potential_evapotranspiration\ncount    462204.000000\nmean       -306.167267\nstd         465.274714\nmin        -999.000000\n25%        -999.000000\n50%           5.300000\n75%           6.900000\nmax           9.800000\nName: potential_evapotranspiration, dtype: float64\nColumn: mean_vapor_pressure_deficit\ncount    462204.000000\nmean       -309.436276\nstd         463.077907\nmin        -999.000000\n25%        -999.000000\n50%           1.110000\n75%           1.780000\nmax           3.290000\nName: mean_vapor_pressure_deficit, dtype: float64\nColumn: relative_humidity_rmax\ncount    462204.000000\nmean       -256.476877\nstd         498.801965\nmin        -999.000000\n25%        -999.000000\n50%          69.300000\n75%          84.100000\nmax         100.000000\nName: relative_humidity_rmax, dtype: float64\nColumn: relative_humidity_rmin\ncount    462204.000000\nmean       -288.160961\nstd         477.524640\nmin        -999.000000\n25%        -999.000000\n50%          21.550000\n75%          32.800000\nmax          87.900000\nName: relative_humidity_rmin, dtype: float64\nColumn: precipitation_amount\ncount    462204.000000\nmean       -309.863964\nstd         462.793032\nmin        -999.000000\n25%        -999.000000\n50%           0.000000\n75%           0.000000\nmax          11.600000\nName: precipitation_amount, dtype: float64\nColumn: air_temperature_tmmx\ncount    462204.000000\nmean       -102.345646\nstd         602.159956\nmin        -999.000000\n25%        -999.000000\n50%         299.950000\n75%         303.700000\nmax         310.800000\nName: air_temperature_tmmx, dtype: float64\nColumn: wind_speed\ncount    462204.000000\nmean       -308.738138\nstd         463.546821\nmin        -999.000000\n25%        -999.000000\n50%           2.000000\n75%           2.900000\nmax           4.400000\nName: wind_speed, dtype: float64\nColumn: elevation\ncount    462204.000000\nmean       -328.271887\nstd         470.371193\nmin        -999.000000\n25%        -999.000000\n50%           1.423000\n75%           1.613000\nmax           2.557000\nName: elevation, dtype: float64\nColumn: slope\ncount    462204.000000\nmean       -296.733568\nstd         496.587226\nmin        -999.000000\n25%        -999.000000\n50%          44.193047\n75%          64.317660\nmax          86.687225\nName: slope, dtype: float64\nColumn: curvature\ncount    462204.000000\nmean       -359.380417\nstd         479.370074\nmin        -999.000000\n25%        -999.000000\n50%          -1.094771\n75%           0.368435\nmax          11.464941\nName: curvature, dtype: float64\nColumn: aspect\ncount    462204.000000\nmean       -219.043457\nstd         558.014747\nmin        -999.000000\n25%        -999.000000\n50%          83.290180\n75%         215.182167\nmax         359.906980\nName: aspect, dtype: float64\nColumn: eastness\ncount    462204.000000\nmean       -349.019408\nstd         476.293139\nmin        -999.000000\n25%        -999.000000\n50%          -0.622041\n75%           0.286890\nmax           0.785398\nName: eastness, dtype: float64\nColumn: northness\ncount    462204.000000\nmean       -349.023058\nstd         476.290475\nmin        -999.000000\n25%        -999.000000\n50%          -0.647724\n75%           0.306277\nmax           0.785398\nName: northness, dtype: float64\nColumn: predicted_swe\ncount    462204.0\nmean          0.0\nstd           0.0\nmin           0.0\n25%           0.0\n50%           0.0\n75%           0.0\nmax           0.0\nName: predicted_swe, dtype: float64\ndata['lon'].values =  [-125.    -124.964 -124.928 ... -100.124 -100.088 -100.052]\nx =  [      0.            4003.01547425    8006.0309485  ... 2766083.69270573\n 2770086.70817998 2774089.72365423]\ny =  [3395311.63129883 3395311.63129883 3395311.63129883 ...    7363.19741597\n    7363.19741597    7363.19741597]\nv =  [-999. -999. -999. ... -999. -999. -999.]\nThe new plot is saved to /home/chetana/gridmet_test_run/predicted_swe-2022-08-21.png\n",
  "history_begin_time" : 1695506008188,
  "history_end_time" : 1695506017592,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "AJTxiRtYXtG5",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport uuid\nfrom snowcast_utils import day_index\nimport matplotlib.colors as mcolors\nfrom matplotlib.patches import Patch\nfrom snowcast_utils import day_index, work_dir, test_start_date\n\n# Define the custom colormap with specified colors and ranges\ncolors = [\n    (0.8627, 0.8627, 0.8627),  # #DCDCDC - 0 - 1\n    (0.8627, 1.0000, 1.0000),  # #DCFFFF - 1 - 2\n    (0.6000, 1.0000, 1.0000),  # #99FFFF - 2 - 4\n    (0.5569, 0.8235, 1.0000),  # #8ED2FF - 4 - 6\n    (0.4509, 0.6196, 0.8745),  # #739EDF - 6 - 8\n    (0.4157, 0.4706, 1.0000),  # #6A78FF - 8 - 10\n    (0.4235, 0.2784, 1.0000),  # #6C47FF - 10 - 12\n    (0.5529, 0.0980, 1.0000),  # #8D19FF - 12 - 14\n    (0.7333, 0.0000, 0.9176),  # #BB00EA - 14 - 16\n    (0.8392, 0.0000, 0.7490),  # #D600BF - 16 - 18\n    (0.7569, 0.0039, 0.4549),  # #C10074 - 18 - 20\n    (0.6784, 0.0000, 0.1961),  # #AD0032 - 20 - 30\n    (0.5020, 0.0000, 0.0000)   # #800000 - > 30\n]\n\ncmap_name = 'custom_snow_colormap'\ncustom_cmap = mcolors.ListedColormap(colors)\n\n# Define the lat_lon_to_map_coordinates function\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\n# Define your value ranges for color mapping\n#value_ranges = [1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 30]\n#value_ranges = [0.1, 0.2, 0.4, 0.6, 0.8, 1.0, 1.2, 1.5, 1.8, 2, 2.5, 3]\n\ndef create_color_maps_with_value_range(df_col):\n  max_value = df_col.max()\n  min_value = df_col.min()\n  step_size = (max_value - min_value) / 12\n\n  # Create 10 periods\n  periods = [min_value + i * step_size for i in range(12)]\n  # Define your custom function to map data values to colors\n  def map_value_to_color(value):\n    # Iterate through the value ranges to find the appropriate color index\n    for i, range_max in enumerate(periods):\n      if value <= range_max:\n        return colors[i]\n\n      # If the value is greater than the largest range, return the last color\n      return colors[-1]\n\n    # Map predicted_swe values to colors using the custom function\n  color_mapping = [map_value_to_color(value) for value in df_col.values]\n  return color_mapping, periods\n\ndef convert_csvs_to_images():\n    data = pd.read_csv(\"/home/chetana/gridmet_test_run/test_data_predicted.csv\")\n    print(data.head())\n    data['predicted_swe'].fillna(0, inplace=True)\n    data['predicted_swe'] = data['predicted_swe'].apply(lambda x: 0 if x < 2 else x)\n    \n    for column in data.columns:\n      column_data = data[column]\n      description = column_data.describe()\n\n      # Print or process the description as needed\n      print(f\"Column: {column}\")\n      print(description)\n    \n    # Create a figure with a white background\n    fig = plt.figure(facecolor='white')\n\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    print(\"data['lon'].values = \", data['lon'].values)\n    x, y = m(data['lon'].values, data['lat'].values)\n    print(\"x = \", x)\n    print(\"y = \", y)\n    print(\"v = \", data['aspect'].values)\n\n    color_mapping, legend_values = create_color_maps_with_value_range(data[\"eastness\"])\n    value_ranges = legend_values\n    \n    # Plot the data using the custom colormap\n    plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\n    \n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_date = datetime(1900, 1, 1)\n    day_value = day_index\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    timestamp_string = result_date.strftime(\"%Y-%m-%d\")\n    \n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    # Create custom legend elements using the same colormap\n    legend_elements = [Patch(color=colors[i], label=f\"{value_ranges[i]} - {value_ranges[i+1]-1}\" if i < len(value_ranges) - 1 else f\"> {value_ranges[-1]}\") for i in range(len(value_ranges))]\n\n    # Create the legend outside the map\n    legend = plt.legend(handles=legend_elements, loc='upper left', title='Legend', fontsize=8)\n    legend.set_bbox_to_anchor((1.01, 1)) \n\n    # Remove the color bar\n    #plt.colorbar().remove()\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Set the aspect ratio to 'equal' to keep the plot at the center\n    plt.gca().set_aspect('equal', adjustable='box')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15, right=0.80)  # Adjust right margin to accommodate the legend\n    # Show the plot or save it to a file\n    new_plot_path = f'/home/chetana/gridmet_test_run/predicted_swe-{test_start_date}.png'\n    print(f\"The new plot is saved to {new_plot_path}\")\n    plt.savefig(new_plot_path)\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "/home/chetana/gw-workspace/AJTxiRtYXtG5/convert_results_to_images.py:95: UserWarning: No data for colormapping provided via 'c'. Parameters 'cmap' will be ignored\n  plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\ntoday date = 2023-09-23\ntest start date:  2022-08-21\ntest end date:  2023-09-23\n/home/chetana\n      date   lat      lon  SWE  ...  aspect  eastness  northness  predicted_swe\n0  44792.0  49.0 -125.000  0.0  ...    -1.0      -1.0       -1.0            0.0\n1  44792.0  49.0 -124.964  0.0  ...    -1.0      -1.0       -1.0            0.0\n2  44792.0  49.0 -124.928  0.0  ...    -1.0      -1.0       -1.0            0.0\n3  44792.0  49.0 -124.892  0.0  ...    -1.0      -1.0       -1.0            0.0\n4  44792.0  49.0 -124.856  0.0  ...    -1.0      -1.0       -1.0            0.0\n[5 rows x 20 columns]\nColumn: date\ncount    462204.0\nmean      44792.0\nstd           0.0\nmin       44792.0\n25%       44792.0\n50%       44792.0\n75%       44792.0\nmax       44792.0\nName: date, dtype: float64\nColumn: lat\ncount    462204.000000\nmean         37.030000\nstd           6.921275\nmin          25.060000\n25%          31.036000\n50%          37.030000\n75%          43.024000\nmax          49.000000\nName: lat, dtype: float64\nColumn: lon\ncount    462204.00000\nmean       -112.52600\nstd           7.21226\nmin        -125.00000\n25%        -118.77200\n50%        -112.52600\n75%        -106.28000\nmax        -100.05200\nName: lon, dtype: float64\nColumn: SWE\ncount    462204.000000\nmean        123.618482\nstd         127.035693\nmin           0.000000\n25%           0.000000\n50%           0.000000\n75%         254.000000\nmax         255.000000\nName: SWE, dtype: float64\nColumn: Flag\ncount    462204.000000\nmean        247.408900\nstd           6.622386\nmin         241.000000\n25%         241.000000\n50%         241.000000\n75%         254.000000\nmax         255.000000\nName: Flag, dtype: float64\nColumn: air_temperature_tmmn\ncount    462204.000000\nmean        197.531381\nstd         133.342811\nmin          -1.000000\n25%          -1.000000\n50%         285.400000\n75%         288.400000\nmax         292.200000\nName: air_temperature_tmmn, dtype: float64\nColumn: potential_evapotranspiration\ncount    462204.000000\nmean          4.021922\nstd           3.622423\nmin          -1.000000\n25%          -1.000000\n50%           5.300000\n75%           6.900000\nmax           9.800000\nName: potential_evapotranspiration, dtype: float64\nColumn: mean_vapor_pressure_deficit\ncount    462204.000000\nmean          0.752913\nstd           1.318036\nmin          -1.000000\n25%          -1.000000\n50%           1.110000\n75%           1.780000\nmax           3.290000\nName: mean_vapor_pressure_deficit, dtype: float64\nColumn: relative_humidity_rmax\ncount    462204.000000\nmean         53.712312\nstd          38.846512\nmin          -1.000000\n25%          -1.000000\n50%          69.300000\n75%          84.100000\nmax         100.000000\nName: relative_humidity_rmax, dtype: float64\nColumn: relative_humidity_rmin\ncount    462204.000000\nmean         22.028228\nstd          19.788809\nmin          -1.000000\n25%          -1.000000\n50%          21.550000\n75%          32.800000\nmax          87.900000\nName: relative_humidity_rmin, dtype: float64\nColumn: precipitation_amount\ncount    462204.000000\nmean          0.325225\nstd           1.818821\nmin          -1.000000\n25%          -1.000000\n50%           0.000000\n75%           0.000000\nmax          11.600000\nName: precipitation_amount, dtype: float64\nColumn: air_temperature_tmmx\ncount    462204.000000\nmean        207.843544\nstd         140.293885\nmin          -1.000000\n25%          -1.000000\n50%         299.950000\n75%         303.700000\nmax         310.800000\nName: air_temperature_tmmx, dtype: float64\nColumn: wind_speed\ncount    462204.000000\nmean          1.451051\nstd           1.770101\nmin          -1.000000\n25%          -1.000000\n50%           2.000000\n75%           2.900000\nmax           4.400000\nName: wind_speed, dtype: float64\nColumn: elevation\ncount    462204.000000\nmean          0.737062\nstd           1.233144\nmin          -1.000000\n25%          -1.000000\n50%           1.423000\n75%           1.613000\nmax           2.557000\nName: elevation, dtype: float64\nColumn: slope\ncount    462204.000000\nmean         35.684788\nstd          30.941746\nmin          -1.000000\n25%          -1.000000\n50%          44.193047\n75%          64.317660\nmax          86.687225\nName: slope, dtype: float64\nColumn: curvature\ncount    462204.000000\nmean         -0.433887\nstd           1.654172\nmin         -25.152820\n25%          -1.000000\n50%          -1.000000\n75%           0.368435\nmax          11.464941\nName: curvature, dtype: float64\nColumn: aspect\ncount    462204.000000\nmean        113.374899\nstd         118.691307\nmin          -1.000000\n25%          -1.000000\n50%          83.290180\n75%         215.182167\nmax         359.906980\nName: aspect, dtype: float64\nColumn: eastness\ncount    462204.000000\nmean         -0.350764\nstd           0.665944\nmin          -1.000000\n25%          -1.000000\n50%          -0.622041\n75%           0.286890\nmax           0.785398\nName: eastness, dtype: float64\nColumn: northness\ncount    462204.000000\nmean         -0.354414\nstd           0.671563\nmin          -1.000000\n25%          -1.000000\n50%          -0.647724\n75%           0.306277\nmax           0.785398\nName: northness, dtype: float64\nColumn: predicted_swe\ncount    462204.0\nmean          0.0\nstd           0.0\nmin           0.0\n25%           0.0\n50%           0.0\n75%           0.0\nmax           0.0\nName: predicted_swe, dtype: float64\ndata['lon'].values =  [-125.    -124.964 -124.928 ... -100.124 -100.088 -100.052]\nx =  [      0.            4003.01547425    8006.0309485  ... 2766083.69270573\n 2770086.70817998 2774089.72365423]\ny =  [3395311.63129883 3395311.63129883 3395311.63129883 ...    7363.19741597\n    7363.19741597    7363.19741597]\nv =  [-1. -1. -1. ... -1. -1. -1.]\nThe new plot is saved to /home/chetana/gridmet_test_run/predicted_swe-2022-08-21.png\n",
  "history_begin_time" : 1695504765739,
  "history_end_time" : 1695504774915,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "7mu8rN5v3Bs7",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport uuid\nfrom snowcast_utils import day_index\nimport matplotlib.colors as mcolors\nfrom matplotlib.patches import Patch\nfrom snowcast_utils import day_index, work_dir, test_start_date\n\n# Define the custom colormap with specified colors and ranges\ncolors = [\n    (0.8627, 0.8627, 0.8627),  # #DCDCDC - 0 - 1\n    (0.8627, 1.0000, 1.0000),  # #DCFFFF - 1 - 2\n    (0.6000, 1.0000, 1.0000),  # #99FFFF - 2 - 4\n    (0.5569, 0.8235, 1.0000),  # #8ED2FF - 4 - 6\n    (0.4509, 0.6196, 0.8745),  # #739EDF - 6 - 8\n    (0.4157, 0.4706, 1.0000),  # #6A78FF - 8 - 10\n    (0.4235, 0.2784, 1.0000),  # #6C47FF - 10 - 12\n    (0.5529, 0.0980, 1.0000),  # #8D19FF - 12 - 14\n    (0.7333, 0.0000, 0.9176),  # #BB00EA - 14 - 16\n    (0.8392, 0.0000, 0.7490),  # #D600BF - 16 - 18\n    (0.7569, 0.0039, 0.4549),  # #C10074 - 18 - 20\n    (0.6784, 0.0000, 0.1961),  # #AD0032 - 20 - 30\n    (0.5020, 0.0000, 0.0000)   # #800000 - > 30\n]\n\ncmap_name = 'custom_snow_colormap'\ncustom_cmap = mcolors.ListedColormap(colors)\n\n# Define the lat_lon_to_map_coordinates function\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\n# Define your value ranges for color mapping\n#value_ranges = [1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 30]\n#value_ranges = [0.1, 0.2, 0.4, 0.6, 0.8, 1.0, 1.2, 1.5, 1.8, 2, 2.5, 3]\n\ndef create_color_maps_with_value_range(df_col):\n  max_value = df_col.max()\n  min_value = df_col.min()\n  step_size = (max_value - min_value) / 12\n\n  # Create 10 periods\n  periods = [min_value + i * step_size for i in range(12)]\n  # Define your custom function to map data values to colors\n  def map_value_to_color(value):\n    # Iterate through the value ranges to find the appropriate color index\n    for i, range_max in enumerate(periods):\n      if value <= range_max:\n        return colors[i]\n\n      # If the value is greater than the largest range, return the last color\n      return colors[-1]\n\n    # Map predicted_swe values to colors using the custom function\n  color_mapping = [map_value_to_color(value) for value in df_col.values]\n  return color_mapping\n\ndef convert_csvs_to_images():\n    data = pd.read_csv(\"/home/chetana/gridmet_test_run/test_data_predicted.csv\")\n    print(data.head())\n    data['predicted_swe'].fillna(0, inplace=True)\n    data['predicted_swe'] = data['predicted_swe'].apply(lambda x: 0 if x < 2 else x)\n    \n    for column in data.columns:\n      column_data = data[column]\n      description = column_data.describe()\n\n      # Print or process the description as needed\n      print(f\"Column: {column}\")\n      print(description)\n    \n    # Create a figure with a white background\n    fig = plt.figure(facecolor='white')\n\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    print(\"data['lon'].values = \", data['lon'].values)\n    x, y = m(data['lon'].values, data['lat'].values)\n    print(\"x = \", x)\n    print(\"y = \", y)\n    print(\"v = \", data['aspect'].values)\n\n    color_mapping = create_color_maps_with_value_range(data[\"eastness\"])\n    \n    # Plot the data using the custom colormap\n    plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\n    \n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_date = datetime(1900, 1, 1)\n    day_value = day_index\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    timestamp_string = result_date.strftime(\"%Y-%m-%d\")\n    \n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    # Create custom legend elements using the same colormap\n    legend_elements = [Patch(color=colors[i], label=f\"{value_ranges[i]} - {value_ranges[i+1]-1}\" if i < len(value_ranges) - 1 else f\"> {value_ranges[-1]}\") for i in range(len(value_ranges))]\n\n    # Create the legend outside the map\n    legend = plt.legend(handles=legend_elements, loc='upper left', title='Legend', fontsize=8)\n    legend.set_bbox_to_anchor((1.01, 1)) \n\n    # Remove the color bar\n    #plt.colorbar().remove()\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Set the aspect ratio to 'equal' to keep the plot at the center\n    plt.gca().set_aspect('equal', adjustable='box')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15, right=0.80)  # Adjust right margin to accommodate the legend\n    # Show the plot or save it to a file\n    new_plot_path = f'/home/chetana/gridmet_test_run/predicted_swe-{test_start_date}.png'\n    print(f\"The new plot is saved to {new_plot_path}\")\n    plt.savefig(new_plot_path)\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "/home/chetana/gw-workspace/7mu8rN5v3Bs7/convert_results_to_images.py:94: UserWarning: No data for colormapping provided via 'c'. Parameters 'cmap' will be ignored\n  plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\ntoday date = 2023-09-23\ntest start date:  2022-08-21\ntest end date:  2023-09-23\n/home/chetana\n      date   lat      lon  SWE  ...  aspect  eastness  northness  predicted_swe\n0  44792.0  49.0 -125.000  0.0  ...    -1.0      -1.0       -1.0            0.0\n1  44792.0  49.0 -124.964  0.0  ...    -1.0      -1.0       -1.0            0.0\n2  44792.0  49.0 -124.928  0.0  ...    -1.0      -1.0       -1.0            0.0\n3  44792.0  49.0 -124.892  0.0  ...    -1.0      -1.0       -1.0            0.0\n4  44792.0  49.0 -124.856  0.0  ...    -1.0      -1.0       -1.0            0.0\n[5 rows x 20 columns]\nColumn: date\ncount    462204.0\nmean      44792.0\nstd           0.0\nmin       44792.0\n25%       44792.0\n50%       44792.0\n75%       44792.0\nmax       44792.0\nName: date, dtype: float64\nColumn: lat\ncount    462204.000000\nmean         37.030000\nstd           6.921275\nmin          25.060000\n25%          31.036000\n50%          37.030000\n75%          43.024000\nmax          49.000000\nName: lat, dtype: float64\nColumn: lon\ncount    462204.00000\nmean       -112.52600\nstd           7.21226\nmin        -125.00000\n25%        -118.77200\n50%        -112.52600\n75%        -106.28000\nmax        -100.05200\nName: lon, dtype: float64\nColumn: SWE\ncount    462204.000000\nmean        123.618482\nstd         127.035693\nmin           0.000000\n25%           0.000000\n50%           0.000000\n75%         254.000000\nmax         255.000000\nName: SWE, dtype: float64\nColumn: Flag\ncount    462204.000000\nmean        247.408900\nstd           6.622386\nmin         241.000000\n25%         241.000000\n50%         241.000000\n75%         254.000000\nmax         255.000000\nName: Flag, dtype: float64\nColumn: air_temperature_tmmn\ncount    462204.000000\nmean        197.531381\nstd         133.342811\nmin          -1.000000\n25%          -1.000000\n50%         285.400000\n75%         288.400000\nmax         292.200000\nName: air_temperature_tmmn, dtype: float64\nColumn: potential_evapotranspiration\ncount    462204.000000\nmean          4.021922\nstd           3.622423\nmin          -1.000000\n25%          -1.000000\n50%           5.300000\n75%           6.900000\nmax           9.800000\nName: potential_evapotranspiration, dtype: float64\nColumn: mean_vapor_pressure_deficit\ncount    462204.000000\nmean          0.752913\nstd           1.318036\nmin          -1.000000\n25%          -1.000000\n50%           1.110000\n75%           1.780000\nmax           3.290000\nName: mean_vapor_pressure_deficit, dtype: float64\nColumn: relative_humidity_rmax\ncount    462204.000000\nmean         53.712312\nstd          38.846512\nmin          -1.000000\n25%          -1.000000\n50%          69.300000\n75%          84.100000\nmax         100.000000\nName: relative_humidity_rmax, dtype: float64\nColumn: relative_humidity_rmin\ncount    462204.000000\nmean         22.028228\nstd          19.788809\nmin          -1.000000\n25%          -1.000000\n50%          21.550000\n75%          32.800000\nmax          87.900000\nName: relative_humidity_rmin, dtype: float64\nColumn: precipitation_amount\ncount    462204.000000\nmean          0.325225\nstd           1.818821\nmin          -1.000000\n25%          -1.000000\n50%           0.000000\n75%           0.000000\nmax          11.600000\nName: precipitation_amount, dtype: float64\nColumn: air_temperature_tmmx\ncount    462204.000000\nmean        207.843544\nstd         140.293885\nmin          -1.000000\n25%          -1.000000\n50%         299.950000\n75%         303.700000\nmax         310.800000\nName: air_temperature_tmmx, dtype: float64\nColumn: wind_speed\ncount    462204.000000\nmean          1.451051\nstd           1.770101\nmin          -1.000000\n25%          -1.000000\n50%           2.000000\n75%           2.900000\nmax           4.400000\nName: wind_speed, dtype: float64\nColumn: elevation\ncount    462204.000000\nmean          0.737062\nstd           1.233144\nmin          -1.000000\n25%          -1.000000\n50%           1.423000\n75%           1.613000\nmax           2.557000\nName: elevation, dtype: float64\nColumn: slope\ncount    462204.000000\nmean         35.684788\nstd          30.941746\nmin          -1.000000\n25%          -1.000000\n50%          44.193047\n75%          64.317660\nmax          86.687225\nName: slope, dtype: float64\nColumn: curvature\ncount    462204.000000\nmean         -0.433887\nstd           1.654172\nmin         -25.152820\n25%          -1.000000\n50%          -1.000000\n75%           0.368435\nmax          11.464941\nName: curvature, dtype: float64\nColumn: aspect\ncount    462204.000000\nmean        113.374899\nstd         118.691307\nmin          -1.000000\n25%          -1.000000\n50%          83.290180\n75%         215.182167\nmax         359.906980\nName: aspect, dtype: float64\nColumn: eastness\ncount    462204.000000\nmean         -0.350764\nstd           0.665944\nmin          -1.000000\n25%          -1.000000\n50%          -0.622041\n75%           0.286890\nmax           0.785398\nName: eastness, dtype: float64\nColumn: northness\ncount    462204.000000\nmean         -0.354414\nstd           0.671563\nmin          -1.000000\n25%          -1.000000\n50%          -0.647724\n75%           0.306277\nmax           0.785398\nName: northness, dtype: float64\nColumn: predicted_swe\ncount    462204.0\nmean          0.0\nstd           0.0\nmin           0.0\n25%           0.0\n50%           0.0\n75%           0.0\nmax           0.0\nName: predicted_swe, dtype: float64\ndata['lon'].values =  [-125.    -124.964 -124.928 ... -100.124 -100.088 -100.052]\nx =  [      0.            4003.01547425    8006.0309485  ... 2766083.69270573\n 2770086.70817998 2774089.72365423]\ny =  [3395311.63129883 3395311.63129883 3395311.63129883 ...    7363.19741597\n    7363.19741597    7363.19741597]\nv =  [-1. -1. -1. ... -1. -1. -1.]\nTraceback (most recent call last):\n  File \"/home/chetana/gw-workspace/7mu8rN5v3Bs7/convert_results_to_images.py\", line 159, in <module>\n    convert_csvs_to_images()\n  File \"/home/chetana/gw-workspace/7mu8rN5v3Bs7/convert_results_to_images.py\", line 135, in convert_csvs_to_images\n    legend_elements = [Patch(color=colors[i], label=f\"{value_ranges[i]} - {value_ranges[i+1]-1}\" if i < len(value_ranges) - 1 else f\"> {value_ranges[-1]}\") for i in range(len(value_ranges))]\nNameError: name 'value_ranges' is not defined\n",
  "history_begin_time" : 1695504633164,
  "history_end_time" : 1695504639098,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Failed"
},{
  "history_id" : "0Z0GQLrlTebH",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport uuid\nfrom snowcast_utils import day_index\nimport matplotlib.colors as mcolors\nfrom matplotlib.patches import Patch\nfrom snowcast_utils import day_index, work_dir, test_start_date\n\n# Define the custom colormap with specified colors and ranges\ncolors = [\n    (0.8627, 0.8627, 0.8627),  # #DCDCDC - 0 - 1\n    (0.8627, 1.0000, 1.0000),  # #DCFFFF - 1 - 2\n    (0.6000, 1.0000, 1.0000),  # #99FFFF - 2 - 4\n    (0.5569, 0.8235, 1.0000),  # #8ED2FF - 4 - 6\n    (0.4509, 0.6196, 0.8745),  # #739EDF - 6 - 8\n    (0.4157, 0.4706, 1.0000),  # #6A78FF - 8 - 10\n    (0.4235, 0.2784, 1.0000),  # #6C47FF - 10 - 12\n    (0.5529, 0.0980, 1.0000),  # #8D19FF - 12 - 14\n    (0.7333, 0.0000, 0.9176),  # #BB00EA - 14 - 16\n    (0.8392, 0.0000, 0.7490),  # #D600BF - 16 - 18\n    (0.7569, 0.0039, 0.4549),  # #C10074 - 18 - 20\n    (0.6784, 0.0000, 0.1961),  # #AD0032 - 20 - 30\n    (0.5020, 0.0000, 0.0000)   # #800000 - > 30\n]\n\ncmap_name = 'custom_snow_colormap'\ncustom_cmap = mcolors.ListedColormap(colors)\n\n# Define the lat_lon_to_map_coordinates function\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\n# Define your value ranges for color mapping\n#value_ranges = [1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 30]\n#value_ranges = [0.1, 0.2, 0.4, 0.6, 0.8, 1.0, 1.2, 1.5, 1.8, 2, 2.5, 3]\n\ndef create_color_maps_with_value_range(df_col):\n  max_value = df_col.max()\n  min_value = df_col.min()\n  step_size = (max_value - min_value) / 12\n\n  # Create 10 periods\n  periods = [min_value + i * step_size for i in range(12)]\n  # Define your custom function to map data values to colors\n  def map_value_to_color(value):\n    # Iterate through the value ranges to find the appropriate color index\n    for i, range_max in enumerate(periods):\n      if value <= range_max:\n        return colors[i]\n\n      # If the value is greater than the largest range, return the last color\n      return colors[-1]\n\n    # Map predicted_swe values to colors using the custom function\n    color_mapping = [map_value_to_color(value) for value in df_col.values]\n  return color_mapping\n\ndef convert_csvs_to_images():\n    data = pd.read_csv(\"/home/chetana/gridmet_test_run/test_data_predicted.csv\")\n    print(data.head())\n    data['predicted_swe'].fillna(0, inplace=True)\n    data['predicted_swe'] = data['predicted_swe'].apply(lambda x: 0 if x < 2 else x)\n    \n    for column in data.columns:\n      column_data = data[column]\n      description = column_data.describe()\n\n      # Print or process the description as needed\n      print(f\"Column: {column}\")\n      print(description)\n    \n    # Create a figure with a white background\n    fig = plt.figure(facecolor='white')\n\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    print(\"data['lon'].values = \", data['lon'].values)\n    x, y = m(data['lon'].values, data['lat'].values)\n    print(\"x = \", x)\n    print(\"y = \", y)\n    print(\"v = \", data['aspect'].values)\n\n    color_mapping = create_color_maps_with_value_range(data[\"eastness\"])\n    \n    # Plot the data using the custom colormap\n    plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\n    \n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_date = datetime(1900, 1, 1)\n    day_value = day_index\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    timestamp_string = result_date.strftime(\"%Y-%m-%d\")\n    \n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    # Create custom legend elements using the same colormap\n    legend_elements = [Patch(color=colors[i], label=f\"{value_ranges[i]} - {value_ranges[i+1]-1}\" if i < len(value_ranges) - 1 else f\"> {value_ranges[-1]}\") for i in range(len(value_ranges))]\n\n    # Create the legend outside the map\n    legend = plt.legend(handles=legend_elements, loc='upper left', title='Legend', fontsize=8)\n    legend.set_bbox_to_anchor((1.01, 1)) \n\n    # Remove the color bar\n    #plt.colorbar().remove()\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Set the aspect ratio to 'equal' to keep the plot at the center\n    plt.gca().set_aspect('equal', adjustable='box')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15, right=0.80)  # Adjust right margin to accommodate the legend\n    # Show the plot or save it to a file\n    new_plot_path = f'/home/chetana/gridmet_test_run/predicted_swe-{test_start_date}.png'\n    print(f\"The new plot is saved to {new_plot_path}\")\n    plt.savefig(new_plot_path)\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "today date = 2023-09-23\ntest start date:  2022-08-21\ntest end date:  2023-09-23\n/home/chetana\n      date   lat      lon  SWE  ...  aspect  eastness  northness  predicted_swe\n0  44792.0  49.0 -125.000  0.0  ...    -1.0      -1.0       -1.0            0.0\n1  44792.0  49.0 -124.964  0.0  ...    -1.0      -1.0       -1.0            0.0\n2  44792.0  49.0 -124.928  0.0  ...    -1.0      -1.0       -1.0            0.0\n3  44792.0  49.0 -124.892  0.0  ...    -1.0      -1.0       -1.0            0.0\n4  44792.0  49.0 -124.856  0.0  ...    -1.0      -1.0       -1.0            0.0\n[5 rows x 20 columns]\nColumn: date\ncount    462204.0\nmean      44792.0\nstd           0.0\nmin       44792.0\n25%       44792.0\n50%       44792.0\n75%       44792.0\nmax       44792.0\nName: date, dtype: float64\nColumn: lat\ncount    462204.000000\nmean         37.030000\nstd           6.921275\nmin          25.060000\n25%          31.036000\n50%          37.030000\n75%          43.024000\nmax          49.000000\nName: lat, dtype: float64\nColumn: lon\ncount    462204.00000\nmean       -112.52600\nstd           7.21226\nmin        -125.00000\n25%        -118.77200\n50%        -112.52600\n75%        -106.28000\nmax        -100.05200\nName: lon, dtype: float64\nColumn: SWE\ncount    462204.000000\nmean        123.618482\nstd         127.035693\nmin           0.000000\n25%           0.000000\n50%           0.000000\n75%         254.000000\nmax         255.000000\nName: SWE, dtype: float64\nColumn: Flag\ncount    462204.000000\nmean        247.408900\nstd           6.622386\nmin         241.000000\n25%         241.000000\n50%         241.000000\n75%         254.000000\nmax         255.000000\nName: Flag, dtype: float64\nColumn: air_temperature_tmmn\ncount    462204.000000\nmean        197.531381\nstd         133.342811\nmin          -1.000000\n25%          -1.000000\n50%         285.400000\n75%         288.400000\nmax         292.200000\nName: air_temperature_tmmn, dtype: float64\nColumn: potential_evapotranspiration\ncount    462204.000000\nmean          4.021922\nstd           3.622423\nmin          -1.000000\n25%          -1.000000\n50%           5.300000\n75%           6.900000\nmax           9.800000\nName: potential_evapotranspiration, dtype: float64\nColumn: mean_vapor_pressure_deficit\ncount    462204.000000\nmean          0.752913\nstd           1.318036\nmin          -1.000000\n25%          -1.000000\n50%           1.110000\n75%           1.780000\nmax           3.290000\nName: mean_vapor_pressure_deficit, dtype: float64\nColumn: relative_humidity_rmax\ncount    462204.000000\nmean         53.712312\nstd          38.846512\nmin          -1.000000\n25%          -1.000000\n50%          69.300000\n75%          84.100000\nmax         100.000000\nName: relative_humidity_rmax, dtype: float64\nColumn: relative_humidity_rmin\ncount    462204.000000\nmean         22.028228\nstd          19.788809\nmin          -1.000000\n25%          -1.000000\n50%          21.550000\n75%          32.800000\nmax          87.900000\nName: relative_humidity_rmin, dtype: float64\nColumn: precipitation_amount\ncount    462204.000000\nmean          0.325225\nstd           1.818821\nmin          -1.000000\n25%          -1.000000\n50%           0.000000\n75%           0.000000\nmax          11.600000\nName: precipitation_amount, dtype: float64\nColumn: air_temperature_tmmx\ncount    462204.000000\nmean        207.843544\nstd         140.293885\nmin          -1.000000\n25%          -1.000000\n50%         299.950000\n75%         303.700000\nmax         310.800000\nName: air_temperature_tmmx, dtype: float64\nColumn: wind_speed\ncount    462204.000000\nmean          1.451051\nstd           1.770101\nmin          -1.000000\n25%          -1.000000\n50%           2.000000\n75%           2.900000\nmax           4.400000\nName: wind_speed, dtype: float64\nColumn: elevation\ncount    462204.000000\nmean          0.737062\nstd           1.233144\nmin          -1.000000\n25%          -1.000000\n50%           1.423000\n75%           1.613000\nmax           2.557000\nName: elevation, dtype: float64\nColumn: slope\ncount    462204.000000\nmean         35.684788\nstd          30.941746\nmin          -1.000000\n25%          -1.000000\n50%          44.193047\n75%          64.317660\nmax          86.687225\nName: slope, dtype: float64\nColumn: curvature\ncount    462204.000000\nmean         -0.433887\nstd           1.654172\nmin         -25.152820\n25%          -1.000000\n50%          -1.000000\n75%           0.368435\nmax          11.464941\nName: curvature, dtype: float64\nColumn: aspect\ncount    462204.000000\nmean        113.374899\nstd         118.691307\nmin          -1.000000\n25%          -1.000000\n50%          83.290180\n75%         215.182167\nmax         359.906980\nName: aspect, dtype: float64\nColumn: eastness\ncount    462204.000000\nmean         -0.350764\nstd           0.665944\nmin          -1.000000\n25%          -1.000000\n50%          -0.622041\n75%           0.286890\nmax           0.785398\nName: eastness, dtype: float64\nColumn: northness\ncount    462204.000000\nmean         -0.354414\nstd           0.671563\nmin          -1.000000\n25%          -1.000000\n50%          -0.647724\n75%           0.306277\nmax           0.785398\nName: northness, dtype: float64\nColumn: predicted_swe\ncount    462204.0\nmean          0.0\nstd           0.0\nmin           0.0\n25%           0.0\n50%           0.0\n75%           0.0\nmax           0.0\nName: predicted_swe, dtype: float64\ndata['lon'].values =  [-125.    -124.964 -124.928 ... -100.124 -100.088 -100.052]\nx =  [      0.            4003.01547425    8006.0309485  ... 2766083.69270573\n 2770086.70817998 2774089.72365423]\ny =  [3395311.63129883 3395311.63129883 3395311.63129883 ...    7363.19741597\n    7363.19741597    7363.19741597]\nv =  [-1. -1. -1. ... -1. -1. -1.]\nTraceback (most recent call last):\n  File \"/home/chetana/gw-workspace/0Z0GQLrlTebH/convert_results_to_images.py\", line 159, in <module>\n    convert_csvs_to_images()\n  File \"/home/chetana/gw-workspace/0Z0GQLrlTebH/convert_results_to_images.py\", line 91, in convert_csvs_to_images\n    color_mapping = create_color_maps_with_value_range(data[\"eastness\"])\n  File \"/home/chetana/gw-workspace/0Z0GQLrlTebH/convert_results_to_images.py\", line 60, in create_color_maps_with_value_range\n    return color_mapping\nNameError: name 'color_mapping' is not defined\n",
  "history_begin_time" : 1695504608225,
  "history_end_time" : 1695504613901,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Failed"
},{
  "history_id" : "3Lsdb8CnqMTq",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport uuid\nfrom snowcast_utils import day_index\nimport matplotlib.colors as mcolors\nfrom matplotlib.patches import Patch\nfrom snowcast_utils import day_index, work_dir, test_start_date\n\n# Define the custom colormap with specified colors and ranges\ncolors = [\n    (0.8627, 0.8627, 0.8627),  # #DCDCDC - 0 - 1\n    (0.8627, 1.0000, 1.0000),  # #DCFFFF - 1 - 2\n    (0.6000, 1.0000, 1.0000),  # #99FFFF - 2 - 4\n    (0.5569, 0.8235, 1.0000),  # #8ED2FF - 4 - 6\n    (0.4509, 0.6196, 0.8745),  # #739EDF - 6 - 8\n    (0.4157, 0.4706, 1.0000),  # #6A78FF - 8 - 10\n    (0.4235, 0.2784, 1.0000),  # #6C47FF - 10 - 12\n    (0.5529, 0.0980, 1.0000),  # #8D19FF - 12 - 14\n    (0.7333, 0.0000, 0.9176),  # #BB00EA - 14 - 16\n    (0.8392, 0.0000, 0.7490),  # #D600BF - 16 - 18\n    (0.7569, 0.0039, 0.4549),  # #C10074 - 18 - 20\n    (0.6784, 0.0000, 0.1961),  # #AD0032 - 20 - 30\n    (0.5020, 0.0000, 0.0000)   # #800000 - > 30\n]\n\ncmap_name = 'custom_snow_colormap'\ncustom_cmap = mcolors.ListedColormap(colors)\n\n# Define the lat_lon_to_map_coordinates function\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\n# Define your value ranges for color mapping\n#value_ranges = [1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 30]\nvalue_ranges = [0.1, 0.2, 0.4, 0.6, 0.8, 1.0, 1.2, 1.5, 1.8, 2, 2.5, 3]\n\ndef convert_csvs_to_images():\n    data = pd.read_csv(\"/home/chetana/gridmet_test_run/test_data_predicted.csv\")\n    print(data.head())\n    data['predicted_swe'].fillna(0, inplace=True)\n    data['predicted_swe'] = data['predicted_swe'].apply(lambda x: 0 if x < 2 else x)\n    \n    for column in data.columns:\n      column_data = data[column]\n      description = column_data.describe()\n\n      # Print or process the description as needed\n      print(f\"Column: {column}\")\n      print(description)\n    \n    # Create a figure with a white background\n    fig = plt.figure(facecolor='white')\n\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    print(\"data['lon'].values = \", data['lon'].values)\n    x, y = m(data['lon'].values, data['lat'].values)\n    print(\"x = \", x)\n    print(\"y = \", y)\n    print(\"v = \", data['aspect'].values)\n\n    # Define your custom function to map data values to colors\n    def map_value_to_color(value):\n        # Iterate through the value ranges to find the appropriate color index\n        for i, range_max in enumerate(value_ranges):\n            if value <= range_max:\n                return colors[i]\n        \n        # If the value is greater than the largest range, return the last color\n        return colors[-1]\n\n    # Map predicted_swe values to colors using the custom function\n    color_mapping = [map_value_to_color(value) for value in data['elevation'].values]\n    \n    # Plot the data using the custom colormap\n    plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\n    \n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_date = datetime(1900, 1, 1)\n    day_value = day_index\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    timestamp_string = result_date.strftime(\"%Y-%m-%d\")\n    \n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    # Create custom legend elements using the same colormap\n    legend_elements = [Patch(color=colors[i], label=f\"{value_ranges[i]} - {value_ranges[i+1]-1}\" if i < len(value_ranges) - 1 else f\"> {value_ranges[-1]}\") for i in range(len(value_ranges))]\n\n    # Create the legend outside the map\n    legend = plt.legend(handles=legend_elements, loc='upper left', title='Legend', fontsize=8)\n    legend.set_bbox_to_anchor((1.01, 1)) \n\n    # Remove the color bar\n    #plt.colorbar().remove()\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Set the aspect ratio to 'equal' to keep the plot at the center\n    plt.gca().set_aspect('equal', adjustable='box')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15, right=0.80)  # Adjust right margin to accommodate the legend\n    # Show the plot or save it to a file\n    new_plot_path = f'/home/chetana/gridmet_test_run/predicted_swe-{test_start_date}.png'\n    print(f\"The new plot is saved to {new_plot_path}\")\n    plt.savefig(new_plot_path)\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "/home/chetana/gw-workspace/3Lsdb8CnqMTq/convert_results_to_images.py:84: UserWarning: No data for colormapping provided via 'c'. Parameters 'cmap' will be ignored\n  plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\ntoday date = 2023-09-23\ntest start date:  2022-08-21\ntest end date:  2023-09-23\n/home/chetana\n      date   lat      lon  SWE  ...  aspect  eastness  northness  predicted_swe\n0  44792.0  49.0 -125.000  0.0  ...    -1.0      -1.0       -1.0            0.0\n1  44792.0  49.0 -124.964  0.0  ...    -1.0      -1.0       -1.0            0.0\n2  44792.0  49.0 -124.928  0.0  ...    -1.0      -1.0       -1.0            0.0\n3  44792.0  49.0 -124.892  0.0  ...    -1.0      -1.0       -1.0            0.0\n4  44792.0  49.0 -124.856  0.0  ...    -1.0      -1.0       -1.0            0.0\n[5 rows x 20 columns]\nColumn: date\ncount    462204.0\nmean      44792.0\nstd           0.0\nmin       44792.0\n25%       44792.0\n50%       44792.0\n75%       44792.0\nmax       44792.0\nName: date, dtype: float64\nColumn: lat\ncount    462204.000000\nmean         37.030000\nstd           6.921275\nmin          25.060000\n25%          31.036000\n50%          37.030000\n75%          43.024000\nmax          49.000000\nName: lat, dtype: float64\nColumn: lon\ncount    462204.00000\nmean       -112.52600\nstd           7.21226\nmin        -125.00000\n25%        -118.77200\n50%        -112.52600\n75%        -106.28000\nmax        -100.05200\nName: lon, dtype: float64\nColumn: SWE\ncount    462204.000000\nmean        123.618482\nstd         127.035693\nmin           0.000000\n25%           0.000000\n50%           0.000000\n75%         254.000000\nmax         255.000000\nName: SWE, dtype: float64\nColumn: Flag\ncount    462204.000000\nmean        247.408900\nstd           6.622386\nmin         241.000000\n25%         241.000000\n50%         241.000000\n75%         254.000000\nmax         255.000000\nName: Flag, dtype: float64\nColumn: air_temperature_tmmn\ncount    462204.000000\nmean        197.531381\nstd         133.342811\nmin          -1.000000\n25%          -1.000000\n50%         285.400000\n75%         288.400000\nmax         292.200000\nName: air_temperature_tmmn, dtype: float64\nColumn: potential_evapotranspiration\ncount    462204.000000\nmean          4.021922\nstd           3.622423\nmin          -1.000000\n25%          -1.000000\n50%           5.300000\n75%           6.900000\nmax           9.800000\nName: potential_evapotranspiration, dtype: float64\nColumn: mean_vapor_pressure_deficit\ncount    462204.000000\nmean          0.752913\nstd           1.318036\nmin          -1.000000\n25%          -1.000000\n50%           1.110000\n75%           1.780000\nmax           3.290000\nName: mean_vapor_pressure_deficit, dtype: float64\nColumn: relative_humidity_rmax\ncount    462204.000000\nmean         53.712312\nstd          38.846512\nmin          -1.000000\n25%          -1.000000\n50%          69.300000\n75%          84.100000\nmax         100.000000\nName: relative_humidity_rmax, dtype: float64\nColumn: relative_humidity_rmin\ncount    462204.000000\nmean         22.028228\nstd          19.788809\nmin          -1.000000\n25%          -1.000000\n50%          21.550000\n75%          32.800000\nmax          87.900000\nName: relative_humidity_rmin, dtype: float64\nColumn: precipitation_amount\ncount    462204.000000\nmean          0.325225\nstd           1.818821\nmin          -1.000000\n25%          -1.000000\n50%           0.000000\n75%           0.000000\nmax          11.600000\nName: precipitation_amount, dtype: float64\nColumn: air_temperature_tmmx\ncount    462204.000000\nmean        207.843544\nstd         140.293885\nmin          -1.000000\n25%          -1.000000\n50%         299.950000\n75%         303.700000\nmax         310.800000\nName: air_temperature_tmmx, dtype: float64\nColumn: wind_speed\ncount    462204.000000\nmean          1.451051\nstd           1.770101\nmin          -1.000000\n25%          -1.000000\n50%           2.000000\n75%           2.900000\nmax           4.400000\nName: wind_speed, dtype: float64\nColumn: elevation\ncount    462204.000000\nmean          0.737062\nstd           1.233144\nmin          -1.000000\n25%          -1.000000\n50%           1.423000\n75%           1.613000\nmax           2.557000\nName: elevation, dtype: float64\nColumn: slope\ncount    462204.000000\nmean         35.684788\nstd          30.941746\nmin          -1.000000\n25%          -1.000000\n50%          44.193047\n75%          64.317660\nmax          86.687225\nName: slope, dtype: float64\nColumn: curvature\ncount    462204.000000\nmean         -0.433887\nstd           1.654172\nmin         -25.152820\n25%          -1.000000\n50%          -1.000000\n75%           0.368435\nmax          11.464941\nName: curvature, dtype: float64\nColumn: aspect\ncount    462204.000000\nmean        113.374899\nstd         118.691307\nmin          -1.000000\n25%          -1.000000\n50%          83.290180\n75%         215.182167\nmax         359.906980\nName: aspect, dtype: float64\nColumn: eastness\ncount    462204.000000\nmean         -0.350764\nstd           0.665944\nmin          -1.000000\n25%          -1.000000\n50%          -0.622041\n75%           0.286890\nmax           0.785398\nName: eastness, dtype: float64\nColumn: northness\ncount    462204.000000\nmean         -0.354414\nstd           0.671563\nmin          -1.000000\n25%          -1.000000\n50%          -0.647724\n75%           0.306277\nmax           0.785398\nName: northness, dtype: float64\nColumn: predicted_swe\ncount    462204.0\nmean          0.0\nstd           0.0\nmin           0.0\n25%           0.0\n50%           0.0\n75%           0.0\nmax           0.0\nName: predicted_swe, dtype: float64\ndata['lon'].values =  [-125.    -124.964 -124.928 ... -100.124 -100.088 -100.052]\nx =  [      0.            4003.01547425    8006.0309485  ... 2766083.69270573\n 2770086.70817998 2774089.72365423]\ny =  [3395311.63129883 3395311.63129883 3395311.63129883 ...    7363.19741597\n    7363.19741597    7363.19741597]\nv =  [-1. -1. -1. ... -1. -1. -1.]\nThe new plot is saved to /home/chetana/gridmet_test_run/predicted_swe-2022-08-21.png\n",
  "history_begin_time" : 1695480323657,
  "history_end_time" : 1695480333023,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "Bi7LD8vMWdzH",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport uuid\nfrom snowcast_utils import day_index\nimport matplotlib.colors as mcolors\nfrom matplotlib.patches import Patch\nfrom snowcast_utils import day_index, work_dir, test_start_date\n\n# Define the custom colormap with specified colors and ranges\ncolors = [\n    (0.8627, 0.8627, 0.8627),  # #DCDCDC - 0 - 1\n    (0.8627, 1.0000, 1.0000),  # #DCFFFF - 1 - 2\n    (0.6000, 1.0000, 1.0000),  # #99FFFF - 2 - 4\n    (0.5569, 0.8235, 1.0000),  # #8ED2FF - 4 - 6\n    (0.4509, 0.6196, 0.8745),  # #739EDF - 6 - 8\n    (0.4157, 0.4706, 1.0000),  # #6A78FF - 8 - 10\n    (0.4235, 0.2784, 1.0000),  # #6C47FF - 10 - 12\n    (0.5529, 0.0980, 1.0000),  # #8D19FF - 12 - 14\n    (0.7333, 0.0000, 0.9176),  # #BB00EA - 14 - 16\n    (0.8392, 0.0000, 0.7490),  # #D600BF - 16 - 18\n    (0.7569, 0.0039, 0.4549),  # #C10074 - 18 - 20\n    (0.6784, 0.0000, 0.1961),  # #AD0032 - 20 - 30\n    (0.5020, 0.0000, 0.0000)   # #800000 - > 30\n]\n\ncmap_name = 'custom_snow_colormap'\ncustom_cmap = mcolors.ListedColormap(colors)\n\n# Define the lat_lon_to_map_coordinates function\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\n# Define your value ranges for color mapping\nvalue_ranges = [1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 30]\n\ndef convert_csvs_to_images():\n    data = pd.read_csv(\"/home/chetana/gridmet_test_run/test_data_predicted.csv\")\n    print(data.head())\n    data['predicted_swe'].fillna(0, inplace=True)\n    data['predicted_swe'] = data['predicted_swe'].apply(lambda x: 0 if x < 2 else x)\n    \n    for column in data.columns:\n      column_data = data[column]\n      description = column_data.describe()\n\n      # Print or process the description as needed\n      print(f\"Column: {column}\")\n      print(description)\n    \n    # Create a figure with a white background\n    fig = plt.figure(facecolor='white')\n\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    print(\"data['lon'].values = \", data['lon'].values)\n    x, y = m(data['lon'].values, data['lat'].values)\n    print(\"x = \", x)\n    print(\"y = \", y)\n    print(\"v = \", data['aspect'].values)\n\n    # Define your custom function to map data values to colors\n    def map_value_to_color(value):\n        # Iterate through the value ranges to find the appropriate color index\n        for i, range_max in enumerate(value_ranges):\n            if value <= range_max:\n                return colors[i]\n        \n        # If the value is greater than the largest range, return the last color\n        return colors[-1]\n\n    # Map predicted_swe values to colors using the custom function\n    color_mapping = [map_value_to_color(value) for value in data['aspect'].values]\n    \n    # Plot the data using the custom colormap\n    plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\n    \n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_date = datetime(1900, 1, 1)\n    day_value = day_index\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    timestamp_string = result_date.strftime(\"%Y-%m-%d\")\n    \n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    # Create custom legend elements using the same colormap\n    legend_elements = [Patch(color=colors[i], label=f\"{value_ranges[i]} - {value_ranges[i+1]-1}\" if i < len(value_ranges) - 1 else f\"> {value_ranges[-1]}\") for i in range(len(value_ranges))]\n\n    # Create the legend outside the map\n    legend = plt.legend(handles=legend_elements, loc='upper left', title='Legend', fontsize=8)\n    legend.set_bbox_to_anchor((1.01, 1)) \n\n    # Remove the color bar\n    #plt.colorbar().remove()\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Set the aspect ratio to 'equal' to keep the plot at the center\n    plt.gca().set_aspect('equal', adjustable='box')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15, right=0.80)  # Adjust right margin to accommodate the legend\n    # Show the plot or save it to a file\n    new_plot_path = f'/home/chetana/gridmet_test_run/predicted_swe-{test_start_date}.png'\n    print(f\"The new plot is saved to {new_plot_path}\")\n    plt.savefig(new_plot_path)\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "/home/chetana/gw-workspace/Bi7LD8vMWdzH/convert_results_to_images.py:83: UserWarning: No data for colormapping provided via 'c'. Parameters 'cmap' will be ignored\n  plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\ntoday date = 2023-09-23\ntest start date:  2022-08-21\ntest end date:  2023-09-23\n/home/chetana\n      date   lat      lon  SWE  ...  aspect  eastness  northness  predicted_swe\n0  44792.0  49.0 -125.000  0.0  ...    -1.0      -1.0       -1.0            0.0\n1  44792.0  49.0 -124.964  0.0  ...    -1.0      -1.0       -1.0            0.0\n2  44792.0  49.0 -124.928  0.0  ...    -1.0      -1.0       -1.0            0.0\n3  44792.0  49.0 -124.892  0.0  ...    -1.0      -1.0       -1.0            0.0\n4  44792.0  49.0 -124.856  0.0  ...    -1.0      -1.0       -1.0            0.0\n[5 rows x 20 columns]\nColumn: date\ncount    462204.0\nmean      44792.0\nstd           0.0\nmin       44792.0\n25%       44792.0\n50%       44792.0\n75%       44792.0\nmax       44792.0\nName: date, dtype: float64\nColumn: lat\ncount    462204.000000\nmean         37.030000\nstd           6.921275\nmin          25.060000\n25%          31.036000\n50%          37.030000\n75%          43.024000\nmax          49.000000\nName: lat, dtype: float64\nColumn: lon\ncount    462204.00000\nmean       -112.52600\nstd           7.21226\nmin        -125.00000\n25%        -118.77200\n50%        -112.52600\n75%        -106.28000\nmax        -100.05200\nName: lon, dtype: float64\nColumn: SWE\ncount    462204.000000\nmean        123.618482\nstd         127.035693\nmin           0.000000\n25%           0.000000\n50%           0.000000\n75%         254.000000\nmax         255.000000\nName: SWE, dtype: float64\nColumn: Flag\ncount    462204.000000\nmean        247.408900\nstd           6.622386\nmin         241.000000\n25%         241.000000\n50%         241.000000\n75%         254.000000\nmax         255.000000\nName: Flag, dtype: float64\nColumn: air_temperature_tmmn\ncount    462204.000000\nmean        197.531381\nstd         133.342811\nmin          -1.000000\n25%          -1.000000\n50%         285.400000\n75%         288.400000\nmax         292.200000\nName: air_temperature_tmmn, dtype: float64\nColumn: potential_evapotranspiration\ncount    462204.000000\nmean          4.021922\nstd           3.622423\nmin          -1.000000\n25%          -1.000000\n50%           5.300000\n75%           6.900000\nmax           9.800000\nName: potential_evapotranspiration, dtype: float64\nColumn: mean_vapor_pressure_deficit\ncount    462204.000000\nmean          0.752913\nstd           1.318036\nmin          -1.000000\n25%          -1.000000\n50%           1.110000\n75%           1.780000\nmax           3.290000\nName: mean_vapor_pressure_deficit, dtype: float64\nColumn: relative_humidity_rmax\ncount    462204.000000\nmean         53.712312\nstd          38.846512\nmin          -1.000000\n25%          -1.000000\n50%          69.300000\n75%          84.100000\nmax         100.000000\nName: relative_humidity_rmax, dtype: float64\nColumn: relative_humidity_rmin\ncount    462204.000000\nmean         22.028228\nstd          19.788809\nmin          -1.000000\n25%          -1.000000\n50%          21.550000\n75%          32.800000\nmax          87.900000\nName: relative_humidity_rmin, dtype: float64\nColumn: precipitation_amount\ncount    462204.000000\nmean          0.325225\nstd           1.818821\nmin          -1.000000\n25%          -1.000000\n50%           0.000000\n75%           0.000000\nmax          11.600000\nName: precipitation_amount, dtype: float64\nColumn: air_temperature_tmmx\ncount    462204.000000\nmean        207.843544\nstd         140.293885\nmin          -1.000000\n25%          -1.000000\n50%         299.950000\n75%         303.700000\nmax         310.800000\nName: air_temperature_tmmx, dtype: float64\nColumn: wind_speed\ncount    462204.000000\nmean          1.451051\nstd           1.770101\nmin          -1.000000\n25%          -1.000000\n50%           2.000000\n75%           2.900000\nmax           4.400000\nName: wind_speed, dtype: float64\nColumn: elevation\ncount    462204.000000\nmean          0.737062\nstd           1.233144\nmin          -1.000000\n25%          -1.000000\n50%           1.423000\n75%           1.613000\nmax           2.557000\nName: elevation, dtype: float64\nColumn: slope\ncount    462204.000000\nmean         35.684788\nstd          30.941746\nmin          -1.000000\n25%          -1.000000\n50%          44.193047\n75%          64.317660\nmax          86.687225\nName: slope, dtype: float64\nColumn: curvature\ncount    462204.000000\nmean         -0.433887\nstd           1.654172\nmin         -25.152820\n25%          -1.000000\n50%          -1.000000\n75%           0.368435\nmax          11.464941\nName: curvature, dtype: float64\nColumn: aspect\ncount    462204.000000\nmean        113.374899\nstd         118.691307\nmin          -1.000000\n25%          -1.000000\n50%          83.290180\n75%         215.182167\nmax         359.906980\nName: aspect, dtype: float64\nColumn: eastness\ncount    462204.000000\nmean         -0.350764\nstd           0.665944\nmin          -1.000000\n25%          -1.000000\n50%          -0.622041\n75%           0.286890\nmax           0.785398\nName: eastness, dtype: float64\nColumn: northness\ncount    462204.000000\nmean         -0.354414\nstd           0.671563\nmin          -1.000000\n25%          -1.000000\n50%          -0.647724\n75%           0.306277\nmax           0.785398\nName: northness, dtype: float64\nColumn: predicted_swe\ncount    462204.0\nmean          0.0\nstd           0.0\nmin           0.0\n25%           0.0\n50%           0.0\n75%           0.0\nmax           0.0\nName: predicted_swe, dtype: float64\ndata['lon'].values =  [-125.    -124.964 -124.928 ... -100.124 -100.088 -100.052]\nx =  [      0.            4003.01547425    8006.0309485  ... 2766083.69270573\n 2770086.70817998 2774089.72365423]\ny =  [3395311.63129883 3395311.63129883 3395311.63129883 ...    7363.19741597\n    7363.19741597    7363.19741597]\nv =  [-1. -1. -1. ... -1. -1. -1.]\nThe new plot is saved to /home/chetana/gridmet_test_run/predicted_swe-2022-08-21.png\n",
  "history_begin_time" : 1695480055092,
  "history_end_time" : 1695480064603,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "UJwGQmOJTSn7",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport uuid\nfrom snowcast_utils import day_index\nimport matplotlib.colors as mcolors\nfrom matplotlib.patches import Patch\nfrom snowcast_utils import day_index, work_dir, test_start_date\n\n# Define the custom colormap with specified colors and ranges\ncolors = [\n    (0.8627, 0.8627, 0.8627),  # #DCDCDC - 0 - 1\n    (0.8627, 1.0000, 1.0000),  # #DCFFFF - 1 - 2\n    (0.6000, 1.0000, 1.0000),  # #99FFFF - 2 - 4\n    (0.5569, 0.8235, 1.0000),  # #8ED2FF - 4 - 6\n    (0.4509, 0.6196, 0.8745),  # #739EDF - 6 - 8\n    (0.4157, 0.4706, 1.0000),  # #6A78FF - 8 - 10\n    (0.4235, 0.2784, 1.0000),  # #6C47FF - 10 - 12\n    (0.5529, 0.0980, 1.0000),  # #8D19FF - 12 - 14\n    (0.7333, 0.0000, 0.9176),  # #BB00EA - 14 - 16\n    (0.8392, 0.0000, 0.7490),  # #D600BF - 16 - 18\n    (0.7569, 0.0039, 0.4549),  # #C10074 - 18 - 20\n    (0.6784, 0.0000, 0.1961),  # #AD0032 - 20 - 30\n    (0.5020, 0.0000, 0.0000)   # #800000 - > 30\n]\n\ncmap_name = 'custom_snow_colormap'\ncustom_cmap = mcolors.ListedColormap(colors)\n\n# Define the lat_lon_to_map_coordinates function\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\n# Define your value ranges for color mapping\nvalue_ranges = [1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 30]\n\ndef convert_csvs_to_images():\n    data = pd.read_csv(\"/home/chetana/gridmet_test_run/test_data_predicted.csv\")\n    print(data.head())\n    data['predicted_swe'].fillna(0, inplace=True)\n    data['predicted_swe'] = data['predicted_swe'].apply(lambda x: 0 if x < 2 else x)\n    print(data['predicted_swe'].describe())\n    \n    # Create a figure with a white background\n    fig = plt.figure(facecolor='white')\n\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    print(\"data['lon'].values = \", data['lon'].values)\n    x, y = m(data['lon'].values, data['lat'].values)\n    print(\"x = \", x)\n    print(\"y = \", y)\n    print(\"v = \", data['aspect'].values)\n\n    # Define your custom function to map data values to colors\n    def map_value_to_color(value):\n        # Iterate through the value ranges to find the appropriate color index\n        for i, range_max in enumerate(value_ranges):\n            if value <= range_max:\n                return colors[i]\n        \n        # If the value is greater than the largest range, return the last color\n        return colors[-1]\n\n    # Map predicted_swe values to colors using the custom function\n    color_mapping = [map_value_to_color(value) for value in data['aspect'].values]\n    \n    # Plot the data using the custom colormap\n    plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\n    \n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_date = datetime(1900, 1, 1)\n    day_value = day_index\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    timestamp_string = result_date.strftime(\"%Y-%m-%d\")\n    \n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    # Create custom legend elements using the same colormap\n    legend_elements = [Patch(color=colors[i], label=f\"{value_ranges[i]} - {value_ranges[i+1]-1}\" if i < len(value_ranges) - 1 else f\"> {value_ranges[-1]}\") for i in range(len(value_ranges))]\n\n    # Create the legend outside the map\n    legend = plt.legend(handles=legend_elements, loc='upper left', title='Legend', fontsize=8)\n    legend.set_bbox_to_anchor((1.01, 1)) \n\n    # Remove the color bar\n    #plt.colorbar().remove()\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Set the aspect ratio to 'equal' to keep the plot at the center\n    plt.gca().set_aspect('equal', adjustable='box')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15, right=0.80)  # Adjust right margin to accommodate the legend\n    # Show the plot or save it to a file\n    new_plot_path = f'/home/chetana/gridmet_test_run/predicted_swe-{test_start_date}.png'\n    print(f\"The new plot is saved to {new_plot_path}\")\n    plt.savefig(new_plot_path)\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "/home/chetana/gw-workspace/UJwGQmOJTSn7/convert_results_to_images.py:76: UserWarning: No data for colormapping provided via 'c'. Parameters 'cmap' will be ignored\n  plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\ntoday date = 2023-09-23\ntest start date:  2022-08-21\ntest end date:  2023-09-23\n/home/chetana\n      date   lat      lon  SWE  ...  aspect  eastness  northness  predicted_swe\n0  44792.0  49.0 -125.000  0.0  ...    -1.0      -1.0       -1.0            0.0\n1  44792.0  49.0 -124.964  0.0  ...    -1.0      -1.0       -1.0            0.0\n2  44792.0  49.0 -124.928  0.0  ...    -1.0      -1.0       -1.0            0.0\n3  44792.0  49.0 -124.892  0.0  ...    -1.0      -1.0       -1.0            0.0\n4  44792.0  49.0 -124.856  0.0  ...    -1.0      -1.0       -1.0            0.0\n[5 rows x 20 columns]\ncount    462204.0\nmean          0.0\nstd           0.0\nmin           0.0\n25%           0.0\n50%           0.0\n75%           0.0\nmax           0.0\nName: predicted_swe, dtype: float64\ndata['lon'].values =  [-125.    -124.964 -124.928 ... -100.124 -100.088 -100.052]\nx =  [      0.            4003.01547425    8006.0309485  ... 2766083.69270573\n 2770086.70817998 2774089.72365423]\ny =  [3395311.63129883 3395311.63129883 3395311.63129883 ...    7363.19741597\n    7363.19741597    7363.19741597]\nv =  [-1. -1. -1. ... -1. -1. -1.]\nThe new plot is saved to /home/chetana/gridmet_test_run/predicted_swe-2022-08-21.png\n",
  "history_begin_time" : 1695479373663,
  "history_end_time" : 1695479382786,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "IZLWQzKYzGRT",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport uuid\nfrom snowcast_utils import day_index\nimport matplotlib.colors as mcolors\nfrom matplotlib.patches import Patch\nfrom snowcast_utils import day_index, work_dir, test_start_date\n\n# Define the custom colormap with specified colors and ranges\ncolors = [\n    (0.8627, 0.8627, 0.8627),  # #DCDCDC - 0 - 1\n    (0.8627, 1.0000, 1.0000),  # #DCFFFF - 1 - 2\n    (0.6000, 1.0000, 1.0000),  # #99FFFF - 2 - 4\n    (0.5569, 0.8235, 1.0000),  # #8ED2FF - 4 - 6\n    (0.4509, 0.6196, 0.8745),  # #739EDF - 6 - 8\n    (0.4157, 0.4706, 1.0000),  # #6A78FF - 8 - 10\n    (0.4235, 0.2784, 1.0000),  # #6C47FF - 10 - 12\n    (0.5529, 0.0980, 1.0000),  # #8D19FF - 12 - 14\n    (0.7333, 0.0000, 0.9176),  # #BB00EA - 14 - 16\n    (0.8392, 0.0000, 0.7490),  # #D600BF - 16 - 18\n    (0.7569, 0.0039, 0.4549),  # #C10074 - 18 - 20\n    (0.6784, 0.0000, 0.1961),  # #AD0032 - 20 - 30\n    (0.5020, 0.0000, 0.0000)   # #800000 - > 30\n]\n\ncmap_name = 'custom_snow_colormap'\ncustom_cmap = mcolors.ListedColormap(colors)\n\n# Define the lat_lon_to_map_coordinates function\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\n# Define your value ranges for color mapping\nvalue_ranges = [1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 30]\n\ndef convert_csvs_to_images():\n    data = pd.read_csv(\"/home/chetana/gridmet_test_run/test_data_predicted.csv\")\n    print(data.head())\n    data['predicted_swe'].fillna(0, inplace=True)\n    data['predicted_swe'] = data['predicted_swe'].apply(lambda x: 0 if x < 2 else x)\n    print(data['predicted_swe'].describe())\n    \n    # Create a figure with a white background\n    fig = plt.figure(facecolor='white')\n\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    print(\"data['lon'].values = \", data['lon'].values)\n    x, y = m(data['lon'].values, data['lat'].values)\n    print(\"x = \", x)\n\n    # Define your custom function to map data values to colors\n    def map_value_to_color(value):\n        # Iterate through the value ranges to find the appropriate color index\n        for i, range_max in enumerate(value_ranges):\n            if value <= range_max:\n                return colors[i]\n        \n        # If the value is greater than the largest range, return the last color\n        return colors[-1]\n\n    # Map predicted_swe values to colors using the custom function\n    color_mapping = [map_value_to_color(value) for value in data['aspect']]\n    \n    # Plot the data using the custom colormap\n    plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\n    \n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_date = datetime(1900, 1, 1)\n    day_value = day_index\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    timestamp_string = result_date.strftime(\"%Y-%m-%d\")\n    \n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    # Create custom legend elements using the same colormap\n    legend_elements = [Patch(color=colors[i], label=f\"{value_ranges[i]} - {value_ranges[i+1]-1}\" if i < len(value_ranges) - 1 else f\"> {value_ranges[-1]}\") for i in range(len(value_ranges))]\n\n    # Create the legend outside the map\n    legend = plt.legend(handles=legend_elements, loc='upper left', title='Legend', fontsize=8)\n    legend.set_bbox_to_anchor((1.01, 1)) \n\n    # Remove the color bar\n    #plt.colorbar().remove()\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Set the aspect ratio to 'equal' to keep the plot at the center\n    plt.gca().set_aspect('equal', adjustable='box')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15, right=0.80)  # Adjust right margin to accommodate the legend\n    # Show the plot or save it to a file\n    new_plot_path = f'/home/chetana/gridmet_test_run/predicted_swe-{test_start_date}.png'\n    print(f\"The new plot is saved to {new_plot_path}\")\n    plt.savefig(new_plot_path)\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "/home/chetana/gw-workspace/IZLWQzKYzGRT/convert_results_to_images.py:74: UserWarning: No data for colormapping provided via 'c'. Parameters 'cmap' will be ignored\n  plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\ntoday date = 2023-09-23\ntest start date:  2022-08-21\ntest end date:  2023-09-23\n/home/chetana\n      date   lat      lon  SWE  ...  aspect  eastness  northness  predicted_swe\n0  44792.0  49.0 -125.000  0.0  ...    -1.0      -1.0       -1.0            0.0\n1  44792.0  49.0 -124.964  0.0  ...    -1.0      -1.0       -1.0            0.0\n2  44792.0  49.0 -124.928  0.0  ...    -1.0      -1.0       -1.0            0.0\n3  44792.0  49.0 -124.892  0.0  ...    -1.0      -1.0       -1.0            0.0\n4  44792.0  49.0 -124.856  0.0  ...    -1.0      -1.0       -1.0            0.0\n[5 rows x 20 columns]\ncount    462204.0\nmean          0.0\nstd           0.0\nmin           0.0\n25%           0.0\n50%           0.0\n75%           0.0\nmax           0.0\nName: predicted_swe, dtype: float64\ndata['lon'].values =  [-125.    -124.964 -124.928 ... -100.124 -100.088 -100.052]\nx =  [      0.            4003.01547425    8006.0309485  ... 2766083.69270573\n 2770086.70817998 2774089.72365423]\nThe new plot is saved to /home/chetana/gridmet_test_run/predicted_swe-2022-08-21.png\n",
  "history_begin_time" : 1695479214963,
  "history_end_time" : 1695479224835,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "nuldofer4eo",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport uuid\nfrom snowcast_utils import day_index\nimport matplotlib.colors as mcolors\nfrom matplotlib.patches import Patch\nfrom snowcast_utils import day_index, work_dir, test_start_date\n\n# Define the custom colormap with specified colors and ranges\ncolors = [\n    (0.8627, 0.8627, 0.8627),  # #DCDCDC - 0 - 1\n    (0.8627, 1.0000, 1.0000),  # #DCFFFF - 1 - 2\n    (0.6000, 1.0000, 1.0000),  # #99FFFF - 2 - 4\n    (0.5569, 0.8235, 1.0000),  # #8ED2FF - 4 - 6\n    (0.4509, 0.6196, 0.8745),  # #739EDF - 6 - 8\n    (0.4157, 0.4706, 1.0000),  # #6A78FF - 8 - 10\n    (0.4235, 0.2784, 1.0000),  # #6C47FF - 10 - 12\n    (0.5529, 0.0980, 1.0000),  # #8D19FF - 12 - 14\n    (0.7333, 0.0000, 0.9176),  # #BB00EA - 14 - 16\n    (0.8392, 0.0000, 0.7490),  # #D600BF - 16 - 18\n    (0.7569, 0.0039, 0.4549),  # #C10074 - 18 - 20\n    (0.6784, 0.0000, 0.1961),  # #AD0032 - 20 - 30\n    (0.5020, 0.0000, 0.0000)   # #800000 - > 30\n]\n\ncmap_name = 'custom_snow_colormap'\ncustom_cmap = mcolors.ListedColormap(colors)\n\n# Define the lat_lon_to_map_coordinates function\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\n# Define your value ranges for color mapping\nvalue_ranges = [1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 30]\n\ndef convert_csvs_to_images():\n    data = pd.read_csv(\"/home/chetana/gridmet_test_run/test_data_predicted.csv\")\n    print(data.head())\n    data['predicted_swe'].fillna(0, inplace=True)\n    data['predicted_swe'] = data['predicted_swe'].apply(lambda x: 0 if x < 2 else x)\n    print(data['predicted_swe'].describe())\n    \n    # Create a figure with a white background\n    fig = plt.figure(facecolor='white')\n\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    print(\"data['lon'].values = \", data['lon'].values)\n    x, y = m(data['lon'].values, data['lat'].values)\n    print(\"x = \", x)\n\n    # Define your custom function to map data values to colors\n    def map_value_to_color(value):\n        # Iterate through the value ranges to find the appropriate color index\n        for i, range_max in enumerate(value_ranges):\n            if value <= range_max:\n                return colors[i]\n        \n        # If the value is greater than the largest range, return the last color\n        return colors[-1]\n\n    # Map predicted_swe values to colors using the custom function\n    color_mapping = [map_value_to_color(value) for value in data['predicted_swe']]\n    \n    # Plot the data using the custom colormap\n    plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\n    \n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_date = datetime(1900, 1, 1)\n    day_value = day_index\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    timestamp_string = result_date.strftime(\"%Y-%m-%d\")\n    \n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    # Create custom legend elements using the same colormap\n    legend_elements = [Patch(color=colors[i], label=f\"{value_ranges[i]} - {value_ranges[i+1]-1}\" if i < len(value_ranges) - 1 else f\"> {value_ranges[-1]}\") for i in range(len(value_ranges))]\n\n    # Create the legend outside the map\n    legend = plt.legend(handles=legend_elements, loc='upper left', title='Legend', fontsize=8)\n    legend.set_bbox_to_anchor((1.01, 1)) \n\n    # Remove the color bar\n    #plt.colorbar().remove()\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Set the aspect ratio to 'equal' to keep the plot at the center\n    plt.gca().set_aspect('equal', adjustable='box')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15, right=0.80)  # Adjust right margin to accommodate the legend\n    # Show the plot or save it to a file\n    new_plot_path = f'/home/chetana/gridmet_test_run/predicted_swe-{test_start_date}.png'\n    print(f\"The new plot is saved to {new_plot_path}\")\n    plt.savefig(new_plot_path)\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "/home/chetana/gw-workspace/nuldofer4eo/convert_results_to_images.py:74: UserWarning: No data for colormapping provided via 'c'. Parameters 'cmap' will be ignored\n  plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\ntoday date = 2023-09-22\ntest start date:  2022-08-21\ntest end date:  2023-09-22\n/home/chetana\n      date   lat      lon  SWE  ...  aspect  eastness  northness  predicted_swe\n0  44792.0  49.0 -125.000  0.0  ...    -1.0      -1.0       -1.0            0.0\n1  44792.0  49.0 -124.964  0.0  ...    -1.0      -1.0       -1.0            0.0\n2  44792.0  49.0 -124.928  0.0  ...    -1.0      -1.0       -1.0            0.0\n3  44792.0  49.0 -124.892  0.0  ...    -1.0      -1.0       -1.0            0.0\n4  44792.0  49.0 -124.856  0.0  ...    -1.0      -1.0       -1.0            0.0\n[5 rows x 20 columns]\ncount    462204.0\nmean          0.0\nstd           0.0\nmin           0.0\n25%           0.0\n50%           0.0\n75%           0.0\nmax           0.0\nName: predicted_swe, dtype: float64\ndata['lon'].values =  [-125.    -124.964 -124.928 ... -100.124 -100.088 -100.052]\nx =  [      0.            4003.01547425    8006.0309485  ... 2766083.69270573\n 2770086.70817998 2774089.72365423]\nThe new plot is saved to /home/chetana/gridmet_test_run/predicted_swe-2022-08-21.png\n",
  "history_begin_time" : 1695418919904,
  "history_end_time" : 1695418930422,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "100001",
  "indicator" : "Done"
},{
  "history_id" : "8bh3cqh20pf",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport uuid\nfrom snowcast_utils import day_index\nimport matplotlib.colors as mcolors\nfrom matplotlib.patches import Patch\nfrom snowcast_utils import day_index, work_dir, test_start_date\n\n# Define the custom colormap with specified colors and ranges\ncolors = [\n    (0.8627, 0.8627, 0.8627),  # #DCDCDC - 0 - 1\n    (0.8627, 1.0000, 1.0000),  # #DCFFFF - 1 - 2\n    (0.6000, 1.0000, 1.0000),  # #99FFFF - 2 - 4\n    (0.5569, 0.8235, 1.0000),  # #8ED2FF - 4 - 6\n    (0.4509, 0.6196, 0.8745),  # #739EDF - 6 - 8\n    (0.4157, 0.4706, 1.0000),  # #6A78FF - 8 - 10\n    (0.4235, 0.2784, 1.0000),  # #6C47FF - 10 - 12\n    (0.5529, 0.0980, 1.0000),  # #8D19FF - 12 - 14\n    (0.7333, 0.0000, 0.9176),  # #BB00EA - 14 - 16\n    (0.8392, 0.0000, 0.7490),  # #D600BF - 16 - 18\n    (0.7569, 0.0039, 0.4549),  # #C10074 - 18 - 20\n    (0.6784, 0.0000, 0.1961),  # #AD0032 - 20 - 30\n    (0.5020, 0.0000, 0.0000)   # #800000 - > 30\n]\n\ncmap_name = 'custom_snow_colormap'\ncustom_cmap = mcolors.ListedColormap(colors)\n\n# Define the lat_lon_to_map_coordinates function\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\n# Define your value ranges for color mapping\nvalue_ranges = [1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 30]\n\ndef convert_csvs_to_images():\n    data = pd.read_csv(\"/home/chetana/gridmet_test_run/test_data_predicted.csv\")\n    print(data.head())\n    data['predicted_swe'].fillna(0, inplace=True)\n    data['predicted_swe'] = data['predicted_swe'].apply(lambda x: 0 if x < 2 else x)\n    print(data['predicted_swe'].describe())\n    \n    # Create a figure with a white background\n    fig = plt.figure(facecolor='white')\n\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    print(\"data['lon'].values = \", data['lon'].values)\n    x, y = m(data['lon'].values, data['lat'].values)\n    print(\"x = \", x)\n\n    # Define your custom function to map data values to colors\n    def map_value_to_color(value):\n        # Iterate through the value ranges to find the appropriate color index\n        for i, range_max in enumerate(value_ranges):\n            if value <= range_max:\n                return colors[i]\n        \n        # If the value is greater than the largest range, return the last color\n        return colors[-1]\n\n    # Map predicted_swe values to colors using the custom function\n    color_mapping = [map_value_to_color(value) for value in data['predicted_swe']]\n    \n    # Plot the data using the custom colormap\n    plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\n    \n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_date = datetime(1900, 1, 1)\n    day_value = day_index\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    timestamp_string = result_date.strftime(\"%Y-%m-%d\")\n    \n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    # Create custom legend elements using the same colormap\n    legend_elements = [Patch(color=colors[i], label=f\"{value_ranges[i]} - {value_ranges[i+1]-1}\" if i < len(value_ranges) - 1 else f\"> {value_ranges[-1]}\") for i in range(len(value_ranges))]\n\n    # Create the legend outside the map\n    legend = plt.legend(handles=legend_elements, loc='upper left', title='Legend', fontsize=8)\n    legend.set_bbox_to_anchor((1.01, 1)) \n\n    # Remove the color bar\n    #plt.colorbar().remove()\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Set the aspect ratio to 'equal' to keep the plot at the center\n    plt.gca().set_aspect('equal', adjustable='box')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15, right=0.80)  # Adjust right margin to accommodate the legend\n    # Show the plot or save it to a file\n    new_plot_path = f'/home/chetana/gridmet_test_run/predicted_swe-{test_start_date}.png'\n    print(f\"The new plot is saved to {new_plot_path}\")\n    plt.savefig(new_plot_path)\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "/home/chetana/gw-workspace/8bh3cqh20pf/convert_results_to_images.py:74: UserWarning: No data for colormapping provided via 'c'. Parameters 'cmap' will be ignored\n  plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\ntoday date = 2023-09-22\ntest start date:  2022-03-21\ntest end date:  2023-09-22\n/home/chetana\n      date   lat      lon  SWE  ...  aspect  eastness  northness  predicted_swe\n0  44639.0  49.0 -125.000  0.0  ...    -1.0      -1.0       -1.0            0.0\n1  44639.0  49.0 -124.964  0.0  ...    -1.0      -1.0       -1.0            0.0\n2  44639.0  49.0 -124.928  0.0  ...    -1.0      -1.0       -1.0            0.0\n3  44639.0  49.0 -124.892  0.0  ...    -1.0      -1.0       -1.0            0.0\n4  44639.0  49.0 -124.856  0.0  ...    -1.0      -1.0       -1.0            0.0\n[5 rows x 20 columns]\ncount    462204.000000\nmean          1.806689\nstd           3.602613\nmin           0.000000\n25%           0.000000\n50%           0.000000\n75%           0.000000\nmax          10.265000\nName: predicted_swe, dtype: float64\ndata['lon'].values =  [-125.    -124.964 -124.928 ... -100.124 -100.088 -100.052]\nx =  [      0.            4003.01547425    8006.0309485  ... 2766083.69270573\n 2770086.70817998 2774089.72365423]\nThe new plot is saved to /home/chetana/gridmet_test_run/predicted_swe-2022-03-21.png\n",
  "history_begin_time" : 1695417795246,
  "history_end_time" : 1695417805677,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "100001",
  "indicator" : "Done"
},{
  "history_id" : "du4e2dghs53",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport uuid\nfrom snowcast_utils import day_index\nimport matplotlib.colors as mcolors\nfrom matplotlib.patches import Patch\nfrom snowcast_utils import day_index, work_dir, test_start_date\n\n# Define the custom colormap with specified colors and ranges\ncolors = [\n    (0.8627, 0.8627, 0.8627),  # #DCDCDC - 0 - 1\n    (0.8627, 1.0000, 1.0000),  # #DCFFFF - 1 - 2\n    (0.6000, 1.0000, 1.0000),  # #99FFFF - 2 - 4\n    (0.5569, 0.8235, 1.0000),  # #8ED2FF - 4 - 6\n    (0.4509, 0.6196, 0.8745),  # #739EDF - 6 - 8\n    (0.4157, 0.4706, 1.0000),  # #6A78FF - 8 - 10\n    (0.4235, 0.2784, 1.0000),  # #6C47FF - 10 - 12\n    (0.5529, 0.0980, 1.0000),  # #8D19FF - 12 - 14\n    (0.7333, 0.0000, 0.9176),  # #BB00EA - 14 - 16\n    (0.8392, 0.0000, 0.7490),  # #D600BF - 16 - 18\n    (0.7569, 0.0039, 0.4549),  # #C10074 - 18 - 20\n    (0.6784, 0.0000, 0.1961),  # #AD0032 - 20 - 30\n    (0.5020, 0.0000, 0.0000)   # #800000 - > 30\n]\n\ncmap_name = 'custom_snow_colormap'\ncustom_cmap = mcolors.ListedColormap(colors)\n\n# Define the lat_lon_to_map_coordinates function\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\n# Define your value ranges for color mapping\nvalue_ranges = [1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 30]\n\ndef convert_csvs_to_images():\n    data = pd.read_csv(\"/home/chetana/gridmet_test_run/test_data_predicted.csv\")\n    print(data.head())\n    data['predicted_swe'].fillna(0, inplace=True)\n    data['predicted_swe'] = data['predicted_swe'].apply(lambda x: 0 if x < 2 else x)\n    print(data['predicted_swe'].describe())\n    \n    # Create a figure with a white background\n    fig = plt.figure(facecolor='white')\n\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    print(\"data['lon'].values = \", data['lon'].values)\n    x, y = m(data['lon'].values, data['lat'].values)\n    print(\"x = \", x)\n\n    # Define your custom function to map data values to colors\n    def map_value_to_color(value):\n        # Iterate through the value ranges to find the appropriate color index\n        for i, range_max in enumerate(value_ranges):\n            if value <= range_max:\n                return colors[i]\n        \n        # If the value is greater than the largest range, return the last color\n        return colors[-1]\n\n    # Map predicted_swe values to colors using the custom function\n    color_mapping = [map_value_to_color(value) for value in data['predicted_swe']]\n    \n    # Plot the data using the custom colormap\n    plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\n    \n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_date = datetime(1900, 1, 1)\n    day_value = day_index\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    timestamp_string = result_date.strftime(\"%Y-%m-%d\")\n    \n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    # Create custom legend elements using the same colormap\n    legend_elements = [Patch(color=colors[i], label=f\"{value_ranges[i]} - {value_ranges[i+1]-1}\" if i < len(value_ranges) - 1 else f\"> {value_ranges[-1]}\") for i in range(len(value_ranges))]\n\n    # Create the legend outside the map\n    legend = plt.legend(handles=legend_elements, loc='upper left', title='Legend', fontsize=8)\n    legend.set_bbox_to_anchor((1.01, 1)) \n\n    # Remove the color bar\n    #plt.colorbar().remove()\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Set the aspect ratio to 'equal' to keep the plot at the center\n    plt.gca().set_aspect('equal', adjustable='box')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15, right=0.80)  # Adjust right margin to accommodate the legend\n    # Show the plot or save it to a file\n    new_plot_path = f'/home/chetana/gridmet_test_run/predicted_swe-{test_start_date}.png'\n    print(f\"The new plot is saved to {new_plot_path}\")\n    plt.savefig(new_plot_path)\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "/home/chetana/gw-workspace/du4e2dghs53/convert_results_to_images.py:74: UserWarning: No data for colormapping provided via 'c'. Parameters 'cmap' will be ignored\n  plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\ntoday date = 2023-09-22\ntest start date:  2022-03-20\ntest end date:  2023-09-22\n/home/chetana\n      date   lat      lon  SWE  ...  aspect  eastness  northness  predicted_swe\n0  44638.0  49.0 -125.000  0.0  ...    -1.0      -1.0       -1.0            0.0\n1  44638.0  49.0 -124.964  0.0  ...    -1.0      -1.0       -1.0            0.0\n2  44638.0  49.0 -124.928  0.0  ...    -1.0      -1.0       -1.0            0.0\n3  44638.0  49.0 -124.892  0.0  ...    -1.0      -1.0       -1.0            0.0\n4  44638.0  49.0 -124.856  0.0  ...    -1.0      -1.0       -1.0            0.0\n[5 rows x 20 columns]\ncount    462204.000000\nmean          1.207054\nstd           3.142981\nmin           0.000000\n25%           0.000000\n50%           0.000000\n75%           0.000000\nmax          10.235000\nName: predicted_swe, dtype: float64\ndata['lon'].values =  [-125.    -124.964 -124.928 ... -100.124 -100.088 -100.052]\nx =  [      0.            4003.01547425    8006.0309485  ... 2766083.69270573\n 2770086.70817998 2774089.72365423]\nThe new plot is saved to /home/chetana/gridmet_test_run/predicted_swe-2022-03-20.png\n",
  "history_begin_time" : 1695417379080,
  "history_end_time" : 1695417389684,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "100001",
  "indicator" : "Done"
},{
  "history_id" : "c8chgobwssz",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport uuid\nfrom snowcast_utils import day_index\nimport matplotlib.colors as mcolors\nfrom matplotlib.patches import Patch\nfrom snowcast_utils import day_index, work_dir, test_start_date\n\n# Define the custom colormap with specified colors and ranges\ncolors = [\n    (0.8627, 0.8627, 0.8627),  # #DCDCDC - 0 - 1\n    (0.8627, 1.0000, 1.0000),  # #DCFFFF - 1 - 2\n    (0.6000, 1.0000, 1.0000),  # #99FFFF - 2 - 4\n    (0.5569, 0.8235, 1.0000),  # #8ED2FF - 4 - 6\n    (0.4509, 0.6196, 0.8745),  # #739EDF - 6 - 8\n    (0.4157, 0.4706, 1.0000),  # #6A78FF - 8 - 10\n    (0.4235, 0.2784, 1.0000),  # #6C47FF - 10 - 12\n    (0.5529, 0.0980, 1.0000),  # #8D19FF - 12 - 14\n    (0.7333, 0.0000, 0.9176),  # #BB00EA - 14 - 16\n    (0.8392, 0.0000, 0.7490),  # #D600BF - 16 - 18\n    (0.7569, 0.0039, 0.4549),  # #C10074 - 18 - 20\n    (0.6784, 0.0000, 0.1961),  # #AD0032 - 20 - 30\n    (0.5020, 0.0000, 0.0000)   # #800000 - > 30\n]\n\ncmap_name = 'custom_snow_colormap'\ncustom_cmap = mcolors.ListedColormap(colors)\n\n# Define the lat_lon_to_map_coordinates function\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\n# Define your value ranges for color mapping\nvalue_ranges = [1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 30]\n\ndef convert_csvs_to_images():\n    data = pd.read_csv(\"/home/chetana/gridmet_test_run/test_data_predicted.csv\")\n    print(data.head())\n    data['predicted_swe'].fillna(0, inplace=True)\n    data['predicted_swe'] = data['predicted_swe'].apply(lambda x: 0 if x < 2 else x)\n    print(data['predicted_swe'].describe())\n    \n    # Create a figure with a white background\n    fig = plt.figure(facecolor='white')\n\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    print(\"data['lon'].values = \", data['lon'].values)\n    x, y = m(data['lon'].values, data['lat'].values)\n    print(\"x = \", x)\n\n    # Define your custom function to map data values to colors\n    def map_value_to_color(value):\n        # Iterate through the value ranges to find the appropriate color index\n        for i, range_max in enumerate(value_ranges):\n            if value <= range_max:\n                return colors[i]\n        \n        # If the value is greater than the largest range, return the last color\n        return colors[-1]\n\n    # Map predicted_swe values to colors using the custom function\n    color_mapping = [map_value_to_color(value) for value in data['predicted_swe']]\n    \n    # Plot the data using the custom colormap\n    plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\n    \n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_date = datetime(1900, 1, 1)\n    day_value = day_index\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    timestamp_string = result_date.strftime(\"%Y-%m-%d\")\n    \n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    # Create custom legend elements using the same colormap\n    legend_elements = [Patch(color=colors[i], label=f\"{value_ranges[i]} - {value_ranges[i+1]-1}\" if i < len(value_ranges) - 1 else f\"> {value_ranges[-1]}\") for i in range(len(value_ranges))]\n\n    # Create the legend outside the map\n    legend = plt.legend(handles=legend_elements, loc='upper left', title='Legend', fontsize=8)\n    legend.set_bbox_to_anchor((1.01, 1)) \n\n    # Remove the color bar\n    #plt.colorbar().remove()\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Set the aspect ratio to 'equal' to keep the plot at the center\n    plt.gca().set_aspect('equal', adjustable='box')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15, right=0.80)  # Adjust right margin to accommodate the legend\n    # Show the plot or save it to a file\n    new_plot_path = f'/home/chetana/gridmet_test_run/predicted_swe-{test_start_date}.png'\n    print(f\"The new plot is saved to {new_plot_path}\")\n    plt.savefig(new_plot_path)\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "today date = 2023-09-22\ntest start date:  2022-03-20\ntest end date:  2023-09-22\n/home/chetana\nTraceback (most recent call last):\n  File \"/home/chetana/gw-workspace/c8chgobwssz/convert_results_to_images.py\", line 139, in <module>\n    convert_csvs_to_images()\n  File \"/home/chetana/gw-workspace/c8chgobwssz/convert_results_to_images.py\", line 41, in convert_csvs_to_images\n    data = pd.read_csv(\"/home/chetana/gridmet_test_run/test_data_predicted.csv\")\n  File \"/home/chetana/anaconda3/lib/python3.9/site-packages/pandas/util/_decorators.py\", line 211, in wrapper\n    return func(*args, **kwargs)\n  File \"/home/chetana/anaconda3/lib/python3.9/site-packages/pandas/util/_decorators.py\", line 331, in wrapper\n    return func(*args, **kwargs)\n  File \"/home/chetana/anaconda3/lib/python3.9/site-packages/pandas/io/parsers/readers.py\", line 950, in read_csv\n    return _read(filepath_or_buffer, kwds)\n  File \"/home/chetana/anaconda3/lib/python3.9/site-packages/pandas/io/parsers/readers.py\", line 605, in _read\n    parser = TextFileReader(filepath_or_buffer, **kwds)\n  File \"/home/chetana/anaconda3/lib/python3.9/site-packages/pandas/io/parsers/readers.py\", line 1442, in __init__\n    self._engine = self._make_engine(f, self.engine)\n  File \"/home/chetana/anaconda3/lib/python3.9/site-packages/pandas/io/parsers/readers.py\", line 1735, in _make_engine\n    self.handles = get_handle(\n  File \"/home/chetana/anaconda3/lib/python3.9/site-packages/pandas/io/common.py\", line 856, in get_handle\n    handle = open(\nFileNotFoundError: [Errno 2] No such file or directory: '/home/chetana/gridmet_test_run/test_data_predicted.csv'\n",
  "history_begin_time" : 1695417090692,
  "history_end_time" : 1695417093127,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "100001",
  "indicator" : "Failed"
},{
  "history_id" : "o8g3v8c412n",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport uuid\nfrom snowcast_utils import day_index\nimport matplotlib.colors as mcolors\nfrom matplotlib.patches import Patch\nfrom snowcast_utils import day_index, work_dir, test_start_date\n\n# Define the custom colormap with specified colors and ranges\ncolors = [\n    (0.8627, 0.8627, 0.8627),  # #DCDCDC - 0 - 1\n    (0.8627, 1.0000, 1.0000),  # #DCFFFF - 1 - 2\n    (0.6000, 1.0000, 1.0000),  # #99FFFF - 2 - 4\n    (0.5569, 0.8235, 1.0000),  # #8ED2FF - 4 - 6\n    (0.4509, 0.6196, 0.8745),  # #739EDF - 6 - 8\n    (0.4157, 0.4706, 1.0000),  # #6A78FF - 8 - 10\n    (0.4235, 0.2784, 1.0000),  # #6C47FF - 10 - 12\n    (0.5529, 0.0980, 1.0000),  # #8D19FF - 12 - 14\n    (0.7333, 0.0000, 0.9176),  # #BB00EA - 14 - 16\n    (0.8392, 0.0000, 0.7490),  # #D600BF - 16 - 18\n    (0.7569, 0.0039, 0.4549),  # #C10074 - 18 - 20\n    (0.6784, 0.0000, 0.1961),  # #AD0032 - 20 - 30\n    (0.5020, 0.0000, 0.0000)   # #800000 - > 30\n]\n\ncmap_name = 'custom_snow_colormap'\ncustom_cmap = mcolors.ListedColormap(colors)\n\n# Define the lat_lon_to_map_coordinates function\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\n# Define your value ranges for color mapping\nvalue_ranges = [1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 30]\n\ndef convert_csvs_to_images():\n    data = pd.read_csv(\"/home/chetana/gridmet_test_run/test_data_predicted.csv\")\n    print(data.head())\n    data['predicted_swe'].fillna(0, inplace=True)\n    data['predicted_swe'] = data['predicted_swe'].apply(lambda x: 0 if x < 2 else x)\n    print(data['predicted_swe'].describe())\n    \n    # Create a figure with a white background\n    fig = plt.figure(facecolor='white')\n\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    print(\"data['lon'].values = \", data['lon'].values)\n    x, y = m(data['lon'].values, data['lat'].values)\n    print(\"x = \", x)\n\n    # Define your custom function to map data values to colors\n    def map_value_to_color(value):\n        # Iterate through the value ranges to find the appropriate color index\n        for i, range_max in enumerate(value_ranges):\n            if value <= range_max:\n                return colors[i]\n        \n        # If the value is greater than the largest range, return the last color\n        return colors[-1]\n\n    # Map predicted_swe values to colors using the custom function\n    color_mapping = [map_value_to_color(value) for value in data['predicted_swe']]\n    \n    # Plot the data using the custom colormap\n    plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\n    \n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_date = datetime(1900, 1, 1)\n    day_value = day_index\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    timestamp_string = result_date.strftime(\"%Y-%m-%d\")\n    \n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    # Create custom legend elements using the same colormap\n    legend_elements = [Patch(color=colors[i], label=f\"{value_ranges[i]} - {value_ranges[i+1]-1}\" if i < len(value_ranges) - 1 else f\"> {value_ranges[-1]}\") for i in range(len(value_ranges))]\n\n    # Create the legend outside the map\n    legend = plt.legend(handles=legend_elements, loc='upper left', title='Legend', fontsize=8)\n    legend.set_bbox_to_anchor((1.01, 1)) \n\n    # Remove the color bar\n    #plt.colorbar().remove()\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Set the aspect ratio to 'equal' to keep the plot at the center\n    plt.gca().set_aspect('equal', adjustable='box')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15, right=0.80)  # Adjust right margin to accommodate the legend\n    # Show the plot or save it to a file\n    new_plot_path = f'/home/chetana/gridmet_test_run/predicted_swe-{test_start_date}.png'\n    print(f\"The new plot is saved to {new_plot_path}\")\n    plt.savefig(new_plot_path)\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "/home/chetana/gw-workspace/o8g3v8c412n/convert_results_to_images.py:74: UserWarning: No data for colormapping provided via 'c'. Parameters 'cmap' will be ignored\n  plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\ntoday date = 2023-09-22\ntest start date:  2022-03-19\ntest end date:  2023-09-22\n/home/chetana\n      date   lat      lon  SWE  ...  aspect  eastness  northness  predicted_swe\n0  44637.0  49.0 -125.000  0.0  ...    -1.0      -1.0       -1.0            0.0\n1  44637.0  49.0 -124.964  0.0  ...    -1.0      -1.0       -1.0            0.0\n2  44637.0  49.0 -124.928  0.0  ...    -1.0      -1.0       -1.0            0.0\n3  44637.0  49.0 -124.892  0.0  ...    -1.0      -1.0       -1.0            0.0\n4  44637.0  49.0 -124.856  0.0  ...    -1.0      -1.0       -1.0            0.0\n[5 rows x 20 columns]\ncount    462204.000000\nmean          1.482221\nstd           3.219268\nmin           0.000000\n25%           0.000000\n50%           0.000000\n75%           0.000000\nmax          10.387000\nName: predicted_swe, dtype: float64\ndata['lon'].values =  [-125.    -124.964 -124.928 ... -100.124 -100.088 -100.052]\nx =  [      0.            4003.01547425    8006.0309485  ... 2766083.69270573\n 2770086.70817998 2774089.72365423]\nThe new plot is saved to /home/chetana/gridmet_test_run/predicted_swe-2022-03-19.png\n",
  "history_begin_time" : 1695417004879,
  "history_end_time" : 1695417015730,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "100001",
  "indicator" : "Done"
},{
  "history_id" : "UrvQAodhpw9y",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport uuid\nfrom snowcast_utils import day_index\nimport matplotlib.colors as mcolors\nfrom matplotlib.patches import Patch\nfrom snowcast_utils import day_index, work_dir, test_start_date\n\n# Define the custom colormap with specified colors and ranges\ncolors = [\n    (0.8627, 0.8627, 0.8627),  # #DCDCDC - 0 - 1\n    (0.8627, 1.0000, 1.0000),  # #DCFFFF - 1 - 2\n    (0.6000, 1.0000, 1.0000),  # #99FFFF - 2 - 4\n    (0.5569, 0.8235, 1.0000),  # #8ED2FF - 4 - 6\n    (0.4509, 0.6196, 0.8745),  # #739EDF - 6 - 8\n    (0.4157, 0.4706, 1.0000),  # #6A78FF - 8 - 10\n    (0.4235, 0.2784, 1.0000),  # #6C47FF - 10 - 12\n    (0.5529, 0.0980, 1.0000),  # #8D19FF - 12 - 14\n    (0.7333, 0.0000, 0.9176),  # #BB00EA - 14 - 16\n    (0.8392, 0.0000, 0.7490),  # #D600BF - 16 - 18\n    (0.7569, 0.0039, 0.4549),  # #C10074 - 18 - 20\n    (0.6784, 0.0000, 0.1961),  # #AD0032 - 20 - 30\n    (0.5020, 0.0000, 0.0000)   # #800000 - > 30\n]\n\ncmap_name = 'custom_snow_colormap'\ncustom_cmap = mcolors.ListedColormap(colors)\n\n# Define the lat_lon_to_map_coordinates function\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\n# Define your value ranges for color mapping\nvalue_ranges = [1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 30]\n\ndef convert_csvs_to_images():\n    data = pd.read_csv(\"/home/chetana/gridmet_test_run/test_data_predicted.csv\")\n    print(data.head())\n    data['predicted_swe'].fillna(0, inplace=True)\n    data['predicted_swe'] = data['predicted_swe'].apply(lambda x: 0 if x < 2 else x)\n    print(data['predicted_swe'].describe())\n    \n    # Create a figure with a white background\n    fig = plt.figure(facecolor='white')\n\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    print(\"data['lon'].values = \", data['lon'].values)\n    x, y = m(data['lon'].values, data['lat'].values)\n    print(\"x = \", x)\n\n    # Define your custom function to map data values to colors\n    def map_value_to_color(value):\n        # Iterate through the value ranges to find the appropriate color index\n        for i, range_max in enumerate(value_ranges):\n            if value <= range_max:\n                return colors[i]\n        \n        # If the value is greater than the largest range, return the last color\n        return colors[-1]\n\n    # Map predicted_swe values to colors using the custom function\n    color_mapping = [map_value_to_color(value) for value in data['predicted_swe']]\n    \n    # Plot the data using the custom colormap\n    plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\n    \n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_date = datetime(1900, 1, 1)\n    day_value = day_index\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    timestamp_string = result_date.strftime(\"%Y-%m-%d\")\n    \n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    # Create custom legend elements using the same colormap\n    legend_elements = [Patch(color=colors[i], label=f\"{value_ranges[i]} - {value_ranges[i+1]-1}\" if i < len(value_ranges) - 1 else f\"> {value_ranges[-1]}\") for i in range(len(value_ranges))]\n\n    # Create the legend outside the map\n    legend = plt.legend(handles=legend_elements, loc='upper left', title='Legend', fontsize=8)\n    legend.set_bbox_to_anchor((1.01, 1)) \n\n    # Remove the color bar\n    #plt.colorbar().remove()\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Set the aspect ratio to 'equal' to keep the plot at the center\n    plt.gca().set_aspect('equal', adjustable='box')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15, right=0.80)  # Adjust right margin to accommodate the legend\n    # Show the plot or save it to a file\n    new_plot_path = f'/home/chetana/gridmet_test_run/predicted_swe-{test_start_date}.png'\n    print(f\"The new plot is saved to {new_plot_path}\")\n    plt.savefig(new_plot_path)\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "/home/chetana/gw-workspace/UrvQAodhpw9y/convert_results_to_images.py:74: UserWarning: No data for colormapping provided via 'c'. Parameters 'cmap' will be ignored\n  plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\ntoday date = 2023-09-20\ntest start date:  2022-03-19\ntest end date:  2023-09-20\n/home/chetana\n      date   lat      lon  SWE  ...  aspect  eastness  northness  predicted_swe\n0  44636.0  49.0 -125.000  0.0  ...    -1.0      -1.0       -1.0            0.0\n1  44636.0  49.0 -124.964  0.0  ...    -1.0      -1.0       -1.0            0.0\n2  44636.0  49.0 -124.928  0.0  ...    -1.0      -1.0       -1.0            0.0\n3  44636.0  49.0 -124.892  0.0  ...    -1.0      -1.0       -1.0            0.0\n4  44636.0  49.0 -124.856  0.0  ...    -1.0      -1.0       -1.0            0.0\n[5 rows x 20 columns]\ncount    462204.000000\nmean          1.640329\nstd           3.489648\nmin           0.000000\n25%           0.000000\n50%           0.000000\n75%           0.000000\nmax          10.618000\nName: predicted_swe, dtype: float64\ndata['lon'].values =  [-125.    -124.964 -124.928 ... -100.124 -100.088 -100.052]\nx =  [      0.            4003.01547425    8006.0309485  ... 2766083.69270573\n 2770086.70817998 2774089.72365423]\nThe new plot is saved to /home/chetana/gridmet_test_run/predicted_swe-2022-03-19.png\n",
  "history_begin_time" : 1695185354018,
  "history_end_time" : 1695185362972,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "d6pW1tpXmAcc",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport uuid\nfrom snowcast_utils import day_index\nimport matplotlib.colors as mcolors\nfrom matplotlib.patches import Patch\nfrom snowcast_utils import day_index, work_dir, test_start_date\n\n# Define the custom colormap with specified colors and ranges\ncolors = [\n    (0.8627, 0.8627, 0.8627),  # #DCDCDC - 0 - 1\n    (0.8627, 1.0000, 1.0000),  # #DCFFFF - 1 - 2\n    (0.6000, 1.0000, 1.0000),  # #99FFFF - 2 - 4\n    (0.5569, 0.8235, 1.0000),  # #8ED2FF - 4 - 6\n    (0.4509, 0.6196, 0.8745),  # #739EDF - 6 - 8\n    (0.4157, 0.4706, 1.0000),  # #6A78FF - 8 - 10\n    (0.4235, 0.2784, 1.0000),  # #6C47FF - 10 - 12\n    (0.5529, 0.0980, 1.0000),  # #8D19FF - 12 - 14\n    (0.7333, 0.0000, 0.9176),  # #BB00EA - 14 - 16\n    (0.8392, 0.0000, 0.7490),  # #D600BF - 16 - 18\n    (0.7569, 0.0039, 0.4549),  # #C10074 - 18 - 20\n    (0.6784, 0.0000, 0.1961),  # #AD0032 - 20 - 30\n    (0.5020, 0.0000, 0.0000)   # #800000 - > 30\n]\n\ncmap_name = 'custom_snow_colormap'\ncustom_cmap = mcolors.ListedColormap(colors)\n\n# Define the lat_lon_to_map_coordinates function\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\n# Define your value ranges for color mapping\nvalue_ranges = [1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 30]\n\ndef convert_csvs_to_images():\n    data = pd.read_csv(\"/home/chetana/gridmet_test_run/test_data_predicted.csv\")\n    print(data.head())\n    data['predicted_swe'].fillna(0, inplace=True)\n    data['predicted_swe'] = data['predicted_swe'].apply(lambda x: 0 if x < 2 else x)\n    print(data['predicted_swe'].describe())\n    \n    # Create a figure with a white background\n    fig = plt.figure(facecolor='white')\n\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    print(\"data['lon'].values = \", data['lon'].values)\n    x, y = m(data['lon'].values, data['lat'].values)\n    print(\"x = \", x)\n    \n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_date = datetime(1900, 1, 1)\n    day_value = day_index\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    timestamp_string = result_date.strftime(\"%Y-%m-%d\")\n    \n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    # Create custom legend elements using the same colormap\n    legend_elements = [Patch(color=colors[i], label=f\"{value_ranges[i]} - {value_ranges[i+1]-1}\" if i < len(value_ranges) - 1 else f\"> {value_ranges[-1]}\") for i in range(len(value_ranges))]\n\n    # Create the legend outside the map\n    legend = plt.legend(handles=legend_elements, loc='upper left', title='Legend', fontsize=8)\n    legend.set_bbox_to_anchor((1.01, 1)) \n\n    # Remove the color bar\n    #plt.colorbar().remove()\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Set the aspect ratio to 'equal' to keep the plot at the center\n    plt.gca().set_aspect('equal', adjustable='box')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15, right=0.80)  # Adjust right margin to accommodate the legend\n    # Show the plot or save it to a file\n    new_plot_path = f'/home/chetana/gridmet_test_run/predicted_swe-{test_start_date}.png'\n    print(f\"The new plot is saved to {new_plot_path}\")\n    plt.savefig(new_plot_path)\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "today date = 2023-09-20\ntest start date:  2022-03-19\ntest end date:  2023-09-20\n/home/chetana\n      date   lat      lon  SWE  ...  aspect  eastness  northness  predicted_swe\n0  44636.0  49.0 -125.000  0.0  ...    -1.0      -1.0       -1.0            0.0\n1  44636.0  49.0 -124.964  0.0  ...    -1.0      -1.0       -1.0            0.0\n2  44636.0  49.0 -124.928  0.0  ...    -1.0      -1.0       -1.0            0.0\n3  44636.0  49.0 -124.892  0.0  ...    -1.0      -1.0       -1.0            0.0\n4  44636.0  49.0 -124.856  0.0  ...    -1.0      -1.0       -1.0            0.0\n[5 rows x 20 columns]\ncount    462204.000000\nmean          1.640329\nstd           3.489648\nmin           0.000000\n25%           0.000000\n50%           0.000000\n75%           0.000000\nmax          10.618000\nName: predicted_swe, dtype: float64\ndata['lon'].values =  [-125.    -124.964 -124.928 ... -100.124 -100.088 -100.052]\nx =  [      0.            4003.01547425    8006.0309485  ... 2766083.69270573\n 2770086.70817998 2774089.72365423]\nThe new plot is saved to /home/chetana/gridmet_test_run/predicted_swe-2022-03-19.png\n",
  "history_begin_time" : 1695185289504,
  "history_end_time" : 1695185293793,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "UiRigfr35h82",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport uuid\nfrom snowcast_utils import day_index\nimport matplotlib.colors as mcolors\nfrom matplotlib.patches import Patch\nfrom snowcast_utils import day_index, work_dir, test_start_date\n\n# Define the custom colormap with specified colors and ranges\ncolors = [\n    (0.8627, 0.8627, 0.8627),  # #DCDCDC - 0 - 1\n    (0.8627, 1.0000, 1.0000),  # #DCFFFF - 1 - 2\n    (0.6000, 1.0000, 1.0000),  # #99FFFF - 2 - 4\n    (0.5569, 0.8235, 1.0000),  # #8ED2FF - 4 - 6\n    (0.4509, 0.6196, 0.8745),  # #739EDF - 6 - 8\n    (0.4157, 0.4706, 1.0000),  # #6A78FF - 8 - 10\n    (0.4235, 0.2784, 1.0000),  # #6C47FF - 10 - 12\n    (0.5529, 0.0980, 1.0000),  # #8D19FF - 12 - 14\n    (0.7333, 0.0000, 0.9176),  # #BB00EA - 14 - 16\n    (0.8392, 0.0000, 0.7490),  # #D600BF - 16 - 18\n    (0.7569, 0.0039, 0.4549),  # #C10074 - 18 - 20\n    (0.6784, 0.0000, 0.1961),  # #AD0032 - 20 - 30\n    (0.5020, 0.0000, 0.0000)   # #800000 - > 30\n]\n\ncmap_name = 'custom_snow_colormap'\ncustom_cmap = mcolors.ListedColormap(colors)\n\n# Define the lat_lon_to_map_coordinates function\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\n# Define your value ranges for color mapping\nvalue_ranges = [1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 30]\n\ndef convert_csvs_to_images():\n    data = pd.read_csv(\"/home/chetana/gridmet_test_run/test_data_predicted.csv\")\n    print(data.head())\n    data['predicted_swe'].fillna(0, inplace=True)\n    data['predicted_swe'] = data['predicted_swe'].apply(lambda x: 0 if x < 2 else x)\n    print(data['predicted_swe'].describe())\n    \n    # Create a figure with a white background\n    fig = plt.figure(facecolor='white')\n\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    print(\"data['lon'].values = \", data['lon'].values)\n    x, y = m(data['lon'].values, data['lat'].values)\n    print(\"x = \", x)\n    \n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_date = datetime(1900, 1, 1)\n    day_value = day_index\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    timestamp_string = result_date.strftime(\"%Y-%m-%d\")\n    \n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    # Create custom legend elements using the same colormap\n    legend_elements = [Patch(color=colors[i], label=f\"{value_ranges[i]} - {value_ranges[i+1]-1}\" if i < len(value_ranges) - 1 else f\"> {value_ranges[-1]}\") for i in range(len(value_ranges))]\n\n    # Create the legend outside the map\n    legend = plt.legend(handles=legend_elements, loc='upper left', title='Legend', fontsize=8)\n    legend.set_bbox_to_anchor((1.01, 1)) \n\n    # Remove the color bar\n    #plt.colorbar().remove()\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Set the aspect ratio to 'equal' to keep the plot at the center\n    plt.gca().set_aspect('equal', adjustable='box')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15, right=0.80)  # Adjust right margin to accommodate the legend\n    # Show the plot or save it to a file\n    new_plot_path = f'/home/chetana/gridmet_test_run/predicted_swe-{test_start_date}.png'\n    print(f\"The new plot is saved to {new_plot_path}\")\n    plt.savefig(new_plot_path)\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "today date = 2023-09-20\ntest start date:  2022-03-19\ntest end date:  2023-09-20\n/home/chetana\n    date   lat      lon  SWE  ...  aspect  eastness  northness  predicted_swe\n0  44636  49.0 -125.000    0  ...    -1.0      -1.0       -1.0          8.429\n1  44636  49.0 -124.964    0  ...    -1.0      -1.0       -1.0          8.429\n2  44636  49.0 -124.928    0  ...    -1.0      -1.0       -1.0          8.429\n3  44636  49.0 -124.892    0  ...    -1.0      -1.0       -1.0          8.429\n4  44636  49.0 -124.856    0  ...    -1.0      -1.0       -1.0          8.429\n[5 rows x 20 columns]\ncount    462204.000000\nmean          8.431052\nstd           1.158904\nmin           4.636000\n25%           7.678000\n50%           8.805000\n75%           9.113000\nmax          10.618000\nName: predicted_swe, dtype: float64\ndata['lon'].values =  [-125.    -124.964 -124.928 ... -100.124 -100.088 -100.052]\nx =  [      0.            4003.01547425    8006.0309485  ... 2766083.69270573\n 2770086.70817998 2774089.72365423]\nThe new plot is saved to /home/chetana/gridmet_test_run/predicted_swe-2022-03-19.png\n",
  "history_begin_time" : 1695183315803,
  "history_end_time" : 1695183320107,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "D1bddaQB8NdY",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport uuid\nfrom snowcast_utils import day_index\nimport matplotlib.colors as mcolors\nfrom matplotlib.patches import Patch\nfrom snowcast_utils import day_index, work_dir, test_start_date\n\n# Define the custom colormap with specified colors and ranges\ncolors = [\n    (0.8627, 0.8627, 0.8627),  # #DCDCDC - 0 - 1\n    (0.8627, 1.0000, 1.0000),  # #DCFFFF - 1 - 2\n    (0.6000, 1.0000, 1.0000),  # #99FFFF - 2 - 4\n    (0.5569, 0.8235, 1.0000),  # #8ED2FF - 4 - 6\n    (0.4509, 0.6196, 0.8745),  # #739EDF - 6 - 8\n    (0.4157, 0.4706, 1.0000),  # #6A78FF - 8 - 10\n    (0.4235, 0.2784, 1.0000),  # #6C47FF - 10 - 12\n    (0.5529, 0.0980, 1.0000),  # #8D19FF - 12 - 14\n    (0.7333, 0.0000, 0.9176),  # #BB00EA - 14 - 16\n    (0.8392, 0.0000, 0.7490),  # #D600BF - 16 - 18\n    (0.7569, 0.0039, 0.4549),  # #C10074 - 18 - 20\n    (0.6784, 0.0000, 0.1961),  # #AD0032 - 20 - 30\n    (0.5020, 0.0000, 0.0000)   # #800000 - > 30\n]\n\ncmap_name = 'custom_snow_colormap'\ncustom_cmap = mcolors.ListedColormap(colors)\n\n# Define the lat_lon_to_map_coordinates function\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\n# Define your value ranges for color mapping\nvalue_ranges = [1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 30]\n\ndef convert_csvs_to_images():\n    data = pd.read_csv(\"/home/chetana/gridmet_test_run/test_data_predicted.csv\")\n    print(data.head())\n    data['predicted_swe'].fillna(0, inplace=True)\n    data['predicted_swe'] = data['predicted_swe'].apply(lambda x: 0 if x < 2 else x)\n    print(data['predicted_swe'].describe())\n    \n    # Create a figure with a white background\n    fig = plt.figure(facecolor='white')\n\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    print(\"data['lon'].values = \", data['lon'].values)\n    x, y = m(data['lon'].values, data['lat'].values)\n    print(\"x = \", x)\n    \n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_date = datetime(1900, 1, 1)\n    day_value = day_index\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    timestamp_string = result_date.strftime(\"%Y-%m-%d\")\n    \n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    # Create custom legend elements using the same colormap\n    legend_elements = [Patch(color=colors[i], label=f\"{value_ranges[i]} - {value_ranges[i+1]-1}\" if i < len(value_ranges) - 1 else f\"> {value_ranges[-1]}\") for i in range(len(value_ranges))]\n\n    # Create the legend outside the map\n    legend = plt.legend(handles=legend_elements, loc='upper left', title='Legend', fontsize=8)\n    legend.set_bbox_to_anchor((1.01, 1)) \n\n    # Remove the color bar\n    plt.colorbar().remove()\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Set the aspect ratio to 'equal' to keep the plot at the center\n    plt.gca().set_aspect('equal', adjustable='box')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15, right=0.80)  # Adjust right margin to accommodate the legend\n    # Show the plot or save it to a file\n    new_plot_path = f'/home/chetana/gridmet_test_run/predicted_swe-{test_start_date}.png'\n    print(f\"The new plot is saved to {new_plot_path}\")\n    plt.savefig(new_plot_path)\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "today date = 2023-09-20\ntest start date:  2022-03-19\ntest end date:  2023-09-20\n/home/chetana\n    date   lat      lon  SWE  ...  aspect  eastness  northness  predicted_swe\n0  44636  49.0 -125.000    0  ...    -1.0      -1.0       -1.0          8.429\n1  44636  49.0 -124.964    0  ...    -1.0      -1.0       -1.0          8.429\n2  44636  49.0 -124.928    0  ...    -1.0      -1.0       -1.0          8.429\n3  44636  49.0 -124.892    0  ...    -1.0      -1.0       -1.0          8.429\n4  44636  49.0 -124.856    0  ...    -1.0      -1.0       -1.0          8.429\n[5 rows x 20 columns]\ncount    462204.000000\nmean          8.431052\nstd           1.158904\nmin           4.636000\n25%           7.678000\n50%           8.805000\n75%           9.113000\nmax          10.618000\nName: predicted_swe, dtype: float64\ndata['lon'].values =  [-125.    -124.964 -124.928 ... -100.124 -100.088 -100.052]\nx =  [      0.            4003.01547425    8006.0309485  ... 2766083.69270573\n 2770086.70817998 2774089.72365423]\nTraceback (most recent call last):\n  File \"/home/chetana/gw-workspace/D1bddaQB8NdY/convert_results_to_images.py\", line 123, in <module>\n    convert_csvs_to_images()\n  File \"/home/chetana/gw-workspace/D1bddaQB8NdY/convert_results_to_images.py\", line 106, in convert_csvs_to_images\n    plt.colorbar().remove()\n  File \"/home/chetana/anaconda3/lib/python3.9/site-packages/matplotlib/pyplot.py\", line 2322, in colorbar\n    raise RuntimeError('No mappable was found to use for colorbar '\nRuntimeError: No mappable was found to use for colorbar creation. First define a mappable such as an image (with imshow) or a contour set (with contourf).\n",
  "history_begin_time" : 1695183159702,
  "history_end_time" : 1695183163978,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Failed"
},{
  "history_id" : "dfi8sVMMGy25",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport uuid\nfrom snowcast_utils import day_index\nimport matplotlib.colors as mcolors\nfrom matplotlib.patches import Patch\nfrom snowcast_utils import day_index, work_dir, test_start_date\n\n# Define the custom colormap with specified colors and ranges\ncolors = [\n    (0.8627, 0.8627, 0.8627),  # #DCDCDC - 0 - 1\n    (0.8627, 1.0000, 1.0000),  # #DCFFFF - 1 - 2\n    (0.6000, 1.0000, 1.0000),  # #99FFFF - 2 - 4\n    (0.5569, 0.8235, 1.0000),  # #8ED2FF - 4 - 6\n    (0.4509, 0.6196, 0.8745),  # #739EDF - 6 - 8\n    (0.4157, 0.4706, 1.0000),  # #6A78FF - 8 - 10\n    (0.4235, 0.2784, 1.0000),  # #6C47FF - 10 - 12\n    (0.5529, 0.0980, 1.0000),  # #8D19FF - 12 - 14\n    (0.7333, 0.0000, 0.9176),  # #BB00EA - 14 - 16\n    (0.8392, 0.0000, 0.7490),  # #D600BF - 16 - 18\n    (0.7569, 0.0039, 0.4549),  # #C10074 - 18 - 20\n    (0.6784, 0.0000, 0.1961),  # #AD0032 - 20 - 30\n    (0.5020, 0.0000, 0.0000)   # #800000 - > 30\n]\n\ncmap_name = 'custom_snow_colormap'\ncustom_cmap = mcolors.ListedColormap(colors)\n\n# Define the lat_lon_to_map_coordinates function\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\n# Define your value ranges for color mapping\nvalue_ranges = [1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 30]\n\ndef convert_csvs_to_images():\n    data = pd.read_csv(\"/home/chetana/gridmet_test_run/test_data_predicted.csv\")\n    print(data.head())\n    data['predicted_swe'].fillna(0, inplace=True)\n    data['predicted_swe'] = data['predicted_swe'].apply(lambda x: 0 if x < 2 else x)\n    print(data['predicted_swe'].describe())\n    \n    # Create a figure with a white background\n    fig = plt.figure(facecolor='white')\n\n    # Define your custom function to map data values to colors\n    def map_value_to_color(value):\n        # Iterate through the value ranges to find the appropriate color index\n        for i, range_max in enumerate(value_ranges):\n            if value <= range_max:\n                return colors[i]\n        \n        # If the value is greater than the largest range, return the last color\n        return colors[-1]\n\n    # Map predicted_swe values to colors using the custom function\n    color_mapping = [map_value_to_color(value) for value in data['predicted_swe'].values]\n    \n    # Plot the data using the custom colormap\n    plt.scatter(data['lon'].values, data['lat'].values, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\n\n#     lon_min, lon_max = -125, -100\n#     lat_min, lat_max = 25, 49.5\n\n#     m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n#                 projection='merc', resolution='i')\n\n#     print(\"data['lon'].values = \", data['lon'].values)\n#     x, y = m(data['lon'].values, data['lat'].values)\n#     print(\"x = \", x)\n    \n    \n\n#     # Draw coastlines and other map features\n#     m.drawcoastlines()\n#     m.drawcountries()\n#     m.drawstates()\n\n#     reference_date = datetime(1900, 1, 1)\n#     day_value = day_index\n    \n#     result_date = reference_date + timedelta(days=day_value)\n#     today = result_date.strftime(\"%Y-%m-%d\")\n#     timestamp_string = result_date.strftime(\"%Y-%m-%d\")\n    \n#     # Add a title\n#     plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n#     # Add labels for latitude and longitude on x and y axes with smaller font size\n#     plt.xlabel('Longitude', fontsize=6)\n#     plt.ylabel('Latitude', fontsize=6)\n\n#     # Add longitude values to the x-axis and adjust font size\n#     x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n#     x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n#     plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n#     plt.gca().set_xticklabels(x_tick_labels_str)\n\n#     # Add latitude values to the y-axis and adjust font size\n#     y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n#     y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n#     plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n#     plt.gca().set_yticklabels(y_tick_labels_str)\n\n#     # Convert map coordinates to latitude and longitude for y-axis labels\n#     y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n#     y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n#     y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n#     y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n#     plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n#     # Create custom legend elements using the same colormap\n#     legend_elements = [Patch(color=colors[i], label=f\"{value_ranges[i]} - {value_ranges[i+1]-1}\" if i < len(value_ranges) - 1 else f\"> {value_ranges[-1]}\") for i in range(len(value_ranges))]\n\n#     # Create the legend outside the map\n#     legend = plt.legend(handles=legend_elements, loc='upper left', title='Legend', fontsize=8)\n#     legend.set_bbox_to_anchor((1.01, 1)) \n\n#     # Remove the color bar\n#     plt.colorbar().remove()\n\n#     plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n#              horizontalalignment='right', verticalalignment='bottom',\n#              transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n#     # Set the aspect ratio to 'equal' to keep the plot at the center\n#     plt.gca().set_aspect('equal', adjustable='box')\n\n#     # Adjust the bottom and top margins to create more white space between the title and the plot\n#     plt.subplots_adjust(bottom=0.15, right=0.80)  # Adjust right margin to accommodate the legend\n    # Show the plot or save it to a file\n    new_plot_path = f'/home/chetana/gridmet_test_run/predicted_swe-{test_start_date}.png'\n    print(f\"The new plot is saved to {new_plot_path}\")\n    plt.savefig(new_plot_path)\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "/home/chetana/gw-workspace/dfi8sVMMGy25/convert_results_to_images.py:64: UserWarning: No data for colormapping provided via 'c'. Parameters 'cmap' will be ignored\n  plt.scatter(data['lon'].values, data['lat'].values, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\ntoday date = 2023-09-19\ntest start date:  2022-03-19\ntest end date:  2023-09-19\n/home/chetana\n   date   lat      lon  SWE  ...  aspect  eastness  northness  predicted_swe\n0  -1.0  49.0 -125.000 -1.0  ...    -1.0      -1.0       -1.0          4.928\n1  -1.0  49.0 -124.964 -1.0  ...    -1.0      -1.0       -1.0          4.928\n2  -1.0  49.0 -124.928 -1.0  ...    -1.0      -1.0       -1.0          4.928\n3  -1.0  49.0 -124.892 -1.0  ...    -1.0      -1.0       -1.0          4.928\n4  -1.0  49.0 -124.856 -1.0  ...    -1.0      -1.0       -1.0          4.928\n[5 rows x 20 columns]\ncount    462204.000000\nmean          5.273755\nstd           0.715343\nmin           4.669000\n25%           4.839000\n50%           4.939000\n75%           5.603000\nmax           8.085000\nName: predicted_swe, dtype: float64\nThe new plot is saved to /home/chetana/gridmet_test_run/predicted_swe-2022-03-19.png\n",
  "history_begin_time" : 1695132559536,
  "history_end_time" : 1695132566666,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "BihLJ1mBMfKR",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport uuid\nfrom snowcast_utils import day_index\nimport matplotlib.colors as mcolors\nfrom matplotlib.patches import Patch\n\n# Define the custom colormap with specified colors and ranges\ncolors = [\n    (0.8627, 0.8627, 0.8627),  # #DCDCDC - 0 - 1\n    (0.8627, 1.0000, 1.0000),  # #DCFFFF - 1 - 2\n    (0.6000, 1.0000, 1.0000),  # #99FFFF - 2 - 4\n    (0.5569, 0.8235, 1.0000),  # #8ED2FF - 4 - 6\n    (0.4509, 0.6196, 0.8745),  # #739EDF - 6 - 8\n    (0.4157, 0.4706, 1.0000),  # #6A78FF - 8 - 10\n    (0.4235, 0.2784, 1.0000),  # #6C47FF - 10 - 12\n    (0.5529, 0.0980, 1.0000),  # #8D19FF - 12 - 14\n    (0.7333, 0.0000, 0.9176),  # #BB00EA - 14 - 16\n    (0.8392, 0.0000, 0.7490),  # #D600BF - 16 - 18\n    (0.7569, 0.0039, 0.4549),  # #C10074 - 18 - 20\n    (0.6784, 0.0000, 0.1961),  # #AD0032 - 20 - 30\n    (0.5020, 0.0000, 0.0000)   # #800000 - > 30\n]\n\ncmap_name = 'custom_snow_colormap'\ncustom_cmap = mcolors.ListedColormap(colors)\n\n# Define the lat_lon_to_map_coordinates function\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\n# Define your value ranges for color mapping\nvalue_ranges = [1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 30]\n\ndef convert_csvs_to_images():\n    data = pd.read_csv(\"/home/chetana/gridmet_test_run/test_data_predicted.csv\")\n    print(data.head())\n    data['predicted_swe'].fillna(0, inplace=True)\n    data['predicted_swe'] = data['predicted_swe'].apply(lambda x: 0 if x < 2 else x)\n    print(data['predicted_swe'].describe())\n    \n    # Create a figure with a white background\n    fig = plt.figure(facecolor='white')\n\n    # Define your custom function to map data values to colors\n    def map_value_to_color(value):\n        # Iterate through the value ranges to find the appropriate color index\n        for i, range_max in enumerate(value_ranges):\n            if value <= range_max:\n                return colors[i]\n        \n        # If the value is greater than the largest range, return the last color\n        return colors[-1]\n\n    # Map predicted_swe values to colors using the custom function\n    color_mapping = [map_value_to_color(value) for value in data['predicted_swe'].values]\n    \n    # Plot the data using the custom colormap\n    plt.scatter(data['lon'].values, data['lat'].values, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\n\n#     lon_min, lon_max = -125, -100\n#     lat_min, lat_max = 25, 49.5\n\n#     m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n#                 projection='merc', resolution='i')\n\n#     print(\"data['lon'].values = \", data['lon'].values)\n#     x, y = m(data['lon'].values, data['lat'].values)\n#     print(\"x = \", x)\n    \n    \n\n#     # Draw coastlines and other map features\n#     m.drawcoastlines()\n#     m.drawcountries()\n#     m.drawstates()\n\n#     reference_date = datetime(1900, 1, 1)\n#     day_value = day_index\n    \n#     result_date = reference_date + timedelta(days=day_value)\n#     today = result_date.strftime(\"%Y-%m-%d\")\n#     timestamp_string = result_date.strftime(\"%Y-%m-%d\")\n    \n#     # Add a title\n#     plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n#     # Add labels for latitude and longitude on x and y axes with smaller font size\n#     plt.xlabel('Longitude', fontsize=6)\n#     plt.ylabel('Latitude', fontsize=6)\n\n#     # Add longitude values to the x-axis and adjust font size\n#     x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n#     x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n#     plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n#     plt.gca().set_xticklabels(x_tick_labels_str)\n\n#     # Add latitude values to the y-axis and adjust font size\n#     y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n#     y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n#     plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n#     plt.gca().set_yticklabels(y_tick_labels_str)\n\n#     # Convert map coordinates to latitude and longitude for y-axis labels\n#     y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n#     y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n#     y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n#     y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n#     plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n#     # Create custom legend elements using the same colormap\n#     legend_elements = [Patch(color=colors[i], label=f\"{value_ranges[i]} - {value_ranges[i+1]-1}\" if i < len(value_ranges) - 1 else f\"> {value_ranges[-1]}\") for i in range(len(value_ranges))]\n\n#     # Create the legend outside the map\n#     legend = plt.legend(handles=legend_elements, loc='upper left', title='Legend', fontsize=8)\n#     legend.set_bbox_to_anchor((1.01, 1)) \n\n#     # Remove the color bar\n#     plt.colorbar().remove()\n\n#     plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n#              horizontalalignment='right', verticalalignment='bottom',\n#              transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n#     # Set the aspect ratio to 'equal' to keep the plot at the center\n#     plt.gca().set_aspect('equal', adjustable='box')\n\n#     # Adjust the bottom and top margins to create more white space between the title and the plot\n#     plt.subplots_adjust(bottom=0.15, right=0.80)  # Adjust right margin to accommodate the legend\n    # Show the plot or save it to a file\n    new_plot_path = f'/home/chetana/gridmet_test_run/predicted_swe-{timestamp_string}.png'\n    print(f\"The new plot is saved to {new_plot_path}\")\n    plt.savefig(new_plot_path)\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "/home/chetana/gw-workspace/BihLJ1mBMfKR/convert_results_to_images.py:63: UserWarning: No data for colormapping provided via 'c'. Parameters 'cmap' will be ignored\n  plt.scatter(data['lon'].values, data['lat'].values, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\ntoday date = 2023-09-19\ntest start date:  2022-03-19\ntest end date:  2023-09-19\n/home/chetana\n   date   lat      lon  SWE  ...  aspect  eastness  northness  predicted_swe\n0  -1.0  49.0 -125.000 -1.0  ...    -1.0      -1.0       -1.0          4.928\n1  -1.0  49.0 -124.964 -1.0  ...    -1.0      -1.0       -1.0          4.928\n2  -1.0  49.0 -124.928 -1.0  ...    -1.0      -1.0       -1.0          4.928\n3  -1.0  49.0 -124.892 -1.0  ...    -1.0      -1.0       -1.0          4.928\n4  -1.0  49.0 -124.856 -1.0  ...    -1.0      -1.0       -1.0          4.928\n[5 rows x 20 columns]\ncount    462204.000000\nmean          5.273755\nstd           0.715343\nmin           4.669000\n25%           4.839000\n50%           4.939000\n75%           5.603000\nmax           8.085000\nName: predicted_swe, dtype: float64\nTraceback (most recent call last):\n  File \"/home/chetana/gw-workspace/BihLJ1mBMfKR/convert_results_to_images.py\", line 140, in <module>\n    convert_csvs_to_images()\n  File \"/home/chetana/gw-workspace/BihLJ1mBMfKR/convert_results_to_images.py\", line 135, in convert_csvs_to_images\n    new_plot_path = f'/home/chetana/gridmet_test_run/predicted_swe-{timestamp_string}.png'\nNameError: name 'timestamp_string' is not defined\n",
  "history_begin_time" : 1695132501313,
  "history_end_time" : 1695132503660,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Failed"
},{
  "history_id" : "bWjMTlA7pGkQ",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport uuid\nfrom snowcast_utils import day_index\nimport matplotlib.colors as mcolors\nfrom matplotlib.patches import Patch\n\n# Define the custom colormap with specified colors and ranges\ncolors = [\n    (0.8627, 0.8627, 0.8627),  # #DCDCDC - 0 - 1\n    (0.8627, 1.0000, 1.0000),  # #DCFFFF - 1 - 2\n    (0.6000, 1.0000, 1.0000),  # #99FFFF - 2 - 4\n    (0.5569, 0.8235, 1.0000),  # #8ED2FF - 4 - 6\n    (0.4509, 0.6196, 0.8745),  # #739EDF - 6 - 8\n    (0.4157, 0.4706, 1.0000),  # #6A78FF - 8 - 10\n    (0.4235, 0.2784, 1.0000),  # #6C47FF - 10 - 12\n    (0.5529, 0.0980, 1.0000),  # #8D19FF - 12 - 14\n    (0.7333, 0.0000, 0.9176),  # #BB00EA - 14 - 16\n    (0.8392, 0.0000, 0.7490),  # #D600BF - 16 - 18\n    (0.7569, 0.0039, 0.4549),  # #C10074 - 18 - 20\n    (0.6784, 0.0000, 0.1961),  # #AD0032 - 20 - 30\n    (0.5020, 0.0000, 0.0000)   # #800000 - > 30\n]\n\ncmap_name = 'custom_snow_colormap'\ncustom_cmap = mcolors.ListedColormap(colors)\n\n# Define the lat_lon_to_map_coordinates function\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\n# Define your value ranges for color mapping\nvalue_ranges = [1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 30]\n\ndef convert_csvs_to_images():\n    data = pd.read_csv(\"/home/chetana/gridmet_test_run/test_data_predicted.csv\")\n    print(data.head())\n    data['predicted_swe'].fillna(0, inplace=True)\n    data['predicted_swe'] = data['predicted_swe'].apply(lambda x: 0 if x < 2 else x)\n    print(data['predicted_swe'].describe())\n\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    print(\"data['lon'].values = \", data['lon'].values)\n    x, y = m(data['lon'].values, data['lat'].values)\n    print(\"x = \", x)\n    \n    # Create a figure with a white background\n    fig = plt.figure(facecolor='white')\n\n    # Define your custom function to map data values to colors\n    def map_value_to_color(value):\n        # Iterate through the value ranges to find the appropriate color index\n        for i, range_max in enumerate(value_ranges):\n            if value <= range_max:\n                return colors[i]\n        \n        # If the value is greater than the largest range, return the last color\n        return colors[-1]\n\n    # Map predicted_swe values to colors using the custom function\n    color_mapping = [map_value_to_color(value) for value in data['predicted_swe']]\n    \n    # Plot the data using the custom colormap\n    plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\n\n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_date = datetime(1900, 1, 1)\n    day_value = day_index\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    timestamp_string = result_date.strftime(\"%Y-%m-%d\")\n    \n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    # Create custom legend elements using the same colormap\n    legend_elements = [Patch(color=colors[i], label=f\"{value_ranges[i]} - {value_ranges[i+1]-1}\" if i < len(value_ranges) - 1 else f\"> {value_ranges[-1]}\") for i in range(len(value_ranges))]\n\n    # Create the legend outside the map\n    legend = plt.legend(handles=legend_elements, loc='upper left', title='Legend', fontsize=8)\n    legend.set_bbox_to_anchor((1.01, 1)) \n\n    # Remove the color bar\n    plt.colorbar().remove()\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Set the aspect ratio to 'equal' to keep the plot at the center\n    plt.gca().set_aspect('equal', adjustable='box')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15, right=0.80)  # Adjust right margin to accommodate the legend\n    # Show the plot or save it to a file\n    new_plot_path = f'/home/chetana/gridmet_test_run/predicted_swe-{timestamp_string}.png'\n    print(f\"The new plot is saved to {new_plot_path}\")\n    plt.savefig(new_plot_path)\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "/home/chetana/gw-workspace/bWjMTlA7pGkQ/convert_results_to_images.py:73: UserWarning: No data for colormapping provided via 'c'. Parameters 'cmap' will be ignored\n  plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\ntoday date = 2023-09-19\ntest start date:  2022-03-19\ntest end date:  2023-09-19\n/home/chetana\n   date   lat      lon  SWE  ...  aspect  eastness  northness  predicted_swe\n0  -1.0  49.0 -125.000 -1.0  ...    -1.0      -1.0       -1.0          4.928\n1  -1.0  49.0 -124.964 -1.0  ...    -1.0      -1.0       -1.0          4.928\n2  -1.0  49.0 -124.928 -1.0  ...    -1.0      -1.0       -1.0          4.928\n3  -1.0  49.0 -124.892 -1.0  ...    -1.0      -1.0       -1.0          4.928\n4  -1.0  49.0 -124.856 -1.0  ...    -1.0      -1.0       -1.0          4.928\n[5 rows x 20 columns]\ncount    462204.000000\nmean          5.273755\nstd           0.715343\nmin           4.669000\n25%           4.839000\n50%           4.939000\n75%           5.603000\nmax           8.085000\nName: predicted_swe, dtype: float64\ndata['lon'].values =  [-125.    -124.964 -124.928 ... -100.124 -100.088 -100.052]\nx =  [      0.            4003.01547425    8006.0309485  ... 2766083.69270573\n 2770086.70817998 2774089.72365423]\nThe new plot is saved to /home/chetana/gridmet_test_run/predicted_swe-2022-03-19.png\n",
  "history_begin_time" : 1695132188535,
  "history_end_time" : 1695132197583,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "vfTd7ESrmWeH",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport uuid\nfrom snowcast_utils import day_index\nimport matplotlib.colors as mcolors\nfrom matplotlib.patches import Patch\n\n# Define the custom colormap with specified colors and ranges\ncolors = [\n    (0.8627, 0.8627, 0.8627),  # #DCDCDC - 0 - 1\n    (0.8627, 1.0000, 1.0000),  # #DCFFFF - 1 - 2\n    (0.6000, 1.0000, 1.0000),  # #99FFFF - 2 - 4\n    (0.5569, 0.8235, 1.0000),  # #8ED2FF - 4 - 6\n    (0.4509, 0.6196, 0.8745),  # #739EDF - 6 - 8\n    (0.4157, 0.4706, 1.0000),  # #6A78FF - 8 - 10\n    (0.4235, 0.2784, 1.0000),  # #6C47FF - 10 - 12\n    (0.5529, 0.0980, 1.0000),  # #8D19FF - 12 - 14\n    (0.7333, 0.0000, 0.9176),  # #BB00EA - 14 - 16\n    (0.8392, 0.0000, 0.7490),  # #D600BF - 16 - 18\n    (0.7569, 0.0039, 0.4549),  # #C10074 - 18 - 20\n    (0.6784, 0.0000, 0.1961),  # #AD0032 - 20 - 30\n    (0.5020, 0.0000, 0.0000)   # #800000 - > 30\n]\n\ncmap_name = 'custom_snow_colormap'\ncustom_cmap = mcolors.ListedColormap(colors)\n\n# Define the lat_lon_to_map_coordinates function\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\n# Define your value ranges for color mapping\nvalue_ranges = [1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 30]\n\ndef convert_csvs_to_images():\n    data = pd.read_csv(\"/home/chetana/gridmet_test_run/test_data_predicted.csv\")\n    data['predicted_swe'].fillna(0, inplace=True)\n    data['predicted_swe'] = data['predicted_swe'].apply(lambda x: 0 if x < 2 else x)\n    print(data['predicted_swe'].describe())\n\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    print(\"data['lon'].values = \", data['lon'].values)\n    x, y = m(data['lon'].values, data['lat'].values)\n    print(\"x = \", x)\n    \n    # Create a figure with a white background\n    fig = plt.figure(facecolor='white')\n\n    # Define your custom function to map data values to colors\n    def map_value_to_color(value):\n        # Iterate through the value ranges to find the appropriate color index\n        for i, range_max in enumerate(value_ranges):\n            if value <= range_max:\n                return colors[i]\n        \n        # If the value is greater than the largest range, return the last color\n        return colors[-1]\n\n    # Map predicted_swe values to colors using the custom function\n    color_mapping = [map_value_to_color(value) for value in data['predicted_swe']]\n    \n    # Plot the data using the custom colormap\n    plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\n\n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_date = datetime(1900, 1, 1)\n    day_value = day_index\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    timestamp_string = result_date.strftime(\"%Y-%m-%d\")\n    \n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    # Create custom legend elements using the same colormap\n    legend_elements = [Patch(color=colors[i], label=f\"{value_ranges[i]} - {value_ranges[i+1]-1}\" if i < len(value_ranges) - 1 else f\"> {value_ranges[-1]}\") for i in range(len(value_ranges))]\n\n    # Create the legend outside the map\n    legend = plt.legend(handles=legend_elements, loc='upper left', title='Legend', fontsize=8)\n    legend.set_bbox_to_anchor((1.01, 1)) \n\n    # Remove the color bar\n    plt.colorbar().remove()\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Set the aspect ratio to 'equal' to keep the plot at the center\n    plt.gca().set_aspect('equal', adjustable='box')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15, right=0.80)  # Adjust right margin to accommodate the legend\n    # Show the plot or save it to a file\n    new_plot_path = f'/home/chetana/gridmet_test_run/predicted_swe-{timestamp_string}.png'\n    print(f\"The new plot is saved to {new_plot_path}\")\n    plt.savefig(new_plot_path)\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "/home/chetana/gw-workspace/vfTd7ESrmWeH/convert_results_to_images.py:72: UserWarning: No data for colormapping provided via 'c'. Parameters 'cmap' will be ignored\n  plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\ntoday date = 2023-09-19\ntest start date:  2022-03-19\ntest end date:  2023-09-19\n/home/chetana\ncount    462204.000000\nmean          5.273755\nstd           0.715343\nmin           4.669000\n25%           4.839000\n50%           4.939000\n75%           5.603000\nmax           8.085000\nName: predicted_swe, dtype: float64\ndata['lon'].values =  [-125.    -124.964 -124.928 ... -100.124 -100.088 -100.052]\nx =  [      0.            4003.01547425    8006.0309485  ... 2766083.69270573\n 2770086.70817998 2774089.72365423]\nThe new plot is saved to /home/chetana/gridmet_test_run/predicted_swe-2022-03-19.png\n",
  "history_begin_time" : 1695132113246,
  "history_end_time" : 1695132122459,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "Lc16c2rj77wd",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport uuid\nfrom snowcast_utils import day_index\nimport matplotlib.colors as mcolors\nfrom matplotlib.patches import Patch\n\n# Define the custom colormap with specified colors and ranges\ncolors = [\n    (0.8627, 0.8627, 0.8627),  # #DCDCDC - 0 - 1\n    (0.8627, 1.0000, 1.0000),  # #DCFFFF - 1 - 2\n    (0.6000, 1.0000, 1.0000),  # #99FFFF - 2 - 4\n    (0.5569, 0.8235, 1.0000),  # #8ED2FF - 4 - 6\n    (0.4509, 0.6196, 0.8745),  # #739EDF - 6 - 8\n    (0.4157, 0.4706, 1.0000),  # #6A78FF - 8 - 10\n    (0.4235, 0.2784, 1.0000),  # #6C47FF - 10 - 12\n    (0.5529, 0.0980, 1.0000),  # #8D19FF - 12 - 14\n    (0.7333, 0.0000, 0.9176),  # #BB00EA - 14 - 16\n    (0.8392, 0.0000, 0.7490),  # #D600BF - 16 - 18\n    (0.7569, 0.0039, 0.4549),  # #C10074 - 18 - 20\n    (0.6784, 0.0000, 0.1961),  # #AD0032 - 20 - 30\n    (0.5020, 0.0000, 0.0000)   # #800000 - > 30\n]\n\ncmap_name = 'custom_snow_colormap'\ncustom_cmap = mcolors.ListedColormap(colors)\n\n# Define the lat_lon_to_map_coordinates function\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\n# Define your value ranges for color mapping\nvalue_ranges = [1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 30]\n\ndef convert_csvs_to_images():\n    data = pd.read_csv(\"/home/chetana/gridmet_test_run/test_data_predicted.csv\")\n    data['predicted_swe'].fillna(0, inplace=True)\n    data['predicted_swe'] = data['predicted_swe'].apply(lambda x: 0 if x < 2 else x)\n    print(data['predicted_swe'].describe())\n\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    x, y = m(data['lon'].values, data['lat'].values)\n\n    # Create a figure with a white background\n    fig = plt.figure(facecolor='white')\n\n    # Define your custom function to map data values to colors\n    def map_value_to_color(value):\n        # Iterate through the value ranges to find the appropriate color index\n        for i, range_max in enumerate(value_ranges):\n            if value <= range_max:\n                return colors[i]\n        \n        # If the value is greater than the largest range, return the last color\n        return colors[-1]\n\n    # Map predicted_swe values to colors using the custom function\n    color_mapping = [map_value_to_color(value) for value in data['predicted_swe']]\n    \n    # Plot the data using the custom colormap\n    plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\n\n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_date = datetime(1900, 1, 1)\n    day_value = day_index\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    timestamp_string = result_date.strftime(\"%Y-%m-%d\")\n    \n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    # Create custom legend elements using the same colormap\n    legend_elements = [Patch(color=colors[i], label=f\"{value_ranges[i]} - {value_ranges[i+1]-1}\" if i < len(value_ranges) - 1 else f\"> {value_ranges[-1]}\") for i in range(len(value_ranges))]\n\n    # Create the legend outside the map\n    legend = plt.legend(handles=legend_elements, loc='upper left', title='Legend', fontsize=8)\n    legend.set_bbox_to_anchor((1.01, 1)) \n\n    # Remove the color bar\n    plt.colorbar().remove()\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Set the aspect ratio to 'equal' to keep the plot at the center\n    plt.gca().set_aspect('equal', adjustable='box')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15, right=0.80)  # Adjust right margin to accommodate the legend\n    # Show the plot or save it to a file\n    new_plot_path = f'/home/chetana/gridmet_test_run/predicted_swe-{timestamp_string}.png'\n    print(f\"The new plot is saved to {new_plot_path}\")\n    plt.savefig(new_plot_path)\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "/home/chetana/gw-workspace/Lc16c2rj77wd/convert_results_to_images.py:70: UserWarning: No data for colormapping provided via 'c'. Parameters 'cmap' will be ignored\n  plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\ntoday date = 2023-09-19\ntest start date:  2022-03-19\ntest end date:  2023-09-19\n/home/chetana\ncount    462204.000000\nmean          5.273755\nstd           0.715343\nmin           4.669000\n25%           4.839000\n50%           4.939000\n75%           5.603000\nmax           8.085000\nName: predicted_swe, dtype: float64\nThe new plot is saved to /home/chetana/gridmet_test_run/predicted_swe-2022-03-19.png\n",
  "history_begin_time" : 1695107221952,
  "history_end_time" : 1695107233873,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "EcyRnzniyFNu",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport uuid\nfrom snowcast_utils import day_index\nimport matplotlib.colors as mcolors\nfrom matplotlib.patches import Patch\n\n# Define the custom colormap with specified colors and ranges\ncolors = [\n    (0.8627, 0.8627, 0.8627),  # #DCDCDC - 0 - 1\n    (0.8627, 1.0000, 1.0000),  # #DCFFFF - 1 - 2\n    (0.6000, 1.0000, 1.0000),  # #99FFFF - 2 - 4\n    (0.5569, 0.8235, 1.0000),  # #8ED2FF - 4 - 6\n    (0.4509, 0.6196, 0.8745),  # #739EDF - 6 - 8\n    (0.4157, 0.4706, 1.0000),  # #6A78FF - 8 - 10\n    (0.4235, 0.2784, 1.0000),  # #6C47FF - 10 - 12\n    (0.5529, 0.0980, 1.0000),  # #8D19FF - 12 - 14\n    (0.7333, 0.0000, 0.9176),  # #BB00EA - 14 - 16\n    (0.8392, 0.0000, 0.7490),  # #D600BF - 16 - 18\n    (0.7569, 0.0039, 0.4549),  # #C10074 - 18 - 20\n    (0.6784, 0.0000, 0.1961),  # #AD0032 - 20 - 30\n    (0.5020, 0.0000, 0.0000)   # #800000 - > 30\n]\n\ncmap_name = 'custom_snow_colormap'\ncustom_cmap = mcolors.ListedColormap(colors)\n\n# Define the lat_lon_to_map_coordinates function\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\n# Define your value ranges for color mapping\nvalue_ranges = [1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 30]\n\ndef convert_csvs_to_images():\n    data = pd.read_csv(\"/home/chetana/gridmet_test_run/test_data_predicted.csv\")\n    data['predicted_swe'].fillna(0, inplace=True)\n    data['predicted_swe'] = data['predicted_swe'].apply(lambda x: 0 if x < 2 else x)\n    print(data['predicted_swe'].describe())\n\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    x, y = m(data['lon'].values, data['lat'].values)\n\n    # Create a figure with a white background\n    fig = plt.figure(facecolor='white')\n\n    # Define your custom function to map data values to colors\n    def map_value_to_color(value):\n        # Iterate through the value ranges to find the appropriate color index\n        for i, range_max in enumerate(value_ranges):\n            if value <= range_max:\n                return colors[i]\n        \n        # If the value is greater than the largest range, return the last color\n        return colors[-1]\n\n    # Map predicted_swe values to colors using the custom function\n    color_mapping = [map_value_to_color(value) for value in data['predicted_swe']]\n    \n    # Plot the data using the custom colormap\n    plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\n\n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_date = datetime(1900, 1, 1)\n    day_value = day_index\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    timestamp_string = result_date.strftime(\"%Y-%m-%d\")\n    \n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    # Create custom legend elements using the same colormap\n    legend_elements = [Patch(color=colors[i], label=f\"{value_ranges[i]} - {value_ranges[i+1]-1}\" if i < len(value_ranges) - 1 else f\"> {value_ranges[-1]}\") for i in range(len(value_ranges))]\n\n    # Create the legend outside the map\n    legend = plt.legend(handles=legend_elements, loc='upper left', title='Legend', fontsize=8)\n    legend.set_bbox_to_anchor((1.01, 1)) \n\n    # Remove the color bar\n    plt.colorbar().remove()\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Set the aspect ratio to 'equal' to keep the plot at the center\n    plt.gca().set_aspect('equal', adjustable='box')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15, right=0.80)  # Adjust right margin to accommodate the legend\n    # Show the plot or save it to a file\n    new_plot_path = f'/home/chetana/gridmet_test_run/predicted_swe-{timestamp_string}.png'\n    print(f\"The new plot is saved to {new_plot_path}\")\n    plt.savefig(new_plot_path)\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "/home/chetana/gw-workspace/EcyRnzniyFNu/convert_results_to_images.py:70: UserWarning: No data for colormapping provided via 'c'. Parameters 'cmap' will be ignored\n  plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\ntoday date = 2023-09-19\ntest start date:  2022-03-19\ntest end date:  2023-09-19\n/home/chetana\ncount    462204.0\nmean          0.0\nstd           0.0\nmin           0.0\n25%           0.0\n50%           0.0\n75%           0.0\nmax           0.0\nName: predicted_swe, dtype: float64\nThe new plot is saved to /home/chetana/gridmet_test_run/predicted_swe-2022-03-19.png\n",
  "history_begin_time" : 1695106965513,
  "history_end_time" : 1695106977131,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "x9y19jdtxb1",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport uuid\nfrom snowcast_utils import day_index\nimport matplotlib.colors as mcolors\nfrom matplotlib.patches import Patch\n\n# Define the custom colormap with specified colors and ranges\ncolors = [\n    (0.8627, 0.8627, 0.8627),  # #DCDCDC - 0 - 1\n    (0.8627, 1.0000, 1.0000),  # #DCFFFF - 1 - 2\n    (0.6000, 1.0000, 1.0000),  # #99FFFF - 2 - 4\n    (0.5569, 0.8235, 1.0000),  # #8ED2FF - 4 - 6\n    (0.4509, 0.6196, 0.8745),  # #739EDF - 6 - 8\n    (0.4157, 0.4706, 1.0000),  # #6A78FF - 8 - 10\n    (0.4235, 0.2784, 1.0000),  # #6C47FF - 10 - 12\n    (0.5529, 0.0980, 1.0000),  # #8D19FF - 12 - 14\n    (0.7333, 0.0000, 0.9176),  # #BB00EA - 14 - 16\n    (0.8392, 0.0000, 0.7490),  # #D600BF - 16 - 18\n    (0.7569, 0.0039, 0.4549),  # #C10074 - 18 - 20\n    (0.6784, 0.0000, 0.1961),  # #AD0032 - 20 - 30\n    (0.5020, 0.0000, 0.0000)   # #800000 - > 30\n]\n\ncmap_name = 'custom_snow_colormap'\ncustom_cmap = mcolors.ListedColormap(colors)\n\n# Define the lat_lon_to_map_coordinates function\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\n# Define your value ranges for color mapping\nvalue_ranges = [1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 30]\n\ndef convert_csvs_to_images():\n    data = pd.read_csv(\"/home/chetana/gridmet_test_run/test_data_predicted.csv\")\n    data['predicted_swe'].fillna(0, inplace=True)\n    data['predicted_swe'] = data['predicted_swe'].apply(lambda x: 0 if x < 2 else x)\n    print(data[:5])\n\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    x, y = m(data['lon'].values, data['lat'].values)\n\n    # Create a figure with a white background\n    fig = plt.figure(facecolor='white')\n\n    # Define your custom function to map data values to colors\n    def map_value_to_color(value):\n        # Iterate through the value ranges to find the appropriate color index\n        for i, range_max in enumerate(value_ranges):\n            if value <= range_max:\n                return colors[i]\n        \n        # If the value is greater than the largest range, return the last color\n        return colors[-1]\n\n    # Map predicted_swe values to colors using the custom function\n    color_mapping = [map_value_to_color(value) for value in data['predicted_swe']]\n    \n    # Plot the data using the custom colormap\n    plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\n\n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_date = datetime(1900, 1, 1)\n    day_value = day_index\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    timestamp_string = result_date.strftime(\"%Y-%m-%d\")\n    \n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    # Create custom legend elements using the same colormap\n    legend_elements = [Patch(color=colors[i], label=f\"{value_ranges[i]} - {value_ranges[i+1]-1}\" if i < len(value_ranges) - 1 else f\"> {value_ranges[-1]}\") for i in range(len(value_ranges))]\n\n    # Create the legend outside the map\n    legend = plt.legend(handles=legend_elements, loc='upper left', title='Legend', fontsize=8)\n    legend.set_bbox_to_anchor((1.01, 1)) \n\n    # Remove the color bar\n    plt.colorbar().remove()\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Set the aspect ratio to 'equal' to keep the plot at the center\n    plt.gca().set_aspect('equal', adjustable='box')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15, right=0.80)  # Adjust right margin to accommodate the legend\n    # Show the plot or save it to a file\n    new_plot_path = f'/home/chetana/gridmet_test_run/predicted_swe-{timestamp_string}.png'\n    print(f\"The new plot is saved to {new_plot_path}\")\n    plt.savefig(new_plot_path)\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "/home/chetana/gw-workspace/x9y19jdtxb1/convert_results_to_images.py:70: UserWarning: No data for colormapping provided via 'c'. Parameters 'cmap' will be ignored\n  plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\ntoday date = 2023-09-19\ntest start date:  2022-03-18\ntest end date:  2023-09-19\n/home/chetana\n    lat      lon  potential_evapotranspiration  ...  Flag   date  predicted_swe\n0  49.0 -125.000                           NaN  ...   241  44636              0\n1  49.0 -124.964                           NaN  ...   241  44636              0\n2  49.0 -124.928                           NaN  ...   241  44636              0\n3  49.0 -124.892                           NaN  ...   241  44636              0\n4  49.0 -124.856                           NaN  ...   241  44636              0\n[5 rows x 22 columns]\nThe new plot is saved to /home/chetana/gridmet_test_run/predicted_swe-2022-03-18.png\n",
  "history_begin_time" : 1695106522270,
  "history_end_time" : 1695106532733,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "100001",
  "indicator" : "Done"
},{
  "history_id" : "k09p6qkurwo",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport uuid\nfrom snowcast_utils import day_index\nimport matplotlib.colors as mcolors\nfrom matplotlib.patches import Patch\n\n# Define the custom colormap with specified colors and ranges\ncolors = [\n    (0.8627, 0.8627, 0.8627),  # #DCDCDC - 0 - 1\n    (0.8627, 1.0000, 1.0000),  # #DCFFFF - 1 - 2\n    (0.6000, 1.0000, 1.0000),  # #99FFFF - 2 - 4\n    (0.5569, 0.8235, 1.0000),  # #8ED2FF - 4 - 6\n    (0.4509, 0.6196, 0.8745),  # #739EDF - 6 - 8\n    (0.4157, 0.4706, 1.0000),  # #6A78FF - 8 - 10\n    (0.4235, 0.2784, 1.0000),  # #6C47FF - 10 - 12\n    (0.5529, 0.0980, 1.0000),  # #8D19FF - 12 - 14\n    (0.7333, 0.0000, 0.9176),  # #BB00EA - 14 - 16\n    (0.8392, 0.0000, 0.7490),  # #D600BF - 16 - 18\n    (0.7569, 0.0039, 0.4549),  # #C10074 - 18 - 20\n    (0.6784, 0.0000, 0.1961),  # #AD0032 - 20 - 30\n    (0.5020, 0.0000, 0.0000)   # #800000 - > 30\n]\n\ncmap_name = 'custom_snow_colormap'\ncustom_cmap = mcolors.ListedColormap(colors)\n\n# Define the lat_lon_to_map_coordinates function\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\n# Define your value ranges for color mapping\nvalue_ranges = [1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 30]\n\ndef convert_csvs_to_images():\n    data = pd.read_csv(\"/home/chetana/gridmet_test_run/test_data_predicted.csv\")\n    data['predicted_swe'].fillna(0, inplace=True)\n    data['predicted_swe'] = data['predicted_swe'].apply(lambda x: 0 if x < 2 else x)\n    print(data[:5])\n\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    x, y = m(data['lon'].values, data['lat'].values)\n\n    # Create a figure with a white background\n    fig = plt.figure(facecolor='white')\n\n    # Define your custom function to map data values to colors\n    def map_value_to_color(value):\n        # Iterate through the value ranges to find the appropriate color index\n        for i, range_max in enumerate(value_ranges):\n            if value <= range_max:\n                return colors[i]\n        \n        # If the value is greater than the largest range, return the last color\n        return colors[-1]\n\n    # Map predicted_swe values to colors using the custom function\n    color_mapping = [map_value_to_color(value) for value in data['predicted_swe']]\n    \n    # Plot the data using the custom colormap\n    plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\n\n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_date = datetime(1900, 1, 1)\n    day_value = day_index\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    timestamp_string = result_date.strftime(\"%Y-%m-%d\")\n    \n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    # Create custom legend elements using the same colormap\n    legend_elements = [Patch(color=colors[i], label=f\"{value_ranges[i]} - {value_ranges[i+1]-1}\" if i < len(value_ranges) - 1 else f\"> {value_ranges[-1]}\") for i in range(len(value_ranges))]\n\n    # Create the legend outside the map\n    legend = plt.legend(handles=legend_elements, loc='upper left', title='Legend', fontsize=8)\n    legend.set_bbox_to_anchor((1.01, 1)) \n\n    # Remove the color bar\n    plt.colorbar().remove()\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Set the aspect ratio to 'equal' to keep the plot at the center\n    plt.gca().set_aspect('equal', adjustable='box')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15, right=0.80)  # Adjust right margin to accommodate the legend\n    # Show the plot or save it to a file\n    new_plot_path = f'/home/chetana/gridmet_test_run/predicted_swe-{timestamp_string}.png'\n    print(f\"The new plot is saved to {new_plot_path}\")\n    plt.savefig(new_plot_path)\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "",
  "history_begin_time" : 1695106467388,
  "history_end_time" : 1695106471587,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "100001",
  "indicator" : "Failed"
},{
  "history_id" : "4S86FcZYPZUk",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport uuid\nfrom snowcast_utils import day_index\nimport matplotlib.colors as mcolors\nfrom matplotlib.patches import Patch\n\n# Define the custom colormap with specified colors and ranges\ncolors = [\n    (0.8627, 0.8627, 0.8627),  # #DCDCDC - 0 - 1\n    (0.8627, 1.0000, 1.0000),  # #DCFFFF - 1 - 2\n    (0.6000, 1.0000, 1.0000),  # #99FFFF - 2 - 4\n    (0.5569, 0.8235, 1.0000),  # #8ED2FF - 4 - 6\n    (0.4509, 0.6196, 0.8745),  # #739EDF - 6 - 8\n    (0.4157, 0.4706, 1.0000),  # #6A78FF - 8 - 10\n    (0.4235, 0.2784, 1.0000),  # #6C47FF - 10 - 12\n    (0.5529, 0.0980, 1.0000),  # #8D19FF - 12 - 14\n    (0.7333, 0.0000, 0.9176),  # #BB00EA - 14 - 16\n    (0.8392, 0.0000, 0.7490),  # #D600BF - 16 - 18\n    (0.7569, 0.0039, 0.4549),  # #C10074 - 18 - 20\n    (0.6784, 0.0000, 0.1961),  # #AD0032 - 20 - 30\n    (0.5020, 0.0000, 0.0000)   # #800000 - > 30\n]\n\ncmap_name = 'custom_snow_colormap'\ncustom_cmap = mcolors.ListedColormap(colors)\n\n# Define the lat_lon_to_map_coordinates function\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\n# Define your value ranges for color mapping\nvalue_ranges = [1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 30]\n\ndef convert_csvs_to_images():\n    data = pd.read_csv(\"/home/chetana/gridmet_test_run/test_data_predicted.csv\")\n    data['predicted_swe'].fillna(0, inplace=True)\n    data['predicted_swe'] = data['predicted_swe'].apply(lambda x: 0 if x < 2 else x)\n    print(data[:5])\n\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    x, y = m(data['lon'].values, data['lat'].values)\n\n    # Create a figure with a white background\n    fig = plt.figure(facecolor='white')\n\n    # Define your custom function to map data values to colors\n    def map_value_to_color(value):\n        # Iterate through the value ranges to find the appropriate color index\n        for i, range_max in enumerate(value_ranges):\n            if value <= range_max:\n                return colors[i]\n        \n        # If the value is greater than the largest range, return the last color\n        return colors[-1]\n\n    # Map predicted_swe values to colors using the custom function\n    color_mapping = [map_value_to_color(value) for value in data['predicted_swe']]\n    \n    # Plot the data using the custom colormap\n    plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\n\n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_date = datetime(1900, 1, 1)\n    day_value = day_index\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    timestamp_string = result_date.strftime(\"%Y-%m-%d\")\n    \n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    # Create custom legend elements using the same colormap\n    legend_elements = [Patch(color=colors[i], label=f\"{value_ranges[i]} - {value_ranges[i+1]-1}\" if i < len(value_ranges) - 1 else f\"> {value_ranges[-1]}\") for i in range(len(value_ranges))]\n\n    # Create the legend outside the map\n    legend = plt.legend(handles=legend_elements, loc='upper left', title='Legend', fontsize=8)\n    legend.set_bbox_to_anchor((1.01, 1)) \n\n    # Remove the color bar\n    plt.colorbar().remove()\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Set the aspect ratio to 'equal' to keep the plot at the center\n    plt.gca().set_aspect('equal', adjustable='box')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15, right=0.80)  # Adjust right margin to accommodate the legend\n    # Show the plot or save it to a file\n    new_plot_path = f'/home/chetana/gridmet_test_run/predicted_swe-{timestamp_string}.png'\n    print(f\"The new plot is saved to {new_plot_path}\")\n    plt.savefig(new_plot_path)\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "/home/chetana/gw-workspace/4S86FcZYPZUk/convert_results_to_images.py:70: UserWarning: No data for colormapping provided via 'c'. Parameters 'cmap' will be ignored\n  plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\ntoday date = 2023-09-19\ntest start date:  2022-11-08\ntest end date:  2023-09-19\n/home/chetana\n    lat      lon  air_temperature_tmmn  ...  Flag   date  predicted_swe\n0  49.0 -125.000                   NaN  ...   241  44871              0\n1  49.0 -124.964                   NaN  ...   241  44871              0\n2  49.0 -124.928                   NaN  ...   241  44871              0\n3  49.0 -124.892                   NaN  ...   241  44871              0\n4  49.0 -124.856                   NaN  ...   241  44871              0\n[5 rows x 22 columns]\nThe new plot is saved to /home/chetana/gridmet_test_run/predicted_swe-2022-11-08.png\n",
  "history_begin_time" : 1695106252607,
  "history_end_time" : 1695106262096,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "syjfi2f5myr",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport uuid\nfrom snowcast_utils import day_index\nimport matplotlib.colors as mcolors\nfrom matplotlib.patches import Patch\n\n# Define the custom colormap with specified colors and ranges\ncolors = [\n    (0.8627, 0.8627, 0.8627),  # #DCDCDC - 0 - 1\n    (0.8627, 1.0000, 1.0000),  # #DCFFFF - 1 - 2\n    (0.6000, 1.0000, 1.0000),  # #99FFFF - 2 - 4\n    (0.5569, 0.8235, 1.0000),  # #8ED2FF - 4 - 6\n    (0.4509, 0.6196, 0.8745),  # #739EDF - 6 - 8\n    (0.4157, 0.4706, 1.0000),  # #6A78FF - 8 - 10\n    (0.4235, 0.2784, 1.0000),  # #6C47FF - 10 - 12\n    (0.5529, 0.0980, 1.0000),  # #8D19FF - 12 - 14\n    (0.7333, 0.0000, 0.9176),  # #BB00EA - 14 - 16\n    (0.8392, 0.0000, 0.7490),  # #D600BF - 16 - 18\n    (0.7569, 0.0039, 0.4549),  # #C10074 - 18 - 20\n    (0.6784, 0.0000, 0.1961),  # #AD0032 - 20 - 30\n    (0.5020, 0.0000, 0.0000)   # #800000 - > 30\n]\n\ncmap_name = 'custom_snow_colormap'\ncustom_cmap = mcolors.ListedColormap(colors)\n\n# Define the lat_lon_to_map_coordinates function\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\n# Define your value ranges for color mapping\nvalue_ranges = [1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 30]\n\ndef convert_csvs_to_images():\n    data = pd.read_csv(\"/home/chetana/gridmet_test_run/test_data_predicted.csv\")\n    data['predicted_swe'].fillna(0, inplace=True)\n    data['predicted_swe'] = data['predicted_swe'].apply(lambda x: 0 if x < 2 else x)\n    print(data[:5])\n\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    x, y = m(data['lon'].values, data['lat'].values)\n\n    # Create a figure with a white background\n    fig = plt.figure(facecolor='white')\n\n    # Define your custom function to map data values to colors\n    def map_value_to_color(value):\n        # Iterate through the value ranges to find the appropriate color index\n        for i, range_max in enumerate(value_ranges):\n            if value <= range_max:\n                return colors[i]\n        \n        # If the value is greater than the largest range, return the last color\n        return colors[-1]\n\n    # Map predicted_swe values to colors using the custom function\n    color_mapping = [map_value_to_color(value) for value in data['predicted_swe']]\n    \n    # Plot the data using the custom colormap\n    plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\n\n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_date = datetime(1900, 1, 1)\n    day_value = day_index\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    timestamp_string = result_date.strftime(\"%Y-%m-%d\")\n    \n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    # Create custom legend elements using the same colormap\n    legend_elements = [Patch(color=colors[i], label=f\"{value_ranges[i]} - {value_ranges[i+1]-1}\" if i < len(value_ranges) - 1 else f\"> {value_ranges[-1]}\") for i in range(len(value_ranges))]\n\n    # Create the legend outside the map\n    legend = plt.legend(handles=legend_elements, loc='upper left', title='Legend', fontsize=8)\n    legend.set_bbox_to_anchor((1.01, 1)) \n\n    # Remove the color bar\n    plt.colorbar().remove()\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Set the aspect ratio to 'equal' to keep the plot at the center\n    plt.gca().set_aspect('equal', adjustable='box')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15, right=0.80)  # Adjust right margin to accommodate the legend\n    # Show the plot or save it to a file\n    new_plot_path = f'/home/chetana/gridmet_test_run/predicted_swe-{timestamp_string}.png'\n    print(f\"The new plot is saved to {new_plot_path}\")\n    plt.savefig(new_plot_path)\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "/home/chetana/gw-workspace/syjfi2f5myr/convert_results_to_images.py:70: UserWarning: No data for colormapping provided via 'c'. Parameters 'cmap' will be ignored\n  plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\ntoday date = 2023-09-18\ntest start date:  2022-11-08\ntest end date:  2023-09-18\n/home/chetana\n    lat      lon  mean_vapor_pressure_deficit  ...  Flag   date  predicted_swe\n0  49.0 -125.000                          NaN  ...   241  44869              0\n1  49.0 -124.964                          NaN  ...   241  44869              0\n2  49.0 -124.928                          NaN  ...   241  44869              0\n3  49.0 -124.892                          NaN  ...   241  44869              0\n4  49.0 -124.856                          NaN  ...   241  44869              0\n[5 rows x 20 columns]\nThe new plot is saved to /home/chetana/gridmet_test_run/predicted_swe-2022-11-08.png\n",
  "history_begin_time" : 1695054076102,
  "history_end_time" : 1695054086697,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "100001",
  "indicator" : "Done"
},{
  "history_id" : "njowi9ewl9d",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport uuid\nfrom snowcast_utils import day_index\nimport matplotlib.colors as mcolors\nfrom matplotlib.patches import Patch\n\n# Define the custom colormap with specified colors and ranges\ncolors = [\n    (0.8627, 0.8627, 0.8627),  # #DCDCDC - 0 - 1\n    (0.8627, 1.0000, 1.0000),  # #DCFFFF - 1 - 2\n    (0.6000, 1.0000, 1.0000),  # #99FFFF - 2 - 4\n    (0.5569, 0.8235, 1.0000),  # #8ED2FF - 4 - 6\n    (0.4509, 0.6196, 0.8745),  # #739EDF - 6 - 8\n    (0.4157, 0.4706, 1.0000),  # #6A78FF - 8 - 10\n    (0.4235, 0.2784, 1.0000),  # #6C47FF - 10 - 12\n    (0.5529, 0.0980, 1.0000),  # #8D19FF - 12 - 14\n    (0.7333, 0.0000, 0.9176),  # #BB00EA - 14 - 16\n    (0.8392, 0.0000, 0.7490),  # #D600BF - 16 - 18\n    (0.7569, 0.0039, 0.4549),  # #C10074 - 18 - 20\n    (0.6784, 0.0000, 0.1961),  # #AD0032 - 20 - 30\n    (0.5020, 0.0000, 0.0000)   # #800000 - > 30\n]\n\ncmap_name = 'custom_snow_colormap'\ncustom_cmap = mcolors.ListedColormap(colors)\n\n# Define the lat_lon_to_map_coordinates function\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\n# Define your value ranges for color mapping\nvalue_ranges = [1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 30]\n\ndef convert_csvs_to_images():\n    data = pd.read_csv(\"/home/chetana/gridmet_test_run/test_data_predicted.csv\")\n    data['predicted_swe'].fillna(0, inplace=True)\n    data['predicted_swe'] = data['predicted_swe'].apply(lambda x: 0 if x < 2 else x)\n    print(data[:5])\n\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    x, y = m(data['lon'].values, data['lat'].values)\n\n    # Create a figure with a white background\n    fig = plt.figure(facecolor='white')\n\n    # Define your custom function to map data values to colors\n    def map_value_to_color(value):\n        # Iterate through the value ranges to find the appropriate color index\n        for i, range_max in enumerate(value_ranges):\n            if value <= range_max:\n                return colors[i]\n        \n        # If the value is greater than the largest range, return the last color\n        return colors[-1]\n\n    # Map predicted_swe values to colors using the custom function\n    color_mapping = [map_value_to_color(value) for value in data['predicted_swe']]\n    \n    # Plot the data using the custom colormap\n    plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\n\n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_date = datetime(1900, 1, 1)\n    day_value = day_index\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    timestamp_string = result_date.strftime(\"%Y-%m-%d\")\n    \n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    # Create custom legend elements using the same colormap\n    legend_elements = [Patch(color=colors[i], label=f\"{value_ranges[i]} - {value_ranges[i+1]-1}\" if i < len(value_ranges) - 1 else f\"> {value_ranges[-1]}\") for i in range(len(value_ranges))]\n\n    # Create the legend outside the map\n    legend = plt.legend(handles=legend_elements, loc='upper left', title='Legend', fontsize=8)\n    legend.set_bbox_to_anchor((1.01, 1)) \n\n    # Remove the color bar\n    plt.colorbar().remove()\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Set the aspect ratio to 'equal' to keep the plot at the center\n    plt.gca().set_aspect('equal', adjustable='box')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15, right=0.80)  # Adjust right margin to accommodate the legend\n    # Show the plot or save it to a file\n    new_plot_path = f'/home/chetana/gridmet_test_run/predicted_swe-{timestamp_string}.png'\n    print(f\"The new plot is saved to {new_plot_path}\")\n    plt.savefig(new_plot_path)\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "/home/chetana/gw-workspace/njowi9ewl9d/convert_results_to_images.py:70: UserWarning: No data for colormapping provided via 'c'. Parameters 'cmap' will be ignored\n  plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\ntoday date = 2023-09-18\ntest start date:  2022-11-06\ntest end date:  2023-09-18\n/home/chetana\n    lat      lon  mean_vapor_pressure_deficit  ...  Flag   date  predicted_swe\n0  49.0 -125.000                          NaN  ...   241  44869              0\n1  49.0 -124.964                          NaN  ...   241  44869              0\n2  49.0 -124.928                          NaN  ...   241  44869              0\n3  49.0 -124.892                          NaN  ...   241  44869              0\n4  49.0 -124.856                          NaN  ...   241  44869              0\n[5 rows x 20 columns]\nThe new plot is saved to /home/chetana/gridmet_test_run/predicted_swe-2022-11-06.png\n",
  "history_begin_time" : 1695053829315,
  "history_end_time" : 1695053839801,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "100001",
  "indicator" : "Done"
},{
  "history_id" : "ctaw8b3ns2r",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport uuid\nfrom snowcast_utils import day_index\nimport matplotlib.colors as mcolors\nfrom matplotlib.patches import Patch\n\n# Define the custom colormap with specified colors and ranges\ncolors = [\n    (0.8627, 0.8627, 0.8627),  # #DCDCDC - 0 - 1\n    (0.8627, 1.0000, 1.0000),  # #DCFFFF - 1 - 2\n    (0.6000, 1.0000, 1.0000),  # #99FFFF - 2 - 4\n    (0.5569, 0.8235, 1.0000),  # #8ED2FF - 4 - 6\n    (0.4509, 0.6196, 0.8745),  # #739EDF - 6 - 8\n    (0.4157, 0.4706, 1.0000),  # #6A78FF - 8 - 10\n    (0.4235, 0.2784, 1.0000),  # #6C47FF - 10 - 12\n    (0.5529, 0.0980, 1.0000),  # #8D19FF - 12 - 14\n    (0.7333, 0.0000, 0.9176),  # #BB00EA - 14 - 16\n    (0.8392, 0.0000, 0.7490),  # #D600BF - 16 - 18\n    (0.7569, 0.0039, 0.4549),  # #C10074 - 18 - 20\n    (0.6784, 0.0000, 0.1961),  # #AD0032 - 20 - 30\n    (0.5020, 0.0000, 0.0000)   # #800000 - > 30\n]\n\ncmap_name = 'custom_snow_colormap'\ncustom_cmap = mcolors.ListedColormap(colors)\n\n# Define the lat_lon_to_map_coordinates function\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\n# Define your value ranges for color mapping\nvalue_ranges = [1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 30]\n\ndef convert_csvs_to_images():\n    data = pd.read_csv(\"/home/chetana/gridmet_test_run/test_data_predicted.csv\")\n    data['predicted_swe'].fillna(0, inplace=True)\n    data['predicted_swe'] = data['predicted_swe'].apply(lambda x: 0 if x < 2 else x)\n    print(data[:5])\n\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    x, y = m(data['lon'].values, data['lat'].values)\n\n    # Create a figure with a white background\n    fig = plt.figure(facecolor='white')\n\n    # Define your custom function to map data values to colors\n    def map_value_to_color(value):\n        # Iterate through the value ranges to find the appropriate color index\n        for i, range_max in enumerate(value_ranges):\n            if value <= range_max:\n                return colors[i]\n        \n        # If the value is greater than the largest range, return the last color\n        return colors[-1]\n\n    # Map predicted_swe values to colors using the custom function\n    color_mapping = [map_value_to_color(value) for value in data['predicted_swe']]\n    \n    # Plot the data using the custom colormap\n    plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\n\n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_date = datetime(1900, 1, 1)\n    day_value = day_index\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    timestamp_string = result_date.strftime(\"%Y-%m-%d\")\n    \n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    # Create custom legend elements using the same colormap\n    legend_elements = [Patch(color=colors[i], label=f\"{value_ranges[i]} - {value_ranges[i+1]-1}\" if i < len(value_ranges) - 1 else f\"> {value_ranges[-1]}\") for i in range(len(value_ranges))]\n\n    # Create the legend outside the map\n    legend = plt.legend(handles=legend_elements, loc='upper left', title='Legend', fontsize=8)\n    legend.set_bbox_to_anchor((1.01, 1)) \n\n    # Remove the color bar\n    plt.colorbar().remove()\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Set the aspect ratio to 'equal' to keep the plot at the center\n    plt.gca().set_aspect('equal', adjustable='box')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15, right=0.80)  # Adjust right margin to accommodate the legend\n    # Show the plot or save it to a file\n    new_plot_path = f'/home/chetana/gridmet_test_run/predicted_swe-{timestamp_string}.png'\n    print(f\"The new plot is saved to {new_plot_path}\")\n    plt.savefig(new_plot_path)\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "/home/chetana/gw-workspace/ctaw8b3ns2r/convert_results_to_images.py:70: UserWarning: No data for colormapping provided via 'c'. Parameters 'cmap' will be ignored\n  plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\ntoday date = 2023-09-18\ntest start date:  2022-11-06\ntest end date:  2023-09-18\n/home/chetana\n    lat      lon  mean_vapor_pressure_deficit  ...  Flag   date  predicted_swe\n0  49.0 -125.000                          NaN  ...   241  44869              0\n1  49.0 -124.964                          NaN  ...   241  44869              0\n2  49.0 -124.928                          NaN  ...   241  44869              0\n3  49.0 -124.892                          NaN  ...   241  44869              0\n4  49.0 -124.856                          NaN  ...   241  44869              0\n[5 rows x 20 columns]\nThe new plot is saved to /home/chetana/gridmet_test_run/predicted_swe-2022-11-06.png\n",
  "history_begin_time" : 1695053769825,
  "history_end_time" : 1695053781090,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "100001",
  "indicator" : "Done"
},{
  "history_id" : "tgksp782o6a",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport uuid\nfrom snowcast_utils import day_index\nimport matplotlib.colors as mcolors\nfrom matplotlib.patches import Patch\n\n# Define the custom colormap with specified colors and ranges\ncolors = [\n    (0.8627, 0.8627, 0.8627),  # #DCDCDC - 0 - 1\n    (0.8627, 1.0000, 1.0000),  # #DCFFFF - 1 - 2\n    (0.6000, 1.0000, 1.0000),  # #99FFFF - 2 - 4\n    (0.5569, 0.8235, 1.0000),  # #8ED2FF - 4 - 6\n    (0.4509, 0.6196, 0.8745),  # #739EDF - 6 - 8\n    (0.4157, 0.4706, 1.0000),  # #6A78FF - 8 - 10\n    (0.4235, 0.2784, 1.0000),  # #6C47FF - 10 - 12\n    (0.5529, 0.0980, 1.0000),  # #8D19FF - 12 - 14\n    (0.7333, 0.0000, 0.9176),  # #BB00EA - 14 - 16\n    (0.8392, 0.0000, 0.7490),  # #D600BF - 16 - 18\n    (0.7569, 0.0039, 0.4549),  # #C10074 - 18 - 20\n    (0.6784, 0.0000, 0.1961),  # #AD0032 - 20 - 30\n    (0.5020, 0.0000, 0.0000)   # #800000 - > 30\n]\n\ncmap_name = 'custom_snow_colormap'\ncustom_cmap = mcolors.ListedColormap(colors)\n\n# Define the lat_lon_to_map_coordinates function\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\n# Define your value ranges for color mapping\nvalue_ranges = [1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 30]\n\ndef convert_csvs_to_images():\n    data = pd.read_csv(\"/home/chetana/gridmet_test_run/test_data_predicted.csv\")\n    data['predicted_swe'].fillna(0, inplace=True)\n    data['predicted_swe'] = data['predicted_swe'].apply(lambda x: 0 if x < 2 else x)\n    print(data[:5])\n\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    x, y = m(data['lon'].values, data['lat'].values)\n\n    # Create a figure with a white background\n    fig = plt.figure(facecolor='white')\n\n    # Define your custom function to map data values to colors\n    def map_value_to_color(value):\n        # Iterate through the value ranges to find the appropriate color index\n        for i, range_max in enumerate(value_ranges):\n            if value <= range_max:\n                return colors[i]\n        \n        # If the value is greater than the largest range, return the last color\n        return colors[-1]\n\n    # Map predicted_swe values to colors using the custom function\n    color_mapping = [map_value_to_color(value) for value in data['predicted_swe']]\n    \n    # Plot the data using the custom colormap\n    plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\n\n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_date = datetime(1900, 1, 1)\n    day_value = day_index\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    timestamp_string = result_date.strftime(\"%Y-%m-%d\")\n    \n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    # Create custom legend elements using the same colormap\n    legend_elements = [Patch(color=colors[i], label=f\"{value_ranges[i]} - {value_ranges[i+1]-1}\" if i < len(value_ranges) - 1 else f\"> {value_ranges[-1]}\") for i in range(len(value_ranges))]\n\n    # Create the legend outside the map\n    legend = plt.legend(handles=legend_elements, loc='upper left', title='Legend', fontsize=8)\n    legend.set_bbox_to_anchor((1.01, 1)) \n\n    # Remove the color bar\n    plt.colorbar().remove()\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Set the aspect ratio to 'equal' to keep the plot at the center\n    plt.gca().set_aspect('equal', adjustable='box')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15, right=0.80)  # Adjust right margin to accommodate the legend\n    # Show the plot or save it to a file\n    new_plot_path = f'/home/chetana/gridmet_test_run/predicted_swe-{timestamp_string}.png'\n    print(f\"The new plot is saved to {new_plot_path}\")\n    plt.savefig(new_plot_path)\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "/home/chetana/gw-workspace/tgksp782o6a/convert_results_to_images.py:70: UserWarning: No data for colormapping provided via 'c'. Parameters 'cmap' will be ignored\n  plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\ntoday date = 2023-09-17\ntest start date:  2022-11-06\ntest end date:  2023-09-17\n/home/chetana\n    lat      lon  mean_vapor_pressure_deficit  ...  Flag   date  predicted_swe\n0  49.0 -125.000                          NaN  ...   241  44869              0\n1  49.0 -124.964                          NaN  ...   241  44869              0\n2  49.0 -124.928                          NaN  ...   241  44869              0\n3  49.0 -124.892                          NaN  ...   241  44869              0\n4  49.0 -124.856                          NaN  ...   241  44869              0\n[5 rows x 20 columns]\nThe new plot is saved to /home/chetana/gridmet_test_run/predicted_swe-2022-11-06.png\n",
  "history_begin_time" : 1694971191857,
  "history_end_time" : 1694972839688,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "100001",
  "indicator" : "Stopped"
},{
  "history_id" : "kwze8iol52m",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport uuid\nfrom snowcast_utils import day_index\nimport matplotlib.colors as mcolors\nfrom matplotlib.patches import Patch\n\n# Define the custom colormap with specified colors and ranges\ncolors = [\n    (0.8627, 0.8627, 0.8627),  # #DCDCDC - 0 - 1\n    (0.8627, 1.0000, 1.0000),  # #DCFFFF - 1 - 2\n    (0.6000, 1.0000, 1.0000),  # #99FFFF - 2 - 4\n    (0.5569, 0.8235, 1.0000),  # #8ED2FF - 4 - 6\n    (0.4509, 0.6196, 0.8745),  # #739EDF - 6 - 8\n    (0.4157, 0.4706, 1.0000),  # #6A78FF - 8 - 10\n    (0.4235, 0.2784, 1.0000),  # #6C47FF - 10 - 12\n    (0.5529, 0.0980, 1.0000),  # #8D19FF - 12 - 14\n    (0.7333, 0.0000, 0.9176),  # #BB00EA - 14 - 16\n    (0.8392, 0.0000, 0.7490),  # #D600BF - 16 - 18\n    (0.7569, 0.0039, 0.4549),  # #C10074 - 18 - 20\n    (0.6784, 0.0000, 0.1961),  # #AD0032 - 20 - 30\n    (0.5020, 0.0000, 0.0000)   # #800000 - > 30\n]\n\ncmap_name = 'custom_snow_colormap'\ncustom_cmap = mcolors.ListedColormap(colors)\n\n# Define the lat_lon_to_map_coordinates function\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\n# Define your value ranges for color mapping\nvalue_ranges = [1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 30]\n\ndef convert_csvs_to_images():\n    data = pd.read_csv(\"/home/chetana/gridmet_test_run/test_data_predicted.csv\")\n    data['predicted_swe'].fillna(0, inplace=True)\n    data['predicted_swe'] = data['predicted_swe'].apply(lambda x: 0 if x < 2 else x)\n    print(data[:5])\n\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    x, y = m(data['lon'].values, data['lat'].values)\n\n    # Create a figure with a white background\n    fig = plt.figure(facecolor='white')\n\n    # Define your custom function to map data values to colors\n    def map_value_to_color(value):\n        # Iterate through the value ranges to find the appropriate color index\n        for i, range_max in enumerate(value_ranges):\n            if value <= range_max:\n                return colors[i]\n        \n        # If the value is greater than the largest range, return the last color\n        return colors[-1]\n\n    # Map predicted_swe values to colors using the custom function\n    color_mapping = [map_value_to_color(value) for value in data['predicted_swe']]\n    \n    # Plot the data using the custom colormap\n    plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\n\n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_date = datetime(1900, 1, 1)\n    day_value = day_index\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    timestamp_string = result_date.strftime(\"%Y-%m-%d\")\n    \n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    # Create custom legend elements using the same colormap\n    legend_elements = [Patch(color=colors[i], label=f\"{value_ranges[i]} - {value_ranges[i+1]-1}\" if i < len(value_ranges) - 1 else f\"> {value_ranges[-1]}\") for i in range(len(value_ranges))]\n\n    # Create the legend outside the map\n    legend = plt.legend(handles=legend_elements, loc='upper left', title='Legend', fontsize=8)\n    legend.set_bbox_to_anchor((1.01, 1)) \n\n    # Remove the color bar\n    plt.colorbar().remove()\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Set the aspect ratio to 'equal' to keep the plot at the center\n    plt.gca().set_aspect('equal', adjustable='box')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15, right=0.80)  # Adjust right margin to accommodate the legend\n    # Show the plot or save it to a file\n    new_plot_path = f'/home/chetana/gridmet_test_run/predicted_swe-{timestamp_string}.png'\n    print(f\"The new plot is saved to {new_plot_path}\")\n    plt.savefig(new_plot_path)\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "/home/chetana/gw-workspace/kwze8iol52m/convert_results_to_images.py:70: UserWarning: No data for colormapping provided via 'c'. Parameters 'cmap' will be ignored\n  plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\ntoday date = 2023-09-17\ntest start date:  2022-11-05\ntest end date:  2023-09-17\n/home/chetana\n    lat      lon  mean_vapor_pressure_deficit  ...  Flag   date  predicted_swe\n0  49.0 -125.000                          NaN  ...   241  44868              0\n1  49.0 -124.964                          NaN  ...   241  44868              0\n2  49.0 -124.928                          NaN  ...   241  44868              0\n3  49.0 -124.892                          NaN  ...   241  44868              0\n4  49.0 -124.856                          NaN  ...   241  44868              0\n[5 rows x 20 columns]\nThe new plot is saved to /home/chetana/gridmet_test_run/predicted_swe-2022-11-05.png\n",
  "history_begin_time" : 1694970761658,
  "history_end_time" : 1694970772409,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "100001",
  "indicator" : "Done"
},{
  "history_id" : "g473ur70nqp",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport uuid\nfrom snowcast_utils import day_index\nimport matplotlib.colors as mcolors\nfrom matplotlib.patches import Patch\n\n# Define the custom colormap with specified colors and ranges\ncolors = [\n    (0.8627, 0.8627, 0.8627),  # #DCDCDC - 0 - 1\n    (0.8627, 1.0000, 1.0000),  # #DCFFFF - 1 - 2\n    (0.6000, 1.0000, 1.0000),  # #99FFFF - 2 - 4\n    (0.5569, 0.8235, 1.0000),  # #8ED2FF - 4 - 6\n    (0.4509, 0.6196, 0.8745),  # #739EDF - 6 - 8\n    (0.4157, 0.4706, 1.0000),  # #6A78FF - 8 - 10\n    (0.4235, 0.2784, 1.0000),  # #6C47FF - 10 - 12\n    (0.5529, 0.0980, 1.0000),  # #8D19FF - 12 - 14\n    (0.7333, 0.0000, 0.9176),  # #BB00EA - 14 - 16\n    (0.8392, 0.0000, 0.7490),  # #D600BF - 16 - 18\n    (0.7569, 0.0039, 0.4549),  # #C10074 - 18 - 20\n    (0.6784, 0.0000, 0.1961),  # #AD0032 - 20 - 30\n    (0.5020, 0.0000, 0.0000)   # #800000 - > 30\n]\n\ncmap_name = 'custom_snow_colormap'\ncustom_cmap = mcolors.ListedColormap(colors)\n\n# Define the lat_lon_to_map_coordinates function\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\n# Define your value ranges for color mapping\nvalue_ranges = [1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 30]\n\ndef convert_csvs_to_images():\n    data = pd.read_csv(\"/home/chetana/gridmet_test_run/test_data_predicted.csv\")\n    data['predicted_swe'].fillna(0, inplace=True)\n    data['predicted_swe'] = data['predicted_swe'].apply(lambda x: 0 if x < 2 else x)\n    print(data[:5])\n\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    x, y = m(data['lon'].values, data['lat'].values)\n\n    # Create a figure with a white background\n    fig = plt.figure(facecolor='white')\n\n    # Define your custom function to map data values to colors\n    def map_value_to_color(value):\n        # Iterate through the value ranges to find the appropriate color index\n        for i, range_max in enumerate(value_ranges):\n            if value <= range_max:\n                return colors[i]\n        \n        # If the value is greater than the largest range, return the last color\n        return colors[-1]\n\n    # Map predicted_swe values to colors using the custom function\n    color_mapping = [map_value_to_color(value) for value in data['predicted_swe']]\n    \n    # Plot the data using the custom colormap\n    plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\n\n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_date = datetime(1900, 1, 1)\n    day_value = day_index\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    timestamp_string = result_date.strftime(\"%Y-%m-%d\")\n    \n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    # Create custom legend elements using the same colormap\n    legend_elements = [Patch(color=colors[i], label=f\"{value_ranges[i]} - {value_ranges[i+1]-1}\" if i < len(value_ranges) - 1 else f\"> {value_ranges[-1]}\") for i in range(len(value_ranges))]\n\n    # Create the legend outside the map\n    legend = plt.legend(handles=legend_elements, loc='upper left', title='Legend', fontsize=8)\n    legend.set_bbox_to_anchor((1.01, 1)) \n\n    # Remove the color bar\n    plt.colorbar().remove()\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Set the aspect ratio to 'equal' to keep the plot at the center\n    plt.gca().set_aspect('equal', adjustable='box')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15, right=0.80)  # Adjust right margin to accommodate the legend\n    # Show the plot or save it to a file\n    new_plot_path = f'/home/chetana/gridmet_test_run/predicted_swe-{timestamp_string}.png'\n    print(f\"The new plot is saved to {new_plot_path}\")\n    plt.savefig(new_plot_path)\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "/home/chetana/gw-workspace/g473ur70nqp/convert_results_to_images.py:70: UserWarning: No data for colormapping provided via 'c'. Parameters 'cmap' will be ignored\n  plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\ntoday date = 2023-09-17\ntest start date:  2022-11-05\ntest end date:  2023-09-17\n/home/chetana\n    lat      lon  mean_vapor_pressure_deficit  ...  Flag   date  predicted_swe\n0  49.0 -125.000                          NaN  ...   241  44868              0\n1  49.0 -124.964                          NaN  ...   241  44868              0\n2  49.0 -124.928                          NaN  ...   241  44868              0\n3  49.0 -124.892                          NaN  ...   241  44868              0\n4  49.0 -124.856                          NaN  ...   241  44868              0\n[5 rows x 20 columns]\nThe new plot is saved to /home/chetana/gridmet_test_run/predicted_swe-2022-11-05.png\n",
  "history_begin_time" : 1694970640619,
  "history_end_time" : 1694970651037,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "100001",
  "indicator" : "Done"
},{
  "history_id" : "yol6k8asvv9",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport uuid\nfrom snowcast_utils import day_index\nimport matplotlib.colors as mcolors\nfrom matplotlib.patches import Patch\n\n# Define the custom colormap with specified colors and ranges\ncolors = [\n    (0.8627, 0.8627, 0.8627),  # #DCDCDC - 0 - 1\n    (0.8627, 1.0000, 1.0000),  # #DCFFFF - 1 - 2\n    (0.6000, 1.0000, 1.0000),  # #99FFFF - 2 - 4\n    (0.5569, 0.8235, 1.0000),  # #8ED2FF - 4 - 6\n    (0.4509, 0.6196, 0.8745),  # #739EDF - 6 - 8\n    (0.4157, 0.4706, 1.0000),  # #6A78FF - 8 - 10\n    (0.4235, 0.2784, 1.0000),  # #6C47FF - 10 - 12\n    (0.5529, 0.0980, 1.0000),  # #8D19FF - 12 - 14\n    (0.7333, 0.0000, 0.9176),  # #BB00EA - 14 - 16\n    (0.8392, 0.0000, 0.7490),  # #D600BF - 16 - 18\n    (0.7569, 0.0039, 0.4549),  # #C10074 - 18 - 20\n    (0.6784, 0.0000, 0.1961),  # #AD0032 - 20 - 30\n    (0.5020, 0.0000, 0.0000)   # #800000 - > 30\n]\n\ncmap_name = 'custom_snow_colormap'\ncustom_cmap = mcolors.ListedColormap(colors)\n\n# Define the lat_lon_to_map_coordinates function\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\n# Define your value ranges for color mapping\nvalue_ranges = [1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 30]\n\ndef convert_csvs_to_images():\n    data = pd.read_csv(\"/home/chetana/gridmet_test_run/test_data_predicted.csv\")\n    data['predicted_swe'].fillna(0, inplace=True)\n    data['predicted_swe'] = data['predicted_swe'].apply(lambda x: 0 if x < 2 else x)\n    print(data[:5])\n\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    x, y = m(data['lon'].values, data['lat'].values)\n\n    # Create a figure with a white background\n    fig = plt.figure(facecolor='white')\n\n    # Define your custom function to map data values to colors\n    def map_value_to_color(value):\n        # Iterate through the value ranges to find the appropriate color index\n        for i, range_max in enumerate(value_ranges):\n            if value <= range_max:\n                return colors[i]\n        \n        # If the value is greater than the largest range, return the last color\n        return colors[-1]\n\n    # Map predicted_swe values to colors using the custom function\n    color_mapping = [map_value_to_color(value) for value in data['predicted_swe']]\n    \n    # Plot the data using the custom colormap\n    plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\n\n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_date = datetime(1900, 1, 1)\n    day_value = day_index\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    timestamp_string = result_date.strftime(\"%Y-%m-%d\")\n    \n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    # Create custom legend elements using the same colormap\n    legend_elements = [Patch(color=colors[i], label=f\"{value_ranges[i]} - {value_ranges[i+1]-1}\" if i < len(value_ranges) - 1 else f\"> {value_ranges[-1]}\") for i in range(len(value_ranges))]\n\n    # Create the legend outside the map\n    legend = plt.legend(handles=legend_elements, loc='upper left', title='Legend', fontsize=8)\n    legend.set_bbox_to_anchor((1.01, 1)) \n\n    # Remove the color bar\n    plt.colorbar().remove()\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Set the aspect ratio to 'equal' to keep the plot at the center\n    plt.gca().set_aspect('equal', adjustable='box')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15, right=0.80)  # Adjust right margin to accommodate the legend\n    # Show the plot or save it to a file\n    new_plot_path = f'/home/chetana/gridmet_test_run/predicted_swe-{timestamp_string}.png'\n    print(f\"The new plot is saved to {new_plot_path}\")\n    plt.savefig(new_plot_path)\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "/home/chetana/gw-workspace/yol6k8asvv9/convert_results_to_images.py:70: UserWarning: No data for colormapping provided via 'c'. Parameters 'cmap' will be ignored\n  plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\ntoday date = 2023-09-17\ntest start date:  2023-05-05\ntest end date:  2023-09-17\n/home/chetana\n    lat      lon  mean_vapor_pressure_deficit  ...  Flag   date  predicted_swe\n0  49.0 -125.000                          NaN  ...   241  45049            0.0\n1  49.0 -124.964                          NaN  ...   241  45049            0.0\n2  49.0 -124.928                          NaN  ...   241  45049            0.0\n3  49.0 -124.892                          NaN  ...   241  45049            0.0\n4  49.0 -124.856                          NaN  ...   241  45049            0.0\n[5 rows x 20 columns]\nThe new plot is saved to /home/chetana/gridmet_test_run/predicted_swe-2023-05-05.png\n",
  "history_begin_time" : 1694970186459,
  "history_end_time" : 1694970196903,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "100001",
  "indicator" : "Done"
},{
  "history_id" : "wjsccwjbia0",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport uuid\nfrom snowcast_utils import day_index\nimport matplotlib.colors as mcolors\nfrom matplotlib.patches import Patch\n\n# Define the custom colormap with specified colors and ranges\ncolors = [\n    (0.8627, 0.8627, 0.8627),  # #DCDCDC - 0 - 1\n    (0.8627, 1.0000, 1.0000),  # #DCFFFF - 1 - 2\n    (0.6000, 1.0000, 1.0000),  # #99FFFF - 2 - 4\n    (0.5569, 0.8235, 1.0000),  # #8ED2FF - 4 - 6\n    (0.4509, 0.6196, 0.8745),  # #739EDF - 6 - 8\n    (0.4157, 0.4706, 1.0000),  # #6A78FF - 8 - 10\n    (0.4235, 0.2784, 1.0000),  # #6C47FF - 10 - 12\n    (0.5529, 0.0980, 1.0000),  # #8D19FF - 12 - 14\n    (0.7333, 0.0000, 0.9176),  # #BB00EA - 14 - 16\n    (0.8392, 0.0000, 0.7490),  # #D600BF - 16 - 18\n    (0.7569, 0.0039, 0.4549),  # #C10074 - 18 - 20\n    (0.6784, 0.0000, 0.1961),  # #AD0032 - 20 - 30\n    (0.5020, 0.0000, 0.0000)   # #800000 - > 30\n]\n\ncmap_name = 'custom_snow_colormap'\ncustom_cmap = mcolors.ListedColormap(colors)\n\n# Define the lat_lon_to_map_coordinates function\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\n# Define your value ranges for color mapping\nvalue_ranges = [1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 30]\n\ndef convert_csvs_to_images():\n    data = pd.read_csv(\"/home/chetana/gridmet_test_run/test_data_predicted.csv\")\n    data['predicted_swe'].fillna(0, inplace=True)\n    data['predicted_swe'] = data['predicted_swe'].apply(lambda x: 0 if x < 2 else x)\n    print(data[:5])\n\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    x, y = m(data['lon'].values, data['lat'].values)\n\n    # Create a figure with a white background\n    fig = plt.figure(facecolor='white')\n\n    # Define your custom function to map data values to colors\n    def map_value_to_color(value):\n        # Iterate through the value ranges to find the appropriate color index\n        for i, range_max in enumerate(value_ranges):\n            if value <= range_max:\n                return colors[i]\n        \n        # If the value is greater than the largest range, return the last color\n        return colors[-1]\n\n    # Map predicted_swe values to colors using the custom function\n    color_mapping = [map_value_to_color(value) for value in data['predicted_swe']]\n    \n    # Plot the data using the custom colormap\n    plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\n\n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_date = datetime(1900, 1, 1)\n    day_value = day_index\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    timestamp_string = result_date.strftime(\"%Y-%m-%d\")\n    \n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    # Create custom legend elements using the same colormap\n    legend_elements = [Patch(color=colors[i], label=f\"{value_ranges[i]} - {value_ranges[i+1]-1}\" if i < len(value_ranges) - 1 else f\"> {value_ranges[-1]}\") for i in range(len(value_ranges))]\n\n    # Create the legend outside the map\n    legend = plt.legend(handles=legend_elements, loc='upper left', title='Legend', fontsize=8)\n    legend.set_bbox_to_anchor((1.01, 1)) \n\n    # Remove the color bar\n    plt.colorbar().remove()\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Set the aspect ratio to 'equal' to keep the plot at the center\n    plt.gca().set_aspect('equal', adjustable='box')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15, right=0.80)  # Adjust right margin to accommodate the legend\n    # Show the plot or save it to a file\n    new_plot_path = f'/home/chetana/gridmet_test_run/predicted_swe-{timestamp_string}.png'\n    print(f\"The new plot is saved to {new_plot_path}\")\n    plt.savefig(new_plot_path)\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "/home/chetana/gw-workspace/wjsccwjbia0/convert_results_to_images.py:70: UserWarning: No data for colormapping provided via 'c'. Parameters 'cmap' will be ignored\n  plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\ntoday date = 2023-09-17\ntest start date:  2023-06-05\ntest end date:  2023-09-17\n/home/chetana\n    lat      lon  mean_vapor_pressure_deficit  ...  Flag   date  predicted_swe\n0  49.0 -125.000                          NaN  ...   255  45080            0.0\n1  49.0 -124.964                          NaN  ...   255  45080            0.0\n2  49.0 -124.928                          NaN  ...   255  45080            0.0\n3  49.0 -124.892                          NaN  ...   255  45080            0.0\n4  49.0 -124.856                          NaN  ...   255  45080            0.0\n[5 rows x 20 columns]\nThe new plot is saved to /home/chetana/gridmet_test_run/predicted_swe-2023-06-05.png\n",
  "history_begin_time" : 1694969405193,
  "history_end_time" : 1694969415690,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "100001",
  "indicator" : "Done"
},{
  "history_id" : "pg9FcET291Wo",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport uuid\nfrom snowcast_utils import day_index\nimport matplotlib.colors as mcolors\nfrom matplotlib.patches import Patch\n\n# Define the custom colormap with specified colors and ranges\ncolors = [\n    (0.8627, 0.8627, 0.8627),  # #DCDCDC - 0 - 1\n    (0.8627, 1.0000, 1.0000),  # #DCFFFF - 1 - 2\n    (0.6000, 1.0000, 1.0000),  # #99FFFF - 2 - 4\n    (0.5569, 0.8235, 1.0000),  # #8ED2FF - 4 - 6\n    (0.4509, 0.6196, 0.8745),  # #739EDF - 6 - 8\n    (0.4157, 0.4706, 1.0000),  # #6A78FF - 8 - 10\n    (0.4235, 0.2784, 1.0000),  # #6C47FF - 10 - 12\n    (0.5529, 0.0980, 1.0000),  # #8D19FF - 12 - 14\n    (0.7333, 0.0000, 0.9176),  # #BB00EA - 14 - 16\n    (0.8392, 0.0000, 0.7490),  # #D600BF - 16 - 18\n    (0.7569, 0.0039, 0.4549),  # #C10074 - 18 - 20\n    (0.6784, 0.0000, 0.1961),  # #AD0032 - 20 - 30\n    (0.5020, 0.0000, 0.0000)   # #800000 - > 30\n]\n\ncmap_name = 'custom_snow_colormap'\ncustom_cmap = mcolors.ListedColormap(colors)\n\n# Define the lat_lon_to_map_coordinates function\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\n# Define your value ranges for color mapping\nvalue_ranges = [1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 30]\n\ndef convert_csvs_to_images():\n    data = pd.read_csv(\"/home/chetana/gridmet_test_run/test_data_predicted.csv\")\n    data['predicted_swe'].fillna(0, inplace=True)\n    data['predicted_swe'] = data['predicted_swe'].apply(lambda x: 0 if x < 2 else x)\n    print(data[:5])\n\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    x, y = m(data['lon'].values, data['lat'].values)\n\n    # Create a figure with a white background\n    fig = plt.figure(facecolor='white')\n\n    # Define your custom function to map data values to colors\n    def map_value_to_color(value):\n        # Iterate through the value ranges to find the appropriate color index\n        for i, range_max in enumerate(value_ranges):\n            if value <= range_max:\n                return colors[i]\n        \n        # If the value is greater than the largest range, return the last color\n        return colors[-1]\n\n    # Map predicted_swe values to colors using the custom function\n    color_mapping = [map_value_to_color(value) for value in data['predicted_swe']]\n    \n    # Plot the data using the custom colormap\n    plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\n\n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_date = datetime(1900, 1, 1)\n    day_value = day_index\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    timestamp_string = result_date.strftime(\"%Y-%m-%d\")\n    \n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    # Create custom legend elements using the same colormap\n    legend_elements = [Patch(color=colors[i], label=f\"{value_ranges[i]} - {value_ranges[i+1]-1}\" if i < len(value_ranges) - 1 else f\"> {value_ranges[-1]}\") for i in range(len(value_ranges))]\n\n    # Create the legend outside the map\n    legend = plt.legend(handles=legend_elements, loc='upper left', title='Legend', fontsize=8)\n    legend.set_bbox_to_anchor((1.01, 1)) \n\n    # Remove the color bar\n    plt.colorbar().remove()\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Set the aspect ratio to 'equal' to keep the plot at the center\n    plt.gca().set_aspect('equal', adjustable='box')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15, right=0.80)  # Adjust right margin to accommodate the legend\n    # Show the plot or save it to a file\n    new_plot_path = f'/home/chetana/gridmet_test_run/predicted_swe-{timestamp_string}.png'\n    print(f\"The new plot is saved to {new_plot_path}\")\n    plt.savefig(new_plot_path)\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "/home/chetana/gw-workspace/pg9FcET291Wo/convert_results_to_images.py:70: UserWarning: No data for colormapping provided via 'c'. Parameters 'cmap' will be ignored\n  plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\ntoday date = 2023-09-17\ntest start date:  2023-06-05\ntest end date:  2023-09-17\n/home/chetana\n    lat      lon  mean_vapor_pressure_deficit  ...  Flag   date  predicted_swe\n0  49.0 -125.000                          NaN  ...   255  45080            0.0\n1  49.0 -124.964                          NaN  ...   255  45080            0.0\n2  49.0 -124.928                          NaN  ...   255  45080            0.0\n3  49.0 -124.892                          NaN  ...   255  45080            0.0\n4  49.0 -124.856                          NaN  ...   255  45080            0.0\n[5 rows x 20 columns]\nThe new plot is saved to /home/chetana/gridmet_test_run/predicted_swe-2023-06-05.png\n",
  "history_begin_time" : 1694969257276,
  "history_end_time" : 1694969266648,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "3oFFhlqbP0Nm",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport uuid\nfrom snowcast_utils import day_index\nimport matplotlib.colors as mcolors\nfrom matplotlib.patches import Patch\n\n# Define the custom colormap with specified colors and ranges\ncolors = [\n    (0.8627, 0.8627, 0.8627),  # #DCDCDC - 0 - 1\n    (0.8627, 1.0000, 1.0000),  # #DCFFFF - 1 - 2\n    (0.6000, 1.0000, 1.0000),  # #99FFFF - 2 - 4\n    (0.5569, 0.8235, 1.0000),  # #8ED2FF - 4 - 6\n    (0.4509, 0.6196, 0.8745),  # #739EDF - 6 - 8\n    (0.4157, 0.4706, 1.0000),  # #6A78FF - 8 - 10\n    (0.4235, 0.2784, 1.0000),  # #6C47FF - 10 - 12\n    (0.5529, 0.0980, 1.0000),  # #8D19FF - 12 - 14\n    (0.7333, 0.0000, 0.9176),  # #BB00EA - 14 - 16\n    (0.8392, 0.0000, 0.7490),  # #D600BF - 16 - 18\n    (0.7569, 0.0039, 0.4549),  # #C10074 - 18 - 20\n    (0.6784, 0.0000, 0.1961),  # #AD0032 - 20 - 30\n    (0.5020, 0.0000, 0.0000)   # #800000 - > 30\n]\n\ncmap_name = 'custom_snow_colormap'\ncustom_cmap = mcolors.ListedColormap(colors)\n\n# Define the lat_lon_to_map_coordinates function\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\n# Define your value ranges for color mapping\nvalue_ranges = [1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 30]\n\ndef convert_csvs_to_images():\n    data = pd.read_csv(\"/home/chetana/gridmet_test_run/test_data_predicted.csv\")\n    data['predicted_swe'].fillna(0, inplace=True)\n    data['predicted_swe'] = data['predicted_swe'].apply(lambda x: 0 if x < 2 else x)\n    print(data[:5])\n\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    x, y = m(data['lon'].values, data['lat'].values)\n\n    # Create a figure with a white background\n    fig = plt.figure(facecolor='white')\n\n    # Define your custom function to map data values to colors\n    def map_value_to_color(value):\n        # Iterate through the value ranges to find the appropriate color index\n        for i, range_max in enumerate(value_ranges):\n            if value <= range_max:\n                return colors[i]\n        \n        # If the value is greater than the largest range, return the last color\n        return colors[-1]\n\n    # Map predicted_swe values to colors using the custom function\n    color_mapping = [map_value_to_color(value) for value in data['predicted_swe']]\n    \n    # Plot the data using the custom colormap\n    plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\n\n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_date = datetime(1900, 1, 1)\n    day_value = day_index\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    timestamp_string = result_date.strftime(\"%Y-%m-%d\")\n    \n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    # Create custom legend elements using the same colormap\n    legend_elements = [Patch(color=colors[i], label=f\"{value_ranges[i]} - {value_ranges[i+1]-1}\" if i < len(value_ranges) - 1 else f\"> {value_ranges[-1]}\") for i in range(len(value_ranges))]\n\n    # Create the legend outside the map\n    legend = plt.legend(handles=legend_elements, loc='upper left', title='Legend', fontsize=8)\n    legend.set_bbox_to_anchor((1.01, 1)) \n\n    # Remove the color bar\n    plt.colorbar().remove()\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Set the aspect ratio to 'equal' to keep the plot at the center\n    plt.gca().set_aspect('equal', adjustable='box')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15, right=0.80)  # Adjust right margin to accommodate the legend\n    # Show the plot or save it to a file\n    new_plot_path = f'/home/chetana/gridmet_test_run/predicted_swe-{timestamp_string}.png'\n    print(f\"The new plot is saved to {new_plot_path}\")\n    plt.savefig(new_plot_path)\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "today date = 2023-09-17\n\nStream closed",
  "history_begin_time" : 1694922647118,
  "history_end_time" : 1694927570715,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Failed"
},{
  "history_id" : "0cjPTfyWppLZ",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport uuid\nfrom snowcast_utils import day_index\nimport matplotlib.colors as mcolors\nfrom matplotlib.patches import Patch\n\n# Define the custom colormap with specified colors and ranges\ncolors = [\n    (0.8627, 0.8627, 0.8627),  # #DCDCDC - 0 - 1\n    (0.8627, 1.0000, 1.0000),  # #DCFFFF - 1 - 2\n    (0.6000, 1.0000, 1.0000),  # #99FFFF - 2 - 4\n    (0.5569, 0.8235, 1.0000),  # #8ED2FF - 4 - 6\n    (0.4509, 0.6196, 0.8745),  # #739EDF - 6 - 8\n    (0.4157, 0.4706, 1.0000),  # #6A78FF - 8 - 10\n    (0.4235, 0.2784, 1.0000),  # #6C47FF - 10 - 12\n    (0.5529, 0.0980, 1.0000),  # #8D19FF - 12 - 14\n    (0.7333, 0.0000, 0.9176),  # #BB00EA - 14 - 16\n    (0.8392, 0.0000, 0.7490),  # #D600BF - 16 - 18\n    (0.7569, 0.0039, 0.4549),  # #C10074 - 18 - 20\n    (0.6784, 0.0000, 0.1961),  # #AD0032 - 20 - 30\n    (0.5020, 0.0000, 0.0000)   # #800000 - > 30\n]\n\ncmap_name = 'custom_snow_colormap'\ncustom_cmap = mcolors.ListedColormap(colors)\n\n# Define the lat_lon_to_map_coordinates function\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\n# Define your value ranges for color mapping\nvalue_ranges = [1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 30]\n\ndef convert_csvs_to_images():\n    data = pd.read_csv(\"/home/chetana/gridmet_test_run/test_data_predicted.csv\")\n    data['predicted_swe'].fillna(0, inplace=True)\n    data['predicted_swe'] = data['predicted_swe'].apply(lambda x: 0 if x < 2 else x)\n    print(data[:5])\n\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    x, y = m(data['lon'].values, data['lat'].values)\n\n    # Create a figure with a white background\n    fig = plt.figure(facecolor='white')\n\n    # Define your custom function to map data values to colors\n    def map_value_to_color(value):\n        # Iterate through the value ranges to find the appropriate color index\n        for i, range_max in enumerate(value_ranges):\n            if value <= range_max:\n                return colors[i]\n        \n        # If the value is greater than the largest range, return the last color\n        return colors[-1]\n\n    # Map predicted_swe values to colors using the custom function\n    color_mapping = [map_value_to_color(value) for value in data['predicted_swe']]\n    \n    # Plot the data using the custom colormap\n    plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\n\n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_date = datetime(1900, 1, 1)\n    day_value = day_index\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    timestamp_string = result_date.strftime(\"%Y-%m-%d\")\n    \n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    # Create custom legend elements using the same colormap\n    legend_elements = [Patch(color=colors[i], label=f\"{value_ranges[i]} - {value_ranges[i+1]-1}\" if i < len(value_ranges) - 1 else f\"> {value_ranges[-1]}\") for i in range(len(value_ranges))]\n\n    # Create the legend outside the map\n    legend = plt.legend(handles=legend_elements, loc='upper left', title='Legend', fontsize=8)\n    legend.set_bbox_to_anchor((1.01, 1)) \n\n    # Remove the color bar\n    plt.colorbar().remove()\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Set the aspect ratio to 'equal' to keep the plot at the center\n    plt.gca().set_aspect('equal', adjustable='box')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15, right=0.80)  # Adjust right margin to accommodate the legend\n    # Show the plot or save it to a file\n    new_plot_path = f'/home/chetana/gridmet_test_run/predicted_swe-{timestamp_string}-{uuid.uuid4().hex}.png'\n    print(f\"The new plot is saved to {new_plot_path}\")\n    plt.savefig(new_plot_path)\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "today date = 2023-09-17\ntest start date:  2023-06-01\ntest end date:  2023-09-17\n/home/chetana\n    lat      lon  mean_vapor_pressure_deficit  ...  SWE  Flag  predicted_swe\n0  49.0 -125.000                          NaN  ...    0   241            0.0\n1  49.0 -124.964                          NaN  ...    0   241            0.0\n2  49.0 -124.928                          NaN  ...    0   241            0.0\n3  49.0 -124.892                          NaN  ...    0   241            0.0\n4  49.0 -124.856                          NaN  ...    0   241            0.0\n[5 rows x 20 columns]\nThe new plot is saved to /home/chetana/gridmet_test_run/predicted_swe-2023-06-01-6406e58e1f234b309aa34288293cdbc5.png\n",
  "history_begin_time" : 1694922247985,
  "history_end_time" : 1694922257561,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "FuMpvMbRWPwK",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport uuid\nfrom snowcast_utils import day_index\nimport matplotlib.colors as mcolors\nfrom matplotlib.patches import Patch\n\n# Define the custom colormap with specified colors and ranges\ncolors = [\n    (0.8627, 0.8627, 0.8627),  # #DCDCDC - 0 - 1\n    (0.8627, 1.0000, 1.0000),  # #DCFFFF - 1 - 2\n    (0.6000, 1.0000, 1.0000),  # #99FFFF - 2 - 4\n    (0.5569, 0.8235, 1.0000),  # #8ED2FF - 4 - 6\n    (0.4509, 0.6196, 0.8745),  # #739EDF - 6 - 8\n    (0.4157, 0.4706, 1.0000),  # #6A78FF - 8 - 10\n    (0.4235, 0.2784, 1.0000),  # #6C47FF - 10 - 12\n    (0.5529, 0.0980, 1.0000),  # #8D19FF - 12 - 14\n    (0.7333, 0.0000, 0.9176),  # #BB00EA - 14 - 16\n    (0.8392, 0.0000, 0.7490),  # #D600BF - 16 - 18\n    (0.7569, 0.0039, 0.4549),  # #C10074 - 18 - 20\n    (0.6784, 0.0000, 0.1961),  # #AD0032 - 20 - 30\n    (0.5020, 0.0000, 0.0000)   # #800000 - > 30\n]\n\ncmap_name = 'custom_snow_colormap'\ncustom_cmap = mcolors.ListedColormap(colors)\n\n# Define the lat_lon_to_map_coordinates function\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\n# Define your value ranges for color mapping\nvalue_ranges = [1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 30]\n\ndef convert_csvs_to_images():\n    data = pd.read_csv(\"/home/chetana/gridmet_test_run/test_data_predicted.csv\")\n    data['predicted_swe'].fillna(0, inplace=True)\n    data['predicted_swe'] = data['predicted_swe'].apply(lambda x: 0 if x < 2 else x)\n    print(data[:5])\n\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    x, y = m(data['lon'].values, data['lat'].values)\n\n    # Create a figure with a white background\n    fig = plt.figure(facecolor='white')\n\n    # Define your custom function to map data values to colors\n    def map_value_to_color(value):\n        # Iterate through the value ranges to find the appropriate color index\n        for i, range_max in enumerate(value_ranges):\n            if value <= range_max:\n                return colors[i]\n        \n        # If the value is greater than the largest range, return the last color\n        return colors[-1]\n\n    # Map predicted_swe values to colors using the custom function\n    color_mapping = [map_value_to_color(value) for value in data['predicted_swe']]\n    \n    # Plot the data using the custom colormap\n    plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\n\n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_date = datetime(1900, 1, 1)\n    day_value = day_index\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    timestamp_string = result_date.strftime(\"%Y-%m-%d\")\n    \n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    # Create custom legend elements using the same colormap\n    legend_elements = [Patch(color=colors[i], label=f\"{value_ranges[i]} - {value_ranges[i+1]-1}\" if i < len(value_ranges) - 1 else f\"> {value_ranges[-1]}\") for i in range(len(value_ranges))]\n\n    # Create the legend outside the map\n    legend = plt.legend(handles=legend_elements, loc='upper left', title='Legend', fontsize=8)\n    legend.set_bbox_to_anchor((1.01, 1)) \n\n    # Remove the color bar\n    plt.colorbar().remove()\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Set the aspect ratio to 'equal' to keep the plot at the center\n    plt.gca().set_aspect('equal', adjustable='box')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15, right=0.80)  # Adjust right margin to accommodate the legend\n    # Show the plot or save it to a file\n    new_plot_path = f'/home/chetana/gridmet_test_run/predicted_swe-{timestamp_string}-{uuid.uuid4().hex}.png'\n    plt.savefig(new_plot_path)\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "today date = 2023-09-17\ntest start date:  2023-06-01\ntest end date:  2023-09-17\n/home/chetana\n    lat      lon  mean_vapor_pressure_deficit  ...  SWE  Flag  predicted_swe\n0  49.0 -125.000                          NaN  ...    0   241            0.0\n1  49.0 -124.964                          NaN  ...    0   241            0.0\n2  49.0 -124.928                          NaN  ...    0   241            0.0\n3  49.0 -124.892                          NaN  ...    0   241            0.0\n4  49.0 -124.856                          NaN  ...    0   241            0.0\n[5 rows x 20 columns]\n",
  "history_begin_time" : 1694922217557,
  "history_end_time" : 1694922227311,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "0csw9cezkvf",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport uuid\nfrom snowcast_utils import day_index\nimport matplotlib.colors as mcolors\nfrom matplotlib.patches import Patch\n\n# Define the custom colormap with specified colors and ranges\ncolors = [\n    (0.8627, 0.8627, 0.8627),  # #DCDCDC - 0 - 1\n    (0.8627, 1.0000, 1.0000),  # #DCFFFF - 1 - 2\n    (0.6000, 1.0000, 1.0000),  # #99FFFF - 2 - 4\n    (0.5569, 0.8235, 1.0000),  # #8ED2FF - 4 - 6\n    (0.4509, 0.6196, 0.8745),  # #739EDF - 6 - 8\n    (0.4157, 0.4706, 1.0000),  # #6A78FF - 8 - 10\n    (0.4235, 0.2784, 1.0000),  # #6C47FF - 10 - 12\n    (0.5529, 0.0980, 1.0000),  # #8D19FF - 12 - 14\n    (0.7333, 0.0000, 0.9176),  # #BB00EA - 14 - 16\n    (0.8392, 0.0000, 0.7490),  # #D600BF - 16 - 18\n    (0.7569, 0.0039, 0.4549),  # #C10074 - 18 - 20\n    (0.6784, 0.0000, 0.1961),  # #AD0032 - 20 - 30\n    (0.5020, 0.0000, 0.0000)   # #800000 - > 30\n]\n\ncmap_name = 'custom_snow_colormap'\ncustom_cmap = mcolors.ListedColormap(colors)\n\n# Define the lat_lon_to_map_coordinates function\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\n# Define your value ranges for color mapping\nvalue_ranges = [1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 30]\n\ndef convert_csvs_to_images():\n    data = pd.read_csv(\"/home/chetana/gridmet_test_run/test_data_predicted.csv\")\n    data['predicted_swe'].fillna(0, inplace=True)\n    data['predicted_swe'] = data['predicted_swe'].apply(lambda x: 0 if x < 2 else x)\n    print(data[:5])\n\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    x, y = m(data['lon'].values, data['lat'].values)\n\n    # Create a figure with a white background\n    fig = plt.figure(facecolor='white')\n\n    # Define your custom function to map data values to colors\n    def map_value_to_color(value):\n        # Iterate through the value ranges to find the appropriate color index\n        for i, range_max in enumerate(value_ranges):\n            if value <= range_max:\n                return colors[i]\n        \n        # If the value is greater than the largest range, return the last color\n        return colors[-1]\n\n    # Map predicted_swe values to colors using the custom function\n    color_mapping = [map_value_to_color(value) for value in data['predicted_swe']]\n    \n    # Plot the data using the custom colormap\n    plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\n\n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_date = datetime(1900, 1, 1)\n    day_value = day_index\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    timestamp_string = result_date.strftime(\"%Y-%m-%d\")\n    \n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    # Create custom legend elements using the same colormap\n    legend_elements = [Patch(color=colors[i], label=f\"{value_ranges[i]} - {value_ranges[i+1]-1}\" if i < len(value_ranges) - 1 else f\"> {value_ranges[-1]}\") for i in range(len(value_ranges))]\n\n    # Create the legend outside the map\n    legend = plt.legend(handles=legend_elements, loc='upper left', title='Legend', fontsize=8)\n    legend.set_bbox_to_anchor((1.01, 1)) \n\n    # Remove the color bar\n    plt.colorbar().remove()\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Set the aspect ratio to 'equal' to keep the plot at the center\n    plt.gca().set_aspect('equal', adjustable='box')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15, right=0.80)  # Adjust right margin to accommodate the legend\n    # Show the plot or save it to a file\n    plt.savefig(f'/home/chetana/gridmet_test_run/predicted_swe-{timestamp_string}-{uuid.uuid4().hex}.png')\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "today date = 2023-09-17\ntest start date:  2023-06-01\ntest end date:  2023-09-17\n/home/chetana\n    lat      lon  mean_vapor_pressure_deficit  ...  SWE  Flag  predicted_swe\n0  49.0 -125.000                          NaN  ...    0   241            0.0\n1  49.0 -124.964                          NaN  ...    0   241            0.0\n2  49.0 -124.928                          NaN  ...    0   241            0.0\n3  49.0 -124.892                          NaN  ...    0   241            0.0\n4  49.0 -124.856                          NaN  ...    0   241            0.0\n[5 rows x 20 columns]\n",
  "history_begin_time" : 1694908983408,
  "history_end_time" : 1694908994565,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "100001",
  "indicator" : "Done"
},{
  "history_id" : "ymmqoS7jOBfd",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport uuid\nfrom snowcast_utils import day_index\nimport matplotlib.colors as mcolors\nfrom matplotlib.patches import Patch\n\n# Define the custom colormap with specified colors and ranges\ncolors = [\n    (0.8627, 0.8627, 0.8627),  # #DCDCDC - 0 - 1\n    (0.8627, 1.0000, 1.0000),  # #DCFFFF - 1 - 2\n    (0.6000, 1.0000, 1.0000),  # #99FFFF - 2 - 4\n    (0.5569, 0.8235, 1.0000),  # #8ED2FF - 4 - 6\n    (0.4509, 0.6196, 0.8745),  # #739EDF - 6 - 8\n    (0.4157, 0.4706, 1.0000),  # #6A78FF - 8 - 10\n    (0.4235, 0.2784, 1.0000),  # #6C47FF - 10 - 12\n    (0.5529, 0.0980, 1.0000),  # #8D19FF - 12 - 14\n    (0.7333, 0.0000, 0.9176),  # #BB00EA - 14 - 16\n    (0.8392, 0.0000, 0.7490),  # #D600BF - 16 - 18\n    (0.7569, 0.0039, 0.4549),  # #C10074 - 18 - 20\n    (0.6784, 0.0000, 0.1961),  # #AD0032 - 20 - 30\n    (0.5020, 0.0000, 0.0000)   # #800000 - > 30\n]\n\ncmap_name = 'custom_snow_colormap'\ncustom_cmap = mcolors.ListedColormap(colors)\n\n# Define the lat_lon_to_map_coordinates function\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\n# Define your value ranges for color mapping\nvalue_ranges = [1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 30]\n\ndef convert_csvs_to_images():\n    data = pd.read_csv(\"/home/chetana/gridmet_test_run/test_data_predicted.csv\")\n    data['predicted_swe'].fillna(0, inplace=True)\n    data['predicted_swe'] = data['predicted_swe'].apply(lambda x: 0 if x < 2 else x)\n    print(data[:5])\n\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    x, y = m(data['lon'].values, data['lat'].values)\n\n    # Create a figure with a white background\n    fig = plt.figure(facecolor='white')\n\n    # Define your custom function to map data values to colors\n    def map_value_to_color(value):\n        # Iterate through the value ranges to find the appropriate color index\n        for i, range_max in enumerate(value_ranges):\n            if value <= range_max:\n                return colors[i]\n        \n        # If the value is greater than the largest range, return the last color\n        return colors[-1]\n\n    # Map predicted_swe values to colors using the custom function\n    color_mapping = [map_value_to_color(value) for value in data['predicted_swe']]\n    \n    # Plot the data using the custom colormap\n    plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\n\n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_date = datetime(1900, 1, 1)\n    day_value = day_index\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    timestamp_string = result_date.strftime(\"%Y-%m-%d\")\n    \n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    # Create custom legend elements using the same colormap\n    legend_elements = [Patch(color=colors[i], label=f\"{value_ranges[i]} - {value_ranges[i+1]-1}\" if i < len(value_ranges) - 1 else f\"> {value_ranges[-1]}\") for i in range(len(value_ranges))]\n\n    # Create the legend outside the map\n    legend = plt.legend(handles=legend_elements, loc='upper left', title='Legend', fontsize=8)\n    legend.set_bbox_to_anchor((1.01, 1)) \n\n    # Remove the color bar\n    plt.colorbar().remove()\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Set the aspect ratio to 'equal' to keep the plot at the center\n    plt.gca().set_aspect('equal', adjustable='box')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15, right=0.80)  # Adjust right margin to accommodate the legend\n    # Show the plot or save it to a file\n    plt.savefig(f'/home/chetana/gridmet_test_run/predicted_swe-{timestamp_string}-{uuid.uuid4().hex}.png')\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "today date = 2023-09-16\ntest start date:  2023-06-01\ntest end date:  2023-09-16\n/home/chetana\n    lat      lon  mean_vapor_pressure_deficit  ...  SWE  Flag  predicted_swe\n0  49.0 -125.000                          NaN  ...    0   241            0.0\n1  49.0 -124.964                          NaN  ...    0   241            0.0\n2  49.0 -124.928                          NaN  ...    0   241            0.0\n3  49.0 -124.892                          NaN  ...    0   241            0.0\n4  49.0 -124.856                          NaN  ...    0   241            0.0\n[5 rows x 20 columns]\n",
  "history_begin_time" : 1694904702361,
  "history_end_time" : 1694904712673,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "dWODk8EP36eq",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport uuid\nfrom snowcast_utils import day_index\nimport matplotlib.colors as mcolors\nfrom matplotlib.patches import Patch\n\n# Define the custom colormap with specified colors and ranges\ncolors = [\n    (0.8627, 0.8627, 0.8627),  # #DCDCDC - 0 - 1\n    (0.8627, 1.0000, 1.0000),  # #DCFFFF - 1 - 2\n    (0.6000, 1.0000, 1.0000),  # #99FFFF - 2 - 4\n    (0.5569, 0.8235, 1.0000),  # #8ED2FF - 4 - 6\n    (0.4509, 0.6196, 0.8745),  # #739EDF - 6 - 8\n    (0.4157, 0.4706, 1.0000),  # #6A78FF - 8 - 10\n    (0.4235, 0.2784, 1.0000),  # #6C47FF - 10 - 12\n    (0.5529, 0.0980, 1.0000),  # #8D19FF - 12 - 14\n    (0.7333, 0.0000, 0.9176),  # #BB00EA - 14 - 16\n    (0.8392, 0.0000, 0.7490),  # #D600BF - 16 - 18\n    (0.7569, 0.0039, 0.4549),  # #C10074 - 18 - 20\n    (0.6784, 0.0000, 0.1961),  # #AD0032 - 20 - 30\n    (0.5020, 0.0000, 0.0000)   # #800000 - > 30\n]\n\ncmap_name = 'custom_snow_colormap'\ncustom_cmap = mcolors.ListedColormap(colors)\n\n# Define the lat_lon_to_map_coordinates function\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\n# Define your value ranges for color mapping\nvalue_ranges = [1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 30]\n\ndef convert_csvs_to_images():\n    data = pd.read_csv(\"/home/chetana/gridmet_test_run/test_data_predicted.csv\")\n    data['predicted_swe'].fillna(0, inplace=True)\n    data['predicted_swe'] = data['predicted_swe'].apply(lambda x: 0 if x < 2 else x)\n    print(data[:5])\n\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    x, y = m(data['lon'].values, data['lat'].values)\n\n    # Create a figure with a white background\n    fig = plt.figure(facecolor='white')\n\n    # Define your custom function to map data values to colors\n    def map_value_to_color(value):\n        # Iterate through the value ranges to find the appropriate color index\n        for i, range_max in enumerate(value_ranges):\n            if value <= range_max:\n                return colors[i]\n        \n        # If the value is greater than the largest range, return the last color\n        return colors[-1]\n\n    # Map predicted_swe values to colors using the custom function\n    color_mapping = [map_value_to_color(value) for value in data['predicted_swe']]\n    \n    # Plot the data using the custom colormap\n    plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\n\n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_date = datetime(1900, 1, 1)\n    day_value = day_index\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    timestamp_string = result_date.strftime(\"%Y-%m-%d\")\n    \n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    # Create custom legend elements using the same colormap\n    legend_elements = [Patch(color=colors[i], label=f\"{value_ranges[i]} - {value_ranges[i+1]-1}\" if i < len(value_ranges) - 1 else f\"> {value_ranges[-1]}\") for i in range(len(value_ranges))]\n\n    # Create the legend outside the map\n    legend = plt.legend(handles=legend_elements, loc='upper left', title='Legend', fontsize=8)\n    legend.set_bbox_to_anchor((1.01, 1)) \n\n    # Remove the color bar\n    plt.colorbar().remove()\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Set the aspect ratio to 'equal' to keep the plot at the center\n    plt.gca().set_aspect('equal', adjustable='box')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15, right=0.80)  # Adjust right margin to accommodate the legend\n    # Show the plot or save it to a file\n    plt.savefig(f'/home/chetana/gridmet_test_run/predicted_swe-{timestamp_string}-{uuid.uuid4().hex}.png')\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "Traceback (most recent call last):\n  File \"/home/chetana/gw-workspace/dWODk8EP36eq/convert_results_to_images.py\", line 3, in <module>\n    from mpl_toolkits.basemap import Basemap\nModuleNotFoundError: No module named 'mpl_toolkits.basemap'\n",
  "history_begin_time" : 1694904414189,
  "history_end_time" : 1694904415255,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Failed"
},{
  "history_id" : "Ampef5IOZcHP",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport uuid\nfrom snowcast_utils import day_index\nimport matplotlib.colors as mcolors\nfrom matplotlib.patches import Patch\n\n# Define the custom colormap with specified colors and ranges\ncolors = [\n    (0.8627, 0.8627, 0.8627),  # #DCDCDC - 0 - 1\n    (0.8627, 1.0000, 1.0000),  # #DCFFFF - 1 - 2\n    (0.6000, 1.0000, 1.0000),  # #99FFFF - 2 - 4\n    (0.5569, 0.8235, 1.0000),  # #8ED2FF - 4 - 6\n    (0.4509, 0.6196, 0.8745),  # #739EDF - 6 - 8\n    (0.4157, 0.4706, 1.0000),  # #6A78FF - 8 - 10\n    (0.4235, 0.2784, 1.0000),  # #6C47FF - 10 - 12\n    (0.5529, 0.0980, 1.0000),  # #8D19FF - 12 - 14\n    (0.7333, 0.0000, 0.9176),  # #BB00EA - 14 - 16\n    (0.8392, 0.0000, 0.7490),  # #D600BF - 16 - 18\n    (0.7569, 0.0039, 0.4549),  # #C10074 - 18 - 20\n    (0.6784, 0.0000, 0.1961),  # #AD0032 - 20 - 30\n    (0.5020, 0.0000, 0.0000)   # #800000 - > 30\n]\n\ncmap_name = 'custom_snow_colormap'\ncustom_cmap = mcolors.ListedColormap(colors)\n\n# Define the lat_lon_to_map_coordinates function\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\n# Define your value ranges for color mapping\nvalue_ranges = [1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 30]\n\ndef convert_csvs_to_images():\n    data = pd.read_csv(\"/home/chetana/gridmet_test_run/test_data_predicted.csv\")\n    data['predicted_swe'].fillna(0, inplace=True)\n    data['predicted_swe'] = data['predicted_swe'].apply(lambda x: 0 if x < 2 else x)\n    print(data[:5])\n\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    x, y = m(data['lon'].values, data['lat'].values)\n\n    # Create a figure with a white background\n    fig = plt.figure(facecolor='white')\n\n    # Define your custom function to map data values to colors\n    def map_value_to_color(value):\n        # Iterate through the value ranges to find the appropriate color index\n        for i, range_max in enumerate(value_ranges):\n            if value <= range_max:\n                return colors[i]\n        \n        # If the value is greater than the largest range, return the last color\n        return colors[-1]\n\n    # Map predicted_swe values to colors using the custom function\n    color_mapping = [map_value_to_color(value) for value in data['predicted_swe']]\n    \n    # Plot the data using the custom colormap\n    plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\n\n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_date = datetime(1900, 1, 1)\n    day_value = day_index\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    timestamp_string = result_date.strftime(\"%Y-%m-%d\")\n    \n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    # Create custom legend elements using the same colormap\n    legend_elements = [Patch(color=colors[i], label=f\"{value_ranges[i]} - {value_ranges[i+1]-1}\" if i < len(value_ranges) - 1 else f\"> {value_ranges[-1]}\") for i in range(len(value_ranges))]\n\n    # Create the legend outside the map\n    legend = plt.legend(handles=legend_elements, loc='upper left', title='Legend', fontsize=8)\n    legend.set_bbox_to_anchor((1.01, 1)) \n\n    # Remove the color bar\n    plt.colorbar().remove()\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Set the aspect ratio to 'equal' to keep the plot at the center\n    plt.gca().set_aspect('equal', adjustable='box')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15, right=0.80)  # Adjust right margin to accommodate the legend\n    # Show the plot or save it to a file\n    plt.savefig(f'/home/chetana/gridmet_test_run/predicted_swe-{timestamp_string}-{uuid.uuid4().hex}.png')\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "Traceback (most recent call last):\n  File \"/home/chetana/gw-workspace/Ampef5IOZcHP/convert_results_to_images.py\", line 3, in <module>\n    from mpl_toolkits.basemap import Basemap\nModuleNotFoundError: No module named 'mpl_toolkits.basemap'\n",
  "history_begin_time" : 1694904291568,
  "history_end_time" : 1694904292550,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Failed"
},{
  "history_id" : "ZC5PkFyIDiAM",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport uuid\nfrom snowcast_utils import day_index\nimport matplotlib.colors as mcolors\nfrom matplotlib.patches import Patch\n\n# Define the custom colormap with specified colors and ranges\ncolors = [\n    (0.8627, 0.8627, 0.8627),  # #DCDCDC - 0 - 1\n    (0.8627, 1.0000, 1.0000),  # #DCFFFF - 1 - 2\n    (0.6000, 1.0000, 1.0000),  # #99FFFF - 2 - 4\n    (0.5569, 0.8235, 1.0000),  # #8ED2FF - 4 - 6\n    (0.4509, 0.6196, 0.8745),  # #739EDF - 6 - 8\n    (0.4157, 0.4706, 1.0000),  # #6A78FF - 8 - 10\n    (0.4235, 0.2784, 1.0000),  # #6C47FF - 10 - 12\n    (0.5529, 0.0980, 1.0000),  # #8D19FF - 12 - 14\n    (0.7333, 0.0000, 0.9176),  # #BB00EA - 14 - 16\n    (0.8392, 0.0000, 0.7490),  # #D600BF - 16 - 18\n    (0.7569, 0.0039, 0.4549),  # #C10074 - 18 - 20\n    (0.6784, 0.0000, 0.1961),  # #AD0032 - 20 - 30\n    (0.5020, 0.0000, 0.0000)   # #800000 - > 30\n]\n\ncmap_name = 'custom_snow_colormap'\ncustom_cmap = mcolors.ListedColormap(colors)\n\n# Define the lat_lon_to_map_coordinates function\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\n# Define your value ranges for color mapping\nvalue_ranges = [1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 30]\n\ndef convert_csvs_to_images():\n    data = pd.read_csv(\"/home/chetana/gridmet_test_run/test_data_predicted.csv\")\n    data['predicted_swe'].fillna(0, inplace=True)\n    data['predicted_swe'] = data['predicted_swe'].apply(lambda x: 0 if x < 2 else x)\n    print(data[:5])\n\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    x, y = m(data['lon'].values, data['lat'].values)\n\n    # Create a figure with a white background\n    fig = plt.figure(facecolor='white')\n\n    # Define your custom function to map data values to colors\n    def map_value_to_color(value):\n        # Iterate through the value ranges to find the appropriate color index\n        for i, range_max in enumerate(value_ranges):\n            if value <= range_max:\n                return colors[i]\n        \n        # If the value is greater than the largest range, return the last color\n        return colors[-1]\n\n    # Map predicted_swe values to colors using the custom function\n    color_mapping = [map_value_to_color(value) for value in data['predicted_swe']]\n    \n    # Plot the data using the custom colormap\n    plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\n\n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_date = datetime(1900, 1, 1)\n    day_value = day_index\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    timestamp_string = result_date.strftime(\"%Y-%m-%d\")\n    \n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    # Create custom legend elements using the same colormap\n    legend_elements = [Patch(color=colors[i], label=f\"{value_ranges[i]} - {value_ranges[i+1]-1}\" if i < len(value_ranges) - 1 else f\"> {value_ranges[-1]}\") for i in range(len(value_ranges))]\n\n    # Create the legend outside the map\n    legend = plt.legend(handles=legend_elements, loc='upper left', title='Legend', fontsize=8)\n    legend.set_bbox_to_anchor((1.01, 1)) \n\n    # Remove the color bar\n    plt.colorbar().remove()\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Set the aspect ratio to 'equal' to keep the plot at the center\n    plt.gca().set_aspect('equal', adjustable='box')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15, right=0.80)  # Adjust right margin to accommodate the legend\n    # Show the plot or save it to a file\n    plt.savefig(f'/home/chetana/gridmet_test_run/predicted_swe-{timestamp_string}-{uuid.uuid4().hex}.png')\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "/home/chetana/gw-workspace/ZC5PkFyIDiAM/convert_results_to_images.py:70: UserWarning: No data for colormapping provided via 'c'. Parameters 'cmap' will be ignored\n  plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\ntoday date = 2023-09-16\ntest start date:  2023-06-01\ntest end date:  2023-09-16\n/home/chetana\n    lat      lon  mean_vapor_pressure_deficit  ...  SWE  Flag  predicted_swe\n0  49.0 -125.000                          NaN  ...    0   241            0.0\n1  49.0 -124.964                          NaN  ...    0   241            0.0\n2  49.0 -124.928                          NaN  ...    0   241            0.0\n3  49.0 -124.892                          NaN  ...    0   241            0.0\n4  49.0 -124.856                          NaN  ...    0   241            0.0\n[5 rows x 20 columns]\n",
  "history_begin_time" : 1694902782661,
  "history_end_time" : 1694902793074,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "5065bawxe44",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport uuid\nfrom snowcast_utils import day_index\nimport matplotlib.colors as mcolors\nfrom matplotlib.patches import Patch\n\n# Define the custom colormap with specified colors and ranges\ncolors = [\n    (0.8627, 0.8627, 0.8627),  # #DCDCDC - 0 - 1\n    (0.8627, 1.0000, 1.0000),  # #DCFFFF - 1 - 2\n    (0.6000, 1.0000, 1.0000),  # #99FFFF - 2 - 4\n    (0.5569, 0.8235, 1.0000),  # #8ED2FF - 4 - 6\n    (0.4509, 0.6196, 0.8745),  # #739EDF - 6 - 8\n    (0.4157, 0.4706, 1.0000),  # #6A78FF - 8 - 10\n    (0.4235, 0.2784, 1.0000),  # #6C47FF - 10 - 12\n    (0.5529, 0.0980, 1.0000),  # #8D19FF - 12 - 14\n    (0.7333, 0.0000, 0.9176),  # #BB00EA - 14 - 16\n    (0.8392, 0.0000, 0.7490),  # #D600BF - 16 - 18\n    (0.7569, 0.0039, 0.4549),  # #C10074 - 18 - 20\n    (0.6784, 0.0000, 0.1961),  # #AD0032 - 20 - 30\n    (0.5020, 0.0000, 0.0000)   # #800000 - > 30\n]\n\ncmap_name = 'custom_snow_colormap'\ncustom_cmap = mcolors.ListedColormap(colors)\n\n# Define the lat_lon_to_map_coordinates function\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\n# Define your value ranges for color mapping\nvalue_ranges = [1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 30]\n\ndef convert_csvs_to_images():\n    data = pd.read_csv(\"/home/chetana/gridmet_test_run/test_data_predicted.csv\")\n    data['predicted_swe'].fillna(0, inplace=True)\n    data['predicted_swe'] = data['predicted_swe'].apply(lambda x: 0 if x < 2 else x)\n    print(data[:5])\n\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    x, y = m(data['lon'].values, data['lat'].values)\n\n    # Create a figure with a white background\n    fig = plt.figure(facecolor='white')\n\n    # Define your custom function to map data values to colors\n    def map_value_to_color(value):\n        # Iterate through the value ranges to find the appropriate color index\n        for i, range_max in enumerate(value_ranges):\n            if value <= range_max:\n                return colors[i]\n        \n        # If the value is greater than the largest range, return the last color\n        return colors[-1]\n\n    # Map predicted_swe values to colors using the custom function\n    color_mapping = [map_value_to_color(value) for value in data['predicted_swe']]\n    \n    # Plot the data using the custom colormap\n    plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\n\n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_date = datetime(1900, 1, 1)\n    day_value = day_index\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    timestamp_string = result_date.strftime(\"%Y-%m-%d\")\n    \n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    # Create custom legend elements using the same colormap\n    legend_elements = [Patch(color=colors[i], label=f\"{value_ranges[i]} - {value_ranges[i+1]-1}\" if i < len(value_ranges) - 1 else f\"> {value_ranges[-1]}\") for i in range(len(value_ranges))]\n\n    # Create the legend outside the map\n    legend = plt.legend(handles=legend_elements, loc='upper left', title='Legend', fontsize=8)\n    legend.set_bbox_to_anchor((1.01, 1)) \n\n    # Remove the color bar\n    plt.colorbar().remove()\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Set the aspect ratio to 'equal' to keep the plot at the center\n    plt.gca().set_aspect('equal', adjustable='box')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15, right=0.80)  # Adjust right margin to accommodate the legend\n    # Show the plot or save it to a file\n    plt.savefig(f'/home/chetana/gridmet_test_run/predicted_swe-{timestamp_string}-{uuid.uuid4().hex}.png')\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "Traceback (most recent call last):\n  File \"/home/chetana/gw-workspace/5065bawxe44/convert_results_to_images.py\", line 3, in <module>\n    from mpl_toolkits.basemap import Basemap\nModuleNotFoundError: No module named 'mpl_toolkits.basemap'\n",
  "history_begin_time" : 1694901476272,
  "history_end_time" : 1694901478889,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "100001",
  "indicator" : "Failed"
},{
  "history_id" : "TXR0ODNU58h3",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport uuid\nfrom snowcast_utils import day_index\nimport matplotlib.colors as mcolors\nfrom matplotlib.patches import Patch\n\n# Define the custom colormap with specified colors and ranges\ncolors = [\n    (0.8627, 0.8627, 0.8627),  # #DCDCDC - 0 - 1\n    (0.8627, 1.0000, 1.0000),  # #DCFFFF - 1 - 2\n    (0.6000, 1.0000, 1.0000),  # #99FFFF - 2 - 4\n    (0.5569, 0.8235, 1.0000),  # #8ED2FF - 4 - 6\n    (0.4509, 0.6196, 0.8745),  # #739EDF - 6 - 8\n    (0.4157, 0.4706, 1.0000),  # #6A78FF - 8 - 10\n    (0.4235, 0.2784, 1.0000),  # #6C47FF - 10 - 12\n    (0.5529, 0.0980, 1.0000),  # #8D19FF - 12 - 14\n    (0.7333, 0.0000, 0.9176),  # #BB00EA - 14 - 16\n    (0.8392, 0.0000, 0.7490),  # #D600BF - 16 - 18\n    (0.7569, 0.0039, 0.4549),  # #C10074 - 18 - 20\n    (0.6784, 0.0000, 0.1961),  # #AD0032 - 20 - 30\n    (0.5020, 0.0000, 0.0000)   # #800000 - > 30\n]\n\ncmap_name = 'custom_snow_colormap'\ncustom_cmap = mcolors.ListedColormap(colors)\n\n# Define the lat_lon_to_map_coordinates function\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\n# Define your value ranges for color mapping\nvalue_ranges = [1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 30]\n\ndef convert_csvs_to_images():\n    data = pd.read_csv(\"/home/chetana/gridmet_test_run/test_data_predicted.csv\")\n    data['predicted_swe'].fillna(0, inplace=True)\n    data['predicted_swe'] = data['predicted_swe'].apply(lambda x: 0 if x < 2 else x)\n    print(data[:5])\n\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    x, y = m(data['lon'].values, data['lat'].values)\n\n    # Create a figure with a white background\n    fig = plt.figure(facecolor='white')\n\n    # Define your custom function to map data values to colors\n    def map_value_to_color(value):\n        # Iterate through the value ranges to find the appropriate color index\n        for i, range_max in enumerate(value_ranges):\n            if value <= range_max:\n                return colors[i]\n        \n        # If the value is greater than the largest range, return the last color\n        return colors[-1]\n\n    # Map predicted_swe values to colors using the custom function\n    color_mapping = [map_value_to_color(value) for value in data['predicted_swe']]\n    \n    # Plot the data using the custom colormap\n    plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\n\n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_date = datetime(1900, 1, 1)\n    day_value = day_index\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    timestamp_string = result_date.strftime(\"%Y-%m-%d\")\n    \n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    # Create custom legend elements using the same colormap\n    legend_elements = [Patch(color=colors[i], label=f\"{value_ranges[i]} - {value_ranges[i+1]-1}\" if i < len(value_ranges) - 1 else f\"> {value_ranges[-1]}\") for i in range(len(value_ranges))]\n\n    # Create the legend outside the map\n    legend = plt.legend(handles=legend_elements, loc='upper left', title='Legend', fontsize=8)\n    legend.set_bbox_to_anchor((1.01, 1)) \n\n    # Remove the color bar\n    plt.colorbar().remove()\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Set the aspect ratio to 'equal' to keep the plot at the center\n    plt.gca().set_aspect('equal', adjustable='box')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15, right=0.80)  # Adjust right margin to accommodate the legend\n    # Show the plot or save it to a file\n    plt.savefig(f'/home/chetana/gridmet_test_run/predicted_swe-{timestamp_string}-{uuid.uuid4().hex}.png')\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "today date = 2023-09-14\ntest start date:  2023-04-01\ntest end date:  2023-09-14\n/home/chetana\n    lat      lon  mean_vapor_pressure_deficit  ...  SWE  Flag  predicted_swe\n0  49.0 -125.000                          NaN  ...    0   241            0.0\n1  49.0 -124.964                          NaN  ...    0   241            0.0\n2  49.0 -124.928                          NaN  ...    0   241            0.0\n3  49.0 -124.892                          NaN  ...    0   241            0.0\n4  49.0 -124.856                          NaN  ...    0   241            0.0\n\n[5 rows x 20 columns]\n/home/chetana/gw-workspace/TXR0ODNU58h3/convert_results_to_images.py:70: UserWarning: No data for colormapping provided via 'c'. Parameters 'cmap' will be ignored\n  plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\n",
  "history_begin_time" : 1694726186814,
  "history_end_time" : 1694726198543,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "bj4NEVmoVIz5",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport uuid\nfrom snowcast_utils import day_index\nimport matplotlib.colors as mcolors\nfrom matplotlib.patches import Patch\n\n# Define the custom colormap with specified colors and ranges\ncolors = [\n    (0.8627, 0.8627, 0.8627),  # #DCDCDC - 0 - 1\n    (0.8627, 1.0000, 1.0000),  # #DCFFFF - 1 - 2\n    (0.6000, 1.0000, 1.0000),  # #99FFFF - 2 - 4\n    (0.5569, 0.8235, 1.0000),  # #8ED2FF - 4 - 6\n    (0.4509, 0.6196, 0.8745),  # #739EDF - 6 - 8\n    (0.4157, 0.4706, 1.0000),  # #6A78FF - 8 - 10\n    (0.4235, 0.2784, 1.0000),  # #6C47FF - 10 - 12\n    (0.5529, 0.0980, 1.0000),  # #8D19FF - 12 - 14\n    (0.7333, 0.0000, 0.9176),  # #BB00EA - 14 - 16\n    (0.8392, 0.0000, 0.7490),  # #D600BF - 16 - 18\n    (0.7569, 0.0039, 0.4549),  # #C10074 - 18 - 20\n    (0.6784, 0.0000, 0.1961),  # #AD0032 - 20 - 30\n    (0.5020, 0.0000, 0.0000)   # #800000 - > 30\n]\n\ncmap_name = 'custom_snow_colormap'\ncustom_cmap = mcolors.ListedColormap(colors)\n\n# Define the lat_lon_to_map_coordinates function\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\n# Define your value ranges for color mapping\nvalue_ranges = [1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 30]\n\ndef convert_csvs_to_images():\n    data = pd.read_csv(\"/home/chetana/gridmet_test_run/test_data_predicted.csv\")\n    data['predicted_swe'].fillna(0, inplace=True)\n    data['predicted_swe'] = data['predicted_swe'].apply(lambda x: 0 if x < 2 else x)\n    print(data[:5])\n\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    x, y = m(data['lon'].values, data['lat'].values)\n\n    # Create a figure with a white background\n    fig = plt.figure(facecolor='white')\n\n    # Define your custom function to map data values to colors\n    def map_value_to_color(value):\n        # Iterate through the value ranges to find the appropriate color index\n        for i, range_max in enumerate(value_ranges):\n            if value <= range_max:\n                return colors[i]\n        \n        # If the value is greater than the largest range, return the last color\n        return colors[-1]\n\n    # Map predicted_swe values to colors using the custom function\n    color_mapping = [map_value_to_color(value) for value in data['predicted_swe']]\n    \n    # Plot the data using the custom colormap\n    plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\n\n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_date = datetime(1900, 1, 1)\n    day_value = day_index\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    timestamp_string = result_date.strftime(\"%Y-%m-%d\")\n    \n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    # Create custom legend elements using the same colormap\n    legend_elements = [Patch(color=colors[i], label=f\"{value_ranges[i]} - {value_ranges[i+1]-1}\" if i < len(value_ranges) - 1 else f\"> {value_ranges[-1]}\") for i in range(len(value_ranges))]\n\n    # Create the legend outside the map\n    legend = plt.legend(handles=legend_elements, loc='upper left', title='Legend', fontsize=8)\n    legend.set_bbox_to_anchor((1.01, 1)) \n\n    # Remove the color bar\n    plt.colorbar().remove()\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Set the aspect ratio to 'equal' to keep the plot at the center\n    plt.gca().set_aspect('equal', adjustable='box')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15, right=0.80)  # Adjust right margin to accommodate the legend\n    # Show the plot or save it to a file\n    plt.savefig(f'/home/chetana/gridmet_test_run/predicted_swe-{timestamp_string}-{uuid.uuid4().hex}.png')\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "today date = 2023-09-14\ntest start date:  2023-01-01\ntest end date:  2023-09-14\n/home/chetana\n    lat      lon  mean_vapor_pressure_deficit  ...  SWE  Flag  predicted_swe\n0  49.0 -125.000                          NaN  ...    0   241            0.0\n1  49.0 -124.964                          NaN  ...    0   241            0.0\n2  49.0 -124.928                          NaN  ...    0   241            0.0\n3  49.0 -124.892                          NaN  ...    0   241            0.0\n4  49.0 -124.856                          NaN  ...    0   241            0.0\n\n[5 rows x 20 columns]\n/home/chetana/gw-workspace/bj4NEVmoVIz5/convert_results_to_images.py:70: UserWarning: No data for colormapping provided via 'c'. Parameters 'cmap' will be ignored\n  plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\n",
  "history_begin_time" : 1694676614893,
  "history_end_time" : 1694676629692,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "wkwvLUiqvmCr",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport uuid\nfrom snowcast_utils import day_index\nimport matplotlib.colors as mcolors\nfrom matplotlib.patches import Patch\n\n# Define the custom colormap with specified colors and ranges\ncolors = [\n    (0.8627, 0.8627, 0.8627),  # #DCDCDC - 0 - 1\n    (0.8627, 1.0000, 1.0000),  # #DCFFFF - 1 - 2\n    (0.6000, 1.0000, 1.0000),  # #99FFFF - 2 - 4\n    (0.5569, 0.8235, 1.0000),  # #8ED2FF - 4 - 6\n    (0.4509, 0.6196, 0.8745),  # #739EDF - 6 - 8\n    (0.4157, 0.4706, 1.0000),  # #6A78FF - 8 - 10\n    (0.4235, 0.2784, 1.0000),  # #6C47FF - 10 - 12\n    (0.5529, 0.0980, 1.0000),  # #8D19FF - 12 - 14\n    (0.7333, 0.0000, 0.9176),  # #BB00EA - 14 - 16\n    (0.8392, 0.0000, 0.7490),  # #D600BF - 16 - 18\n    (0.7569, 0.0039, 0.4549),  # #C10074 - 18 - 20\n    (0.6784, 0.0000, 0.1961),  # #AD0032 - 20 - 30\n    (0.5020, 0.0000, 0.0000)   # #800000 - > 30\n]\n\ncmap_name = 'custom_snow_colormap'\ncustom_cmap = mcolors.ListedColormap(colors)\n\n# Define the lat_lon_to_map_coordinates function\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\n# Define your value ranges for color mapping\nvalue_ranges = [1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 30]\n\ndef convert_csvs_to_images():\n    data = pd.read_csv(\"/home/chetana/gridmet_test_run/test_data_predicted.csv\")\n    data['predicted_swe'].fillna(0, inplace=True)\n    data['predicted_swe'] = data['predicted_swe'].apply(lambda x: 0 if x < 2 else x)\n    print(data[:5])\n\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    x, y = m(data['lon'].values, data['lat'].values)\n\n    # Create a figure with a white background\n    fig = plt.figure(facecolor='white')\n\n    # Define your custom function to map data values to colors\n    def map_value_to_color(value):\n        # Iterate through the value ranges to find the appropriate color index\n        for i, range_max in enumerate(value_ranges):\n            if value <= range_max:\n                return colors[i]\n        \n        # If the value is greater than the largest range, return the last color\n        return colors[-1]\n\n    # Map predicted_swe values to colors using the custom function\n    color_mapping = [map_value_to_color(value) for value in data['predicted_swe']]\n    \n    # Plot the data using the custom colormap\n    plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\n\n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_date = datetime(1900, 1, 1)\n    day_value = day_index\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    timestamp_string = result_date.strftime(\"%Y-%m-%d\")\n    \n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    # Create custom legend elements using the same colormap\n    legend_elements = [Patch(color=colors[i], label=f\"{value_ranges[i]} - {value_ranges[i+1]-1}\" if i < len(value_ranges) - 1 else f\"> {value_ranges[-1]}\") for i in range(len(value_ranges))]\n\n    # Create the legend outside the map\n    legend = plt.legend(handles=legend_elements, loc='upper left', title='Legend', fontsize=8)\n    legend.set_bbox_to_anchor((1.01, 1)) \n\n    # Remove the color bar\n    plt.colorbar().remove()\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Set the aspect ratio to 'equal' to keep the plot at the center\n    plt.gca().set_aspect('equal', adjustable='box')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15, right=0.80)  # Adjust right margin to accommodate the legend\n    # Show the plot or save it to a file\n    plt.savefig(f'/home/chetana/gridmet_test_run/predicted_swe-{timestamp_string}-{uuid.uuid4().hex}.png')\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "today date = 2023-09-13\ntest start date:  2023-01-01\ntest end date:  2023-09-13\n/home/chetana\n    lat      lon  mean_vapor_pressure_deficit  ...  SWE  Flag  predicted_swe\n0  49.0 -125.000                          NaN  ...    0   241            0.0\n1  49.0 -124.964                          NaN  ...    0   241            0.0\n2  49.0 -124.928                          NaN  ...    0   241            0.0\n3  49.0 -124.892                          NaN  ...    0   241            0.0\n4  49.0 -124.856                          NaN  ...    0   241            0.0\n\n[5 rows x 20 columns]\n/home/chetana/gw-workspace/wkwvLUiqvmCr/convert_results_to_images.py:70: UserWarning: No data for colormapping provided via 'c'. Parameters 'cmap' will be ignored\n  plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\n",
  "history_begin_time" : 1694623723271,
  "history_end_time" : 1694623734666,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "enArLpSuJlEK",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport uuid\nfrom snowcast_utils import day_index\nimport matplotlib.colors as mcolors\nfrom matplotlib.patches import Patch\n\n# Define the custom colormap with specified colors and ranges\ncolors = [\n    (0.8627, 0.8627, 0.8627),  # #DCDCDC - 0 - 1\n    (0.8627, 1.0000, 1.0000),  # #DCFFFF - 1 - 2\n    (0.6000, 1.0000, 1.0000),  # #99FFFF - 2 - 4\n    (0.5569, 0.8235, 1.0000),  # #8ED2FF - 4 - 6\n    (0.4509, 0.6196, 0.8745),  # #739EDF - 6 - 8\n    (0.4157, 0.4706, 1.0000),  # #6A78FF - 8 - 10\n    (0.4235, 0.2784, 1.0000),  # #6C47FF - 10 - 12\n    (0.5529, 0.0980, 1.0000),  # #8D19FF - 12 - 14\n    (0.7333, 0.0000, 0.9176),  # #BB00EA - 14 - 16\n    (0.8392, 0.0000, 0.7490),  # #D600BF - 16 - 18\n    (0.7569, 0.0039, 0.4549),  # #C10074 - 18 - 20\n    (0.6784, 0.0000, 0.1961),  # #AD0032 - 20 - 30\n    (0.5020, 0.0000, 0.0000)   # #800000 - > 30\n]\n\ncmap_name = 'custom_snow_colormap'\ncustom_cmap = mcolors.ListedColormap(colors)\n\n# Define the lat_lon_to_map_coordinates function\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\n# Define your value ranges for color mapping\nvalue_ranges = [1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 30]\n\ndef convert_csvs_to_images():\n    data = pd.read_csv(\"/home/chetana/gridmet_test_run/test_data_predicted.csv\")\n    data['predicted_swe'].fillna(0, inplace=True)\n    data['predicted_swe'] = data['predicted_swe'].apply(lambda x: 0 if x < 2 else x)\n    print(data[:5])\n\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    x, y = m(data['lon'].values, data['lat'].values)\n\n    # Create a figure with a white background\n    fig = plt.figure(facecolor='white')\n\n    # Define your custom function to map data values to colors\n    def map_value_to_color(value):\n        # Iterate through the value ranges to find the appropriate color index\n        for i, range_max in enumerate(value_ranges):\n            if value <= range_max:\n                return colors[i]\n        \n        # If the value is greater than the largest range, return the last color\n        return colors[-1]\n\n    # Map predicted_swe values to colors using the custom function\n    color_mapping = [map_value_to_color(value) for value in data['predicted_swe']]\n    \n    # Plot the data using the custom colormap\n    plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\n\n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_date = datetime(1900, 1, 1)\n    day_value = day_index\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    timestamp_string = result_date.strftime(\"%Y-%m-%d\")\n    \n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    # Create custom legend elements using the same colormap\n    legend_elements = [Patch(color=colors[i], label=f\"{value_ranges[i]} - {value_ranges[i+1]-1}\" if i < len(value_ranges) - 1 else f\"> {value_ranges[-1]}\") for i in range(len(value_ranges))]\n\n    # Create the legend outside the map\n    legend = plt.legend(handles=legend_elements, loc='upper left', title='Legend', fontsize=8)\n    legend.set_bbox_to_anchor((1.01, 1)) \n\n    # Remove the color bar\n    plt.colorbar().remove()\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Set the aspect ratio to 'equal' to keep the plot at the center\n    plt.gca().set_aspect('equal', adjustable='box')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15, right=0.80)  # Adjust right margin to accommodate the legend\n    # Show the plot or save it to a file\n    plt.savefig(f'/home/chetana/gridmet_test_run/predicted_swe-{timestamp_string}-{uuid.uuid4().hex}.png')\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "today date = 2023-09-13\n/home/chetana\n    lat      lon  mean_vapor_pressure_deficit  ...  SWE  Flag  predicted_swe\n0  49.0 -125.000                          NaN  ...    0   241            0.0\n1  49.0 -124.964                          NaN  ...    0   241            0.0\n2  49.0 -124.928                          NaN  ...    0   241            0.0\n3  49.0 -124.892                          NaN  ...    0   241            0.0\n4  49.0 -124.856                          NaN  ...    0   241            0.0\n\n[5 rows x 20 columns]\n/home/chetana/gw-workspace/enArLpSuJlEK/convert_results_to_images.py:70: UserWarning: No data for colormapping provided via 'c'. Parameters 'cmap' will be ignored\n  plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\n",
  "history_begin_time" : 1694572820919,
  "history_end_time" : 1694572830951,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "s9r1NIyvLTuH",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport uuid\nfrom snowcast_utils import day_index\nimport matplotlib.colors as mcolors\nfrom matplotlib.patches import Patch\n\n# Define the custom colormap with specified colors and ranges\ncolors = [\n    (0.8627, 0.8627, 0.8627),  # #DCDCDC - 0 - 1\n    (0.8627, 1.0000, 1.0000),  # #DCFFFF - 1 - 2\n    (0.6000, 1.0000, 1.0000),  # #99FFFF - 2 - 4\n    (0.5569, 0.8235, 1.0000),  # #8ED2FF - 4 - 6\n    (0.4509, 0.6196, 0.8745),  # #739EDF - 6 - 8\n    (0.4157, 0.4706, 1.0000),  # #6A78FF - 8 - 10\n    (0.4235, 0.2784, 1.0000),  # #6C47FF - 10 - 12\n    (0.5529, 0.0980, 1.0000),  # #8D19FF - 12 - 14\n    (0.7333, 0.0000, 0.9176),  # #BB00EA - 14 - 16\n    (0.8392, 0.0000, 0.7490),  # #D600BF - 16 - 18\n    (0.7569, 0.0039, 0.4549),  # #C10074 - 18 - 20\n    (0.6784, 0.0000, 0.1961),  # #AD0032 - 20 - 30\n    (0.5020, 0.0000, 0.0000)   # #800000 - > 30\n]\n\ncmap_name = 'custom_snow_colormap'\ncustom_cmap = mcolors.ListedColormap(colors)\n\n# Define the lat_lon_to_map_coordinates function\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\n# Define your value ranges for color mapping\nvalue_ranges = [1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 30]\n\ndef convert_csvs_to_images():\n    data = pd.read_csv(\"/home/chetana/gridmet_test_run/test_data_predicted.csv\")\n    data['predicted_swe'].fillna(0, inplace=True)\n    data['predicted_swe'] = data['predicted_swe'].apply(lambda x: 0 if x < 2 else x)\n    print(data[:5])\n\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    x, y = m(data['lon'].values, data['lat'].values)\n\n    # Create a figure with a white background\n    fig = plt.figure(facecolor='white')\n\n    # Define your custom function to map data values to colors\n    def map_value_to_color(value):\n        # Iterate through the value ranges to find the appropriate color index\n        for i, range_max in enumerate(value_ranges):\n            if value <= range_max:\n                return colors[i]\n        \n        # If the value is greater than the largest range, return the last color\n        return colors[-1]\n\n    # Map predicted_swe values to colors using the custom function\n    color_mapping = [map_value_to_color(value) for value in data['predicted_swe']]\n    \n    # Plot the data using the custom colormap\n    plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\n\n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_date = datetime(1900, 1, 1)\n    day_value = day_index\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    timestamp_string = result_date.strftime(\"%Y-%m-%d\")\n    \n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    # Create custom legend elements using the same colormap\n    legend_elements = [Patch(color=colors[i], label=f\"{value_ranges[i]} - {value_ranges[i+1]-1}\" if i < len(value_ranges) - 1 else f\"> {value_ranges[-1]}\") for i in range(len(value_ranges))]\n\n    # Create the legend outside the map\n    legend = plt.legend(handles=legend_elements, loc='upper left', title='Legend', fontsize=8)\n    legend.set_bbox_to_anchor((1.01, 1)) \n\n    # Remove the color bar\n    plt.colorbar().remove()\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Set the aspect ratio to 'equal' to keep the plot at the center\n    plt.gca().set_aspect('equal', adjustable='box')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15, right=0.80)  # Adjust right margin to accommodate the legend\n    # Show the plot or save it to a file\n    plt.savefig(f'/home/chetana/gridmet_test_run/predicted_swe-{timestamp_string}-{uuid.uuid4().hex}.png')\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "today date = 2023-09-13\n/home/chetana\n    lat      lon  mean_vapor_pressure_deficit  ...  SWE  Flag  predicted_swe\n0  49.0 -125.000                          NaN  ...    0   241            0.0\n1  49.0 -124.964                          NaN  ...    0   241            0.0\n2  49.0 -124.928                          NaN  ...    0   241            0.0\n3  49.0 -124.892                          NaN  ...    0   241            0.0\n4  49.0 -124.856                          NaN  ...    0   241            0.0\n\n[5 rows x 20 columns]\n/home/chetana/gw-workspace/s9r1NIyvLTuH/convert_results_to_images.py:70: UserWarning: No data for colormapping provided via 'c'. Parameters 'cmap' will be ignored\n  plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\n",
  "history_begin_time" : 1694570930979,
  "history_end_time" : 1694570941718,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "QbfDydAF39FD",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport uuid\nfrom snowcast_utils import day_index\nimport matplotlib.colors as mcolors\nfrom matplotlib.patches import Patch\n\n# Define the custom colormap with specified colors and ranges\ncolors = [\n    (0.8627, 0.8627, 0.8627),  # #DCDCDC - 0 - 1\n    (0.8627, 1.0000, 1.0000),  # #DCFFFF - 1 - 2\n    (0.6000, 1.0000, 1.0000),  # #99FFFF - 2 - 4\n    (0.5569, 0.8235, 1.0000),  # #8ED2FF - 4 - 6\n    (0.4509, 0.6196, 0.8745),  # #739EDF - 6 - 8\n    (0.4157, 0.4706, 1.0000),  # #6A78FF - 8 - 10\n    (0.4235, 0.2784, 1.0000),  # #6C47FF - 10 - 12\n    (0.5529, 0.0980, 1.0000),  # #8D19FF - 12 - 14\n    (0.7333, 0.0000, 0.9176),  # #BB00EA - 14 - 16\n    (0.8392, 0.0000, 0.7490),  # #D600BF - 16 - 18\n    (0.7569, 0.0039, 0.4549),  # #C10074 - 18 - 20\n    (0.6784, 0.0000, 0.1961),  # #AD0032 - 20 - 30\n    (0.5020, 0.0000, 0.0000)   # #800000 - > 30\n]\n\ncmap_name = 'custom_snow_colormap'\ncustom_cmap = mcolors.ListedColormap(colors)\n\n# Define the lat_lon_to_map_coordinates function\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\n# Define your value ranges for color mapping\nvalue_ranges = [1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 30]\n\ndef convert_csvs_to_images():\n    data = pd.read_csv(\"/home/chetana/gridmet_test_run/test_data_predicted.csv\")\n    data['predicted_swe'].fillna(0, inplace=True)\n    data['predicted_swe'] = data['predicted_swe'].apply(lambda x: 0 if x < 2 else x)\n    print(data[:5])\n\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    x, y = m(data['lon'].values, data['lat'].values)\n\n    # Create a figure with a white background\n    fig = plt.figure(facecolor='white')\n\n    # Define your custom function to map data values to colors\n    def map_value_to_color(value):\n        # Iterate through the value ranges to find the appropriate color index\n        for i, range_max in enumerate(value_ranges):\n            if value <= range_max:\n                return colors[i]\n        \n        # If the value is greater than the largest range, return the last color\n        return colors[-1]\n\n    # Map predicted_swe values to colors using the custom function\n    color_mapping = [map_value_to_color(value) for value in data['predicted_swe']]\n    \n    # Plot the data using the custom colormap\n    plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\n\n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_date = datetime(1900, 1, 1)\n    day_value = day_index\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    timestamp_string = result_date.strftime(\"%Y-%m-%d\")\n    \n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    # Create custom legend elements using the same colormap\n    legend_elements = [Patch(color=colors[i], label=f\"{value_ranges[i]} - {value_ranges[i+1]-1}\" if i < len(value_ranges) - 1 else f\"> {value_ranges[-1]}\") for i in range(len(value_ranges))]\n\n    # Create the legend outside the map\n    legend = plt.legend(handles=legend_elements, loc='upper left', title='Legend', fontsize=8)\n    legend.set_bbox_to_anchor((1.01, 1)) \n\n    # Remove the color bar\n    plt.colorbar().remove()\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Set the aspect ratio to 'equal' to keep the plot at the center\n    plt.gca().set_aspect('equal', adjustable='box')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15, right=0.80)  # Adjust right margin to accommodate the legend\n    # Show the plot or save it to a file\n    plt.savefig(f'/home/chetana/gridmet_test_run/predicted_swe-{timestamp_string}-{uuid.uuid4().hex}.png')\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "today date = 2023-09-12\n/home/chetana\n    lat      lon  mean_vapor_pressure_deficit  ...  SWE  Flag  predicted_swe\n0  49.0 -125.000                          NaN  ...    0   241            0.0\n1  49.0 -124.964                          NaN  ...    0   241            0.0\n2  49.0 -124.928                          NaN  ...    0   241            0.0\n3  49.0 -124.892                          NaN  ...    0   241            0.0\n4  49.0 -124.856                          NaN  ...    0   241            0.0\n\n[5 rows x 20 columns]\n/home/chetana/gw-workspace/QbfDydAF39FD/convert_results_to_images.py:70: UserWarning: No data for colormapping provided via 'c'. Parameters 'cmap' will be ignored\n  plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\n",
  "history_begin_time" : 1694533044203,
  "history_end_time" : 1694533056260,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "BZAqS2xQA3B4",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport uuid\nfrom snowcast_utils import day_index\nimport matplotlib.colors as mcolors\nfrom matplotlib.patches import Patch\n\n# Define the custom colormap with specified colors and ranges\ncolors = [\n    (0.8627, 0.8627, 0.8627),  # #DCDCDC - 0 - 1\n    (0.8627, 1.0000, 1.0000),  # #DCFFFF - 1 - 2\n    (0.6000, 1.0000, 1.0000),  # #99FFFF - 2 - 4\n    (0.5569, 0.8235, 1.0000),  # #8ED2FF - 4 - 6\n    (0.4509, 0.6196, 0.8745),  # #739EDF - 6 - 8\n    (0.4157, 0.4706, 1.0000),  # #6A78FF - 8 - 10\n    (0.4235, 0.2784, 1.0000),  # #6C47FF - 10 - 12\n    (0.5529, 0.0980, 1.0000),  # #8D19FF - 12 - 14\n    (0.7333, 0.0000, 0.9176),  # #BB00EA - 14 - 16\n    (0.8392, 0.0000, 0.7490),  # #D600BF - 16 - 18\n    (0.7569, 0.0039, 0.4549),  # #C10074 - 18 - 20\n    (0.6784, 0.0000, 0.1961),  # #AD0032 - 20 - 30\n    (0.5020, 0.0000, 0.0000)   # #800000 - > 30\n]\n\ncmap_name = 'custom_snow_colormap'\ncustom_cmap = mcolors.ListedColormap(colors)\n\n# Define the lat_lon_to_map_coordinates function\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\n# Define your value ranges for color mapping\nvalue_ranges = [1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 30]\n\ndef convert_csvs_to_images():\n    data = pd.read_csv(\"/home/chetana/gridmet_test_run/test_data_predicted.csv\")\n    data['predicted_swe'].fillna(0, inplace=True)\n    data['predicted_swe'] = data['predicted_swe'].apply(lambda x: 0 if x < 2 else x)\n    print(data[:5])\n\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    x, y = m(data['lon'].values, data['lat'].values)\n\n    # Create a figure with a white background\n    fig = plt.figure(facecolor='white')\n\n    # Define your custom function to map data values to colors\n    def map_value_to_color(value):\n        # Iterate through the value ranges to find the appropriate color index\n        for i, range_max in enumerate(value_ranges):\n            if value <= range_max:\n                return colors[i]\n        \n        # If the value is greater than the largest range, return the last color\n        return colors[-1]\n\n    # Map predicted_swe values to colors using the custom function\n    color_mapping = [map_value_to_color(value) for value in data['predicted_swe']]\n    \n    # Plot the data using the custom colormap\n    plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\n\n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_date = datetime(1900, 1, 1)\n    day_value = day_index\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    timestamp_string = result_date.strftime(\"%Y-%m-%d\")\n    \n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    # Create custom legend elements using the same colormap\n    legend_elements = [Patch(color=colors[i], label=f\"{value_ranges[i]} - {value_ranges[i+1]-1}\" if i < len(value_ranges) - 1 else f\"> {value_ranges[-1]}\") for i in range(len(value_ranges))]\n\n    # Create the legend outside the map\n    legend = plt.legend(handles=legend_elements, loc='upper left', title='Legend', fontsize=8)\n    legend.set_bbox_to_anchor((1.01, 1)) \n\n    # Remove the color bar\n    plt.colorbar().remove()\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Set the aspect ratio to 'equal' to keep the plot at the center\n    plt.gca().set_aspect('equal', adjustable='box')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15, right=0.80)  # Adjust right margin to accommodate the legend\n    # Show the plot or save it to a file\n    plt.savefig(f'/home/chetana/gridmet_test_run/predicted_swe-{timestamp_string}-{uuid.uuid4().hex}.png')\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "today date = 2023-09-12\n/home/chetana\n    lat      lon  mean_vapor_pressure_deficit  ...  SWE  Flag  predicted_swe\n0  49.0 -125.000                          NaN  ...    0   241            0.0\n1  49.0 -124.964                          NaN  ...    0   241            0.0\n2  49.0 -124.928                          NaN  ...    0   241            0.0\n3  49.0 -124.892                          NaN  ...    0   241            0.0\n4  49.0 -124.856                          NaN  ...    0   241            0.0\n\n[5 rows x 20 columns]\n/home/chetana/gw-workspace/BZAqS2xQA3B4/convert_results_to_images.py:70: UserWarning: No data for colormapping provided via 'c'. Parameters 'cmap' will be ignored\n  plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\n",
  "history_begin_time" : 1694499885716,
  "history_end_time" : 1694499896545,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "Y4qgG9wWuoY0",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport uuid\nfrom snowcast_utils import day_index\nimport matplotlib.colors as mcolors\nfrom matplotlib.patches import Patch\n\n# Define the custom colormap with specified colors and ranges\ncolors = [\n    (0.8627, 0.8627, 0.8627),  # #DCDCDC - 0 - 1\n    (0.8627, 1.0000, 1.0000),  # #DCFFFF - 1 - 2\n    (0.6000, 1.0000, 1.0000),  # #99FFFF - 2 - 4\n    (0.5569, 0.8235, 1.0000),  # #8ED2FF - 4 - 6\n    (0.4509, 0.6196, 0.8745),  # #739EDF - 6 - 8\n    (0.4157, 0.4706, 1.0000),  # #6A78FF - 8 - 10\n    (0.4235, 0.2784, 1.0000),  # #6C47FF - 10 - 12\n    (0.5529, 0.0980, 1.0000),  # #8D19FF - 12 - 14\n    (0.7333, 0.0000, 0.9176),  # #BB00EA - 14 - 16\n    (0.8392, 0.0000, 0.7490),  # #D600BF - 16 - 18\n    (0.7569, 0.0039, 0.4549),  # #C10074 - 18 - 20\n    (0.6784, 0.0000, 0.1961),  # #AD0032 - 20 - 30\n    (0.5020, 0.0000, 0.0000)   # #800000 - > 30\n]\n\ncmap_name = 'custom_snow_colormap'\ncustom_cmap = mcolors.ListedColormap(colors)\n\n# Define the lat_lon_to_map_coordinates function\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\n# Define your value ranges for color mapping\nvalue_ranges = [1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 30]\n\ndef convert_csvs_to_images():\n    data = pd.read_csv(\"/home/chetana/gridmet_test_run/test_data_predicted.csv\")\n    data['predicted_swe'].fillna(0, inplace=True)\n    data['predicted_swe'] = data['predicted_swe'].apply(lambda x: 0 if x < 2 else x)\n    print(data[:5])\n\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    x, y = m(data['lon'].values, data['lat'].values)\n\n    # Create a figure with a white background\n    fig = plt.figure(facecolor='white')\n\n    # Define your custom function to map data values to colors\n    def map_value_to_color(value):\n        # Iterate through the value ranges to find the appropriate color index\n        for i, range_max in enumerate(value_ranges):\n            if value <= range_max:\n                return colors[i]\n        \n        # If the value is greater than the largest range, return the last color\n        return colors[-1]\n\n    # Map predicted_swe values to colors using the custom function\n    color_mapping = [map_value_to_color(value) for value in data['predicted_swe']]\n    \n    # Plot the data using the custom colormap\n    plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\n\n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_date = datetime(1900, 1, 1)\n    day_value = day_index\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    timestamp_string = result_date.strftime(\"%Y-%m-%d\")\n    \n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    # Create custom legend elements using the same colormap\n    legend_elements = [Patch(color=colors[i], label=f\"{value_ranges[i]} - {value_ranges[i+1]-1}\" if i < len(value_ranges) - 1 else f\"> {value_ranges[-1]}\") for i in range(len(value_ranges))]\n\n    # Create the legend outside the map\n    legend = plt.legend(handles=legend_elements, loc='upper left', title='Legend', fontsize=8)\n    legend.set_bbox_to_anchor((1.01, 1)) \n\n    # Remove the color bar\n    plt.colorbar().remove()\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Set the aspect ratio to 'equal' to keep the plot at the center\n    plt.gca().set_aspect('equal', adjustable='box')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15, right=0.80)  # Adjust right margin to accommodate the legend\n    # Show the plot or save it to a file\n    plt.savefig(f'/home/chetana/gridmet_test_run/predicted_swe-{timestamp_string}-{uuid.uuid4().hex}.png')\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "today date = 2023-09-12\n/home/chetana\n    lat      lon  mean_vapor_pressure_deficit  ...  SWE  Flag  predicted_swe\n0  49.0 -125.000                          NaN  ...    0   241            0.0\n1  49.0 -124.964                          NaN  ...    0   241            0.0\n2  49.0 -124.928                          NaN  ...    0   241            0.0\n3  49.0 -124.892                          NaN  ...    0   241            0.0\n4  49.0 -124.856                          NaN  ...    0   241            0.0\n\n[5 rows x 20 columns]\n/home/chetana/gw-workspace/Y4qgG9wWuoY0/convert_results_to_images.py:70: UserWarning: No data for colormapping provided via 'c'. Parameters 'cmap' will be ignored\n  plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\n",
  "history_begin_time" : 1694493779341,
  "history_end_time" : 1694493789368,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "bg7O84WSJxs4",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport uuid\nfrom snowcast_utils import day_index\nimport matplotlib.colors as mcolors\nfrom matplotlib.patches import Patch\n\n# Define the custom colormap with specified colors and ranges\ncolors = [\n    (0.8627, 0.8627, 0.8627),  # #DCDCDC - 0 - 1\n    (0.8627, 1.0000, 1.0000),  # #DCFFFF - 1 - 2\n    (0.6000, 1.0000, 1.0000),  # #99FFFF - 2 - 4\n    (0.5569, 0.8235, 1.0000),  # #8ED2FF - 4 - 6\n    (0.4509, 0.6196, 0.8745),  # #739EDF - 6 - 8\n    (0.4157, 0.4706, 1.0000),  # #6A78FF - 8 - 10\n    (0.4235, 0.2784, 1.0000),  # #6C47FF - 10 - 12\n    (0.5529, 0.0980, 1.0000),  # #8D19FF - 12 - 14\n    (0.7333, 0.0000, 0.9176),  # #BB00EA - 14 - 16\n    (0.8392, 0.0000, 0.7490),  # #D600BF - 16 - 18\n    (0.7569, 0.0039, 0.4549),  # #C10074 - 18 - 20\n    (0.6784, 0.0000, 0.1961),  # #AD0032 - 20 - 30\n    (0.5020, 0.0000, 0.0000)   # #800000 - > 30\n]\n\ncmap_name = 'custom_snow_colormap'\ncustom_cmap = mcolors.ListedColormap(colors)\n\n# Define the lat_lon_to_map_coordinates function\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\n# Define your value ranges for color mapping\nvalue_ranges = [1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 30]\n\ndef convert_csvs_to_images():\n    data = pd.read_csv(\"/home/chetana/gridmet_test_run/test_data_predicted.csv\")\n    data['predicted_swe'].fillna(0, inplace=True)\n    data['predicted_swe'] = data['predicted_swe'].apply(lambda x: 0 if x < 2 else x)\n    print(data[:5])\n\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    x, y = m(data['lon'].values, data['lat'].values)\n\n    # Create a figure with a white background\n    fig = plt.figure(facecolor='white')\n\n    # Define your custom function to map data values to colors\n    def map_value_to_color(value):\n        # Iterate through the value ranges to find the appropriate color index\n        for i, range_max in enumerate(value_ranges):\n            if value <= range_max:\n                return colors[i]\n        \n        # If the value is greater than the largest range, return the last color\n        return colors[-1]\n\n    # Map predicted_swe values to colors using the custom function\n    color_mapping = [map_value_to_color(value) for value in data['predicted_swe']]\n    \n    # Plot the data using the custom colormap\n    plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\n\n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_date = datetime(1900, 1, 1)\n    day_value = day_index\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    timestamp_string = result_date.strftime(\"%Y-%m-%d\")\n    \n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    # Create custom legend elements using the same colormap\n    legend_elements = [Patch(color=colors[i], label=f\"{value_ranges[i]} - {value_ranges[i+1]-1}\" if i < len(value_ranges) - 1 else f\"> {value_ranges[-1]}\") for i in range(len(value_ranges))]\n\n    # Create the legend outside the map\n    legend = plt.legend(handles=legend_elements, loc='upper left', title='Legend', fontsize=8)\n    legend.set_bbox_to_anchor((1.01, 1)) \n\n    # Remove the color bar\n    plt.colorbar().remove()\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Set the aspect ratio to 'equal' to keep the plot at the center\n    plt.gca().set_aspect('equal', adjustable='box')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15, right=0.80)  # Adjust right margin to accommodate the legend\n    # Show the plot or save it to a file\n    plt.savefig(f'/home/chetana/gridmet_test_run/predicted_swe-{timestamp_string}-{uuid.uuid4().hex}.png')\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "today date = 2023-09-12\n/home/chetana\n    lat      lon  mean_vapor_pressure_deficit  ...  SWE  Flag  predicted_swe\n0  49.0 -125.000                          NaN  ...    0   241            0.0\n1  49.0 -124.964                          NaN  ...    0   241            0.0\n2  49.0 -124.928                          NaN  ...    0   241            0.0\n3  49.0 -124.892                          NaN  ...    0   241            0.0\n4  49.0 -124.856                          NaN  ...    0   241            0.0\n\n[5 rows x 20 columns]\n/home/chetana/gw-workspace/bg7O84WSJxs4/convert_results_to_images.py:70: UserWarning: No data for colormapping provided via 'c'. Parameters 'cmap' will be ignored\n  plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\n",
  "history_begin_time" : 1694493590471,
  "history_end_time" : 1694493600623,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "Ts65pdPP1T5d",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport uuid\nfrom snowcast_utils import day_index\nimport matplotlib.colors as mcolors\nfrom matplotlib.patches import Patch\n\n# Define the custom colormap with specified colors and ranges\ncolors = [\n    (0.8627, 0.8627, 0.8627),  # #DCDCDC - 0 - 1\n    (0.8627, 1.0000, 1.0000),  # #DCFFFF - 1 - 2\n    (0.6000, 1.0000, 1.0000),  # #99FFFF - 2 - 4\n    (0.5569, 0.8235, 1.0000),  # #8ED2FF - 4 - 6\n    (0.4509, 0.6196, 0.8745),  # #739EDF - 6 - 8\n    (0.4157, 0.4706, 1.0000),  # #6A78FF - 8 - 10\n    (0.4235, 0.2784, 1.0000),  # #6C47FF - 10 - 12\n    (0.5529, 0.0980, 1.0000),  # #8D19FF - 12 - 14\n    (0.7333, 0.0000, 0.9176),  # #BB00EA - 14 - 16\n    (0.8392, 0.0000, 0.7490),  # #D600BF - 16 - 18\n    (0.7569, 0.0039, 0.4549),  # #C10074 - 18 - 20\n    (0.6784, 0.0000, 0.1961),  # #AD0032 - 20 - 30\n    (0.5020, 0.0000, 0.0000)   # #800000 - > 30\n]\n\ncmap_name = 'custom_snow_colormap'\ncustom_cmap = mcolors.ListedColormap(colors)\n\n# Define the lat_lon_to_map_coordinates function\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\n# Define your value ranges for color mapping\nvalue_ranges = [1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 30]\n\ndef convert_csvs_to_images():\n    data = pd.read_csv(\"/home/chetana/gridmet_test_run/test_data_predicted.csv\")\n    data['predicted_swe'].fillna(0, inplace=True)\n    data['predicted_swe'] = data['predicted_swe'].apply(lambda x: 0 if x < 2 else x)\n    print(data[:5])\n\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    x, y = m(data['lon'].values, data['lat'].values)\n\n    # Create a figure with a white background\n    fig = plt.figure(facecolor='white')\n\n    # Define your custom function to map data values to colors\n    def map_value_to_color(value):\n        # Iterate through the value ranges to find the appropriate color index\n        for i, range_max in enumerate(value_ranges):\n            if value <= range_max:\n                return colors[i]\n        \n        # If the value is greater than the largest range, return the last color\n        return colors[-1]\n\n    # Map predicted_swe values to colors using the custom function\n    color_mapping = [map_value_to_color(value) for value in data['predicted_swe']]\n    \n    # Plot the data using the custom colormap\n    plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\n\n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_date = datetime(1900, 1, 1)\n    day_value = day_index\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    timestamp_string = result_date.strftime(\"%Y-%m-%d\")\n    \n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    # Create custom legend elements using the same colormap\n    legend_elements = [Patch(color=colors[i], label=f\"{value_ranges[i]} - {value_ranges[i+1]-1}\" if i < len(value_ranges) - 1 else f\"> {value_ranges[-1]}\") for i in range(len(value_ranges))]\n\n    # Create the legend outside the map\n    legend = plt.legend(handles=legend_elements, loc='upper left', title='Legend', fontsize=8)\n    legend.set_bbox_to_anchor((1.01, 1)) \n\n    # Remove the color bar\n    plt.colorbar().remove()\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Set the aspect ratio to 'equal' to keep the plot at the center\n    plt.gca().set_aspect('equal', adjustable='box')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15, right=0.80)  # Adjust right margin to accommodate the legend\n    # Show the plot or save it to a file\n    plt.savefig(f'/home/chetana/gridmet_test_run/predicted_swe-{timestamp_string}-{uuid.uuid4().hex}.png')\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "today date = 2023-09-12\n/home/chetana\n    lat      lon  mean_vapor_pressure_deficit  ...  SWE  Flag  predicted_swe\n0  49.0 -125.000                          NaN  ...    0   241            0.0\n1  49.0 -124.964                          NaN  ...    0   241            0.0\n2  49.0 -124.928                          NaN  ...    0   241            0.0\n3  49.0 -124.892                          NaN  ...    0   241            0.0\n4  49.0 -124.856                          NaN  ...    0   241            0.0\n\n[5 rows x 20 columns]\n/home/chetana/gw-workspace/Ts65pdPP1T5d/convert_results_to_images.py:70: UserWarning: No data for colormapping provided via 'c'. Parameters 'cmap' will be ignored\n  plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\n",
  "history_begin_time" : 1694492766662,
  "history_end_time" : 1694492776688,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "0KyLcEDds6Rr",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport uuid\nfrom snowcast_utils import day_index\nimport matplotlib.colors as mcolors\nfrom matplotlib.patches import Patch\n\n# Define the custom colormap with specified colors and ranges\ncolors = [\n    (0.8627, 0.8627, 0.8627),  # #DCDCDC - 0 - 1\n    (0.8627, 1.0000, 1.0000),  # #DCFFFF - 1 - 2\n    (0.6000, 1.0000, 1.0000),  # #99FFFF - 2 - 4\n    (0.5569, 0.8235, 1.0000),  # #8ED2FF - 4 - 6\n    (0.4509, 0.6196, 0.8745),  # #739EDF - 6 - 8\n    (0.4157, 0.4706, 1.0000),  # #6A78FF - 8 - 10\n    (0.4235, 0.2784, 1.0000),  # #6C47FF - 10 - 12\n    (0.5529, 0.0980, 1.0000),  # #8D19FF - 12 - 14\n    (0.7333, 0.0000, 0.9176),  # #BB00EA - 14 - 16\n    (0.8392, 0.0000, 0.7490),  # #D600BF - 16 - 18\n    (0.7569, 0.0039, 0.4549),  # #C10074 - 18 - 20\n    (0.6784, 0.0000, 0.1961),  # #AD0032 - 20 - 30\n    (0.5020, 0.0000, 0.0000)   # #800000 - > 30\n]\n\ncmap_name = 'custom_snow_colormap'\ncustom_cmap = mcolors.ListedColormap(colors)\n\n# Define the lat_lon_to_map_coordinates function\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\n# Define your value ranges for color mapping\nvalue_ranges = [1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 30]\n\ndef convert_csvs_to_images():\n    data = pd.read_csv(\"/home/chetana/gridmet_test_run/predicted_val_with_2_thrushold.csv\")\n    data['predicted_swe'].fillna(0, inplace=True)\n    data['predicted_swe'] = data['predicted_swe'].apply(lambda x: 0 if x < 2 else x)\n    print(data[:5])\n\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    x, y = m(data['lon'].values, data['lat'].values)\n\n    # Create a figure with a white background\n    fig = plt.figure(facecolor='white')\n\n    # Define your custom function to map data values to colors\n    def map_value_to_color(value):\n        # Iterate through the value ranges to find the appropriate color index\n        for i, range_max in enumerate(value_ranges):\n            if value <= range_max:\n                return colors[i]\n        \n        # If the value is greater than the largest range, return the last color\n        return colors[-1]\n\n    # Map predicted_swe values to colors using the custom function\n    color_mapping = [map_value_to_color(value) for value in data['predicted_swe']]\n    \n    # Plot the data using the custom colormap\n    plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\n\n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_date = datetime(1900, 1, 1)\n    day_value = day_index\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    timestamp_string = result_date.strftime(\"%Y-%m-%d\")\n    \n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    # Create custom legend elements using the same colormap\n    legend_elements = [Patch(color=colors[i], label=f\"{value_ranges[i]} - {value_ranges[i+1]-1}\" if i < len(value_ranges) - 1 else f\"> {value_ranges[-1]}\") for i in range(len(value_ranges))]\n\n    # Create the legend outside the map\n    legend = plt.legend(handles=legend_elements, loc='upper left', title='Legend', fontsize=8)\n    legend.set_bbox_to_anchor((1.01, 1)) \n\n    # Remove the color bar\n    plt.colorbar().remove()\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Set the aspect ratio to 'equal' to keep the plot at the center\n    plt.gca().set_aspect('equal', adjustable='box')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15, right=0.80)  # Adjust right margin to accommodate the legend\n    # Show the plot or save it to a file\n    plt.savefig(f'/home/chetana/gridmet_test_run/predicted_swe-{timestamp_string}-{uuid.uuid4().hex}.png')\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "today date = 2023-09-12\n/home/chetana\n    lat      lon  mean_vapor_pressure_deficit  ...  SWE  Flag  predicted_swe\n0  49.0 -125.000                          NaN  ...    0   241            0.0\n1  49.0 -124.964                          NaN  ...    0   241            0.0\n2  49.0 -124.928                          NaN  ...    0   241            0.0\n3  49.0 -124.892                          NaN  ...    0   241            0.0\n4  49.0 -124.856                          NaN  ...    0   241            0.0\n\n[5 rows x 20 columns]\n/home/chetana/gw-workspace/0KyLcEDds6Rr/convert_results_to_images.py:70: UserWarning: No data for colormapping provided via 'c'. Parameters 'cmap' will be ignored\n  plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\n",
  "history_begin_time" : 1694492638260,
  "history_end_time" : 1694492648430,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "gGJ4IEuHqxxg",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport uuid\nfrom snowcast_utils import day_index\nimport matplotlib.colors as mcolors\nfrom matplotlib.patches import Patch\n\n# Define the custom colormap with specified colors and ranges\ncolors = [\n    (0.8627, 0.8627, 0.8627),  # #DCDCDC - 0 - 1\n    (0.8627, 1.0000, 1.0000),  # #DCFFFF - 1 - 2\n    (0.6000, 1.0000, 1.0000),  # #99FFFF - 2 - 4\n    (0.5569, 0.8235, 1.0000),  # #8ED2FF - 4 - 6\n    (0.4509, 0.6196, 0.8745),  # #739EDF - 6 - 8\n    (0.4157, 0.4706, 1.0000),  # #6A78FF - 8 - 10\n    (0.4235, 0.2784, 1.0000),  # #6C47FF - 10 - 12\n    (0.5529, 0.0980, 1.0000),  # #8D19FF - 12 - 14\n    (0.7333, 0.0000, 0.9176),  # #BB00EA - 14 - 16\n    (0.8392, 0.0000, 0.7490),  # #D600BF - 16 - 18\n    (0.7569, 0.0039, 0.4549),  # #C10074 - 18 - 20\n    (0.6784, 0.0000, 0.1961),  # #AD0032 - 20 - 30\n    (0.5020, 0.0000, 0.0000)   # #800000 - > 30\n]\n\ncmap_name = 'custom_snow_colormap'\ncustom_cmap = mcolors.ListedColormap(colors)\n\n# Define the lat_lon_to_map_coordinates function\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\n# Define your value ranges for color mapping\nvalue_ranges = [1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 30]\n\ndef convert_csvs_to_images():\n    data = pd.read_csv(\"/home/chetana/gridmet_test_run/predicted_val_with_2_thrushold.csv\")\n    data['predicted_swe'].fillna(0, inplace=True)\n    print(data[:5])\n\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    x, y = m(data['lon'].values, data['lat'].values)\n\n    # Create a figure with a white background\n    fig = plt.figure(facecolor='white')\n\n    # Define your custom function to map data values to colors\n    def map_value_to_color(value):\n        # Iterate through the value ranges to find the appropriate color index\n        for i, range_max in enumerate(value_ranges):\n            if value <= range_max:\n                return colors[i]\n        \n        # If the value is greater than the largest range, return the last color\n        return colors[-1]\n\n    # Map predicted_swe values to colors using the custom function\n    color_mapping = [map_value_to_color(value) for value in data['predicted_swe']]\n    \n    # Plot the data using the custom colormap\n    plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\n\n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_date = datetime(1900, 1, 1)\n    day_value = day_index\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    timestamp_string = result_date.strftime(\"%Y-%m-%d\")\n    \n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    # Create custom legend elements using the same colormap\n    legend_elements = [Patch(color=colors[i], label=f\"{value_ranges[i]} - {value_ranges[i+1]-1}\" if i < len(value_ranges) - 1 else f\"> {value_ranges[-1]}\") for i in range(len(value_ranges))]\n\n    # Create the legend outside the map\n    legend = plt.legend(handles=legend_elements, loc='upper left', title='Legend', fontsize=8)\n    legend.set_bbox_to_anchor((1.01, 1)) \n\n    # Remove the color bar\n    plt.colorbar().remove()\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Set the aspect ratio to 'equal' to keep the plot at the center\n    plt.gca().set_aspect('equal', adjustable='box')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15, right=0.80)  # Adjust right margin to accommodate the legend\n    # Show the plot or save it to a file\n    plt.savefig(f'/home/chetana/gridmet_test_run/predicted_swe-{timestamp_string}-{uuid.uuid4().hex}.png')\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "today date = 2023-09-12\n/home/chetana\n    lat      lon  mean_vapor_pressure_deficit  ...  SWE  Flag  predicted_swe\n0  49.0 -125.000                          NaN  ...    0   241            0.0\n1  49.0 -124.964                          NaN  ...    0   241            0.0\n2  49.0 -124.928                          NaN  ...    0   241            0.0\n3  49.0 -124.892                          NaN  ...    0   241            0.0\n4  49.0 -124.856                          NaN  ...    0   241            0.0\n\n[5 rows x 20 columns]\n/home/chetana/gw-workspace/gGJ4IEuHqxxg/convert_results_to_images.py:69: UserWarning: No data for colormapping provided via 'c'. Parameters 'cmap' will be ignored\n  plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\n",
  "history_begin_time" : 1694486168914,
  "history_end_time" : 1694486178551,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "ZaLOa22YTTI3",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport uuid\nfrom snowcast_utils import day_index\nimport matplotlib.colors as mcolors\nfrom matplotlib.patches import Patch\n\n# Define the custom colormap with specified colors and ranges\ncolors = [\n    (0.8627, 0.8627, 0.8627),  # #DCDCDC - 0 - 1\n    (0.8627, 1.0000, 1.0000),  # #DCFFFF - 1 - 2\n    (0.6000, 1.0000, 1.0000),  # #99FFFF - 2 - 4\n    (0.5569, 0.8235, 1.0000),  # #8ED2FF - 4 - 6\n    (0.4509, 0.6196, 0.8745),  # #739EDF - 6 - 8\n    (0.4157, 0.4706, 1.0000),  # #6A78FF - 8 - 10\n    (0.4235, 0.2784, 1.0000),  # #6C47FF - 10 - 12\n    (0.5529, 0.0980, 1.0000),  # #8D19FF - 12 - 14\n    (0.7333, 0.0000, 0.9176),  # #BB00EA - 14 - 16\n    (0.8392, 0.0000, 0.7490),  # #D600BF - 16 - 18\n    (0.7569, 0.0039, 0.4549),  # #C10074 - 18 - 20\n    (0.6784, 0.0000, 0.1961),  # #AD0032 - 20 - 30\n    (0.5020, 0.0000, 0.0000)   # #800000 - > 30\n]\n\ncmap_name = 'custom_snow_colormap'\ncustom_cmap = mcolors.ListedColormap(colors)\n\n# Define the lat_lon_to_map_coordinates function\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\n# Define your value ranges for color mapping\nvalue_ranges = [1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 30]\n\ndef convert_csvs_to_images():\n    data = pd.read_csv(\"/home/chetana/gridmet_test_run/predicted_val_with_2_thrushold.csv\")\n    print(data[:5])\n\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    x, y = m(data['lon'].values, data['lat'].values)\n\n    # Create a figure with a white background\n    fig = plt.figure(facecolor='white')\n\n    # Define your custom function to map data values to colors\n    def map_value_to_color(value):\n        # Iterate through the value ranges to find the appropriate color index\n        for i, range_max in enumerate(value_ranges):\n            if value <= range_max:\n                return colors[i]\n        \n        # If the value is greater than the largest range, return the last color\n        return colors[-1]\n\n    # Map predicted_swe values to colors using the custom function\n    color_mapping = [map_value_to_color(value) for value in data['predicted_swe']]\n    \n    # Plot the data using the custom colormap\n    plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\n\n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_date = datetime(1900, 1, 1)\n    day_value = day_index\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    timestamp_string = result_date.strftime(\"%Y-%m-%d\")\n    \n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    # Create custom legend elements using the same colormap\n    legend_elements = [Patch(color=colors[i], label=f\"{value_ranges[i]} - {value_ranges[i+1]-1}\" if i < len(value_ranges) - 1 else f\"> {value_ranges[-1]}\") for i in range(len(value_ranges))]\n\n    # Create the legend outside the map\n    legend = plt.legend(handles=legend_elements, loc='upper left', title='Legend', fontsize=8)\n    legend.set_bbox_to_anchor((1.01, 1)) \n\n    # Remove the color bar\n    plt.colorbar().remove()\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Set the aspect ratio to 'equal' to keep the plot at the center\n    plt.gca().set_aspect('equal', adjustable='box')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15, right=0.80)  # Adjust right margin to accommodate the legend\n    # Show the plot or save it to a file\n    plt.savefig(f'/home/chetana/gridmet_test_run/predicted_swe-{timestamp_string}-{uuid.uuid4().hex}.png')\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "today date = 2023-09-12\n/home/chetana\n    lat      lon  mean_vapor_pressure_deficit  ...  SWE  Flag  predicted_swe\n0  49.0 -125.000                          NaN  ...    0   241            NaN\n1  49.0 -124.964                          NaN  ...    0   241            NaN\n2  49.0 -124.928                          NaN  ...    0   241            NaN\n3  49.0 -124.892                          NaN  ...    0   241            NaN\n4  49.0 -124.856                          NaN  ...    0   241            NaN\n\n[5 rows x 20 columns]\n/home/chetana/gw-workspace/ZaLOa22YTTI3/convert_results_to_images.py:68: UserWarning: No data for colormapping provided via 'c'. Parameters 'cmap' will be ignored\n  plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\n",
  "history_begin_time" : 1694486122086,
  "history_end_time" : 1694486131982,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "f7PMQMeZLGbo",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport uuid\nfrom snowcast_utils import day_index\nimport matplotlib.colors as mcolors\nfrom matplotlib.patches import Patch\n\n# Define the custom colormap with specified colors and ranges\ncolors = [\n    (0.8627, 0.8627, 0.8627),  # #DCDCDC - 0 - 1\n    (0.8627, 1.0000, 1.0000),  # #DCFFFF - 1 - 2\n    (0.6000, 1.0000, 1.0000),  # #99FFFF - 2 - 4\n    (0.5569, 0.8235, 1.0000),  # #8ED2FF - 4 - 6\n    (0.4509, 0.6196, 0.8745),  # #739EDF - 6 - 8\n    (0.4157, 0.4706, 1.0000),  # #6A78FF - 8 - 10\n    (0.4235, 0.2784, 1.0000),  # #6C47FF - 10 - 12\n    (0.5529, 0.0980, 1.0000),  # #8D19FF - 12 - 14\n    (0.7333, 0.0000, 0.9176),  # #BB00EA - 14 - 16\n    (0.8392, 0.0000, 0.7490),  # #D600BF - 16 - 18\n    (0.7569, 0.0039, 0.4549),  # #C10074 - 18 - 20\n    (0.6784, 0.0000, 0.1961),  # #AD0032 - 20 - 30\n    (0.5020, 0.0000, 0.0000)   # #800000 - > 30\n]\n\ncmap_name = 'custom_snow_colormap'\ncustom_cmap = mcolors.ListedColormap(colors)\n\n# Define the lat_lon_to_map_coordinates function\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\n# Define your value ranges for color mapping\nvalue_ranges = [1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 30]\n\ndef convert_csvs_to_images():\n    data = pd.read_csv(\"/home/chetana/gridmet_test_run/predicted_val_with_2_thrushold.csv\")\n\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    x, y = m(data['lon'].values, data['lat'].values)\n\n    # Create a figure with a white background\n    fig = plt.figure(facecolor='white')\n\n    # Define your custom function to map data values to colors\n    def map_value_to_color(value):\n        # Define your value ranges and corresponding color indices\n        value_ranges = [1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 30]\n\n        if value < 2:\n            return (1, 1, 1)\n\n        # Iterate through the value ranges to find the appropriate color index\n        for i, range_max in enumerate(value_ranges):\n            if value <= range_max:\n                return colors[i]\n\n        # If the value is greater than the largest range, return the last color\n        return colors[-1]\n\n    # Map predicted_swe values to colors using the custom function\n    color_mapping = [map_value_to_color(value) for value in data['predicted_swe']]\n    \n    # Plot the data using the custom colormap\n    plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\n\n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_date = datetime(1900, 1, 1)\n    day_value = day_index\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    timestamp_string = result_date.strftime(\"%Y-%m-%d\")\n    \n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    # Create custom legend elements using the same colormap\n    legend_elements = [Patch(color=colors[i], label=f\"{value_ranges[i]} - {value_ranges[i+1]-1}\" if i < len(value_ranges) - 1 else f\"> {value_ranges[-1]}\") for i in range(len(value_ranges))]\n\n    # Create the legend outside the map\n    legend = plt.legend(handles=legend_elements, loc='upper left', title='Legend', fontsize=8)\n    legend.set_bbox_to_anchor((1.01, 1)) \n\n    # Remove the color bar\n    plt.colorbar().remove()\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Set the aspect ratio to 'equal' to keep the plot at the center\n    plt.gca().set_aspect('equal', adjustable='box')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15, right=0.80)  # Adjust right margin to accommodate the legend\n    # Show the plot or save it to a file\n    plt.savefig(f'/home/chetana/gridmet_test_run/predicted_swe-{timestamp_string}-{uuid.uuid4().hex}.png')\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "today date = 2023-09-12\n/home/chetana\n/home/chetana/gw-workspace/f7PMQMeZLGbo/convert_results_to_images.py:73: UserWarning: No data for colormapping provided via 'c'. Parameters 'cmap' will be ignored\n  plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\n",
  "history_begin_time" : 1694485761622,
  "history_end_time" : 1694485771494,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "Jy4uznJrpdEt",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport uuid\nfrom snowcast_utils import day_index\nimport matplotlib.colors as mcolors\nfrom matplotlib.patches import Patch\n\n# Define the custom colormap with specified colors and ranges\ncolors = [\n    (0.8627, 0.8627, 0.8627),  # #DCDCDC - 0 - 1\n    (0.8627, 1.0000, 1.0000),  # #DCFFFF - 1 - 2\n    (0.6000, 1.0000, 1.0000),  # #99FFFF - 2 - 4\n    (0.5569, 0.8235, 1.0000),  # #8ED2FF - 4 - 6\n    (0.4509, 0.6196, 0.8745),  # #739EDF - 6 - 8\n    (0.4157, 0.4706, 1.0000),  # #6A78FF - 8 - 10\n    (0.4235, 0.2784, 1.0000),  # #6C47FF - 10 - 12\n    (0.5529, 0.0980, 1.0000),  # #8D19FF - 12 - 14\n    (0.7333, 0.0000, 0.9176),  # #BB00EA - 14 - 16\n    (0.8392, 0.0000, 0.7490),  # #D600BF - 16 - 18\n    (0.7569, 0.0039, 0.4549),  # #C10074 - 18 - 20\n    (0.6784, 0.0000, 0.1961),  # #AD0032 - 20 - 30\n    (0.5020, 0.0000, 0.0000)   # #800000 - > 30\n]\n\ncmap_name = 'custom_snow_colormap'\ncustom_cmap = mcolors.ListedColormap(colors)\n\n# Define the lat_lon_to_map_coordinates function\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\n# Define your value ranges for color mapping\nvalue_ranges = [1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 30]\n\ndef convert_csvs_to_images():\n    data = pd.read_csv(\"/home/chetana/gridmet_test_run/predicted_val_with_2_thrushold.csv\")\n\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    x, y = m(data['lon'].values, data['lat'].values)\n\n    # Create a figure with a white background\n    fig = plt.figure(facecolor='white')\n\n    # Define your custom function to map data values to colors\n    def map_value_to_color(value):\n        # Iterate through the value ranges to find the appropriate color index\n        for i, range_max in enumerate(value_ranges):\n            if value <= range_max:\n                return colors[i]\n        \n        # If the value is greater than the largest range, return the last color\n        return colors[-1]\n\n    # Map predicted_swe values to colors using the custom function\n    color_mapping = [map_value_to_color(value) for value in data['predicted_swe']]\n    \n    # Plot the data using the custom colormap\n    plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\n\n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_date = datetime(1900, 1, 1)\n    day_value = day_index\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    timestamp_string = result_date.strftime(\"%Y-%m-%d\")\n    \n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    # Create custom legend elements using the same colormap\n    legend_elements = [Patch(color=colors[i], label=f\"{value_ranges[i]} - {value_ranges[i+1]-1}\" if i < len(value_ranges) - 1 else f\"> {value_ranges[-1]}\") for i in range(len(value_ranges))]\n\n    # Create the legend outside the map\n    legend = plt.legend(handles=legend_elements, loc='upper left', title='Legend', fontsize=8)\n    legend.set_bbox_to_anchor((1.01, 1)) \n\n    # Remove the color bar\n    plt.colorbar().remove()\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Set the aspect ratio to 'equal' to keep the plot at the center\n    plt.gca().set_aspect('equal', adjustable='box')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15, right=0.80)  # Adjust right margin to accommodate the legend\n    # Show the plot or save it to a file\n    plt.savefig(f'/home/chetana/gridmet_test_run/predicted_swe-{timestamp_string}-{uuid.uuid4().hex}.png')\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "today date = 2023-09-12\n/home/chetana\n/home/chetana/gw-workspace/Jy4uznJrpdEt/convert_results_to_images.py:67: UserWarning: No data for colormapping provided via 'c'. Parameters 'cmap' will be ignored\n  plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\n",
  "history_begin_time" : 1694485591554,
  "history_end_time" : 1694485601215,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "U50QSRcIBbL0",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport uuid\nfrom snowcast_utils import day_index\nimport matplotlib.colors as mcolors\nfrom matplotlib.patches import Patch\n\n# Define the custom colormap with specified colors and ranges\ncolors = [\n    (1.0, 1.0, 1.0),           # White for 0\n    (0.8627, 0.8627, 0.8627),  # #DCDCDC - 0 - 1\n    (0.8627, 1.0000, 1.0000),  # #DCFFFF - 1 - 2\n    (0.6000, 1.0000, 1.0000),  # #99FFFF - 2 - 4\n    (0.5569, 0.8235, 1.0000),  # #8ED2FF - 4 - 6\n    (0.4509, 0.6196, 0.8745),  # #739EDF - 6 - 8\n    (0.4157, 0.4706, 1.0000),  # #6A78FF - 8 - 10\n    (0.4235, 0.2784, 1.0000),  # #6C47FF - 10 - 12\n    (0.5529, 0.0980, 1.0000),  # #8D19FF - 12 - 14\n    (0.7333, 0.0000, 0.9176),  # #BB00EA - 14 - 16\n    (0.8392, 0.0000, 0.7490),  # #D600BF - 16 - 18\n    (0.7569, 0.0039, 0.4549),  # #C10074 - 18 - 20\n    (0.6784, 0.0000, 0.1961),  # #AD0032 - 20 - 30\n    (0.5020, 0.0000, 0.0000)   # #800000 - > 30\n]\n\ncmap_name = 'custom_snow_colormap'\ncustom_cmap = mcolors.ListedColormap(colors)\n\n# Define the lat_lon_to_map_coordinates function\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\n# Define your value ranges for color mapping\nvalue_ranges = [0, 1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 30]\n\ndef convert_csvs_to_images():\n    data = pd.read_csv(\"/home/chetana/gridmet_test_run/predicted_val_with_2_thrushold.csv\")\n\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    x, y = m(data['lon'].values, data['lat'].values)\n\n    # Define your custom function to map data values to colors\n    def map_value_to_color(value):\n        if value == 0:\n            return (1.0, 1.0, 1.0)  # White for 0\n        \n        # Iterate through the value ranges to find the appropriate color index\n        for i, range_max in enumerate(value_ranges):\n            if value <= range_max:\n                return colors[i]\n        \n        # If the value is greater than the largest range, return the last color\n        return colors[-1]\n\n    # Map predicted_swe values to colors using the custom function\n    color_mapping = [map_value_to_color(value) for value in data['predicted_swe']]\n    \n    # Plot the data using the custom colormap\n    plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\n\n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_date = datetime(1900, 1, 1)\n    day_value = day_index\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    timestamp_string = result_date.strftime(\"%Y-%m-%d\")\n    \n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    # Create custom legend elements using the same colormap\n    legend_elements = [Patch(color=colors[i], label=f\"{value_ranges[i]} - {value_ranges[i+1]-1}\" if i < len(value_ranges) - 1 else f\"> {value_ranges[-1]}\") for i in range(len(value_ranges))]\n\n    # Create the legend outside the map\n    legend = plt.legend(handles=legend_elements, loc='upper left', title='Legend', fontsize=8)\n    legend.set_bbox_to_anchor((1.01, 1)) \n\n    # Remove the color bar\n    plt.colorbar().remove()\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Set the aspect ratio to 'equal' to keep the plot at the center\n    plt.gca().set_aspect('equal', adjustable='box')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15, right=0.80)  # Adjust right margin to accommodate the legend\n    # Show the plot or save it to a file\n    plt.savefig(f'/home/chetana/gridmet_test_run/predicted_swe-{timestamp_string}-{uuid.uuid4().hex}.png')\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "today date = 2023-09-12\n/home/chetana\n/home/chetana/gw-workspace/U50QSRcIBbL0/convert_results_to_images.py:68: UserWarning: No data for colormapping provided via 'c'. Parameters 'cmap' will be ignored\n  plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\n",
  "history_begin_time" : 1694485448430,
  "history_end_time" : 1694485458029,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "5SqMDrqmyr4m",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport uuid\nfrom snowcast_utils import day_index\nimport matplotlib.colors as mcolors\nfrom matplotlib.patches import Patch\n\n# Define the custom colormap with specified colors and ranges\ncolors = [\n    (0.8627, 0.8627, 0.8627),  # #DCDCDC - 0 - 1\n    (0.8627, 1.0000, 1.0000),  # #DCFFFF - 1 - 2\n    (0.6000, 1.0000, 1.0000),  # #99FFFF - 2 - 4\n    (0.5569, 0.8235, 1.0000),  # #8ED2FF - 4 - 6\n    (0.4509, 0.6196, 0.8745),  # #739EDF - 6 - 8\n    (0.4157, 0.4706, 1.0000),  # #6A78FF - 8 - 10\n    (0.4235, 0.2784, 1.0000),  # #6C47FF - 10 - 12\n    (0.5529, 0.0980, 1.0000),  # #8D19FF - 12 - 14\n    (0.7333, 0.0000, 0.9176),  # #BB00EA - 14 - 16\n    (0.8392, 0.0000, 0.7490),  # #D600BF - 16 - 18\n    (0.7569, 0.0039, 0.4549),  # #C10074 - 18 - 20\n    (0.6784, 0.0000, 0.1961),  # #AD0032 - 20 - 30\n    (0.5020, 0.0000, 0.0000)   # #800000 - > 30\n]\n\ncmap_name = 'custom_snow_colormap'\ncustom_cmap = mcolors.ListedColormap(colors)\n\n# Define the lat_lon_to_map_coordinates function\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\n# Define your value ranges for color mapping\nvalue_ranges = [1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 30]\n\ndef convert_csvs_to_images():\n    data = pd.read_csv(\"/home/chetana/gridmet_test_run/predicted_val_with_2_thrushold.csv\")\n\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    x, y = m(data['lon'].values, data['lat'].values)\n\n    # Define your custom function to map data values to colors\n    def map_value_to_color(value):\n        # Iterate through the value ranges to find the appropriate color index\n        for i, range_max in enumerate(value_ranges):\n            if value <= range_max:\n                return colors[i]\n        \n        # If the value is greater than the largest range, return the last color\n        return colors[-1]\n\n    # Map predicted_swe values to colors using the custom function\n    color_mapping = [map_value_to_color(value) for value in data['predicted_swe']]\n    \n    # Plot the data using the custom colormap\n    plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\n\n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_date = datetime(1900, 1, 1)\n    day_value = day_index\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    timestamp_string = result_date.strftime(\"%Y-%m-%d\")\n    \n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    # Create custom legend elements using the same colormap\n    legend_elements = [Patch(color=colors[i], label=f\"{value_ranges[i]} - {value_ranges[i+1]-1}\" if i < len(value_ranges) - 1 else f\"> {value_ranges[-1]}\") for i in range(len(value_ranges))]\n\n    # Create the legend outside the map\n    legend = plt.legend(handles=legend_elements, loc='upper left', title='Legend', fontsize=8)\n    legend.set_bbox_to_anchor((1.01, 1)) \n\n    # Remove the color bar\n    plt.colorbar().remove()\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Set the aspect ratio to 'equal' to keep the plot at the center\n    plt.gca().set_aspect('equal', adjustable='box')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15, right=0.80)  # Adjust right margin to accommodate the legend\n    # Show the plot or save it to a file\n    plt.savefig(f'/home/chetana/gridmet_test_run/predicted_swe-{timestamp_string}-{uuid.uuid4().hex}.png')\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "today date = 2023-09-12\n/home/chetana\n/home/chetana/gw-workspace/5SqMDrqmyr4m/convert_results_to_images.py:64: UserWarning: No data for colormapping provided via 'c'. Parameters 'cmap' will be ignored\n  plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\n",
  "history_begin_time" : 1694485059178,
  "history_end_time" : 1694485069278,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "J2R2behhZ0Jp",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport uuid\nfrom snowcast_utils import day_index\nimport matplotlib.colors as mcolors\nfrom matplotlib.patches import Patch\n\n# Define the custom colormap with specified colors and ranges\ncolors = [\n    (0.8627, 0.8627, 0.8627),  # #DCDCDC - 0 - 1\n    (0.8627, 1.0000, 1.0000),  # #DCFFFF - 1 - 2\n    (0.6000, 1.0000, 1.0000),  # #99FFFF - 2 - 4\n    (0.5569, 0.8235, 1.0000),  # #8ED2FF - 4 - 6\n    (0.4509, 0.6196, 0.8745),  # #739EDF - 6 - 8\n    (0.4157, 0.4706, 1.0000),  # #6A78FF - 8 - 10\n    (0.4235, 0.2784, 1.0000),  # #6C47FF - 10 - 12\n    (0.5529, 0.0980, 1.0000),  # #8D19FF - 12 - 14\n    (0.7333, 0.0000, 0.9176),  # #BB00EA - 14 - 16\n    (0.8392, 0.0000, 0.7490),  # #D600BF - 16 - 18\n    (0.7569, 0.0039, 0.4549),  # #C10074 - 18 - 20\n    (0.6784, 0.0000, 0.1961),  # #AD0032 - 20 - 30\n    (0.5020, 0.0000, 0.0000)   # #800000 - > 30\n]\n\ncmap_name = 'custom_snow_colormap'\ncustom_cmap = mcolors.ListedColormap(colors)\n\n# Define the lat_lon_to_map_coordinates function\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\n# Define your value ranges for color mapping\nvalue_ranges = [1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 30]\n\ndef convert_csvs_to_images():\n    data = pd.read_csv(\"/home/chetana/gridmet_test_run/predicted_val_with_2_thrushold.csv\")\n\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    x, y = m(data['lon'].values, data['lat'].values)\n\n    # Define your custom function to map data values to colors\n    def map_value_to_color(value):\n        # Iterate through the value ranges to find the appropriate color index\n        for i, range_max in enumerate(value_ranges):\n            if value <= range_max:\n                return colors[i]\n        \n        # If the value is greater than the largest range, return the last color\n        return colors[-1]\n\n    # Map predicted_swe values to colors using the custom function\n    color_mapping = [map_value_to_color(value) for value in data['predicted_swe']]\n    \n    # Plot the data using the custom colormap\n    plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\n\n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_date = datetime(1900, 1, 1)\n    day_value = day_index\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    \n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    # Create custom legend elements using the same colormap\n    legend_elements = [Patch(color=colors[i], label=f\"{value_ranges[i]} - {value_ranges[i+1]-1}\" if i < len(value_ranges) - 1 else f\"> {value_ranges[-1]}\") for i in range(len(value_ranges))]\n\n    # Create the legend outside the map\n    legend = plt.legend(handles=legend_elements, loc='upper left', title='Legend', fontsize=8)\n    legend.set_bbox_to_anchor((1.01, 1)) \n\n    # Remove the color bar\n    plt.colorbar().remove()\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Set the aspect ratio to 'equal' to keep the plot at the center\n    plt.gca().set_aspect('equal', adjustable='box')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15, right=0.80)  # Adjust right margin to accommodate the legend\n    # Show the plot or save it to a file\n    plt.savefig(f'/home/chetana/gridmet_test_run/predicted_swe-{timestamp_string}-{uuid.uuid4().hex}.png')\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "today date = 2023-09-12\n/home/chetana\n/home/chetana/gw-workspace/J2R2behhZ0Jp/convert_results_to_images.py:64: UserWarning: No data for colormapping provided via 'c'. Parameters 'cmap' will be ignored\n  plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\nTraceback (most recent call last):\n  File \"/home/chetana/gw-workspace/J2R2behhZ0Jp/convert_results_to_images.py\", line 126, in <module>\n    convert_csvs_to_images()\n  File \"/home/chetana/gw-workspace/J2R2behhZ0Jp/convert_results_to_images.py\", line 123, in convert_csvs_to_images\n    plt.savefig(f'/home/chetana/gridmet_test_run/predicted_swe-{timestamp_string}-{uuid.uuid4().hex}.png')\nNameError: name 'timestamp_string' is not defined\n",
  "history_begin_time" : 1694484990537,
  "history_end_time" : 1694484995830,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "tq4oltXwYmK0",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport uuid\nfrom snowcast_utils import day_index\nimport matplotlib.colors as mcolors\nfrom matplotlib.patches import Patch\n\n# Define the custom colormap with specified colors and ranges\ncolors = [\n    (0.8627, 0.8627, 0.8627),  # #DCDCDC - 0 - 1\n    (0.8627, 1.0000, 1.0000),  # #DCFFFF - 1 - 2\n    (0.6000, 1.0000, 1.0000),  # #99FFFF - 2 - 4\n    (0.5569, 0.8235, 1.0000),  # #8ED2FF - 4 - 6\n    (0.4509, 0.6196, 0.8745),  # #739EDF - 6 - 8\n    (0.4157, 0.4706, 1.0000),  # #6A78FF - 8 - 10\n    (0.4235, 0.2784, 1.0000),  # #6C47FF - 10 - 12\n    (0.5529, 0.0980, 1.0000),  # #8D19FF - 12 - 14\n    (0.7333, 0.0000, 0.9176),  # #BB00EA - 14 - 16\n    (0.8392, 0.0000, 0.7490),  # #D600BF - 16 - 18\n    (0.7569, 0.0039, 0.4549),  # #C10074 - 18 - 20\n    (0.6784, 0.0000, 0.1961),  # #AD0032 - 20 - 30\n    (0.5020, 0.0000, 0.0000)   # #800000 - > 30\n]\n\ncmap_name = 'custom_snow_colormap'\ncustom_cmap = mcolors.ListedColormap(colors)\n\n# Define the lat_lon_to_map_coordinates function\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\n# Define your value ranges for color mapping\nvalue_ranges = [1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 30]\n\ndef convert_csvs_to_images():\n    data = pd.read_csv(\"/home/chetana/gridmet_test_run/predicted_val_with_2_thrushold.csv\")\n\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    x, y = m(data['lon'].values, data['lat'].values)\n\n    # Define your custom function to map data values to colors\n    def map_value_to_color(value):\n        # Iterate through the value ranges to find the appropriate color index\n        for i, range_max in enumerate(value_ranges):\n            if value <= range_max:\n                return colors[i]\n        \n        # If the value is greater than the largest range, return the last color\n        return colors[-1]\n\n    # Map predicted_swe values to colors using the custom function\n    color_mapping = [map_value_to_color(value) for value in data['predicted_swe']]\n    \n    # Plot the data using the custom colormap\n    plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\n\n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_date = datetime(1900, 1, 1)\n    day_value = day_index\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    \n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    # Create custom legend elements using the same colormap\n    legend_elements = [Patch(color=colors[i], label=f\"{value_ranges[i]} - {value_ranges[i+1]-1}\" if i < len(value_ranges) - 1 else f\"> {value_ranges[-1]}\") for i in range(len(value_ranges))]\n\n    # Create the legend outside the map\n    legend = plt.legend(handles=legend_elements, loc='upper left', title='Legend', fontsize=8)\nlegend.set_bbox_to_anchor((1.01, 1)) \n\n    # Remove the color bar\n    plt.colorbar().remove()\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Set the aspect ratio to 'equal' to keep the plot at the center\n    plt.gca().set_aspect('equal', adjustable='box')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15, right=0.80)  # Adjust right margin to accommodate the legend\n    # Show the plot or save it to a file\n    plt.savefig(f'/home/chetana/gridmet_test_run/predicted_swe-{timestamp_string}-{uuid.uuid4().hex}.png')\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "  File \"/home/chetana/gw-workspace/tq4oltXwYmK0/convert_results_to_images.py\", line 111\n    plt.colorbar().remove()\nIndentationError: unexpected indent\n",
  "history_begin_time" : 1694484977377,
  "history_end_time" : 1694484978386,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "6EEjLweJ5bkz",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport uuid\nfrom snowcast_utils import day_index\nimport matplotlib.colors as mcolors\nfrom matplotlib.patches import Patch\n\n# Define the custom colormap with specified colors and ranges\ncolors = [\n    (0.8627, 0.8627, 0.8627),  # #DCDCDC - 0 - 1\n    (0.8627, 1.0000, 1.0000),  # #DCFFFF - 1 - 2\n    (0.6000, 1.0000, 1.0000),  # #99FFFF - 2 - 4\n    (0.5569, 0.8235, 1.0000),  # #8ED2FF - 4 - 6\n    (0.4509, 0.6196, 0.8745),  # #739EDF - 6 - 8\n    (0.4157, 0.4706, 1.0000),  # #6A78FF - 8 - 10\n    (0.4235, 0.2784, 1.0000),  # #6C47FF - 10 - 12\n    (0.5529, 0.0980, 1.0000),  # #8D19FF - 12 - 14\n    (0.7333, 0.0000, 0.9176),  # #BB00EA - 14 - 16\n    (0.8392, 0.0000, 0.7490),  # #D600BF - 16 - 18\n    (0.7569, 0.0039, 0.4549),  # #C10074 - 18 - 20\n    (0.6784, 0.0000, 0.1961),  # #AD0032 - 20 - 30\n    (0.5020, 0.0000, 0.0000)   # #800000 - > 30\n]\n\ncmap_name = 'custom_snow_colormap'\ncustom_cmap = mcolors.ListedColormap(colors)\n\n# Define the lat_lon_to_map_coordinates function\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\n# Define your value ranges for color mapping\nvalue_ranges = [1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 30]\n\ndef convert_csvs_to_images():\n    data = pd.read_csv(\"/home/chetana/gridmet_test_run/predicted_val_with_2_thrushold.csv\")\n\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    x, y = m(data['lon'].values, data['lat'].values)\n\n    # Define your custom function to map data values to colors\n    def map_value_to_color(value):\n        # Iterate through the value ranges to find the appropriate color index\n        for i, range_max in enumerate(value_ranges):\n            if value <= range_max:\n                return colors[i]\n        \n        # If the value is greater than the largest range, return the last color\n        return colors[-1]\n\n    # Map predicted_swe values to colors using the custom function\n    color_mapping = [map_value_to_color(value) for value in data['predicted_swe']]\n    \n    # Plot the data using the custom colormap\n    plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\n\n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_date = datetime(1900, 1, 1)\n    day_value = day_index\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    \n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    # Create custom legend elements using the same colormap\n    legend_elements = [Patch(color=colors[i], label=f\"{value_ranges[i]} - {value_ranges[i+1]-1}\" if i < len(value_ranges) - 1 else f\"> {value_ranges[-1]}\") for i in range(len(value_ranges))]\n\n    # Create the legend outside the map\n    legend = plt.legend(handles=legend_elements, loc='upper left', title='Legend', fontsize=8)\nlegend.set_bbox_to_anchor((1.01, 1)) \n\n    # Remove the color bar\n    plt.colorbar().remove()\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Set the aspect ratio to 'equal' to keep the plot at the center\n    plt.gca().set_aspect('equal', adjustable='box')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15, right=0.80)  # Adjust right margin to accommodate the legend\n    # Show the plot or save it to a file\n    plt.savefig(f'/home/chetana/gridmet_test_run/predicted_swe-{timestamp_string}-{uuid.uuid4().hex}.png')\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "  File \"/home/chetana/gw-workspace/6EEjLweJ5bkz/convert_results_to_images.py\", line 111\n    plt.colorbar().remove()\nIndentationError: unexpected indent\n",
  "history_begin_time" : 1694484965207,
  "history_end_time" : 1694484966224,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "6tmG8CF54sMS",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport uuid\nfrom snowcast_utils import day_index\nimport matplotlib.colors as mcolors\nfrom matplotlib.patches import Patch\n\n# Define the custom colormap with specified colors and ranges\ncolors = [\n    (0.8627, 0.8627, 0.8627),  # #DCDCDC - 0 - 1\n    (0.8627, 1.0000, 1.0000),  # #DCFFFF - 1 - 2\n    (0.6000, 1.0000, 1.0000),  # #99FFFF - 2 - 4\n    (0.5569, 0.8235, 1.0000),  # #8ED2FF - 4 - 6\n    (0.4509, 0.6196, 0.8745),  # #739EDF - 6 - 8\n    (0.4157, 0.4706, 1.0000),  # #6A78FF - 8 - 10\n    (0.4235, 0.2784, 1.0000),  # #6C47FF - 10 - 12\n    (0.5529, 0.0980, 1.0000),  # #8D19FF - 12 - 14\n    (0.7333, 0.0000, 0.9176),  # #BB00EA - 14 - 16\n    (0.8392, 0.0000, 0.7490),  # #D600BF - 16 - 18\n    (0.7569, 0.0039, 0.4549),  # #C10074 - 18 - 20\n    (0.6784, 0.0000, 0.1961),  # #AD0032 - 20 - 30\n    (0.5020, 0.0000, 0.0000)   # #800000 - > 30\n]\n\ncmap_name = 'custom_snow_colormap'\ncustom_cmap = mcolors.ListedColormap(colors)\n\n# Define the lat_lon_to_map_coordinates function\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\n# Define your value ranges for color mapping\nvalue_ranges = [1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 30]\n\ndef convert_csvs_to_images():\n    data = pd.read_csv(\"/home/chetana/gridmet_test_run/predicted_val_with_2_thrushold.csv\")\n\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    x, y = m(data['lon'].values, data['lat'].values)\n\n    # Define your custom function to map data values to colors\n    def map_value_to_color(value):\n        # Iterate through the value ranges to find the appropriate color index\n        for i, range_max in enumerate(value_ranges):\n            if value <= range_max:\n                return colors[i]\n        \n        # If the value is greater than the largest range, return the last color\n        return colors[-1]\n\n    # Map predicted_swe values to colors using the custom function\n    color_mapping = [map_value_to_color(value) for value in data['predicted_swe']]\n    \n    # Plot the data using the custom colormap\n    plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\n\n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_date = datetime(1900, 1, 1)\n    day_value = day_index\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    \n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    # Create custom legend elements using the same colormap\n    legend_elements = [Patch(color=colors[i], label=f\"{value_ranges[i]} - {value_ranges[i+1]-1}\" if i < len(colors) - 1 else f\"> {value_ranges[-1]}\") for i in range(len(colors))]\n\n    # Create the legend outside the map\n    legend = plt.legend(handles=legend_elements, loc='upper left', title='Legend', fontsize=8)\n    legend.set_bbox_to_anchor((1.01, 1))  # Adjust the position of the legend\n\n    # Remove the color bar\n    plt.colorbar().remove()\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Set the aspect ratio to 'equal' to keep the plot at the center\n    plt.gca().set_aspect('equal', adjustable='box')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15, right=0.80)  # Adjust right margin to accommodate the legend\n    # Show the plot or save it to a file\n    plt.savefig(f'/home/chetana/gridmet_test_run/predicted_swe-{timestamp_string}-{uuid.uuid4().hex}.png')\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "today date = 2023-09-12\n/home/chetana\n/home/chetana/gw-workspace/6tmG8CF54sMS/convert_results_to_images.py:64: UserWarning: No data for colormapping provided via 'c'. Parameters 'cmap' will be ignored\n  plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\nTraceback (most recent call last):\n  File \"/home/chetana/gw-workspace/6tmG8CF54sMS/convert_results_to_images.py\", line 126, in <module>\n    convert_csvs_to_images()\n  File \"/home/chetana/gw-workspace/6tmG8CF54sMS/convert_results_to_images.py\", line 104, in convert_csvs_to_images\n    legend_elements = [Patch(color=colors[i], label=f\"{value_ranges[i]} - {value_ranges[i+1]-1}\" if i < len(colors) - 1 else f\"> {value_ranges[-1]}\") for i in range(len(colors))]\n  File \"/home/chetana/gw-workspace/6tmG8CF54sMS/convert_results_to_images.py\", line 104, in <listcomp>\n    legend_elements = [Patch(color=colors[i], label=f\"{value_ranges[i]} - {value_ranges[i+1]-1}\" if i < len(colors) - 1 else f\"> {value_ranges[-1]}\") for i in range(len(colors))]\nIndexError: list index out of range\n",
  "history_begin_time" : 1694484882538,
  "history_end_time" : 1694484887785,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "sr0lkvN4hyt8",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport uuid\nfrom snowcast_utils import day_index\nimport matplotlib.colors as mcolors\nfrom matplotlib.patches import Patch\n\n# Define the custom colormap with specified colors and ranges\ncolors = [\n    (0.8627, 0.8627, 0.8627),  # #DCDCDC - 0 - 1\n    (0.8627, 1.0000, 1.0000),  # #DCFFFF - 1 - 2\n    (0.6000, 1.0000, 1.0000),  # #99FFFF - 2 - 4\n    (0.5569, 0.8235, 1.0000),  # #8ED2FF - 4 - 6\n    (0.4509, 0.6196, 0.8745),  # #739EDF - 6 - 8\n    (0.4157, 0.4706, 1.0000),  # #6A78FF - 8 - 10\n    (0.4235, 0.2784, 1.0000),  # #6C47FF - 10 - 12\n    (0.5529, 0.0980, 1.0000),  # #8D19FF - 12 - 14\n    (0.7333, 0.0000, 0.9176),  # #BB00EA - 14 - 16\n    (0.8392, 0.0000, 0.7490),  # #D600BF - 16 - 18\n    (0.7569, 0.0039, 0.4549),  # #C10074 - 18 - 20\n    (0.6784, 0.0000, 0.1961),  # #AD0032 - 20 - 30\n    (0.5020, 0.0000, 0.0000)   # #800000 - > 30\n]\n\ncmap_name = 'custom_snow_colormap'\ncustom_cmap = mcolors.ListedColormap(colors)\n\n# Define the lat_lon_to_map_coordinates function\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\n# Define your value ranges for color mapping\nvalue_ranges = [1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 30]\n\ndef convert_csvs_to_images():\n    data = pd.read_csv(\"/home/chetana/gridmet_test_run/predicted_val_with_2_thrushold.csv\")\n\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    x, y = m(data['lon'].values, data['lat'].values)\n\n    # Define your custom function to map data values to colors\n    def map_value_to_color(value):\n        # Iterate through the value ranges to find the appropriate color index\n        for i, range_max in enumerate(value_ranges):\n            if value <= range_max:\n                return colors[i]\n        \n        # If the value is greater than the largest range, return the last color\n        return colors[-1]\n\n    # Map predicted_swe values to colors using the custom function\n    color_mapping = [map_value_to_color(value) for value in data['predicted_swe']]\n    \n    # Plot the data using the custom colormap\n    plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\n\n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_date = datetime(1900, 1, 1)\n    day_value = day_index\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    \n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    # Create custom legend elements using the same colormap\n    legend_elements = [Patch(color=colors[i], label=f\"{value_ranges[i]} - {value_ranges[i+1]-1}\" if i < len(colors) - 1 else f\"> {value_ranges[-1]}\") for i in range(len(colors))]\n\n    # Create the legend outside the map\n    legend = plt.legend(handles=legend_elements, loc='upper left', title='Legend', fontsize=8)\n    legend.set_bbox_to_anchor((1.01, 1))  # Adjust the position of the legend\n\n    # Remove the color bar\n    plt.colorbar().remove()\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Set the aspect ratio to 'equal' to keep the plot at the center\n    plt.gca().set_aspect('equal', adjustable='box')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15, right=0.80)  # Adjust right margin to accommodate the legend\n    # Show the plot or save it to a file\n    plt.savefig(f'/home/chetana/gridmet_test_run/predicted_swe-{timestamp_string}-{uuid.uuid4().hex}.png')\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "today date = 2023-09-12\n/home/chetana\n/home/chetana/gw-workspace/sr0lkvN4hyt8/convert_results_to_images.py:64: UserWarning: No data for colormapping provided via 'c'. Parameters 'cmap' will be ignored\n  plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\nTraceback (most recent call last):\n  File \"/home/chetana/gw-workspace/sr0lkvN4hyt8/convert_results_to_images.py\", line 126, in <module>\n    convert_csvs_to_images()\n  File \"/home/chetana/gw-workspace/sr0lkvN4hyt8/convert_results_to_images.py\", line 104, in convert_csvs_to_images\n    legend_elements = [Patch(color=colors[i], label=f\"{value_ranges[i]} - {value_ranges[i+1]-1}\" if i < len(colors) - 1 else f\"> {value_ranges[-1]}\") for i in range(len(colors))]\n  File \"/home/chetana/gw-workspace/sr0lkvN4hyt8/convert_results_to_images.py\", line 104, in <listcomp>\n    legend_elements = [Patch(color=colors[i], label=f\"{value_ranges[i]} - {value_ranges[i+1]-1}\" if i < len(colors) - 1 else f\"> {value_ranges[-1]}\") for i in range(len(colors))]\nIndexError: list index out of range\n",
  "history_begin_time" : 1694484830891,
  "history_end_time" : 1694484836126,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "cEF2edISQEui",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport uuid\nfrom snowcast_utils import day_index\nimport matplotlib.colors as mcolors\nfrom matplotlib.patches import Patch\n\n# Define the custom colormap with specified colors and ranges\ncolors = [\n    (0.8627, 0.8627, 0.8627),  # #DCDCDC - 0 - 1\n    (0.8627, 1.0000, 1.0000),  # #DCFFFF - 1 - 2\n    (0.6000, 1.0000, 1.0000),  # #99FFFF - 2 - 4\n    (0.5569, 0.8235, 1.0000),  # #8ED2FF - 4 - 6\n    (0.4509, 0.6196, 0.8745),  # #739EDF - 6 - 8\n    (0.4157, 0.4706, 1.0000),  # #6A78FF - 8 - 10\n    (0.4235, 0.2784, 1.0000),  # #6C47FF - 10 - 12\n    (0.5529, 0.0980, 1.0000),  # #8D19FF - 12 - 14\n    (0.7333, 0.0000, 0.9176),  # #BB00EA - 14 - 16\n    (0.8392, 0.0000, 0.7490),  # #D600BF - 16 - 18\n    (0.7569, 0.0039, 0.4549),  # #C10074 - 18 - 20\n    (0.6784, 0.0000, 0.1961),  # #AD0032 - 20 - 30\n    (0.5020, 0.0000, 0.0000)   # #800000 - > 30\n]\n\ncmap_name = 'custom_snow_colormap'\ncustom_cmap = mcolors.ListedColormap(colors)\n\n# Define the lat_lon_to_map_coordinates function\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\n# Define your value ranges for color mapping\nvalue_ranges = [1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 30]\n\ndef convert_csvs_to_images():\n    data = pd.read_csv(\"/home/chetana/gridmet_test_run/predicted_val_with_2_thrushold.csv\")\n\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    x, y = m(data['lon'].values, data['lat'].values)\n\n    # Define your custom function to map data values to colors\n    def map_value_to_color(value):\n        # Iterate through the value ranges to find the appropriate color index\n        for i, range_max in enumerate(value_ranges):\n            if value <= range_max:\n                return colors[i]\n        \n        # If the value is greater than the largest range, return the last color\n        return colors[-1]\n\n    # Map predicted_swe values to colors using the custom function\n    color_mapping = [map_value_to_color(value) for value in data['predicted_swe']]\n    \n    # Plot the data using the custom colormap\n    plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\n\n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_date = datetime(1900, 1, 1)\n    day_value = day_index\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    \n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    # Create custom legend elements using the same colormap\n    legend_elements = [Patch(color=colors[i], label=f\"{value_ranges[i]} - {value_ranges[i+1]-1}\" if i < len(colors) - 1 else f\"> {value_ranges[-1]}\") for i in range(len(colors))]\n\n    # Create the legend outside the map\n    legend = plt.legend(handles=legend_elements, loc='upper left', title='Legend', fontsize=8)\n    legend.set_bbox_to_anchor((1.01, 1))  # Adjust the position of the legend\n\n    # Remove the color bar\n    plt.colorbar().remove()\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Set the aspect ratio to 'equal' to keep the plot at the center\n    plt.gca().set_aspect('equal', adjustable='box')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15, right=0.80)  # Adjust right margin to accommodate the legend\n    # Show the plot or save it to a file\n    plt.savefig(f'/home/chetana/gridmet_test_run/predicted_swe-{timestamp_string}-{uuid.uuid4().hex}.png')\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "today date = 2023-09-12\n/home/chetana\n/home/chetana/gw-workspace/cEF2edISQEui/convert_results_to_images.py:64: UserWarning: No data for colormapping provided via 'c'. Parameters 'cmap' will be ignored\n  plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\nTraceback (most recent call last):\n  File \"/home/chetana/gw-workspace/cEF2edISQEui/convert_results_to_images.py\", line 126, in <module>\n    convert_csvs_to_images()\n  File \"/home/chetana/gw-workspace/cEF2edISQEui/convert_results_to_images.py\", line 104, in convert_csvs_to_images\n    legend_elements = [Patch(color=colors[i], label=f\"{value_ranges[i]} - {value_ranges[i+1]-1}\" if i < len(colors) - 1 else f\"> {value_ranges[-1]}\") for i in range(len(colors))]\n  File \"/home/chetana/gw-workspace/cEF2edISQEui/convert_results_to_images.py\", line 104, in <listcomp>\n    legend_elements = [Patch(color=colors[i], label=f\"{value_ranges[i]} - {value_ranges[i+1]-1}\" if i < len(colors) - 1 else f\"> {value_ranges[-1]}\") for i in range(len(colors))]\nIndexError: list index out of range\n",
  "history_begin_time" : 1694484818712,
  "history_end_time" : 1694484823902,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "Fkgn7pwoiAir",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport uuid\nfrom snowcast_utils import day_index\nimport matplotlib.colors as mcolors\nfrom matplotlib.patches import Patch\n\n# Define the custom colormap with specified colors and ranges\ncolors = [\n    (0.8627, 0.8627, 0.8627),  # #DCDCDC - 0 - 1\n    (0.8627, 1.0000, 1.0000),  # #DCFFFF - 1 - 2\n    (0.6000, 1.0000, 1.0000),  # #99FFFF - 2 - 4\n    (0.5569, 0.8235, 1.0000),  # #8ED2FF - 4 - 6\n    (0.4509, 0.6196, 0.8745),  # #739EDF - 6 - 8\n    (0.4157, 0.4706, 1.0000),  # #6A78FF - 8 - 10\n    (0.4235, 0.2784, 1.0000),  # #6C47FF - 10 - 12\n    (0.5529, 0.0980, 1.0000),  # #8D19FF - 12 - 14\n    (0.7333, 0.0000, 0.9176),  # #BB00EA - 14 - 16\n    (0.8392, 0.0000, 0.7490),  # #D600BF - 16 - 18\n    (0.7569, 0.0039, 0.4549),  # #C10074 - 18 - 20\n    (0.6784, 0.0000, 0.1961),  # #AD0032 - 20 - 30\n    (0.5020, 0.0000, 0.0000)   # #800000 - > 30\n]\n\ncmap_name = 'custom_snow_colormap'\ncustom_cmap = mcolors.ListedColormap(colors)\n\n# Define the lat_lon_to_map_coordinates function\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\n# Define your value ranges for color mapping\nvalue_ranges = [1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 30]\n\ndef convert_csvs_to_images():\n    data = pd.read_csv(\"/home/chetana/gridmet_test_run/predicted_val_with_2_thrushold.csv\")\n\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    x, y = m(data['lon'].values, data['lat'].values)\n\n    # Define your custom function to map data values to colors\n    def map_value_to_color(value):\n        # Iterate through the value ranges to find the appropriate color index\n        for i, range_max in enumerate(value_ranges):\n            if value <= range_max:\n                return colors[i]\n        \n        # If the value is greater than the largest range, return the last color\n        return colors[-1]\n\n    # Map predicted_swe values to colors using the custom function\n    color_mapping = [map_value_to_color(value) for value in data['predicted_swe']]\n    \n    # Plot the data using the custom colormap\n    plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\n\n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_date = datetime(1900, 1, 1)\n    day_value = day_index\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    \n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    # Create custom legend elements using the same colormap\n    legend_elements = [Patch(color=custom_cmap(i / len(colors)), label=f\"{value_ranges[i]} - {value_ranges[i+1]-1}\" if i < len(colors) - 1 else f\"> {value_ranges[-1]}\") for i in range(len(colors))]\n\n    # Create the legend outside the map\n    legend = plt.legend(handles=legend_elements, loc='upper left', title='Legend', fontsize=8)\n    legend.set_bbox_to_anchor((1.01, 1))  # Adjust the position of the legend\n\n    # Remove the color bar\n    plt.colorbar().remove()\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Set the aspect ratio to 'equal' to keep the plot at the center\n    plt.gca().set_aspect('equal', adjustable='box')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15, right=0.80)  # Adjust right margin to accommodate the legend\n    # Show the plot or save it to a file\n    plt.savefig(f'/home/chetana/gridmet_test_run/predicted_swe-{timestamp_string}-{uuid.uuid4().hex}.png')\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "today date = 2023-09-12\n/home/chetana\n/home/chetana/gw-workspace/Fkgn7pwoiAir/convert_results_to_images.py:64: UserWarning: No data for colormapping provided via 'c'. Parameters 'cmap' will be ignored\n  plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\nTraceback (most recent call last):\n  File \"/home/chetana/gw-workspace/Fkgn7pwoiAir/convert_results_to_images.py\", line 126, in <module>\n    convert_csvs_to_images()\n  File \"/home/chetana/gw-workspace/Fkgn7pwoiAir/convert_results_to_images.py\", line 104, in convert_csvs_to_images\n    legend_elements = [Patch(color=custom_cmap(i / len(colors)), label=f\"{value_ranges[i]} - {value_ranges[i+1]-1}\" if i < len(colors) - 1 else f\"> {value_ranges[-1]}\") for i in range(len(colors))]\n  File \"/home/chetana/gw-workspace/Fkgn7pwoiAir/convert_results_to_images.py\", line 104, in <listcomp>\n    legend_elements = [Patch(color=custom_cmap(i / len(colors)), label=f\"{value_ranges[i]} - {value_ranges[i+1]-1}\" if i < len(colors) - 1 else f\"> {value_ranges[-1]}\") for i in range(len(colors))]\nIndexError: list index out of range\n",
  "history_begin_time" : 1694484694969,
  "history_end_time" : 1694484700241,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "NwEhRkHXl6iU",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport uuid\nfrom snowcast_utils import day_index\nimport matplotlib.colors as mcolors\nfrom matplotlib.patches import Patch\n\nvalue_ranges = [1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 30]\n# Define the custom colormap with specified colors and ranges\ncolors = [\n    (0.8627, 0.8627, 0.8627),  # #DCDCDC - 0 - 1\n    (0.8627, 1.0000, 1.0000),  # #DCFFFF - 1 - 2\n    (0.6000, 1.0000, 1.0000),  # #99FFFF - 2 - 4\n    (0.5569, 0.8235, 1.0000),  # #8ED2FF - 4 - 6\n    (0.4509, 0.6196, 0.8745),  # #739EDF - 6 - 8\n    (0.4157, 0.4706, 1.0000),  # #6A78FF - 8 - 10\n    (0.4235, 0.2784, 1.0000),  # #6C47FF - 10 - 12\n    (0.5529, 0.0980, 1.0000),  # #8D19FF - 12 - 14\n    (0.7333, 0.0000, 0.9176),  # #BB00EA - 14 - 16\n    (0.8392, 0.0000, 0.7490),  # #D600BF - 16 - 18\n    (0.7569, 0.0039, 0.4549),  # #C10074 - 18 - 20\n    (0.6784, 0.0000, 0.1961),  # #AD0032 - 20 - 30\n    (0.5020, 0.0000, 0.0000)   # #800000 - > 30\n]\n\ncmap_name = 'custom_snow_colormap'\ncustom_cmap = mcolors.ListedColormap(colors)\n\n# Define the lat_lon_to_map_coordinates function\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\ndef convert_csvs_to_images():\n    data = pd.read_csv(\"/home/chetana/gridmet_test_run/predicted_val_with_2_thrushold.csv\")\n\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    x, y = m(data['lon'].values, data['lat'].values)\n\n    # Define your custom function to map data values to colors\n    def map_value_to_color(value):\n        # Define your value ranges and corresponding color indices\n        value_ranges = [1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 30]\n        \n        # Iterate through the value ranges to find the appropriate color index\n        for i, range_max in enumerate(value_ranges):\n            if value <= range_max:\n                return colors[i]\n        \n        # If the value is greater than the largest range, return the last color\n        return colors[-1]\n\n    # Map predicted_swe values to colors using the custom function\n    color_mapping = [map_value_to_color(value) for value in data['predicted_swe']]\n    \n    # Plot the data using the custom colormap\n    plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\n\n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_date = datetime(1900, 1, 1)\n    day_value = day_index\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    \n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    # Create custom legend elements using the same colormap\n    legend_elements = [Patch(color=custom_cmap(i / len(colors)), label=f\"{r[0]} - {r[1]}\" if i < len(colors) else \"> 30\") for i, r in enumerate(value_ranges)]\n\n    # Create the legend outside the map\n    legend = plt.legend(handles=legend_elements, loc='upper left', title='Legend', fontsize=8)\n    legend.set_bbox_to_anchor((1.01, 1))  # Adjust the position of the legend\n\n    # Remove the color bar\n    plt.colorbar().remove()\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Set the aspect ratio to 'equal' to keep the plot at the center\n    plt.gca().set_aspect('equal', adjustable='box')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15, right=0.80)  # Adjust right margin to accommodate the legend\n    # Show the plot or save it to a file\n    plt.savefig(f'/home/chetana/gridmet_test_run/predicted_swe-{timestamp_string}-{uuid.uuid4().hex}.png')\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\n# Call the function to convert CSVs to images\nconvert_csvs_to_images()\n",
  "history_output" : "today date = 2023-09-12\n/home/chetana\n/home/chetana/gw-workspace/NwEhRkHXl6iU/convert_results_to_images.py:65: UserWarning: No data for colormapping provided via 'c'. Parameters 'cmap' will be ignored\n  plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\nTraceback (most recent call last):\n  File \"/home/chetana/gw-workspace/NwEhRkHXl6iU/convert_results_to_images.py\", line 128, in <module>\n    convert_csvs_to_images()\n  File \"/home/chetana/gw-workspace/NwEhRkHXl6iU/convert_results_to_images.py\", line 105, in convert_csvs_to_images\n    legend_elements = [Patch(color=custom_cmap(i / len(colors)), label=f\"{r[0]} - {r[1]}\" if i < len(colors) else \"> 30\") for i, r in enumerate(value_ranges)]\n  File \"/home/chetana/gw-workspace/NwEhRkHXl6iU/convert_results_to_images.py\", line 105, in <listcomp>\n    legend_elements = [Patch(color=custom_cmap(i / len(colors)), label=f\"{r[0]} - {r[1]}\" if i < len(colors) else \"> 30\") for i, r in enumerate(value_ranges)]\nTypeError: 'int' object is not subscriptable\n",
  "history_begin_time" : 1694484569086,
  "history_end_time" : 1694484574397,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "Hc135FINzbHg",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport uuid\nfrom snowcast_utils import day_index\nimport matplotlib.colors as mcolors\nfrom matplotlib.patches import Patch\n\n# Define the custom colormap with specified colors and ranges\ncolors = [\n    (0.8627, 0.8627, 0.8627),  # #DCDCDC - 0 - 1\n    (0.8627, 1.0000, 1.0000),  # #DCFFFF - 1 - 2\n    (0.6000, 1.0000, 1.0000),  # #99FFFF - 2 - 4\n    (0.5569, 0.8235, 1.0000),  # #8ED2FF - 4 - 6\n    (0.4509, 0.6196, 0.8745),  # #739EDF - 6 - 8\n    (0.4157, 0.4706, 1.0000),  # #6A78FF - 8 - 10\n    (0.4235, 0.2784, 1.0000),  # #6C47FF - 10 - 12\n    (0.5529, 0.0980, 1.0000),  # #8D19FF - 12 - 14\n    (0.7333, 0.0000, 0.9176),  # #BB00EA - 14 - 16\n    (0.8392, 0.0000, 0.7490),  # #D600BF - 16 - 18\n    (0.7569, 0.0039, 0.4549),  # #C10074 - 18 - 20\n    (0.6784, 0.0000, 0.1961),  # #AD0032 - 20 - 30\n    (0.5020, 0.0000, 0.0000)   # #800000 - > 30\n]\n\ncmap_name = 'custom_snow_colormap'\ncustom_cmap = mcolors.ListedColormap(colors)\n\n# Define the lat_lon_to_map_coordinates function\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\ndef convert_csvs_to_images():\n    data = pd.read_csv(\"/home/chetana/gridmet_test_run/predicted_val_with_2_thrushold.csv\")\n\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    x, y = m(data['lon'].values, data['lat'].values)\n\n    # Define your custom function to map data values to colors\n    def map_value_to_color(value):\n        # Define your value ranges and corresponding color indices\n        value_ranges = [1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 30]\n        \n        # Iterate through the value ranges to find the appropriate color index\n        for i, range_max in enumerate(value_ranges):\n            if value <= range_max:\n                return colors[i]\n        \n        # If the value is greater than the largest range, return the last color\n        return colors[-1]\n\n    # Map predicted_swe values to colors using the custom function\n    color_mapping = [map_value_to_color(value) for value in data['predicted_swe']]\n    \n    # Plot the data using the custom colormap\n    plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\n\n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_date = datetime(1900, 1, 1)\n    day_value = day_index\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    \n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    # Create custom legend elements using the same colormap\n    legend_elements = [Patch(color=custom_cmap(i / len(colors)), label=f\"{r[0]} - {r[1]}\" if i < len(colors) else \"> 30\") for i, r in enumerate(value_ranges)]\n\n    # Create the legend outside the map\n    legend = plt.legend(handles=legend_elements, loc='upper left', title='Legend', fontsize=8)\n    legend.set_bbox_to_anchor((1.01, 1))  # Adjust the position of the legend\n\n    # Remove the color bar\n    plt.colorbar().remove()\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Set the aspect ratio to 'equal' to keep the plot at the center\n    plt.gca().set_aspect('equal', adjustable='box')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15, right=0.80)  # Adjust right margin to accommodate the legend\n    # Show the plot or save it to a file\n    plt.savefig(f'/home/chetana/gridmet_test_run/predicted_swe-{timestamp_string}-{uuid.uuid4().hex}.png')\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\n# Call the function to convert CSVs to images\nconvert_csvs_to_images()\n",
  "history_output" : "today date = 2023-09-12\n/home/chetana\n/home/chetana/gw-workspace/Hc135FINzbHg/convert_results_to_images.py:64: UserWarning: No data for colormapping provided via 'c'. Parameters 'cmap' will be ignored\n  plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\nTraceback (most recent call last):\n  File \"/home/chetana/gw-workspace/Hc135FINzbHg/convert_results_to_images.py\", line 127, in <module>\n    convert_csvs_to_images()\n  File \"/home/chetana/gw-workspace/Hc135FINzbHg/convert_results_to_images.py\", line 104, in convert_csvs_to_images\n    legend_elements = [Patch(color=custom_cmap(i / len(colors)), label=f\"{r[0]} - {r[1]}\" if i < len(colors) else \"> 30\") for i, r in enumerate(value_ranges)]\nNameError: name 'value_ranges' is not defined\n",
  "history_begin_time" : 1694484522643,
  "history_end_time" : 1694484527949,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "cY8h2kflHQmW",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport uuid\nfrom snowcast_utils import day_index\nimport matplotlib.colors as mcolors\nfrom matplotlib.patches import Patch\n\n# Define the custom colormap with specified colors and ranges\ncolors = [\n    (0.8627, 0.8627, 0.8627),  # #DCDCDC - 0 - 1\n    (0.8627, 1.0000, 1.0000),  # #DCFFFF - 1 - 2\n    (0.6000, 1.0000, 1.0000),  # #99FFFF - 2 - 4\n    (0.5569, 0.8235, 1.0000),  # #8ED2FF - 4 - 6\n    (0.4509, 0.6196, 0.8745),  # #739EDF - 6 - 8\n    (0.4157, 0.4706, 1.0000),  # #6A78FF - 8 - 10\n    (0.4235, 0.2784, 1.0000),  # #6C47FF - 10 - 12\n    (0.5529, 0.0980, 1.0000),  # #8D19FF - 12 - 14\n    (0.7333, 0.0000, 0.9176),  # #BB00EA - 14 - 16\n    (0.8392, 0.0000, 0.7490),  # #D600BF - 16 - 18\n    (0.7569, 0.0039, 0.4549),  # #C10074 - 18 - 20\n    (0.6784, 0.0000, 0.1961),  # #AD0032 - 20 - 30\n    (0.5020, 0.0000, 0.0000)   # #800000 - > 30\n]\n\ncmap_name = 'custom_snow_colormap'\ncustom_cmap = mcolors.ListedColormap(colors)\n\ndef convert_csvs_to_images():\n    data = pd.read_csv(\"/home/chetana/gridmet_test_run/predicted_val_with_2_thrushold.csv\")\n\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    x, y = m(data['lon'].values, data['lat'].values)\n\n    # Define your custom function to map data values to colors\n    def map_value_to_color(value):\n        # Define your value ranges and corresponding color indices\n        value_ranges = [1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 30]\n        \n        # Iterate through the value ranges to find the appropriate color index\n        for i, range_max in enumerate(value_ranges):\n            if value <= range_max:\n                return colors[i]\n        \n        # If the value is greater than the largest range, return the last color\n        return colors[-1]\n\n    # Map predicted_swe values to colors using the custom function\n    color_mapping = [map_value_to_color(value) for value in data['predicted_swe']]\n    \n    # Plot the data using the custom colormap\n    plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\n\n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_date = datetime(1900, 1, 1)\n    day_value = day_index\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    \n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    # Create custom legend elements using the same colormap\n    legend_elements = [Patch(color=custom_cmap(i / len(colors)), label=f\"{r[0]} - {r[1]}\" if i < len(colors) else \"> 30\") for i, r in enumerate(zip(value_ranges, value_ranges[1:] + [float('inf')]))]\n\n    # Create the legend outside the map\n    legend = plt.legend(handles=legend_elements, loc='upper left', title='Legend', fontsize=8)\n    legend.set_bbox_to_anchor((1.01, 1))  # Adjust the position of the legend\n\n    # Remove the color bar\n    plt.colorbar().remove()\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Set the aspect ratio to 'equal' to keep the plot at the center\n    plt.gca().set_aspect('equal', adjustable='box')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15, right=0.80)  # Adjust right margin to accommodate the legend\n    # Show the plot or save it to a file\n    plt.savefig(f'/home/chetana/gridmet_test_run/predicted_swe-{timestamp_string}-{uuid.uuid4().hex}.png')\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\n# Call the function to convert CSVs to images\nconvert_csvs_to_images()\n",
  "history_output" : "today date = 2023-09-12\n/home/chetana\n/home/chetana/gw-workspace/cY8h2kflHQmW/convert_results_to_images.py:59: UserWarning: No data for colormapping provided via 'c'. Parameters 'cmap' will be ignored\n  plt.scatter(x, y, c=color_mapping, cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\nTraceback (most recent call last):\n  File \"/home/chetana/gw-workspace/cY8h2kflHQmW/convert_results_to_images.py\", line 122, in <module>\n    convert_csvs_to_images()\n  File \"/home/chetana/gw-workspace/cY8h2kflHQmW/convert_results_to_images.py\", line 93, in convert_csvs_to_images\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\nNameError: name 'lat_lon_to_map_coordinates' is not defined\n",
  "history_begin_time" : 1694484403394,
  "history_end_time" : 1694484408684,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "qhN3SHMOph0E",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport uuid\nfrom snowcast_utils import day_index\nimport matplotlib.colors as mcolors\nfrom matplotlib.patches import Patch\n\nreference_date = datetime(1900, 1, 1)\nresult_date = reference_date + timedelta(days=day_index)\ncurrent_datetime = result_date.strftime(\"%Y-%m-%d\")\ntimestamp_string = current_datetime\n\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\n# Define the custom colormap with specified colors and ranges\ncolors = [\n    (0.8627, 0.8627, 0.8627),  # #DCDCDC - 0 - 1\n    (0.8627, 1.0000, 1.0000),  # #DCFFFF - 1 - 2\n    (0.6000, 1.0000, 1.0000),  # #99FFFF - 2 - 4\n    (0.5569, 0.8235, 1.0000),  # #8ED2FF - 4 - 6\n    (0.4509, 0.6196, 0.8745),  # #739EDF - 6 - 8\n    (0.4157, 0.4706, 1.0000),  # #6A78FF - 8 - 10\n    (0.4235, 0.2784, 1.0000),  # #6C47FF - 10 - 12\n    (0.5529, 0.0980, 1.0000),  # #8D19FF - 12 - 14\n    (0.7333, 0.0000, 0.9176),  # #BB00EA - 14 - 16\n    (0.8392, 0.0000, 0.7490),  # #D600BF - 16 - 18\n    (0.7569, 0.0039, 0.4549),  # #C10074 - 18 - 20\n    (0.6784, 0.0000, 0.1961),  # #AD0032 - 20 - 30\n    (0.5020, 0.0000, 0.0000)   # #800000 - > 30\n]\n\ncmap_name = 'custom_snow_colormap'\ncustom_cmap = mcolors.ListedColormap(colors)\n\ndef convert_csvs_to_images():\n    data = pd.read_csv(\"/home/chetana/gridmet_test_run/predicted_val_with_2_thrushold.csv\")\n\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    x, y = m(data['lon'].values, data['lat'].values)\n\n    colorbar_ticks = [0, 1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 30]\n    colorbar_labels = [\n        \"0 - 1\",\n        \"1 - 2\",\n        \"2 - 4\",\n        \"4 - 6\",\n        \"6 - 8\",\n        \"8 - 10\",\n        \"10 - 12\",\n        \"12 - 14\",\n        \"14 - 16\",\n        \"16 - 18\",\n        \"18 - 20\",\n        \"20 - 30\",\n        \"> 30\"\n    ]\n\n    # Plot the data using the custom colormap\n    plt.scatter(x, y, c=data['predicted_swe'], cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\n\n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_date = datetime(1900, 1, 1)\n    day_value = day_index\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    \n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    # Create custom legend elements using the same colormap\n    legend_elements = [Patch(color=custom_cmap(i / len(colorbar_ticks)), label=label) for i, label in enumerate(colorbar_labels)]\n\n    # Create the legend outside the map\n    legend = plt.legend(handles=legend_elements, loc='upper left', title='Legend', fontsize=8)\n    legend.set_bbox_to_anchor((1.01, 1))  # Adjust the position of the legend\n\n    # Remove the color bar\n    plt.colorbar().remove()\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Set the aspect ratio to 'equal' to keep the plot at the center\n    plt.gca().set_aspect('equal', adjustable='box')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15, right=0.80)  # Adjust right margin to accommodate the legend\n    # Show the plot or save it to a file\n    plt.savefig(f'/home/chetana/gridmet_test_run/predicted_swe-{timestamp_string}-{uuid.uuid4().hex}.png')\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "today date = 2023-09-12\n/home/chetana\n",
  "history_begin_time" : 1694483889072,
  "history_end_time" : 1694483897444,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "NEba2izaW2LF",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport uuid\nimport matplotlib.colors as mcolors\nfrom matplotlib.patches import Patch\n\nreference_date = datetime(1900, 1, 1)\nresult_date = reference_date + timedelta(days=day_index)\ncurrent_datetime = result_date.strftime(\"%Y-%m-%d\")\ntimestamp_string = current_datetime\n\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\n# Define the custom colormap with specified colors and ranges\ncolors = [\n    (1.0, 1.0, 1.0),      # 0 - 1: White\n    (0.8627, 1.0, 1.0),  # 1 - 2: #DCFFFF\n    (0.6, 1.0, 1.0),     # 2 - 4: #99FFFF\n    (0.5569, 0.8235, 1.0),  # 4 - 6: #8ED2FF\n    (0.4509, 0.6196, 0.8745),  # 6 - 8: #739EDF\n    (0.4157, 0.4706, 1.0),  # 8 - 10: #6A78FF\n    (0.4235, 0.2784, 1.0),  # 10 - 12: #6C47FF\n    (0.5529, 0.0980, 1.0),  # 12 - 14: #8D19FF\n    (0.7333, 0.0, 0.9176),  # 14 - 16: #BB00EA\n    (0.8392, 0.0, 0.7490),  # 16 - 18: #D600BF\n    (0.7569, 0.0039, 0.4549),  # 18 - 20: #C10074\n    (0.6784, 0.0, 0.1961),  # 20 - 30: #AD0032\n    (0.5020, 0.0, 0.0)     # > 30: #800000\n]\n\ncmap_name = 'custom_snow_colormap'\ncustom_cmap = mcolors.ListedColormap(colors)\n\ndef convert_csvs_to_images():\n    data = pd.read_csv(\"/home/chetana/gridmet_test_run/predicted_val_with_2_thrushold.csv\")\n\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    x, y = m(data['lon'].values, data['lat'].values)\n\n    colorbar_ticks = [0, 1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 30]\n    colorbar_labels = [\n        \"0 - 1\",\n        \"1 - 2\",\n        \"2 - 4\",\n        \"4 - 6\",\n        \"6 - 8\",\n        \"8 - 10\",\n        \"10 - 12\",\n        \"12 - 14\",\n        \"14 - 16\",\n        \"16 - 18\",\n        \"18 - 20\",\n        \"20 - 30\",\n        \"> 30\"\n    ]\n\n    # Plot the data using the custom colormap\n    plt.scatter(x, y, c=data['predicted_swe'], cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7, vmin=0, vmax=30)\n\n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_date = datetime(1900, 1, 1)\n    day_value = day_index\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    \n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    # Create custom legend elements using the same colormap\n    legend_elements = [\n        Patch(color=custom_cmap(0), label=\"0 - 1\"),\n        Patch(color=custom_cmap(1/12), label=\"1 - 2\"),\n        Patch(color=custom_cmap(2/12), label=\"2 - 4\"),\n        Patch(color=custom_cmap(4/12), label=\"4 - 6\"),\n        Patch(color=custom_cmap(6/12), label=\"6 - 8\"),\n        Patch(color=custom_cmap(8/12), label=\"8 - 10\"),\n        Patch(color=custom_cmap(10/12), label=\"10 - 12\"),\n        Patch(color=custom_cmap(11/12), label=\"12 - 14\"),\n        Patch(color=custom_cmap(12/12), label=\"14 - 16\"),\n        Patch(color=custom_cmap(13/12), label=\"16 - 18\"),\n        Patch(color=custom_cmap(14/12), label=\"18 - 20\"),\n        Patch(color=custom_cmap(15/12), label=\"20 - 30\"),\n        Patch(color=custom_cmap(1.0), label=\"> 30\")\n    ]\n\n    # Create the legend outside the map\n    legend = plt.legend(handles=legend_elements, loc='upper left', title='Legend', fontsize=8)\n    legend.set_bbox_to_anchor((1.01, 1))  # Adjust the position of the legend\n\n    # Remove the color bar\n    plt.colorbar().remove()\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Set the aspect ratio to 'equal' to keep the plot at the center\n    plt.gca().set_aspect('equal', adjustable='box')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15, right=0.80)  # Adjust right margin to accommodate the legend\n    # Show the plot or save it to a file\n    plt.savefig(f'/home/chetana/gridmet_test_run/predicted_swe-{timestamp_string}-{uuid.uuid4().hex}.png')\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "Traceback (most recent call last):\n  File \"/home/chetana/gw-workspace/NEba2izaW2LF/convert_results_to_images.py\", line 11, in <module>\n    result_date = reference_date + timedelta(days=day_index)\nNameError: name 'day_index' is not defined\n",
  "history_begin_time" : 1694483842911,
  "history_end_time" : 1694483844793,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "txE8OYxWEWcl",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport uuid\nfrom snowcast_utils import day_index\nimport matplotlib.colors as mcolors\nfrom matplotlib.patches import Patch\n\nreference_date = datetime(1900, 1, 1)\nresult_date = reference_date + timedelta(days=day_index)\ncurrent_datetime = result_date.strftime(\"%Y-%m-%d\")\ntimestamp_string = current_datetime\n\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\n# Define the custom colormap with specified colors and ranges\ncolors = [\n    (0.8627, 0.8627, 0.8627),  # #DCDCDC - 0 - 1\n    (0.8627, 1.0000, 1.0000),  # #DCFFFF - 1 - 2\n    (0.6000, 1.0000, 1.0000),  # #99FFFF - 2 - 4\n    (0.5569, 0.8235, 1.0000),  # #8ED2FF - 4 - 6\n    (0.4509, 0.6196, 0.8745),  # #739EDF - 6 - 8\n    (0.4157, 0.4706, 1.0000),  # #6A78FF - 8 - 10\n    (0.4235, 0.2784, 1.0000),  # #6C47FF - 10 - 12\n    (0.5529, 0.0980, 1.0000),  # #8D19FF - 12 - 14\n    (0.7333, 0.0000, 0.9176),  # #BB00EA - 14 - 16\n    (0.8392, 0.0000, 0.7490),  # #D600BF - 16 - 18\n    (0.7569, 0.0039, 0.4549),  # #C10074 - 18 - 20\n    (0.6784, 0.0000, 0.1961),  # #AD0032 - 20 - 30\n    (0.5020, 0.0000, 0.0000)   # #800000 - > 30\n]\n\ncmap_name = 'custom_snow_colormap'\ncustom_cmap = mcolors.ListedColormap(colors)\n\ndef convert_csvs_to_images():\n    data = pd.read_csv(\"/home/chetana/gridmet_test_run/predicted_val_with_2_thrushold.csv\")\n\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    x, y = m(data['lon'].values, data['lat'].values)\n\n    colorbar_ticks = [0, 1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 30]\n    colorbar_labels = [\n        \"0 - 1\",\n        \"1 - 2\",\n        \"2 - 4\",\n        \"4 - 6\",\n        \"6 - 8\",\n        \"8 - 10\",\n        \"10 - 12\",\n        \"12 - 14\",\n        \"14 - 16\",\n        \"16 - 18\",\n        \"18 - 20\",\n        \"20 - 30\",\n        \"> 30\"\n    ]\n\n    # Plot the data using the custom colormap\n    plt.scatter(x, y, c=data['predicted_swe'], cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\n\n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_date = datetime(1900, 1, 1)\n    day_value = day_index\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    \n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    # Create custom legend elements using the same colormap\n    legend_elements = [Patch(color=custom_cmap(i / len(colorbar_ticks)), label=label) for i, label in enumerate(colorbar_labels)]\n\n    # Create the legend outside the map\n    legend = plt.legend(handles=legend_elements, loc='upper left', title='Legend', fontsize=8)\n    legend.set_bbox_to_anchor((1.01, 1))  # Adjust the position of the legend\n\n    # Remove the color bar\n    plt.colorbar().remove()\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Set the aspect ratio to 'equal' to keep the plot at the center\n    plt.gca().set_aspect('equal', adjustable='box')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15, right=0.80)  # Adjust right margin to accommodate the legend\n    # Show the plot or save it to a file\n    plt.savefig(f'/home/chetana/gridmet_test_run/predicted_swe-{timestamp_string}-{uuid.uuid4().hex}.png')\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "today date = 2023-09-12\n/home/chetana\n",
  "history_begin_time" : 1694480017426,
  "history_end_time" : 1694480025950,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "5JCn7KOsUYis",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nimport netCDF4 as nc\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport pyproj\nimport uuid\nfrom snowcast_utils import day_index\nimport matplotlib.colors as mcolors\nfrom matplotlib.patches import Patch\n\nreference_date = datetime(1900, 1, 1)\n# day_value = convert_date_from_1900(test_start_date)\nresult_date = reference_date + timedelta(days=day_index)\ncurrent_datetime = result_date.strftime(\"%Y-%m-%d\")\n# current_datetime = datetime.now()\ntimestamp_string = current_datetime\n\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\n# Define the custom colormap with specified colors and ranges\ncolors = [\n    (0.8627, 0.8627, 0.8627),  # #DCDCDC - 0 - 1\n    (0.8627, 1.0000, 1.0000),  # #DCFFFF - 1 - 2\n    (0.6000, 1.0000, 1.0000),  # #99FFFF - 2 - 4\n    (0.5569, 0.8235, 1.0000),  # #8ED2FF - 4 - 6\n    (0.4509, 0.6196, 0.8745),  # #739EDF - 6 - 8\n    (0.4157, 0.4706, 1.0000),  # #6A78FF - 8 - 10\n    (0.4235, 0.2784, 1.0000),  # #6C47FF - 10 - 12\n    (0.5529, 0.0980, 1.0000),  # #8D19FF - 12 - 14\n    (0.7333, 0.0000, 0.9176),  # #BB00EA - 14 - 16\n    (0.8392, 0.0000, 0.7490),  # #D600BF - 16 - 18\n    (0.7569, 0.0039, 0.4549),  # #C10074 - 18 - 20\n    (0.6784, 0.0000, 0.1961),  # #AD0032 - 20 - 30\n    (0.5020, 0.0000, 0.0000)   # #800000 - > 30\n]\n\ncmap_name = 'custom_snow_colormap'\ncustom_cmap = mcolors.ListedColormap(colors)\n\ndef convert_csvs_to_images():\n    # Load the CSV data into a DataFrame\n    #data = pd.read_csv('/home/chetana/gridmet_test_run/test_data_prediected.csv')\n    data = pd.read_csv(\"/home/chetana/gridmet_test_run/predicted_val_with_2_thrushold.csv\")\n\n    # Define the map boundaries for the Western US\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    # Create the Basemap instance\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    # Convert lon/lat to map coordinates\n    x, y = m(data['lon'].values, data['lat'].values)\n\n    # Define colorbar ticks and labels\n    colorbar_ticks = [0, 1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 30]\n    colorbar_labels = [\n        \"0 - 1\",\n        \"1 - 2\",\n        \"2 - 4\",\n        \"4 - 6\",\n        \"6 - 8\",\n        \"8 - 10\",\n        \"10 - 12\",\n        \"12 - 14\",\n        \"14 - 16\",\n        \"16 - 18\",\n        \"18 - 20\",\n        \"20 - 30\",\n        \"> 30\"\n    ]\n\n    # Plot the data using the custom colormap\n    plt.scatter(x, y, c=data['predicted_swe'], cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\n\n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_date = datetime(1900, 1, 1)\n    day_value = day_index\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    \n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    # Create custom legend elements using the same colormap\n    legend_elements = [Patch(color=custom_cmap(i / len(colorbar_ticks)), label=label) for i, label in enumerate(colorbar_labels)]\n\n    # Create the legend outside the map\n    legend = plt.legend(handles=legend_elements, loc='upper left', title='Legend', fontsize=8)\n    legend.set_bbox_to_anchor((1.01, 1))  # Adjust the position of the legend\n\n    # Remove the color bar\n    plt.colorbar().remove()\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Set the aspect ratio to 'equal' to keep the plot at the center\n    plt.gca().set_aspect('equal', adjustable='box')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15, right=0.80)  # Adjust right margin to accommodate the legend\n    # Show the plot or save it to a file\n    plt.savefig(f'/home/chetana/gridmet_test_run/predicted_swe-{timestamp_string}-{uuid.uuid4().hex}.png')\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "today date = 2023-09-12\n/home/chetana\n",
  "history_begin_time" : 1694479200568,
  "history_end_time" : 1694479209221,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "8hwknZeCP6Y1",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport uuid\nfrom snowcast_utils import day_index\nimport matplotlib.colors as mcolors\nfrom matplotlib.patches import Patch\n\nreference_date = datetime(1900, 1, 1)\nresult_date = reference_date + timedelta(days=day_index)\ncurrent_datetime = result_date.strftime(\"%Y-%m-%d\")\ntimestamp_string = current_datetime\n\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\n# Define the custom colormap with specified colors and ranges\ncolors = [\n    (0.8627, 0.8627, 0.8627),  # #DCDCDC - 0 - 1\n    (0.8627, 1.0000, 1.0000),  # #DCFFFF - 1 - 2\n    (0.6000, 1.0000, 1.0000),  # #99FFFF - 2 - 4\n    (0.5569, 0.8235, 1.0000),  # #8ED2FF - 4 - 6\n    (0.4509, 0.6196, 0.8745),  # #739EDF - 6 - 8\n    (0.4157, 0.4706, 1.0000),  # #6A78FF - 8 - 10\n    (0.4235, 0.2784, 1.0000),  # #6C47FF - 10 - 12\n    (0.5529, 0.0980, 1.0000),  # #8D19FF - 12 - 14\n    (0.7333, 0.0000, 0.9176),  # #BB00EA - 14 - 16\n    (0.8392, 0.0000, 0.7490),  # #D600BF - 16 - 18\n    (0.7569, 0.0039, 0.4549),  # #C10074 - 18 - 20\n    (0.6784, 0.0000, 0.1961),  # #AD0032 - 20 - 30\n    (0.5020, 0.0000, 0.0000)   # #800000 - > 30\n]\n\ncmap_name = 'custom_snow_colormap'\ncustom_cmap = mcolors.ListedColormap(colors)\n\ndef convert_csvs_to_images():\n    data = pd.read_csv(\"/home/chetana/gridmet_test_run/predicted_val_with_2_thrushold.csv\")\n\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    x, y = m(data['lon'].values, data['lat'].values)\n\n    colorbar_ticks = [0, 1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 30]\n    colorbar_labels = [\n        \"0 - 1\",\n        \"1 - 2\",\n        \"2 - 4\",\n        \"4 - 6\",\n        \"6 - 8\",\n        \"8 - 10\",\n        \"10 - 12\",\n        \"12 - 14\",\n        \"14 - 16\",\n        \"16 - 18\",\n        \"18 - 20\",\n        \"20 - 30\",\n        \"> 30\"\n    ]\n\n    # Plot the data using the custom colormap\n    sc = plt.scatter(x, y, c=data['predicted_swe'], cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\n\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_date = datetime(1900, 1, 1)\n    day_value = day_index\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    \n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    # Create custom legend elements using the same colormap\n    legend_elements = [Patch(color=custom_cmap(i), label=label) for i, label in enumerate(colorbar_labels)]\n\n    # Create the legend outside the map\n    legend = plt.legend(handles=legend_elements, loc='upper left', title='Legend', fontsize=8)\n    legend.set_bbox_to_anchor((1.01, 1))  # Adjust the position of the legend\n\n    # Remove the color bar\n    plt.colorbar(sc, ax=plt.gca(), ticks=colorbar_ticks, label='Predicted SWE')\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Set the aspect ratio to 'equal' to keep the plot at the center\n    plt.gca().set_aspect('equal', adjustable='box')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15, right=0.80)  # Adjust right margin to accommodate the legend\n    plt.savefig(f'/home/chetana/gridmet_test_run/predicted_swe-{timestamp_string}-{uuid.uuid4().hex}.png')\n\nconvert_csvs_to_images()\n",
  "history_output" : "today date = 2023-09-12\n/home/chetana\n",
  "history_begin_time" : 1694479092203,
  "history_end_time" : 1694479100689,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "jmVmDF7JsurP",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nimport netCDF4 as nc\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport pyproj\nimport uuid\nfrom snowcast_utils import day_index\nimport matplotlib.colors as mcolors\nfrom matplotlib.patches import Patch\n\nreference_date = datetime(1900, 1, 1)\n# day_value = convert_date_from_1900(test_start_date)\nresult_date = reference_date + timedelta(days=day_index)\ncurrent_datetime = result_date.strftime(\"%Y-%m-%d\")\n# current_datetime = datetime.now()\ntimestamp_string = current_datetime\n\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\n# Define the custom colormap with specified colors and ranges\ncolors = [\n    (0.8627, 0.8627, 0.8627),  # #DCDCDC - 0 - 1\n    (0.8627, 1.0000, 1.0000),  # #DCFFFF - 1 - 2\n    (0.6000, 1.0000, 1.0000),  # #99FFFF - 2 - 4\n    (0.5569, 0.8235, 1.0000),  # #8ED2FF - 4 - 6\n    (0.4509, 0.6196, 0.8745),  # #739EDF - 6 - 8\n    (0.4157, 0.4706, 1.0000),  # #6A78FF - 8 - 10\n    (0.4235, 0.2784, 1.0000),  # #6C47FF - 10 - 12\n    (0.5529, 0.0980, 1.0000),  # #8D19FF - 12 - 14\n    (0.7333, 0.0000, 0.9176),  # #BB00EA - 14 - 16\n    (0.8392, 0.0000, 0.7490),  # #D600BF - 16 - 18\n    (0.7569, 0.0039, 0.4549),  # #C10074 - 18 - 20\n    (0.6784, 0.0000, 0.1961),  # #AD0032 - 20 - 30\n    (0.5020, 0.0000, 0.0000)   # #800000 - > 30\n]\n\ncmap_name = 'custom_snow_colormap'\ncustom_cmap = mcolors.ListedColormap(colors)\n\ndef convert_csvs_to_images():\n    # Load the CSV data into a DataFrame\n    #data = pd.read_csv('/home/chetana/gridmet_test_run/test_data_prediected.csv')\n    data = pd.read_csv(\"/home/chetana/gridmet_test_run/predicted_val_with_2_thrushold.csv\")\n\n    # Define the map boundaries for the Western US\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    # Create the Basemap instance\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    # Convert lon/lat to map coordinates\n    x, y = m(data['lon'].values, data['lat'].values)\n\n    # Define colorbar ticks and labels\n    colorbar_ticks = [0, 1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 30]\n    colorbar_labels = [\n        \"0 - 1\",\n        \"1 - 2\",\n        \"2 - 4\",\n        \"4 - 6\",\n        \"6 - 8\",\n        \"8 - 10\",\n        \"10 - 12\",\n        \"12 - 14\",\n        \"14 - 16\",\n        \"16 - 18\",\n        \"18 - 20\",\n        \"20 - 30\",\n        \"> 30\"\n    ]\n\n    # Plot the data using the custom colormap\n    plt.scatter(x, y, c=data['predicted_swe'], cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\n\n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_date = datetime(1900, 1, 1)\n    day_value = day_index\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    \n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    # Create custom legend elements using the same colormap\n    legend_elements = [Patch(color=custom_cmap(i / len(colorbar_ticks)), label=label) for i, label in enumerate(colorbar_labels)]\n\n    # Create the legend outside the map\n    legend = plt.legend(handles=legend_elements, loc='upper left', title='Legend', fontsize=8)\n    legend.set_bbox_to_anchor((1.01, 1))  # Adjust the position of the legend\n\n    # Remove the color bar\n    plt.colorbar().remove()\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Set the aspect ratio to 'equal' to keep the plot at the center\n    plt.gca().set_aspect('equal', adjustable='box')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15, right=0.80)  # Adjust right margin to accommodate the legend\n    # Show the plot or save it to a file\n    plt.savefig(f'/home/chetana/gridmet_test_run/predicted_swe-{timestamp_string}-{uuid.uuid4().hex}.png')\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "today date = 2023-09-12\n/home/chetana\n",
  "history_begin_time" : 1694478639063,
  "history_end_time" : 1694478650507,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "acjZMQpGG8I9",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nimport netCDF4 as nc\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport pyproj\nimport uuid\nfrom snowcast_utils import day_index\nimport matplotlib.colors as mcolors\nfrom matplotlib.patches import Patch\n\nreference_date = datetime(1900, 1, 1)\n# day_value = convert_date_from_1900(test_start_date)\nresult_date = reference_date + timedelta(days=day_index)\ncurrent_datetime = result_date.strftime(\"%Y-%m-%d\")\n# current_datetime = datetime.now()\ntimestamp_string = current_datetime\n\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\n# Define the custom colormap with specified colors and ranges\ncolors = [\n    (0.8627, 0.8627, 0.8627),  # #DCDCDC - 0 - 1\n    (0.8627, 1.0000, 1.0000),  # #DCFFFF - 1 - 2\n    (0.6000, 1.0000, 1.0000),  # #99FFFF - 2 - 4\n    (0.5569, 0.8235, 1.0000),  # #8ED2FF - 4 - 6\n    (0.4509, 0.6196, 0.8745),  # #739EDF - 6 - 8\n    (0.4157, 0.4706, 1.0000),  # #6A78FF - 8 - 10\n    (0.4235, 0.2784, 1.0000),  # #6C47FF - 10 - 12\n    (0.5529, 0.0980, 1.0000),  # #8D19FF - 12 - 14\n    (0.7333, 0.0000, 0.9176),  # #BB00EA - 14 - 16\n    (0.8392, 0.0000, 0.7490),  # #D600BF - 16 - 18\n    (0.7569, 0.0039, 0.4549),  # #C10074 - 18 - 20\n    (0.6784, 0.0000, 0.1961),  # #AD0032 - 20 - 30\n    (0.5020, 0.0000, 0.0000)   # #800000 - > 30\n]\n\ncmap_name = 'custom_snow_colormap'\ncustom_cmap = mcolors.ListedColormap(colors)\n\ndef convert_csvs_to_images():\n    # Load the CSV data into a DataFrame\n    #data = pd.read_csv('/home/chetana/gridmet_test_run/test_data_prediected.csv')\n    data = pd.read_csv(\"/home/chetana/gridmet_test_run/predicted_val_with_2_thrushold.csv\")\n\n    # Define the map boundaries for the Western US\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    # Create the Basemap instance\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    # Convert lon/lat to map coordinates\n    x, y = m(data['lon'].values, data['lat'].values)\n\n    # Plot the data using the custom colormap\n    plt.scatter(x, y, c=data['predicted_swe'], cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\n\n    # Define colorbar ticks and labels\n    colorbar_ticks = [0, 1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 30]\n    colorbar_labels = [\n        \"0 - 1\",\n        \"1 - 2\",\n        \"2 - 4\",\n        \"4 - 6\",\n        \"6 - 8\",\n        \"8 - 10\",\n        \"10 - 12\",\n        \"12 - 14\",\n        \"14 - 16\",\n        \"16 - 18\",\n        \"18 - 20\",\n        \"20 - 30\",\n        \"> 30\"\n    ]\n\n    # Create custom legend elements using the same colormap\n    legend_elements = [Patch(color=custom_cmap(i), label=label) for i, label in enumerate(colorbar_labels)]\n\n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_date = datetime(1900, 1, 1)\n    day_value = day_index\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    \n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    # Create the legend outside the map\n    legend = plt.legend(handles=legend_elements, loc='upper left', title='Legend', fontsize=8)\n    legend.set_bbox_to_anchor((1, 1))  # Adjust the position of the legend\n\n    # Remove the color bar\n    plt.colorbar().remove()\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15)\n    # Show the plot or save it to a file\n    plt.savefig(f'/home/chetana/gridmet_test_run/predicted_swe-{timestamp_string}-{uuid.uuid4().hex}.png')\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "today date = 2023-09-12\n/home/chetana\n",
  "history_begin_time" : 1694477930452,
  "history_end_time" : 1694477939123,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "A6lRG71COmEV",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nimport netCDF4 as nc\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport pyproj\nimport uuid\nfrom snowcast_utils import day_index\nimport matplotlib.colors as mcolors\nfrom matplotlib.patches import Patch\n\nreference_date = datetime(1900, 1, 1)\n# day_value = convert_date_from_1900(test_start_date)\nresult_date = reference_date + timedelta(days=day_index)\ncurrent_datetime = result_date.strftime(\"%Y-%m-%d\")\n# current_datetime = datetime.now()\ntimestamp_string = current_datetime\n\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\n# Define the custom colormap with specified colors and ranges\ncolors = [\n    (0.8627, 0.8627, 0.8627),  # #DCDCDC - 0 - 1\n    (0.8627, 1.0000, 1.0000),  # #DCFFFF - 1 - 2\n    (0.6000, 1.0000, 1.0000),  # #99FFFF - 2 - 4\n    (0.5569, 0.8235, 1.0000),  # #8ED2FF - 4 - 6\n    (0.4509, 0.6196, 0.8745),  # #739EDF - 6 - 8\n    (0.4157, 0.4706, 1.0000),  # #6A78FF - 8 - 10\n    (0.4235, 0.2784, 1.0000),  # #6C47FF - 10 - 12\n    (0.5529, 0.0980, 1.0000),  # #8D19FF - 12 - 14\n    (0.7333, 0.0000, 0.9176),  # #BB00EA - 14 - 16\n    (0.8392, 0.0000, 0.7490),  # #D600BF - 16 - 18\n    (0.7569, 0.0039, 0.4549),  # #C10074 - 18 - 20\n    (0.6784, 0.0000, 0.1961),  # #AD0032 - 20 - 30\n    (0.5020, 0.0000, 0.0000)   # #800000 - > 30\n]\n\ncmap_name = 'custom_snow_colormap'\ncustom_cmap = mcolors.ListedColormap(colors)\n\ndef convert_csvs_to_images():\n    # Load the CSV data into a DataFrame\n    #data = pd.read_csv('/home/chetana/gridmet_test_run/test_data_prediected.csv')\n    data = pd.read_csv(\"/home/chetana/gridmet_test_run/predicted_val_with_2_thrushold.csv\")\n\n    # Define the map boundaries for the Western US\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    # Create the Basemap instance\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    # Convert lon/lat to map coordinates\n    x, y = m(data['lon'].values, data['lat'].values)\n\n    # Plot the data using the custom colormap\n    plt.scatter(x, y, c=data['predicted_swe'], cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\n\n    # Define colorbar ticks and labels\n    colorbar_ticks = [0, 1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 30]\n    colorbar_labels = [\n        \"0 - 1\",\n        \"1 - 2\",\n        \"2 - 4\",\n        \"4 - 6\",\n        \"6 - 8\",\n        \"8 - 10\",\n        \"10 - 12\",\n        \"12 - 14\",\n        \"14 - 16\",\n        \"16 - 18\",\n        \"18 - 20\",\n        \"20 - 30\",\n        \"> 30\"\n    ]\n\n    # Plot the colorbar with custom format and labels\n    cbar = plt.colorbar(ticks=colorbar_ticks)\n    cbar.set_ticklabels(colorbar_labels)\n    cbar.set_label('Predicted SWE Range', fontsize=10)\n\n    # Create custom legend elements\n    legend_elements = [Patch(color=colors[i], label=label) for i, label in enumerate(colorbar_labels)]\n\n    # Create the legend\n    plt.legend(handles=legend_elements, loc='upper right', title='Legend', fontsize=8)\n\n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    #reference_nc_file = nc.Dataset('/home/chetana/gridmet_test_run/gridmet_climatology/etr_2023.nc')\n\n    reference_date = datetime(1900, 1, 1)\n    #day = reference_nc_file.variables['day'][:]\n    #day_value = day[-1]\n    day_value = day_index\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    \n\n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15)\n    # Show the plot or save it to a file\n    plt.savefig(f'/home/chetana/gridmet_test_run/predicted_swe-{timestamp_string}-{uuid.uuid4().hex}.png')\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "today date = 2023-09-12\n/home/chetana\n",
  "history_begin_time" : 1694477463761,
  "history_end_time" : 1694477472740,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "TVcy2bYDF3XN",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nimport netCDF4 as nc\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport pyproj\nimport uuid\nfrom snowcast_utils import day_index\nimport matplotlib.colors as mcolors\n\nreference_date = datetime(1900, 1, 1)\n# day_value = convert_date_from_1900(test_start_date)\nresult_date = reference_date + timedelta(days=day_index)\ncurrent_datetime = result_date.strftime(\"%Y-%m-%d\")\n# current_datetime = datetime.now()\ntimestamp_string = current_datetime\n\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\n# Define the custom colormap with specified colors and ranges\ncolors = [\n    (0.8627, 0.8627, 0.8627),  # #DCDCDC - 0 - 1\n    (0.8627, 1.0000, 1.0000),  # #DCFFFF - 1 - 2\n    (0.6000, 1.0000, 1.0000),  # #99FFFF - 2 - 4\n    (0.5569, 0.8235, 1.0000),  # #8ED2FF - 4 - 6\n    (0.4509, 0.6196, 0.8745),  # #739EDF - 6 - 8\n    (0.4157, 0.4706, 1.0000),  # #6A78FF - 8 - 10\n    (0.4235, 0.2784, 1.0000),  # #6C47FF - 10 - 12\n    (0.5529, 0.0980, 1.0000),  # #8D19FF - 12 - 14\n    (0.7333, 0.0000, 0.9176),  # #BB00EA - 14 - 16\n    (0.8392, 0.0000, 0.7490),  # #D600BF - 16 - 18\n    (0.7569, 0.0039, 0.4549),  # #C10074 - 18 - 20\n    (0.6784, 0.0000, 0.1961),  # #AD0032 - 20 - 30\n    (0.5020, 0.0000, 0.0000)   # #800000 - > 30\n]\n\ncmap_name = 'custom_snow_colormap'\ncustom_cmap = mcolors.ListedColormap(colors)\n\ndef convert_csvs_to_images():\n    # Load the CSV data into a DataFrame\n    #data = pd.read_csv('/home/chetana/gridmet_test_run/test_data_prediected.csv')\n    data = pd.read_csv(\"/home/chetana/gridmet_test_run/predicted_val_with_2_thrushold.csv\")\n\n    # Define the map boundaries for the Western US\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    # Create the Basemap instance\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    # Convert lon/lat to map coordinates\n    x, y = m(data['lon'].values, data['lat'].values)\n\n    # Plot the data using the custom colormap\n    plt.scatter(x, y, c=data['predicted_swe'], cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\n\n    # Define colorbar ticks and labels\n    colorbar_ticks = [0, 1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 30]\n    colorbar_labels = [\n        \"#DCDCDC - 0 - 1\",\n        \"#DCFFFF - 1 - 2\",\n        \"#99FFFF - 2 - 4\",\n        \"#8ED2FF - 4 - 6\",\n        \"#739EDF - 6 - 8\",\n        \"#6A78FF - 8 - 10\",\n        \"#6C47FF - 10 - 12\",\n        \"#8D19FF - 12 - 14\",\n        \"#BB00EA - 14 - 16\",\n        \"#D600BF - 16 - 18\",\n        \"#C10074 - 18 - 20\",\n        \"#AD0032 - 20 - 30\",\n        \"#800000 - > 30\"\n    ]\n\n    # Plot the colorbar with custom format and labels\n    cbar = plt.colorbar(ticks=colorbar_ticks)\n    cbar.set_ticklabels(colorbar_labels)\n    cbar.set_label('Predicted SWE Legend', fontsize=10)\n\n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    #reference_nc_file = nc.Dataset('/home/chetana/gridmet_test_run/gridmet_climatology/etr_2023.nc')\n\n    reference_date = datetime(1900, 1, 1)\n    #day = reference_nc_file.variables['day'][:]\n    #day_value = day[-1]\n    day_value = day_index\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    \n\n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15)\n    # Show the plot or save it to a file\n    plt.savefig(f'/home/chetana/gridmet_test_run/predicted_swe-{timestamp_string}-{uuid.uuid4().hex}.png')\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "today date = 2023-09-12\n/home/chetana\n",
  "history_begin_time" : 1694477304959,
  "history_end_time" : 1694477313466,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "z0daJTDJs3Oe",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nimport netCDF4 as nc\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport pyproj\nimport uuid\nfrom snowcast_utils import day_index\nimport matplotlib.colors as mcolors\n\nreference_date = datetime(1900, 1, 1)\n# day_value = convert_date_from_1900(test_start_date)\nresult_date = reference_date + timedelta(days=day_index)\ncurrent_datetime = result_date.strftime(\"%Y-%m-%d\")\n# current_datetime = datetime.now()\ntimestamp_string = current_datetime\n\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\ndef convert_csvs_to_images():\n    # Load the CSV data into a DataFrame\n    #data = pd.read_csv('/home/chetana/gridmet_test_run/test_data_prediected.csv')\n    data = pd.read_csv(\"/home/chetana/gridmet_test_run/predicted_val_with_2_thrushold.csv\")\n\n    # Define the map boundaries for the Western US\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    # Create the Basemap instance\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    # Convert lon/lat to map coordinates\n    x, y = m(data['lon'].values, data['lat'].values)\n\n    # Plot the data using vibrant colors based on predicted_swe\n    # Define custom colors for the colormap\n    colors = [\n    (0.8627, 0.8627, 0.8627),  # #DCDCDC - 0 - 1\n    (0.8627, 1.0000, 1.0000),  # #DCFFFF - 1 - 2\n    (0.6000, 1.0000, 1.0000),  # #99FFFF - 2 - 4\n    (0.5569, 0.8235, 1.0000),  # #8ED2FF - 4 - 6\n    (0.4509, 0.6196, 0.8745),  # #739EDF - 6 - 8\n    (0.4157, 0.4706, 1.0000),  # #6A78FF - 8 - 10\n    (0.4235, 0.2784, 1.0000),  # #6C47FF - 10 - 12\n    (0.5529, 0.0980, 1.0000),  # #8D19FF - 12 - 14\n    (0.7333, 0.0000, 0.9176),  # #BB00EA - 14 - 16\n    (0.8392, 0.0000, 0.7490),  # #D600BF - 16 - 18\n    (0.7569, 0.0039, 0.4549),  # #C10074 - 18 - 20\n    (0.6784, 0.0000, 0.1961),  # #AD0032 - 20 - 30\n    (0.5020, 0.0000, 0.0000)   # #800000 - > 30\n]\n    cmap_name = 'custom_snow_colormap'\n    custom_cmap = mcolors.ListedColormap(colors)\n\n    # Plot the data using the custom colormap\n    plt.scatter(x, y, c=data['predicted_swe'], cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\n\n    # Add colorbar for reference\n    cbar = plt.colorbar()\n    cbar.set_label('Predicted SWE')\n\n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    #reference_nc_file = nc.Dataset('/home/chetana/gridmet_test_run/gridmet_climatology/etr_2023.nc')\n\n    reference_date = datetime(1900, 1, 1)\n    #day = reference_nc_file.variables['day'][:]\n    #day_value = day[-1]\n    day_value = day_index\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    \n\n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15)\n    # Show the plot or save it to a file\n    plt.savefig(f'/home/chetana/gridmet_test_run/predicted_swe-{timestamp_string}-{uuid.uuid4().hex}.png')\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "today date = 2023-09-12\n/home/chetana\n",
  "history_begin_time" : 1694477006454,
  "history_end_time" : 1694477015218,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "3biVVuC1uQQL",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nimport netCDF4 as nc\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport pyproj\nimport uuid\nfrom snowcast_utils import day_index\nimport matplotlib.colors as mcolors\n\nreference_date = datetime(1900, 1, 1)\n# day_value = convert_date_from_1900(test_start_date)\nresult_date = reference_date + timedelta(days=day_index)\ncurrent_datetime = result_date.strftime(\"%Y-%m-%d\")\n# current_datetime = datetime.now()\ntimestamp_string = current_datetime\n\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\ndef convert_csvs_to_images():\n    # Load the CSV data into a DataFrame\n    #data = pd.read_csv('/home/chetana/gridmet_test_run/test_data_prediected.csv')\n    data = pd.read_csv(\"/home/chetana/gridmet_test_run/predicted_val_with_2_thrushold.csv\")\n\n    # Define the map boundaries for the Western US\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    # Create the Basemap instance\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    # Convert lon/lat to map coordinates\n    x, y = m(data['lon'].values, data['lat'].values)\n\n    # Plot the data using vibrant colors based on predicted_swe\n    # Define custom colors for the colormap\n    colors = [(1, 1, 1), (0, 0, 1)]  # White to blue\n    cmap_name = 'custom_snow_colormap'\n    custom_cmap = mcolors.LinearSegmentedColormap.from_list(cmap_name, colors, N=256)\n\n    # Plot the data using the custom colormap\n    plt.scatter(x, y, c=data['predicted_swe'], cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\n\n    # Add colorbar for reference\n    cbar = plt.colorbar()\n    cbar.set_label('Predicted SWE')\n\n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    #reference_nc_file = nc.Dataset('/home/chetana/gridmet_test_run/gridmet_climatology/etr_2023.nc')\n\n    reference_date = datetime(1900, 1, 1)\n    #day = reference_nc_file.variables['day'][:]\n    #day_value = day[-1]\n    day_value = day_index\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    \n\n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15)\n    # Show the plot or save it to a file\n    plt.savefig(f'/home/chetana/gridmet_test_run/predicted_swe-{timestamp_string}-{uuid.uuid4().hex}.png')\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "today date = 2023-09-11\n/home/chetana\n",
  "history_begin_time" : 1694465502772,
  "history_end_time" : 1694465511177,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "sabiaxg4vDPU",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nimport netCDF4 as nc\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport pyproj\nimport uuid\nfrom snowcast_utils import day_index\nimport matplotlib.colors as mcolors\n\nreference_date = datetime(1900, 1, 1)\n# day_value = convert_date_from_1900(test_start_date)\nresult_date = reference_date + timedelta(days=day_index)\ncurrent_datetime = result_date.strftime(\"%Y-%m-%d\")\n# current_datetime = datetime.now()\ntimestamp_string = current_datetime\n\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\ndef convert_csvs_to_images():\n    # Load the CSV data into a DataFrame\n    data = pd.read_csv('/home/chetana/gridmet_test_run/test_data_prediected.csv')\n\n    # Define the map boundaries for the Western US\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    # Create the Basemap instance\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    # Convert lon/lat to map coordinates\n    x, y = m(data['lon'].values, data['lat'].values)\n\n    # Plot the data using vibrant colors based on predicted_swe\n    # Define custom colors for the colormap\n    colors = [(1, 1, 1), (0, 0, 1)]  # White to blue\n    cmap_name = 'custom_snow_colormap'\n    custom_cmap = mcolors.LinearSegmentedColormap.from_list(cmap_name, colors, N=256)\n\n    # Plot the data using the custom colormap\n    plt.scatter(x, y, c=data['predicted_swe'], cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\n\n    # Add colorbar for reference\n    cbar = plt.colorbar()\n    cbar.set_label('Predicted SWE')\n\n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    #reference_nc_file = nc.Dataset('/home/chetana/gridmet_test_run/gridmet_climatology/etr_2023.nc')\n\n    reference_date = datetime(1900, 1, 1)\n    #day = reference_nc_file.variables['day'][:]\n    #day_value = day[-1]\n    day_value = day_index\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    \n\n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15)\n    # Show the plot or save it to a file\n    plt.savefig(f'/home/chetana/gridmet_test_run/predicted_swe-{timestamp_string}-{uuid.uuid4().hex}.png')\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "today date = 2023-09-11\n/home/chetana\n",
  "history_begin_time" : 1694450125793,
  "history_end_time" : 1694450134234,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "oBHxb5yfLssT",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nimport netCDF4 as nc\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport pyproj\nimport uuid\nfrom snowcast_utils import day_index\n\nreference_date = datetime(1900, 1, 1)\n# day_value = convert_date_from_1900(test_start_date)\nresult_date = reference_date + timedelta(days=day_index)\ncurrent_datetime = result_date.strftime(\"%Y-%m-%d\")\n# current_datetime = datetime.now()\ntimestamp_string = current_datetime\n\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\ndef convert_csvs_to_images():\n    # Load the CSV data into a DataFrame\n    data = pd.read_csv('/home/chetana/gridmet_test_run/test_data_prediected.csv')\n\n    # Define the map boundaries for the Western US\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    # Create the Basemap instance\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    # Convert lon/lat to map coordinates\n    x, y = m(data['lon'].values, data['lat'].values)\n\n    # Plot the data using vibrant colors based on predicted_swe\n    plt.scatter(x, y, c=data['predicted_swe'], cmap='cool', s=30, edgecolors='none', alpha=0.7)\n\n    # Add colorbar for reference\n    cbar = plt.colorbar()\n    cbar.set_label('Predicted SWE')\n\n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    #reference_nc_file = nc.Dataset('/home/chetana/gridmet_test_run/gridmet_climatology/etr_2023.nc')\n\n    reference_date = datetime(1900, 1, 1)\n    #day = reference_nc_file.variables['day'][:]\n    #day_value = day[-1]\n    day_value = day_index\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    \n\n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15)\n    # Show the plot or save it to a file\n    plt.savefig(f'/home/chetana/gridmet_test_run/predicted_swe-{timestamp_string}-{uuid.uuid4().hex}.png')\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "today date = 2023-09-11\n/home/chetana\n",
  "history_begin_time" : 1694450023076,
  "history_end_time" : 1694450031667,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "IyK33R1joeXi",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nimport netCDF4 as nc\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport pyproj\nimport uuid\nfrom snowcast_utils import day_index\n\nreference_date = datetime(1900, 1, 1)\n# day_value = convert_date_from_1900(test_start_date)\nresult_date = reference_date + timedelta(days=day_index)\ncurrent_datetime = result_date.strftime(\"%Y-%m-%d\")\n# current_datetime = datetime.now()\ntimestamp_string = current_datetime\n\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\ndef convert_csvs_to_images():\n    # Load the CSV data into a DataFrame\n    data = pd.read_csv('/home/chetana/gridmet_test_run/test_data_prediected.csv')\n\n    # Define the map boundaries for the Western US\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    # Create the Basemap instance\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    # Convert lon/lat to map coordinates\n    x, y = m(data['lon'].values, data['lat'].values)\n\n    # Plot the data using vibrant colors based on predicted_swe\n    plt.scatter(x, y, c=data['predicted_swe'], cmap='coolwarm', s=30, edgecolors='none', alpha=0.7)\n\n    # Add colorbar for reference\n    cbar = plt.colorbar()\n    cbar.set_label('Predicted SWE')\n\n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    #reference_nc_file = nc.Dataset('/home/chetana/gridmet_test_run/gridmet_climatology/etr_2023.nc')\n\n    reference_date = datetime(1900, 1, 1)\n    #day = reference_nc_file.variables['day'][:]\n    #day_value = day[-1]\n    day_value = day_index\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    \n\n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15)\n    # Show the plot or save it to a file\n    plt.savefig(f'/home/chetana/gridmet_test_run/predicted_swe-{timestamp_string}-{uuid.uuid4().hex}.png')\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "today date = 2023-09-11\n/home/chetana\n",
  "history_begin_time" : 1694449910714,
  "history_end_time" : 1694449919239,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "qJHnXrHkfaVx",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nimport netCDF4 as nc\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport pyproj\nimport uuid\nfrom snowcast_utils import day_index\n\nreference_date = datetime(1900, 1, 1)\n# day_value = convert_date_from_1900(test_start_date)\nresult_date = reference_date + timedelta(days=day_index)\ncurrent_datetime = result_date.strftime(\"%Y-%m-%d\")\n# current_datetime = datetime.now()\ntimestamp_string = current_datetime\n\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\ndef convert_csvs_to_images():\n    # Load the CSV data into a DataFrame\n    data = pd.read_csv('/home/chetana/gridmet_test_run/test_data_prediected.csv')\n    data.loc[data['SWE'] == 0, 'predicted_swe'] = 0\n\n    # Define the map boundaries for the Western US\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    # Create the Basemap instance\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    # Convert lon/lat to map coordinates\n    x, y = m(data['lon'].values, data['lat'].values)\n    cmap = plt.cm.get_cmap('Blues')\n    normalized_swe = data['predicted_swe'] / max_swe\n    # Plot the data using vibrant colors based on predicted_swe\n    colors = [cmap(value) if value > 0 else 'white' for value in normalized_swe]\n    plt.scatter(x, y, c=colors, s=30, edgecolors='none', alpha=0.7)\n\n    # Add colorbar for reference\n    cbar = plt.colorbar()\n    cbar.set_label('Predicted SWE')\n\n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    #reference_nc_file = nc.Dataset('/home/chetana/gridmet_test_run/gridmet_climatology/etr_2023.nc')\n\n    reference_date = datetime(1900, 1, 1)\n    #day = reference_nc_file.variables['day'][:]\n    #day_value = day[-1]\n    day_value = day_index\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    \n\n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15)\n    # Show the plot or save it to a file\n    plt.savefig(f'/home/chetana/gridmet_test_run/predicted_swe-{timestamp_string}-{uuid.uuid4().hex}.png')\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "today date = 2023-09-11\n/home/chetana\n/home/chetana/gw-workspace/qJHnXrHkfaVx/convert_results_to_images.py:37: MatplotlibDeprecationWarning: The get_cmap function was deprecated in Matplotlib 3.7 and will be removed two minor releases later. Use ``matplotlib.colormaps[name]`` or ``matplotlib.colormaps.get_cmap(obj)`` instead.\n  cmap = plt.cm.get_cmap('Blues')\nTraceback (most recent call last):\n  File \"/home/chetana/gw-workspace/qJHnXrHkfaVx/convert_results_to_images.py\", line 99, in <module>\n    convert_csvs_to_images()\n  File \"/home/chetana/gw-workspace/qJHnXrHkfaVx/convert_results_to_images.py\", line 38, in convert_csvs_to_images\n    normalized_swe = data['predicted_swe'] / max_swe\nNameError: name 'max_swe' is not defined\n",
  "history_begin_time" : 1694449880048,
  "history_end_time" : 1694449884958,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "Fz0NFpLZYmJ0",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nimport netCDF4 as nc\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport pyproj\nimport uuid\nfrom snowcast_utils import day_index\n\nreference_date = datetime(1900, 1, 1)\n# day_value = convert_date_from_1900(test_start_date)\nresult_date = reference_date + timedelta(days=day_index)\ncurrent_datetime = result_date.strftime(\"%Y-%m-%d\")\n# current_datetime = datetime.now()\ntimestamp_string = current_datetime\n\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\ndef convert_csvs_to_images():\n    # Load the CSV data into a DataFrame\n    data = pd.read_csv('/home/chetana/gridmet_test_run/test_data_prediected.csv')\n    data.loc[data['SWE'] == 0, 'predicted_swe'] = 0\n\n    # Define the map boundaries for the Western US\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    # Create the Basemap instance\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n    max_swe = data['predicted_swe'].max()\n\n    # Convert lon/lat to map coordinates\n    x, y = m(data['lon'].values, data['lat'].values)\n    cmap = plt.cm.get_cmap('Blues')\n    normalized_swe = data['predicted_swe'] / max_swe\n    # Plot the data using vibrant colors based on predicted_swe\n    colors = [cmap(value) if value > 0 else 'white' for value in normalized_swe]\n    plt.scatter(x, y, c=colors, s=30, edgecolors='none', alpha=0.7)\n\n    # Add colorbar for reference\n    cbar = plt.colorbar()\n    cbar.set_label('Predicted SWE')\n\n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    #reference_nc_file = nc.Dataset('/home/chetana/gridmet_test_run/gridmet_climatology/etr_2023.nc')\n\n    reference_date = datetime(1900, 1, 1)\n    #day = reference_nc_file.variables['day'][:]\n    #day_value = day[-1]\n    day_value = day_index\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    \n\n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15)\n    # Show the plot or save it to a file\n    plt.savefig(f'/home/chetana/gridmet_test_run/predicted_swe-{timestamp_string}-{uuid.uuid4().hex}.png')\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "today date = 2023-09-11\n/home/chetana\n/home/chetana/gw-workspace/Fz0NFpLZYmJ0/convert_results_to_images.py:38: MatplotlibDeprecationWarning: The get_cmap function was deprecated in Matplotlib 3.7 and will be removed two minor releases later. Use ``matplotlib.colormaps[name]`` or ``matplotlib.colormaps.get_cmap(obj)`` instead.\n  cmap = plt.cm.get_cmap('Blues')\n/home/chetana/gridmet_test_run/pycrate/lib/python3.9/site-packages/matplotlib/cbook/__init__.py:1067: VisibleDeprecationWarning: Creating an ndarray from ragged nested sequences (which is a list-or-tuple of lists-or-tuples-or ndarrays with different lengths or shapes) is deprecated. If you meant to do this, you must specify 'dtype=object' when creating the ndarray.\n  x = np.asanyarray(x)\n",
  "history_begin_time" : 1694449819325,
  "history_end_time" : 1694449841158,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "2eUad6dpJJQ4",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nimport netCDF4 as nc\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport pyproj\nimport uuid\nfrom snowcast_utils import day_index\n\nreference_date = datetime(1900, 1, 1)\n# day_value = convert_date_from_1900(test_start_date)\nresult_date = reference_date + timedelta(days=day_index)\ncurrent_datetime = result_date.strftime(\"%Y-%m-%d\")\n# current_datetime = datetime.now()\ntimestamp_string = current_datetime\n\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\ndef convert_csvs_to_images():\n    # Load the CSV data into a DataFrame\n    data = pd.read_csv('/home/chetana/gridmet_test_run/test_data_prediected.csv')\n    data.loc[data['SWE'] == 0, 'predicted_swe'] = 0\n\n    # Define the map boundaries for the Western US\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    # Create the Basemap instance\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n    max_swe = data['predicted_swe'].max()\n\n    # Convert lon/lat to map coordinates\n    x, y = m(data['lon'].values, data['lat'].values)\n    cmap = plt.cm.get_cmap('Blues')\n    normalized_swe = data['predicted_swe'] / max_swe\n    # Plot the data using vibrant colors based on predicted_swe\n    colors = [cmap(value) if value > 0 else 'white' for value in normalized_swe]\n    plt.scatter(x, y, c=colors, s=30, edgecolors='none', alpha=0.7)\n\n    # Add colorbar for reference\n    cbar = plt.colorbar()\n    cbar.set_label('Predicted SWE')\n\n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    #reference_nc_file = nc.Dataset('/home/chetana/gridmet_test_run/gridmet_climatology/etr_2023.nc')\n\n    reference_date = datetime(1900, 1, 1)\n    #day = reference_nc_file.variables['day'][:]\n    #day_value = day[-1]\n    day_value = day_index\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    \n\n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15)\n    # Show the plot or save it to a file\n    plt.savefig(f'/home/chetana/gridmet_test_run/predicted_swe-{timestamp_string}-{uuid.uuid4().hex}.png')\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "today date = 2023-08-16\n/home/chetana\n/home/chetana/gw-workspace/2eUad6dpJJQ4/convert_results_to_images.py:38: MatplotlibDeprecationWarning: The get_cmap function was deprecated in Matplotlib 3.7 and will be removed two minor releases later. Use ``matplotlib.colormaps[name]`` or ``matplotlib.colormaps.get_cmap(obj)`` instead.\n  cmap = plt.cm.get_cmap('Blues')\n/home/chetana/gridmet_test_run/pycrate/lib/python3.9/site-packages/matplotlib/cbook/__init__.py:1067: VisibleDeprecationWarning: Creating an ndarray from ragged nested sequences (which is a list-or-tuple of lists-or-tuples-or ndarrays with different lengths or shapes) is deprecated. If you meant to do this, you must specify 'dtype=object' when creating the ndarray.\n  x = np.asanyarray(x)\n",
  "history_begin_time" : 1692207936818,
  "history_end_time" : 1692207951570,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "3isUj4GDlxuF",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nimport netCDF4 as nc\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport pyproj\nimport uuid\nfrom snowcast_utils import day_index\n\nreference_date = datetime(1900, 1, 1)\n# day_value = convert_date_from_1900(test_start_date)\nresult_date = reference_date + timedelta(days=day_index)\ncurrent_datetime = result_date.strftime(\"%Y-%m-%d\")\n# current_datetime = datetime.now()\ntimestamp_string = current_datetime\n\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\ndef convert_csvs_to_images():\n    # Load the CSV data into a DataFrame\n    data = pd.read_csv('/home/chetana/gridmet_test_run/test_data_prediected.csv')\n    data.loc[data['SWE'] == 0, 'predicted_swe'] = 0\n\n    # Define the map boundaries for the Western US\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    # Create the Basemap instance\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    # Convert lon/lat to map coordinates\n    x, y = m(data['lon'].values, data['lat'].values)\n    cmap = plt.cm.get_cmap('Blues')\n    normalized_swe = data['predicted_swe'] / max_swe\n    # Plot the data using vibrant colors based on predicted_swe\n    colors = [cmap(value) if value > 0 else 'white' for value in normalized_swe]\n    plt.scatter(x, y, c=colors, s=30, edgecolors='none', alpha=0.7)\n\n    # Add colorbar for reference\n    cbar = plt.colorbar()\n    cbar.set_label('Predicted SWE')\n\n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    #reference_nc_file = nc.Dataset('/home/chetana/gridmet_test_run/gridmet_climatology/etr_2023.nc')\n\n    reference_date = datetime(1900, 1, 1)\n    #day = reference_nc_file.variables['day'][:]\n    #day_value = day[-1]\n    day_value = day_index\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    \n\n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15)\n    # Show the plot or save it to a file\n    plt.savefig(f'/home/chetana/gridmet_test_run/predicted_swe-{timestamp_string}-{uuid.uuid4().hex}.png')\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "today date = 2023-08-16\n/home/chetana\n/home/chetana/gw-workspace/3isUj4GDlxuF/convert_results_to_images.py:37: MatplotlibDeprecationWarning: The get_cmap function was deprecated in Matplotlib 3.7 and will be removed two minor releases later. Use ``matplotlib.colormaps[name]`` or ``matplotlib.colormaps.get_cmap(obj)`` instead.\n  cmap = plt.cm.get_cmap('Blues')\nTraceback (most recent call last):\n  File \"/home/chetana/gw-workspace/3isUj4GDlxuF/convert_results_to_images.py\", line 99, in <module>\n    convert_csvs_to_images()\n  File \"/home/chetana/gw-workspace/3isUj4GDlxuF/convert_results_to_images.py\", line 38, in convert_csvs_to_images\n    normalized_swe = data['predicted_swe'] / max_swe\nNameError: name 'max_swe' is not defined\n",
  "history_begin_time" : 1692207888071,
  "history_end_time" : 1692207892959,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "ZrgQAEerTkhC",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nimport netCDF4 as nc\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport pyproj\nimport uuid\nfrom snowcast_utils import day_index\n\nreference_date = datetime(1900, 1, 1)\n# day_value = convert_date_from_1900(test_start_date)\nresult_date = reference_date + timedelta(days=day_index)\ncurrent_datetime = result_date.strftime(\"%Y-%m-%d\")\n# current_datetime = datetime.now()\ntimestamp_string = current_datetime\n\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\ndef convert_csvs_to_images():\n    # Load the CSV data into a DataFrame\n    data = pd.read_csv('/home/chetana/gridmet_test_run/test_data_prediected.csv')\n    data.loc[data['SWE'] == 0, 'predicted_swe'] = 0\n\n    # Define the map boundaries for the Western US\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    # Create the Basemap instance\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    # Convert lon/lat to map coordinates\n    x, y = m(data['lon'].values, data['lat'].values)\n\n    # Plot the data using vibrant colors based on predicted_swe\n    colors = np.where(data['predicted_swe'] == 0, 'white', plt.cm.Blues(data['predicted_swe'] / data['predicted_swe'].max()))\n\n    plt.scatter(x, y, c=colors, s=30, edgecolors='none', alpha=0.7)\n\n    # Add colorbar for reference\n    cbar = plt.colorbar()\n    cbar.set_label('Predicted SWE')\n\n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    #reference_nc_file = nc.Dataset('/home/chetana/gridmet_test_run/gridmet_climatology/etr_2023.nc')\n\n    reference_date = datetime(1900, 1, 1)\n    #day = reference_nc_file.variables['day'][:]\n    #day_value = day[-1]\n    day_value = day_index\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    \n\n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15)\n    # Show the plot or save it to a file\n    plt.savefig(f'/home/chetana/gridmet_test_run/predicted_swe-{timestamp_string}-{uuid.uuid4().hex}.png')\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "today date = 2023-08-16\n/home/chetana\nTraceback (most recent call last):\n  File \"/home/chetana/gw-workspace/ZrgQAEerTkhC/convert_results_to_images.py\", line 99, in <module>\n    convert_csvs_to_images()\n  File \"/home/chetana/gw-workspace/ZrgQAEerTkhC/convert_results_to_images.py\", line 39, in convert_csvs_to_images\n    colors = np.where(data['predicted_swe'] == 0, 'white', plt.cm.Blues(data['predicted_swe'] / data['predicted_swe'].max()))\n  File \"<__array_function__ internals>\", line 180, in where\nValueError: operands could not be broadcast together with shapes (462204,) () (462204,4) \n",
  "history_begin_time" : 1692207753090,
  "history_end_time" : 1692207757944,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "DUkWrnUhHa87",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nimport netCDF4 as nc\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport pyproj\nimport uuid\nfrom snowcast_utils import day_index\n\nreference_date = datetime(1900, 1, 1)\n# day_value = convert_date_from_1900(test_start_date)\nresult_date = reference_date + timedelta(days=day_index)\ncurrent_datetime = result_date.strftime(\"%Y-%m-%d\")\n# current_datetime = datetime.now()\ntimestamp_string = current_datetime\n\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\ndef convert_csvs_to_images():\n    # Load the CSV data into a DataFrame\n    data = pd.read_csv('/home/chetana/gridmet_test_run/test_data_prediected.csv')\n    data.loc[data['AMSR_SWE'] == 0, 'predicted_swe'] = 0\n\n    # Define the map boundaries for the Western US\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    # Create the Basemap instance\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    # Convert lon/lat to map coordinates\n    x, y = m(data['lon'].values, data['lat'].values)\n\n    # Plot the data using vibrant colors based on predicted_swe\n    colors = np.where(data['predicted_swe'] == 0, 'white', plt.cm.Blues(data['predicted_swe'] / data['predicted_swe'].max()))\n\n    plt.scatter(x, y, c=colors, s=30, edgecolors='none', alpha=0.7)\n\n    # Add colorbar for reference\n    cbar = plt.colorbar()\n    cbar.set_label('Predicted SWE')\n\n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    #reference_nc_file = nc.Dataset('/home/chetana/gridmet_test_run/gridmet_climatology/etr_2023.nc')\n\n    reference_date = datetime(1900, 1, 1)\n    #day = reference_nc_file.variables['day'][:]\n    #day_value = day[-1]\n    day_value = day_index\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    \n\n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15)\n    # Show the plot or save it to a file\n    plt.savefig(f'/home/chetana/gridmet_test_run/predicted_swe-{timestamp_string}-{uuid.uuid4().hex}.png')\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "today date = 2023-08-16\n/home/chetana\nTraceback (most recent call last):\n  File \"/home/chetana/gridmet_test_run/pycrate/lib/python3.9/site-packages/pandas/core/indexes/base.py\", line 3802, in get_loc\n    return self._engine.get_loc(casted_key)\n  File \"pandas/_libs/index.pyx\", line 138, in pandas._libs.index.IndexEngine.get_loc\n  File \"pandas/_libs/index.pyx\", line 165, in pandas._libs.index.IndexEngine.get_loc\n  File \"pandas/_libs/hashtable_class_helper.pxi\", line 5745, in pandas._libs.hashtable.PyObjectHashTable.get_item\n  File \"pandas/_libs/hashtable_class_helper.pxi\", line 5753, in pandas._libs.hashtable.PyObjectHashTable.get_item\nKeyError: 'AMSR_SWE'\n\nThe above exception was the direct cause of the following exception:\n\nTraceback (most recent call last):\n  File \"/home/chetana/gw-workspace/DUkWrnUhHa87/convert_results_to_images.py\", line 99, in <module>\n    convert_csvs_to_images()\n  File \"/home/chetana/gw-workspace/DUkWrnUhHa87/convert_results_to_images.py\", line 25, in convert_csvs_to_images\n    data.loc[data['AMSR_SWE'] == 0, 'predicted_swe'] = 0\n  File \"/home/chetana/gridmet_test_run/pycrate/lib/python3.9/site-packages/pandas/core/frame.py\", line 3807, in __getitem__\n    indexer = self.columns.get_loc(key)\n  File \"/home/chetana/gridmet_test_run/pycrate/lib/python3.9/site-packages/pandas/core/indexes/base.py\", line 3804, in get_loc\n    raise KeyError(key) from err\nKeyError: 'AMSR_SWE'\n",
  "history_begin_time" : 1692207735634,
  "history_end_time" : 1692207738293,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "OMh7EIUVTDkD",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nimport netCDF4 as nc\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport pyproj\nimport uuid\nfrom snowcast_utils import day_index\n\nreference_date = datetime(1900, 1, 1)\n# day_value = convert_date_from_1900(test_start_date)\nresult_date = reference_date + timedelta(days=day_index)\ncurrent_datetime = result_date.strftime(\"%Y-%m-%d\")\n# current_datetime = datetime.now()\ntimestamp_string = current_datetime\n\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\ndef convert_csvs_to_images():\n    # Load the CSV data into a DataFrame\n    data = pd.read_csv('/home/chetana/gridmet_test_run/test_data_prediected.csv')\n\n    # Define the map boundaries for the Western US\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    # Create the Basemap instance\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    # Convert lon/lat to map coordinates\n    x, y = m(data['lon'].values, data['lat'].values)\n\n    # Plot the data using vibrant colors based on predicted_swe\n    plt.scatter(x, y, c=data['predicted_swe'], cmap='coolwarm', s=30, edgecolors='none', alpha=0.7)\n\n    # Add colorbar for reference\n    cbar = plt.colorbar()\n    cbar.set_label('Predicted SWE')\n\n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    #reference_nc_file = nc.Dataset('/home/chetana/gridmet_test_run/gridmet_climatology/etr_2023.nc')\n\n    reference_date = datetime(1900, 1, 1)\n    #day = reference_nc_file.variables['day'][:]\n    #day_value = day[-1]\n    day_value = day_index\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    \n\n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15)\n    # Show the plot or save it to a file\n    plt.savefig(f'/home/chetana/gridmet_test_run/predicted_swe-{timestamp_string}-{uuid.uuid4().hex}.png')\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "today date = 2023-08-16\n/home/chetana\n",
  "history_begin_time" : 1692207626670,
  "history_end_time" : 1692207637802,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "Kg3aDIgWzQTI",
  "history_input" : "import csv\nimport rasterio\nfrom rasterio.transform import from_origin\nimport pandas as pd\nimport shutil\nimport rasterio\nimport pandas as pd\n\n\n\n# Load the GeoTIFF file\ngeotiff_path = '/home/chetana/gridmet_test_run/dem_file.tif'\ncsv_path = '/home/chetana/gridmet_test_run/test_data_prediected.csv'\noutput_path = '/home/chetana/gridmet_test_run/swe_wormhole_result.tif'  # Path to save the output GeoTIFF\n\nheight = 666\nwidth = 694\n# copy the dem over to the result tif as the image skeleton. \n# the rest is just to feed the resutl csv values into the image.\nshutil.copy(geotiff_path, output_path)\n\n# Read the CSV file using pandas\ncsv_data = pd.read_csv(csv_path)\nprint(\"ai result data frame header: \", csv_data.head())\n\n# Open the GeoTIFF file for reading and writing\nwith rasterio.open(geotiff_path, 'r+') as dataset:\n    # Read the data from the GeoTIFF file\n    geotiff_data = dataset.read(1)\n\n    # one dimension value array\n    print(\"result df shape: \", csv_data.shape)\n    swe_column = csv_data['predicted_swe'].values\n    swe_image_df = swe_column.reshape(height, width)\n    \n    # Ensure the dimensions match between the GeoTIFF and CSV\n    if geotiff_data.shape != swe_image_df.shape:\n        raise ValueError(\"CSV rows do not match GeoTIFF rows\")\n\n    # Get the column you want to write into the GeoTIFF (adjust column name)\n    \n\n    # Write the CSV values into the GeoTIFF\n    geotiff_data[:] = swe_image_df\n\n    # Update the GeoTIFF file with the new data\n    dataset.write(geotiff_data, 1)\n\nprint(\"CSV values written to the GeoTIFF file.\")\n\n#csv_to_geotiff('/home/chetana/gridmet_test_run/test_data_prediected.csv', '/home/chetana/gridmet_test_run/output.tif', (height, width))  ",
  "history_output" : "ai result data frame header:      lat      lon  mean_vapor_pressure_deficit  ...  SWE  Flag  predicted_swe\n0  49.0 -125.000                          NaN  ...    0   241            NaN\n1  49.0 -124.964                          NaN  ...    0   241            NaN\n2  49.0 -124.928                          NaN  ...    0   241            NaN\n3  49.0 -124.892                          NaN  ...    0   241            NaN\n4  49.0 -124.856                          NaN  ...    0   241            NaN\n\n[5 rows x 20 columns]\nresult df shape:  (462204, 20)\nCSV values written to the GeoTIFF file.\n",
  "history_begin_time" : 1692207435476,
  "history_end_time" : 1692207440414,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "817GRXF0qZvx",
  "history_input" : "import csv\nimport rasterio\nfrom rasterio.transform import from_origin\nimport pandas as pd\nimport shutil\nimport rasterio\nimport pandas as pd\n\n\ndef save_csv_to_final_geotiff_products(geotiff_path, csv_path, output_path, height, width):\n  # copy the dem over to the result tif as the image skeleton. \n  # the rest is just to feed the resutl csv values into the image.\n  shutil.copy(geotiff_path, output_path)\n\n  # Read the CSV file using pandas\n  csv_data = pd.read_csv(csv_path)\n  print(\"ai result data frame header: \", csv_data.head())\n\n  # Open the GeoTIFF file for reading and writing\n  with rasterio.open(geotiff_path, 'r+') as dataset:\n      # Read the data from the GeoTIFF file\n      geotiff_data = dataset.read(1)\n\n      # two dimension value array\n      print(\"result df shape: \", csv_data.shape)\n      swe_column = csv_data['predicted_swe'].values\n      swe_image_df = swe_column.reshape(height, width)\n\n      # Ensure the dimensions match between the GeoTIFF and CSV\n      if geotiff_data.shape != swe_image_df.shape:\n          raise ValueError(\"CSV rows do not match GeoTIFF rows\")\n\n      # Get the column you want to write into the GeoTIFF (adjust column name)\n\n\n      # Write the CSV values into the GeoTIFF\n      geotiff_data[:] = swe_image_df\n\n      # Update the GeoTIFF file with the new data\n      dataset.write(geotiff_data, 1)\n\n  print(f\"CSV values written to the GeoTIFF file {output_path}\")\n\n  \ndef visualize_swe_products(new_tif_file_path):\n  # leave it to gokul\n  pass\n  \n  \n# Load the GeoTIFF file\ngeotiff_path = '/home/chetana/gridmet_test_run/dem_file.tif'\ncsv_path = '/home/chetana/gridmet_test_run/test_data_prediected.csv'\noutput_path = '/home/chetana/gridmet_test_run/swe_wormhole_result.tif'  # Path to save the output GeoTIFF\n\nheight = 666\nwidth = 694\n\n# first, save the csv to geotiff files\nsave_csv_to_final_geotiff_products(geotiff_path, csv_path, output_path, height, width)\n\n# second, visualize the geotiff files into jpeg/png images\n#visualize_swe_products(output_path)\n\n#csv_to_geotiff('/home/chetana/gridmet_test_run/test_data_prediected.csv', '/home/chetana/gridmet_test_run/output.tif', (height, width))  ",
  "history_output" : "ai result data frame header:      date   lat      lon  etr  ...  northness  AMSR_SWE  AMSR_Flag  predicted_swe\n0  44560  49.0 -125.000  NaN  ...   0.041025         0        241            0.0\n1  44560  49.0 -124.964  NaN  ...   0.250835         0        241            0.0\n2  44560  49.0 -124.928  NaN  ...   0.218295         0        241            0.0\n3  44560  49.0 -124.892  NaN  ...   0.782300         0        241            0.0\n4  44560  49.0 -124.856  NaN  ...   0.712497         0        241            0.0\n[5 rows x 20 columns]\nresult df shape:  (462204, 20)\nCSV values written to the GeoTIFF file /home/chetana/gridmet_test_run/swe_wormhole_result.tif\n",
  "history_begin_time" : 1691870340395,
  "history_end_time" : 1691870341825,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "RYuwL5ioDciK",
  "history_input" : "import csv\nimport rasterio\nfrom rasterio.transform import from_origin\nimport pandas as pd\nimport shutil\nimport rasterio\nimport pandas as pd\n\n\ndef save_csv_to_final_geotiff_products(geotiff_path, csv_path, output_path, height, width):\n  # copy the dem over to the result tif as the image skeleton. \n  # the rest is just to feed the resutl csv values into the image.\n  shutil.copy(geotiff_path, output_path)\n\n  # Read the CSV file using pandas\n  csv_data = pd.read_csv(csv_path)\n  print(\"ai result data frame header: \", csv_data.head())\n\n  # Open the GeoTIFF file for reading and writing\n  with rasterio.open(geotiff_path, 'r+') as dataset:\n      # Read the data from the GeoTIFF file\n      geotiff_data = dataset.read(1)\n\n      # two dimension value array\n      print(\"result df shape: \", csv_data.shape)\n      swe_column = csv_data['predicted_swe'].values\n      swe_image_df = swe_column.reshape(height, width)\n\n      # Ensure the dimensions match between the GeoTIFF and CSV\n      if geotiff_data.shape != swe_image_df.shape:\n          raise ValueError(\"CSV rows do not match GeoTIFF rows\")\n\n      # Get the column you want to write into the GeoTIFF (adjust column name)\n\n\n      # Write the CSV values into the GeoTIFF\n      geotiff_data[:] = swe_image_df\n\n      # Update the GeoTIFF file with the new data\n      dataset.write(geotiff_data, 1)\n\n  print(\"CSV values written to the GeoTIFF file.\")\n\n  \ndef visualize_swe_products(new_tif_file_path):\n  # leave it to gokul\n  pass\n  \n  \n# Load the GeoTIFF file\ngeotiff_path = '/home/chetana/gridmet_test_run/dem_file.tif'\ncsv_path = '/home/chetana/gridmet_test_run/test_data_prediected.csv'\noutput_path = '/home/chetana/gridmet_test_run/swe_wormhole_result.tif'  # Path to save the output GeoTIFF\n\nheight = 666\nwidth = 694\n\n# first, save the csv to geotiff files\nsave_csv_to_final_geotiff_products(geotiff_path, csv_path, output_path, height, width)\n\n# second, visualize the geotiff files into jpeg/png images\n#visualize_swe_products(output_path)\n\n#csv_to_geotiff('/home/chetana/gridmet_test_run/test_data_prediected.csv', '/home/chetana/gridmet_test_run/output.tif', (height, width))  ",
  "history_output" : "ai result data frame header:      date   lat      lon  etr  ...  northness  AMSR_SWE  AMSR_Flag  predicted_swe\n0  44560  49.0 -125.000  NaN  ...   0.041025         0        241            0.0\n1  44560  49.0 -124.964  NaN  ...   0.250835         0        241            0.0\n2  44560  49.0 -124.928  NaN  ...   0.218295         0        241            0.0\n3  44560  49.0 -124.892  NaN  ...   0.782300         0        241            0.0\n4  44560  49.0 -124.856  NaN  ...   0.712497         0        241            0.0\n[5 rows x 20 columns]\nresult df shape:  (462204, 20)\nCSV values written to the GeoTIFF file.\n",
  "history_begin_time" : 1691870306297,
  "history_end_time" : 1691870307650,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "3Rdbiiq7kFL6",
  "history_input" : "import csv\nimport rasterio\nfrom rasterio.transform import from_origin\nimport pandas as pd\nimport shutil\nimport rasterio\nimport pandas as pd\n\n\ndef save_csv_to_final_geotiff_products(geotiff_path, csv_path, output_path, height, width):\n  # copy the dem over to the result tif as the image skeleton. \n  # the rest is just to feed the resutl csv values into the image.\n  shutil.copy(geotiff_path, output_path)\n\n  # Read the CSV file using pandas\n  csv_data = pd.read_csv(csv_path)\n  print(\"ai result data frame header: \", csv_data.head())\n\n  # Open the GeoTIFF file for reading and writing\n  with rasterio.open(geotiff_path, 'r+') as dataset:\n      # Read the data from the GeoTIFF file\n      geotiff_data = dataset.read(1)\n\n      # two dimension value array\n      print(\"result df shape: \", csv_data.shape)\n      swe_column = csv_data['predicted_swe'].values\n      swe_image_df = swe_column.reshape(height, width)\n\n      # Ensure the dimensions match between the GeoTIFF and CSV\n      if geotiff_data.shape != swe_image_df.shape:\n          raise ValueError(\"CSV rows do not match GeoTIFF rows\")\n\n      # Get the column you want to write into the GeoTIFF (adjust column name)\n\n\n      # Write the CSV values into the GeoTIFF\n      geotiff_data[:] = swe_image_df\n\n      # Update the GeoTIFF file with the new data\n      dataset.write(geotiff_data, 1)\n\n  print(\"CSV values written to the GeoTIFF file.\")\n\n  \ndef visualize_swe_products(new_tif_file_path):\n  # leave it to gokul\n  pass\n  \n  \n# Load the GeoTIFF file\ngeotiff_path = '/home/chetana/gridmet_test_run/dem_file.tif'\ncsv_path = '/home/chetana/gridmet_test_run/test_data_prediected.csv'\noutput_path = '/home/chetana/gridmet_test_run/swe_wormhole_result.tif'  # Path to save the output GeoTIFF\n\nheight = 666\nwidth = 694\n\n# first, save the csv to geotiff files\n#save_csv_to_final_geotiff_products(geotiff_path, csv_path, output_path, height, width)\n\n# second, visualize the geotiff files into jpeg/png images\n#visualize_swe_products(output_path)\n\n#csv_to_geotiff('/home/chetana/gridmet_test_run/test_data_prediected.csv', '/home/chetana/gridmet_test_run/output.tif', (height, width))  ",
  "history_output" : "",
  "history_begin_time" : 1691868303232,
  "history_end_time" : 1691868303899,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "fWPyWPecWzhQ",
  "history_input" : "import csv\nimport rasterio\nfrom rasterio.transform import from_origin\nimport pandas as pd\nimport shutil\nimport rasterio\nimport pandas as pd\n\n\n\n# Load the GeoTIFF file\ngeotiff_path = '/home/chetana/gridmet_test_run/dem_file.tif'\ncsv_path = '/home/chetana/gridmet_test_run/test_data_prediected.csv'\noutput_path = '/home/chetana/gridmet_test_run/swe_wormhole_result.tif'  # Path to save the output GeoTIFF\n\nheight = 666\nwidth = 694\n# copy the dem over to the result tif as the image skeleton. \n# the rest is just to feed the resutl csv values into the image.\nshutil.copy(geotiff_path, output_path)\n\n# Read the CSV file using pandas\ncsv_data = pd.read_csv(csv_path)\nprint(\"ai result data frame header: \", csv_data.head())\n\n# Open the GeoTIFF file for reading and writing\nwith rasterio.open(geotiff_path, 'r+') as dataset:\n    # Read the data from the GeoTIFF file\n    geotiff_data = dataset.read(1)\n\n    # one dimension value array\n    print(\"result df shape: \", csv_data.shape)\n    swe_column = csv_data['predicted_swe'].values\n    swe_image_df = swe_column.reshape(height, width)\n    \n    # Ensure the dimensions match between the GeoTIFF and CSV\n    if geotiff_data.shape != swe_image_df.shape:\n        raise ValueError(\"CSV rows do not match GeoTIFF rows\")\n\n    # Get the column you want to write into the GeoTIFF (adjust column name)\n    \n\n    # Write the CSV values into the GeoTIFF\n    geotiff_data[:] = swe_image_df\n\n    # Update the GeoTIFF file with the new data\n    dataset.write(geotiff_data, 1)\n\nprint(\"CSV values written to the GeoTIFF file.\")\n\n#csv_to_geotiff('/home/chetana/gridmet_test_run/test_data_prediected.csv', '/home/chetana/gridmet_test_run/output.tif', (height, width))  ",
  "history_output" : "today date = 2023-08-12\n\nStream closed",
  "history_begin_time" : 1691867731554,
  "history_end_time" : 1691867737998,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Failed"
},{
  "history_id" : "dNdvttkwmfU2",
  "history_input" : "import csv\nimport rasterio\nfrom rasterio.transform import from_origin\nimport pandas as pd\nimport shutil\nimport rasterio\nimport pandas as pd\n\n\n\n# Load the GeoTIFF file\ngeotiff_path = '/home/chetana/gridmet_test_run/dem_file.tif'\ncsv_path = '/home/chetana/gridmet_test_run/test_data_prediected.csv'\noutput_path = '/home/chetana/gridmet_test_run/swe_wormhole_result.tif'  # Path to save the output GeoTIFF\n\nheight = 666\nwidth = 694\n# copy the dem over to the result tif as the image skeleton. \n# the rest is just to feed the resutl csv values into the image.\nshutil.copy(geotiff_path, output_path)\n\n# Read the CSV file using pandas\ncsv_data = pd.read_csv(csv_path)\nprint(\"ai result data frame header: \", csv_data.head())\n\n# Open the GeoTIFF file for reading and writing\nwith rasterio.open(geotiff_path, 'r+') as dataset:\n    # Read the data from the GeoTIFF file\n    geotiff_data = dataset.read(1)\n\n    # one dimension value array\n    print(\"result df shape: \", csv_data.shape)\n    swe_column = csv_data['predicted_swe'].values\n    swe_image_df = swe_column.reshape(height, width)\n    \n    # Ensure the dimensions match between the GeoTIFF and CSV\n    if geotiff_data.shape != swe_image_df.shape:\n        raise ValueError(\"CSV rows do not match GeoTIFF rows\")\n\n    # Get the column you want to write into the GeoTIFF (adjust column name)\n    \n\n    # Write the CSV values into the GeoTIFF\n    geotiff_data[:] = csv_column\n\n    # Update the GeoTIFF file with the new data\n    dataset.write(geotiff_data, 1)\n\nprint(\"CSV values written to the GeoTIFF file.\")\n\n#csv_to_geotiff('/home/chetana/gridmet_test_run/test_data_prediected.csv', '/home/chetana/gridmet_test_run/output.tif', (height, width))  ",
  "history_output" : "ai result data frame header:      date   lat      lon  etr  ...  northness  AMSR_SWE  AMSR_Flag  predicted_swe\n0  44560  49.0 -125.000 -1.0  ...   0.041025         0        241         14.527\n1  44560  49.0 -124.964 -1.0  ...   0.250835         0        241         14.527\n2  44560  49.0 -124.928 -1.0  ...   0.218295         0        241         14.527\n3  44560  49.0 -124.892 -1.0  ...   0.782300         0        241         14.368\n4  44560  49.0 -124.856 -1.0  ...   0.712497         0        241         14.368\n[5 rows x 20 columns]\nresult df shape:  (462204, 20)\nTraceback (most recent call last):\n  File \"/home/chetana/gw-workspace/dNdvttkwmfU2/convert_results_to_images.py\", line 44, in <module>\n    geotiff_data[:] = csv_column\nNameError: name 'csv_column' is not defined\n",
  "history_begin_time" : 1691867715441,
  "history_end_time" : 1691867716856,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Failed"
},{
  "history_id" : "GFLBdBjGVieL",
  "history_input" : "import csv\nimport rasterio\nfrom rasterio.transform import from_origin\nimport pandas as pd\nimport shutil\nimport rasterio\nimport pandas as pd\n\n\n\n# Load the GeoTIFF file\ngeotiff_path = '/home/chetana/gridmet_test_run/dem_file.tif'\ncsv_path = '/home/chetana/gridmet_test_run/test_data_prediected.csv'\noutput_path = '/home/chetana/gridmet_test_run/swe_wormhole_result.tif'  # Path to save the output GeoTIFF\n\nheight = 666\nwidth = 694\n# copy the dem over to the result tif as the image skeleton. \n# the rest is just to feed the resutl csv values into the image.\nshutil.copy(geotiff_path, output_path)\n\n# Read the CSV file using pandas\ncsv_data = pd.read_csv(csv_path)\nprint(\"ai result data frame header: \", csv_data.head())\n\n# Open the GeoTIFF file for reading and writing\nwith rasterio.open(geotiff_path, 'r+') as dataset:\n    # Read the data from the GeoTIFF file\n    geotiff_data = dataset.read(1)\n\n    # one dimension value array\n    print(\"result df shape: \", csv_data.shape)\n    swe_column = csv_data['predicted_swe'].values\n    swe_image_df = swe_column.reshape(height, width)\n    \n    # Ensure the dimensions match between the GeoTIFF and CSV\n    if geotiff_data.shape != swe_image_df.shape:\n        raise ValueError(\"CSV rows do not match GeoTIFF rows\")\n\n    # Get the column you want to write into the GeoTIFF (adjust column name)\n    \n\n    # Write the CSV values into the GeoTIFF\n    geotiff_data[:] = csv_column\n\n    # Update the GeoTIFF file with the new data\n    dataset.write(geotiff_data, 1)\n\nprint(\"CSV values written to the GeoTIFF file.\")\n\n#csv_to_geotiff('/home/chetana/gridmet_test_run/test_data_prediected.csv', '/home/chetana/gridmet_test_run/output.tif', (height, width))  ",
  "history_output" : "ai result data frame header:      date   lat      lon  etr  ...  northness  AMSR_SWE  AMSR_Flag  predicted_swe\n0  44560  49.0 -123.092  3.5  ...  -0.569510       254        254         14.219\n1  44560  49.0 -123.056  3.5  ...  -0.774772       254        254         14.251\n2  44560  49.0 -123.020  3.5  ...   0.000000       254        254         14.171\n3  44560  49.0 -122.804  3.4  ...   0.779788         0        241         14.095\n4  44560  49.0 -122.768  3.4  ...   0.388832         0        241         14.057\n[5 rows x 20 columns]\nresult df shape:  (310570, 20)\nTraceback (most recent call last):\n  File \"/home/chetana/gw-workspace/GFLBdBjGVieL/convert_results_to_images.py\", line 34, in <module>\n    swe_image_df = swe_column.reshape(height, width)\nValueError: cannot reshape array of size 310570 into shape (666,694)\n",
  "history_begin_time" : 1691867015923,
  "history_end_time" : 1691867017107,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Failed"
},{
  "history_id" : "Ycw8QidQm4DA",
  "history_input" : "import csv\nimport rasterio\nfrom rasterio.transform import from_origin\nimport pandas as pd\nimport shutil\nimport rasterio\nimport pandas as pd\n\n\n\n# Load the GeoTIFF file\ngeotiff_path = '/home/chetana/gridmet_test_run/dem_file.tif'\ncsv_path = '/home/chetana/gridmet_test_run/test_data_prediected.csv'\noutput_path = '/home/chetana/gridmet_test_run/swe_wormhole_result.tif'  # Path to save the output GeoTIFF\n\nheight = 666\nwidth = 694\n# copy the dem over to the result tif as the image skeleton. \n# the rest is just to feed the resutl csv values into the image.\nshutil.copy(geotiff_path, output_path)\n\n# Read the CSV file using pandas\ncsv_data = pd.read_csv(csv_path)\nprint(\"ai result data frame header: \", csv_data.head())\n\n# Open the GeoTIFF file for reading and writing\nwith rasterio.open(geotiff_path, 'r+') as dataset:\n    # Read the data from the GeoTIFF file\n    geotiff_data = dataset.read(1)\n\n    # one dimension value array\n    print(\"result df shape: \", csv_data.shape)\n    \n    # Ensure the dimensions match between the GeoTIFF and CSV\n    if geotiff_data.shape != csv_data.shape[0]:\n        raise ValueError(\"CSV rows do not match GeoTIFF rows\")\n\n    # Get the column you want to write into the GeoTIFF (adjust column name)\n    csv_column = csv_data['column_name'].values\n\n    # Write the CSV values into the GeoTIFF\n    geotiff_data[:] = csv_column\n\n    # Update the GeoTIFF file with the new data\n    dataset.write(geotiff_data, 1)\n\nprint(\"CSV values written to the GeoTIFF file.\")\n\n#csv_to_geotiff('/home/chetana/gridmet_test_run/test_data_prediected.csv', '/home/chetana/gridmet_test_run/output.tif', (height, width))  ",
  "history_output" : "ai result data frame header:      date   lat      lon  etr  ...  northness  AMSR_SWE  AMSR_Flag  predicted_swe\n0  44560  49.0 -123.092  3.5  ...  -0.569510       254        254         14.219\n1  44560  49.0 -123.056  3.5  ...  -0.774772       254        254         14.251\n2  44560  49.0 -123.020  3.5  ...   0.000000       254        254         14.171\n3  44560  49.0 -122.804  3.4  ...   0.779788         0        241         14.095\n4  44560  49.0 -122.768  3.4  ...   0.388832         0        241         14.057\n[5 rows x 20 columns]\nresult df shape:  (310570, 20)\nTraceback (most recent call last):\n  File \"/home/chetana/gw-workspace/Ycw8QidQm4DA/convert_results_to_images.py\", line 36, in <module>\n    raise ValueError(\"CSV rows do not match GeoTIFF rows\")\nValueError: CSV rows do not match GeoTIFF rows\n",
  "history_begin_time" : 1691866940880,
  "history_end_time" : 1691866942107,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Failed"
},{
  "history_id" : "96V6DRYTGpUz",
  "history_input" : "import csv\nimport rasterio\nfrom rasterio.transform import from_origin\nimport pandas as pd\n\nimport rasterio\nimport pandas as pd\n\n\n\n# Load the GeoTIFF file\ngeotiff_path = '/home/chetana/gridmet_test_run/dem_file.tif'\ncsv_path = '/home/chetana/gridmet_test_run/test_data_prediected.csv'\noutput_path = '/home/chetana/gridmet_test_run/swe_wormhole_result.tif'  # Path to save the output GeoTIFF\n\nheight = 666\nwidth = 694\n# copy the dem over to the result tif as the image skeleton. \n# the rest is just to feed the resutl csv values into the image.\nshutil.copy(geotiff_path, output_path)\n\n# Read the CSV file using pandas\ncsv_data = pd.read_csv(csv_path)\nprint(\"ai result data frame header: \", csv_data.head())\n\n# Open the GeoTIFF file for reading and writing\nwith rasterio.open(geotiff_path, 'r+') as dataset:\n    # Read the data from the GeoTIFF file\n    geotiff_data = dataset.read(1)\n\n    # one dimension value array\n    print(\"result df shape: \", csv_data.shape)\n    \n    # Ensure the dimensions match between the GeoTIFF and CSV\n    if geotiff_data.shape != csv_data.shape[0]:\n        raise ValueError(\"CSV rows do not match GeoTIFF rows\")\n\n    # Get the column you want to write into the GeoTIFF (adjust column name)\n    csv_column = csv_data['column_name'].values\n\n    # Write the CSV values into the GeoTIFF\n    geotiff_data[:] = csv_column\n\n    # Update the GeoTIFF file with the new data\n    dataset.write(geotiff_data, 1)\n\nprint(\"CSV values written to the GeoTIFF file.\")\n\n#csv_to_geotiff('/home/chetana/gridmet_test_run/test_data_prediected.csv', '/home/chetana/gridmet_test_run/output.tif', (height, width))  ",
  "history_output" : "Traceback (most recent call last):\n  File \"/home/chetana/gw-workspace/96V6DRYTGpUz/convert_results_to_images.py\", line 20, in <module>\n    shutil.copy(geotiff_path, output_path)\nNameError: name 'shutil' is not defined\n",
  "history_begin_time" : 1691866924633,
  "history_end_time" : 1691866925132,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Failed"
},{
  "history_id" : "qbPzSg7WZrzN",
  "history_input" : "import csv\nimport rasterio\nfrom rasterio.transform import from_origin\nimport pandas as pd\n\n\ndata = pd.read_csv('/home/chetana/gridmet_test_run/test_data_prediected.csv')\n\ndef csv_to_geotiff(csv_file, geotiff_file, image_shape):\n    # Read CSV file and store data\n    data = []\n    with open(csv_file, 'r') as csvfile:\n        csvreader = csv.reader(csvfile)\n        header = next(csvreader)  # Skip the header\n        for row in csvreader:\n            data.append(row)\n    swe_predicted_index = header.index(\"predicted_swe\")\n\n    # Extract data dimensions\n    num_rows = len(data)\n    num_cols = len(data[0])\n\n    # Extract image values and geographic coordinates\n    latitudes = [float(row[0]) for row in data]\n    longitudes = [float(row[1]) for row in data]\n    image_values = [float(row[swe_predicted_index]) for row in data]\n\n    # Calculate pixel size and geotransform\n    pixel_width = (longitudes[-1] - longitudes[0]) / (num_cols - 1)\n    pixel_height = (latitudes[-1] - latitudes[0]) / (num_rows - 1)\n    top_left_x = longitudes[0]\n    top_left_y = latitudes[0]\n    transform = from_origin(top_left_x, top_left_y, pixel_width, pixel_height)\n\n    # Create the GeoTIFF file\n    with rasterio.open(\n        geotiff_file,\n        'w',\n        driver='GTiff',\n        height=image_shape[0],\n        width=image_shape[1],\n        count=1,\n        dtype=rasterio.float32,\n        crs='EPSG:4326',\n        transform=transform,\n    ) as dst:\n        # Reshape image values to match GeoTIFF dimensions\n        image_data = [image_values[i:i + num_cols] for i in range(0, len(image_values), num_cols)]\n        image_data = [[float(val) for val in row] for row in image_data]\n\n        # Write image data to GeoTIFF\n        dst.write(image_data, 1)\n\n\nheight = 666\nwidth = 694\ncsv_to_geotiff('/home/chetana/gridmet_test_run/test_data_prediected.csv', '/home/chetana/gridmet_test_run/output.tif', (height, width))  ",
  "history_output" : "Traceback (most recent call last):\n  File \"rasterio/_crs.pyx\", line 363, in rasterio._crs._CRS.from_user_input\n  File \"rasterio/_err.pyx\", line 194, in rasterio._err.exc_wrap_ogrerr\nrasterio._err.CPLE_BaseError: OGR Error code 6\nDuring handling of the above exception, another exception occurred:\nTraceback (most recent call last):\n  File \"convert_results_to_images.py\", line 57, in <module>\n    csv_to_geotiff('/home/chetana/gridmet_test_run/test_data_prediected.csv', '/home/chetana/gridmet_test_run/output.tif', (height, width))  \n  File \"convert_results_to_images.py\", line 45, in csv_to_geotiff\n    transform=transform,\n  File \"/usr/local/lib/python3.6/dist-packages/rasterio/env.py\", line 434, in wrapper\n    return f(*args, **kwds)\n  File \"/usr/local/lib/python3.6/dist-packages/rasterio/__init__.py\", line 229, in open\n    **kwargs)\n  File \"rasterio/_io.pyx\", line 1248, in rasterio._io.DatasetWriterBase.__init__\n  File \"rasterio/_io.pyx\", line 1286, in rasterio._io.DatasetWriterBase._set_crs\n  File \"/usr/local/lib/python3.6/dist-packages/rasterio/crs.py\", line 459, in from_user_input\n    obj._crs = _CRS.from_user_input(value, morph_from_esri_dialect=morph_from_esri_dialect)\n  File \"rasterio/_crs.pyx\", line 367, in rasterio._crs._CRS.from_user_input\nrasterio.errors.CRSError: The WKT could not be parsed. OGR Error code 6\n",
  "history_begin_time" : 1691866598298,
  "history_end_time" : 1691866602956,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Failed"
},{
  "history_id" : "5X36pHq6sL00",
  "history_input" : "import csv\nimport rasterio\nfrom rasterio.transform import from_origin\nimport pandas as pd\n\n\ndata = pd.read_csv('/home/chetana/gridmet_test_run/test_data_prediected.csv')\n\ndef csv_to_geotiff(csv_file, geotiff_file, image_shape):\n    # Read CSV file and store data\n    data = []\n    with open(csv_file, 'r') as csvfile:\n        csvreader = csv.reader(csvfile)\n        header = next(csvreader)  # Skip the header\n        for row in csvreader:\n            data.append(row)\n    swe_predicted_index = header.index(\"predicted_swe\")\n\n    # Extract data dimensions\n    num_rows = len(data)\n    num_cols = len(data[0])\n\n    # Extract image values and geographic coordinates\n    latitudes = [float(row[0]) for row in data]\n    longitudes = [float(row[1]) for row in data]\n    image_values = [float(row[swe_predicted_index]) for row in data]\n\n    # Calculate pixel size and geotransform\n    pixel_width = (longitudes[-1] - longitudes[0]) / (num_cols - 1)\n    pixel_height = (latitudes[-1] - latitudes[0]) / (num_rows - 1)\n    top_left_x = longitudes[0]\n    top_left_y = latitudes[0]\n    transform = from_origin(top_left_x, top_left_y, pixel_width, pixel_height)\n\n    # Create the GeoTIFF file\n    with rasterio.open(\n        geotiff_file,\n        'w',\n        driver='GTiff',\n        height=image_shape[0],\n        width=image_shape[1],\n        count=1,\n        dtype=rasterio.float32,\n        crs='EPSG:4326',\n        transform=transform,\n    ) as dst:\n        # Reshape image values to match GeoTIFF dimensions\n        image_data = [image_values[i:i + num_cols] for i in range(0, len(image_values), num_cols)]\n        image_data = [[float(val) for val in row] for row in image_data]\n\n        # Write image data to GeoTIFF\n        dst.write(image_data, 1)\n\n\nheight = 666\nwidth = 694\ncsv_to_geotiff('/home/chetana/gridmet_test_run/test_data_prediected.csv', '/home/chetana/gridmet_test_run/output.tif', (height, width))  ",
  "history_output" : "Traceback (most recent call last):\n  File \"rasterio/crs.pyx\", line 775, in rasterio.crs.CRS.from_user_input\n  File \"rasterio/_err.pyx\", line 209, in rasterio._err.exc_wrap_ogrerr\nrasterio._err.CPLE_BaseError: OGR Error code 6\nDuring handling of the above exception, another exception occurred:\nTraceback (most recent call last):\n  File \"/home/chetana/gw-workspace/5X36pHq6sL00/convert_results_to_images.py\", line 57, in <module>\n    csv_to_geotiff('/home/chetana/gridmet_test_run/test_data_prediected.csv', '/home/chetana/gridmet_test_run/output.tif', (height, width))  \n  File \"/home/chetana/gw-workspace/5X36pHq6sL00/convert_results_to_images.py\", line 36, in csv_to_geotiff\n    with rasterio.open(\n  File \"/home/chetana/anaconda3/lib/python3.9/site-packages/rasterio/env.py\", line 451, in wrapper\n    return f(*args, **kwds)\n  File \"/home/chetana/anaconda3/lib/python3.9/site-packages/rasterio/__init__.py\", line 314, in open\n    dataset = writer(\n  File \"rasterio/_io.pyx\", line 1525, in rasterio._io.DatasetWriterBase.__init__\n  File \"rasterio/_io.pyx\", line 1554, in rasterio._io.DatasetWriterBase._set_crs\n  File \"rasterio/crs.pyx\", line 777, in rasterio.crs.CRS.from_user_input\nrasterio.errors.CRSError: The WKT could not be parsed. OGR Error code 6\n",
  "history_begin_time" : 1691866385908,
  "history_end_time" : 1691866395707,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Failed"
},{
  "history_id" : "Pi86rU8Nh4pZ",
  "history_input" : "import csv\nimport rasterio\nfrom rasterio.transform import from_origin\nimport pandas as pd\n\n\ndata = pd.read_csv('/home/chetana/gridmet_test_run/test_data_prediected.csv')\n\ndef csv_to_geotiff(csv_file, geotiff_file, image_shape):\n    # Read CSV file and store data\n    data = []\n    with open(csv_file, 'r') as csvfile:\n        csvreader = csv.reader(csvfile)\n        header = next(csvreader)  # Skip the header\n        for row in csvreader:\n            data.append(row)\n    swe_predicted_index = header.index(\"predicted_swe\")\n\n    # Extract data dimensions\n    num_rows = len(data)\n    num_cols = len(data[0])\n\n    # Extract image values and geographic coordinates\n    latitudes = [float(row[0]) for row in data]\n    longitudes = [float(row[1]) for row in data]\n    image_values = [float(row[swe_predicted_index]) for row in data]\n\n    # Calculate pixel size and geotransform\n    pixel_width = (longitudes[-1] - longitudes[0]) / (num_cols - 1)\n    pixel_height = (latitudes[-1] - latitudes[0]) / (num_rows - 1)\n    top_left_x = longitudes[0]\n    top_left_y = latitudes[0]\n    transform = from_origin(top_left_x, top_left_y, pixel_width, pixel_height)\n\n    # Create the GeoTIFF file\n    with rasterio.open(\n        geotiff_file,\n        'w',\n        driver='GTiff',\n        height=image_shape[0],\n        width=image_shape[1],\n        count=1,\n        dtype=rasterio.float32,\n        crs='EPSG:4326',\n        transform=transform,\n    ) as dst:\n        # Reshape image values to match GeoTIFF dimensions\n        image_data = [image_values[i:i + num_cols] for i in range(0, len(image_values), num_cols)]\n        image_data = [[float(val) for val in row] for row in image_data]\n\n        # Write image data to GeoTIFF\n        dst.write(image_data, 1)\n\n\nheight = 666\nwidth = 694\ncsv_to_geotiff('/home/chetana/gridmet_test_run/test_data_prediected.csv', '/home/chetana/gridmet_test_run/output.tif', (height, width))  ",
  "history_output" : "Cannot run program \"/home/chetana/anaconda3/conda/bin/python\" (in directory \"/home/chetana/gw-workspace/Pi86rU8Nh4pZ\"): error=2, No such file or directory",
  "history_begin_time" : 1691866353303,
  "history_end_time" : 1691866353308,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Failed"
},{
  "history_id" : "oRMVevJoifdN",
  "history_input" : "import csv\nimport rasterio\nfrom rasterio.transform import from_origin\nimport pandas as pd\n\n\ndata = pd.read_csv('/home/chetana/gridmet_test_run/test_data_prediected.csv')\n\ndef csv_to_geotiff(csv_file, geotiff_file, image_shape):\n    # Read CSV file and store data\n    data = []\n    with open(csv_file, 'r') as csvfile:\n        csvreader = csv.reader(csvfile)\n        header = next(csvreader)  # Skip the header\n        for row in csvreader:\n            data.append(row)\n    swe_predicted_index = header.index(\"predicted_swe\")\n\n    # Extract data dimensions\n    num_rows = len(data)\n    num_cols = len(data[0])\n\n    # Extract image values and geographic coordinates\n    latitudes = [float(row[0]) for row in data]\n    longitudes = [float(row[1]) for row in data]\n    image_values = [float(row[swe_predicted_index]) for row in data]\n\n    # Calculate pixel size and geotransform\n    pixel_width = (longitudes[-1] - longitudes[0]) / (num_cols - 1)\n    pixel_height = (latitudes[-1] - latitudes[0]) / (num_rows - 1)\n    top_left_x = longitudes[0]\n    top_left_y = latitudes[0]\n    transform = from_origin(top_left_x, top_left_y, pixel_width, pixel_height)\n\n    # Create the GeoTIFF file\n    with rasterio.open(\n        geotiff_file,\n        'w',\n        driver='GTiff',\n        height=image_shape[0],\n        width=image_shape[1],\n        count=1,\n        dtype=rasterio.float32,\n        crs='EPSG:4326',\n        transform=transform,\n    ) as dst:\n        # Reshape image values to match GeoTIFF dimensions\n        image_data = [image_values[i:i + num_cols] for i in range(0, len(image_values), num_cols)]\n        image_data = [[float(val) for val in row] for row in image_data]\n\n        # Write image data to GeoTIFF\n        dst.write(image_data, 1)\n\n\nheight = 666\nwidth = 694\ncsv_to_geotiff('/home/chetana/gridmet_test_run/test_data_prediected.csv', '/home/chetana/gridmet_test_run/output.tif', (height, width))  ",
  "history_output" : "",
  "history_begin_time" : 1691866352929,
  "history_end_time" : 1691866353313,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Failed"
},{
  "history_id" : "Mg5mOFpYio1n",
  "history_input" : "import csv\nimport rasterio\nfrom rasterio.transform import from_origin\nimport pandas as pd\n\n\ndata = pd.read_csv('/home/chetana/gridmet_test_run/test_data_prediected.csv')\n\ndef csv_to_geotiff(csv_file, geotiff_file, image_shape):\n    # Read CSV file and store data\n    data = []\n    with open(csv_file, 'r') as csvfile:\n        csvreader = csv.reader(csvfile)\n        header = next(csvreader)  # Skip the header\n        for row in csvreader:\n            data.append(row)\n    swe_predicted_index = header.index(\"predicted_swe\")\n\n    # Extract data dimensions\n    num_rows = len(data)\n    num_cols = len(data[0])\n\n    # Extract image values and geographic coordinates\n    latitudes = [float(row[0]) for row in data]\n    longitudes = [float(row[1]) for row in data]\n    image_values = [float(row[swe_predicted_index]) for row in data]\n\n    # Calculate pixel size and geotransform\n    pixel_width = (longitudes[-1] - longitudes[0]) / (num_cols - 1)\n    pixel_height = (latitudes[-1] - latitudes[0]) / (num_rows - 1)\n    top_left_x = longitudes[0]\n    top_left_y = latitudes[0]\n    transform = from_origin(top_left_x, top_left_y, pixel_width, pixel_height)\n\n    # Create the GeoTIFF file\n    with rasterio.open(\n        geotiff_file,\n        'w',\n        driver='GTiff',\n        height=image_shape[0],\n        width=image_shape[1],\n        count=1,\n        dtype=rasterio.float32,\n        crs='EPSG:4326',\n        transform=transform,\n    ) as dst:\n        # Reshape image values to match GeoTIFF dimensions\n        image_data = [image_values[i:i + num_cols] for i in range(0, len(image_values), num_cols)]\n        image_data = [[float(val) for val in row] for row in image_data]\n\n        # Write image data to GeoTIFF\n        dst.write(image_data, 1)\n\n\nheight = 666\nwidth = 694\ncsv_to_geotiff('/home/chetana/gridmet_test_run/test_data_prediected.csv', '/home/chetana/gridmet_test_run/output.tif', (height, width))  ",
  "history_output" : "Traceback (most recent call last):\n  File \"rasterio/crs.pyx\", line 775, in rasterio.crs.CRS.from_user_input\n  File \"rasterio/_err.pyx\", line 209, in rasterio._err.exc_wrap_ogrerr\nrasterio._err.CPLE_BaseError: OGR Error code 6\nDuring handling of the above exception, another exception occurred:\nTraceback (most recent call last):\n  File \"/home/chetana/gw-workspace/Mg5mOFpYio1n/convert_results_to_images.py\", line 57, in <module>\n    csv_to_geotiff('/home/chetana/gridmet_test_run/test_data_prediected.csv', '/home/chetana/gridmet_test_run/output.tif', (height, width))  \n  File \"/home/chetana/gw-workspace/Mg5mOFpYio1n/convert_results_to_images.py\", line 36, in csv_to_geotiff\n    with rasterio.open(\n  File \"/home/chetana/gridmet_test_run/pycrate/lib/python3.9/site-packages/rasterio/env.py\", line 451, in wrapper\n    return f(*args, **kwds)\n  File \"/home/chetana/gridmet_test_run/pycrate/lib/python3.9/site-packages/rasterio/__init__.py\", line 314, in open\n    dataset = writer(\n  File \"rasterio/_io.pyx\", line 1561, in rasterio._io.DatasetWriterBase.__init__\n  File \"rasterio/_io.pyx\", line 1590, in rasterio._io.DatasetWriterBase._set_crs\n  File \"rasterio/crs.pyx\", line 777, in rasterio.crs.CRS.from_user_input\nrasterio.errors.CRSError: The WKT could not be parsed. OGR Error code 6\n",
  "history_begin_time" : 1691866314407,
  "history_end_time" : 1691866318228,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Failed"
},{
  "history_id" : "dDPS5TrPkx0d",
  "history_input" : "import csv\nimport rasterio\nfrom rasterio.transform import from_origin\nimport pandas as pd\n\n\ndata = pd.read_csv('/home/chetana/gridmet_test_run/test_data_prediected.csv')\n\ndef csv_to_geotiff(csv_file, geotiff_file, image_shape):\n    # Read CSV file and store data\n    data = []\n    with open(csv_file, 'r') as csvfile:\n        csvreader = csv.reader(csvfile)\n        header = next(csvreader)  # Skip the header\n        for row in csvreader:\n            data.append(row)\n    swe_predicted_index = header.index(\"predicted_swe\")\n\n    # Extract data dimensions\n    num_rows = len(data)\n    num_cols = len(data[0])\n\n    # Extract image values and geographic coordinates\n    latitudes = [float(row[0]) for row in data]\n    longitudes = [float(row[1]) for row in data]\n    image_values = [float(row[swe_predicted_index]) for row in data]\n\n    # Calculate pixel size and geotransform\n    pixel_width = (longitudes[-1] - longitudes[0]) / (num_cols - 1)\n    pixel_height = (latitudes[-1] - latitudes[0]) / (num_rows - 1)\n    top_left_x = longitudes[0]\n    top_left_y = latitudes[0]\n    transform = from_origin(top_left_x, top_left_y, pixel_width, pixel_height)\n\n    # Create the GeoTIFF file\n    with rasterio.open(\n        geotiff_file,\n        'w',\n        driver='GTiff',\n        height=image_shape[0],\n        width=image_shape[1],\n        count=1,\n        dtype=rasterio.float32,\n        crs='EPSG:4326',\n        transform=transform,\n    ) as dst:\n        # Reshape image values to match GeoTIFF dimensions\n        image_data = [image_values[i:i + num_cols] for i in range(0, len(image_values), num_cols)]\n        image_data = [[float(val) for val in row] for row in image_data]\n\n        # Write image data to GeoTIFF\n        dst.write(image_data, 1)\n\n\nheight = 666\nwidth = 694\ncsv_to_geotiff('/home/chetana/gridmet_test_run/test_data_prediected.csv', '/home/chetana/gridmet_test_run/output.tif', (height, width))  ",
  "history_output" : "Traceback (most recent call last):\n  File \"rasterio/crs.pyx\", line 775, in rasterio.crs.CRS.from_user_input\n  File \"rasterio/_err.pyx\", line 209, in rasterio._err.exc_wrap_ogrerr\nrasterio._err.CPLE_BaseError: OGR Error code 6\nDuring handling of the above exception, another exception occurred:\nTraceback (most recent call last):\n  File \"/home/chetana/gw-workspace/dDPS5TrPkx0d/convert_results_to_images.py\", line 57, in <module>\n    csv_to_geotiff('/home/chetana/gridmet_test_run/test_data_prediected.csv', '/home/chetana/gridmet_test_run/output.tif', (height, width))  \n  File \"/home/chetana/gw-workspace/dDPS5TrPkx0d/convert_results_to_images.py\", line 36, in csv_to_geotiff\n    with rasterio.open(\n  File \"/home/chetana/gridmet_test_run/pycrate/lib/python3.9/site-packages/rasterio/env.py\", line 451, in wrapper\n    return f(*args, **kwds)\n  File \"/home/chetana/gridmet_test_run/pycrate/lib/python3.9/site-packages/rasterio/__init__.py\", line 314, in open\n    dataset = writer(\n  File \"rasterio/_io.pyx\", line 1561, in rasterio._io.DatasetWriterBase.__init__\n  File \"rasterio/_io.pyx\", line 1590, in rasterio._io.DatasetWriterBase._set_crs\n  File \"rasterio/crs.pyx\", line 777, in rasterio.crs.CRS.from_user_input\nrasterio.errors.CRSError: The WKT could not be parsed. OGR Error code 6\n",
  "history_begin_time" : 1691866210622,
  "history_end_time" : 1691866214537,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Failed"
},{
  "history_id" : "kb0zYja6C40b",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nimport netCDF4 as nc\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport pyproj\nimport uuid\nfrom snowcast_utils import day_index\nfrom matplotlib.colors import LinearSegmentedColormap\n\nreference_date = datetime(1900, 1, 1)\n# day_value = convert_date_from_1900(test_start_date)\nresult_date = reference_date + timedelta(days=day_index)\ncurrent_datetime = result_date.strftime(\"%Y-%m-%d\")\n# current_datetime = datetime.now()\ntimestamp_string = current_datetime\n\ndef create_custom_colormap():\n    # Define the colors for the custom colormap\n    colors = ['white', *plt.cm.Blues(np.linspace(0, 1, 255))]\n\n    # Create a colormap using LinearSegmentedColormap\n    cmap = LinearSegmentedColormap.from_list('custom_cmap', colors)\n\n    return cmap\n\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\ndef convert_csvs_to_images():\n    # Load the CSV data into a DataFrame\n    data = pd.read_csv('/home/chetana/gridmet_test_run/test_data_prediected.csv')\n    data.loc[data['AMSR_SWE'] == 0, 'predicted_swe'] = 0\n\n    # Define the map boundaries for the Western US\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    # Create the Basemap instance\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    # Convert lon/lat to map coordinates\n    x, y = m(data['lon'].values, data['lat'].values)\n\n    # Plot the data using vibrant colors based on predicted_swe\n    custom_cmap = create_custom_colormap()\n    vmin, vmax = 0, 50\n    plt.scatter(x, y, c=data['predicted_swe'], cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7, vmin=vmin, vmax=vmax)\n\n    # Add colorbar for reference\n    cbar = plt.colorbar()\n    cbar.set_label('Predicted SWE')\n\n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    #reference_nc_file = nc.Dataset('/home/chetana/gridmet_test_run/gridmet_climatology/etr_2023.nc')\n\n    reference_date = datetime(1900, 1, 1)\n    #day = reference_nc_file.variables['day'][:]\n    #day_value = day[-1]\n    day_value = day_index\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    \n\n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15)\n    # Show the plot or save it to a file\n    plt.savefig(f'/home/chetana/gridmet_test_run/predicted_swe-{timestamp_string}-{uuid.uuid4().hex}.png')\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "today date = 2023-08-11\n/home/chetana\n",
  "history_begin_time" : 1691797699834,
  "history_end_time" : 1691797708194,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "IvQcKJsBLhpZ",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nimport netCDF4 as nc\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport pyproj\nimport uuid\nfrom snowcast_utils import day_index\nfrom matplotlib.colors import LinearSegmentedColormap\n\nreference_date = datetime(1900, 1, 1)\n# day_value = convert_date_from_1900(test_start_date)\nresult_date = reference_date + timedelta(days=day_index)\ncurrent_datetime = result_date.strftime(\"%Y-%m-%d\")\n# current_datetime = datetime.now()\ntimestamp_string = current_datetime\n\ndef create_custom_colormap():\n    # Define the colors for the custom colormap\n    colors = ['white', *plt.cm.Blues(np.linspace(0, 1, 255))]\n\n    # Create a colormap using LinearSegmentedColormap\n    cmap = LinearSegmentedColormap.from_list('custom_cmap', colors)\n\n    return cmap\n\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\ndef convert_csvs_to_images():\n    # Load the CSV data into a DataFrame\n    data = pd.read_csv('/home/chetana/gridmet_test_run/test_data_prediected.csv')\n    data.loc[data['AMSR_SWE'] == 0, 'predicted_swe'] = 0\n\n    # Define the map boundaries for the Western US\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    # Create the Basemap instance\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    # Convert lon/lat to map coordinates\n    x, y = m(data['lon'].values, data['lat'].values)\n\n    # Plot the data using vibrant colors based on predicted_swe\n    custom_cmap = create_custom_colormap()\n    plt.scatter(x, y, c=data['predicted_swe'], cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\n\n    # Add colorbar for reference\n    cbar = plt.colorbar()\n    cbar.set_label('Predicted SWE')\n\n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    #reference_nc_file = nc.Dataset('/home/chetana/gridmet_test_run/gridmet_climatology/etr_2023.nc')\n\n    reference_date = datetime(1900, 1, 1)\n    #day = reference_nc_file.variables['day'][:]\n    #day_value = day[-1]\n    day_value = day_index\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    \n\n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15)\n    # Show the plot or save it to a file\n    plt.savefig(f'/home/chetana/gridmet_test_run/predicted_swe-{timestamp_string}-{uuid.uuid4().hex}.png')\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "today date = 2023-08-11\n/home/chetana\n",
  "history_begin_time" : 1691789884494,
  "history_end_time" : 1691789892742,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "pBFpUoAyu7Jp",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nimport netCDF4 as nc\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport pyproj\nimport uuid\nfrom snowcast_utils import day_index\n\nreference_date = datetime(1900, 1, 1)\n# day_value = convert_date_from_1900(test_start_date)\nresult_date = reference_date + timedelta(days=day_index)\ncurrent_datetime = result_date.strftime(\"%Y-%m-%d\")\n# current_datetime = datetime.now()\ntimestamp_string = current_datetime\n\ndef create_custom_colormap():\n    # Define the colors for the custom colormap\n    colors = ['white', *plt.cm.Blues(np.linspace(0, 1, 255))]\n\n    # Create a colormap using LinearSegmentedColormap\n    cmap = LinearSegmentedColormap.from_list('custom_cmap', colors)\n\n    return cmap\n\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\ndef convert_csvs_to_images():\n    # Load the CSV data into a DataFrame\n    data = pd.read_csv('/home/chetana/gridmet_test_run/test_data_prediected.csv')\n    data.loc[data['AMSR_SWE'] == 0, 'predicted_swe'] = 0\n\n    # Define the map boundaries for the Western US\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    # Create the Basemap instance\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    # Convert lon/lat to map coordinates\n    x, y = m(data['lon'].values, data['lat'].values)\n\n    # Plot the data using vibrant colors based on predicted_swe\n    custom_cmap = create_custom_colormap()\n    plt.scatter(x, y, c=data['predicted_swe'], cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\n\n    # Add colorbar for reference\n    cbar = plt.colorbar()\n    cbar.set_label('Predicted SWE')\n\n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    #reference_nc_file = nc.Dataset('/home/chetana/gridmet_test_run/gridmet_climatology/etr_2023.nc')\n\n    reference_date = datetime(1900, 1, 1)\n    #day = reference_nc_file.variables['day'][:]\n    #day_value = day[-1]\n    day_value = day_index\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    \n\n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15)\n    # Show the plot or save it to a file\n    plt.savefig(f'/home/chetana/gridmet_test_run/predicted_swe-{timestamp_string}-{uuid.uuid4().hex}.png')\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "today date = 2023-08-11\n/home/chetana\nTraceback (most recent call last):\n  File \"/home/chetana/gw-workspace/pBFpUoAyu7Jp/convert_results_to_images.py\", line 107, in <module>\n    convert_csvs_to_images()\n  File \"/home/chetana/gw-workspace/pBFpUoAyu7Jp/convert_results_to_images.py\", line 48, in convert_csvs_to_images\n    custom_cmap = create_custom_colormap()\n  File \"/home/chetana/gw-workspace/pBFpUoAyu7Jp/convert_results_to_images.py\", line 23, in create_custom_colormap\n    cmap = LinearSegmentedColormap.from_list('custom_cmap', colors)\nNameError: name 'LinearSegmentedColormap' is not defined\n",
  "history_begin_time" : 1691789863635,
  "history_end_time" : 1691789868528,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "kxVjXObWMD11",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nimport netCDF4 as nc\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport pyproj\nimport uuid\nfrom snowcast_utils import day_index\n\nreference_date = datetime(1900, 1, 1)\n# day_value = convert_date_from_1900(test_start_date)\nresult_date = reference_date + timedelta(days=day_index)\ncurrent_datetime = result_date.strftime(\"%Y-%m-%d\")\n# current_datetime = datetime.now()\ntimestamp_string = current_datetime\n\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\ndef convert_csvs_to_images():\n    # Load the CSV data into a DataFrame\n    data = pd.read_csv('/home/chetana/gridmet_test_run/test_data_prediected.csv')\n    data.loc[data['AMSR_SWE'] == 0, 'predicted_swe'] = 0\n\n    # Define the map boundaries for the Western US\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    # Create the Basemap instance\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    # Convert lon/lat to map coordinates\n    x, y = m(data['lon'].values, data['lat'].values)\n\n    # Plot the data using vibrant colors based on predicted_swe\n    cmap_colors = ['white'] + plt.cm.Blues(np.linspace(0, 1, 255))\n    custom_cmap = ListedColormap(cmap_colors)\n    plt.scatter(x, y, c=data['predicted_swe'], cmap=custom_cmap, s=30, edgecolors='none', alpha=0.7)\n\n    # Add colorbar for reference\n    cbar = plt.colorbar()\n    cbar.set_label('Predicted SWE')\n\n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    #reference_nc_file = nc.Dataset('/home/chetana/gridmet_test_run/gridmet_climatology/etr_2023.nc')\n\n    reference_date = datetime(1900, 1, 1)\n    #day = reference_nc_file.variables['day'][:]\n    #day_value = day[-1]\n    day_value = day_index\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    \n\n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15)\n    # Show the plot or save it to a file\n    plt.savefig(f'/home/chetana/gridmet_test_run/predicted_swe-{timestamp_string}-{uuid.uuid4().hex}.png')\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "today date = 2023-08-11\n/home/chetana\nTraceback (most recent call last):\n  File \"/home/chetana/gw-workspace/kxVjXObWMD11/convert_results_to_images.py\", line 99, in <module>\n    convert_csvs_to_images()\n  File \"/home/chetana/gw-workspace/kxVjXObWMD11/convert_results_to_images.py\", line 39, in convert_csvs_to_images\n    cmap_colors = ['white'] + plt.cm.Blues(np.linspace(0, 1, 255))\nnumpy.core._exceptions._UFuncNoLoopError: ufunc 'add' did not contain a loop with signature matching types (dtype('<U5'), dtype('float64')) -> None\n",
  "history_begin_time" : 1691789806869,
  "history_end_time" : 1691789811666,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "53gcEY1x0tFj",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nimport netCDF4 as nc\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport pyproj\nimport uuid\nfrom snowcast_utils import day_index\n\nreference_date = datetime(1900, 1, 1)\n# day_value = convert_date_from_1900(test_start_date)\nresult_date = reference_date + timedelta(days=day_index)\ncurrent_datetime = result_date.strftime(\"%Y-%m-%d\")\n# current_datetime = datetime.now()\ntimestamp_string = current_datetime\n\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\ndef convert_csvs_to_images():\n    # Load the CSV data into a DataFrame\n    data = pd.read_csv('/home/chetana/gridmet_test_run/test_data_prediected.csv')\n    data.loc[data['AMSR_SWE'] == 0, 'predicted_swe'] = 0\n\n    # Define the map boundaries for the Western US\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    # Create the Basemap instance\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    # Convert lon/lat to map coordinates\n    x, y = m(data['lon'].values, data['lat'].values)\n\n    # Plot the data using vibrant colors based on predicted_swe\n    colors = np.where(data['predicted_swe'] == 0, 'white', plt.cm.Blues(data['predicted_swe'] / data['predicted_swe'].max()))\n\n    plt.scatter(x, y, c=colors, s=30, edgecolors='none', alpha=0.7)\n\n    # Add colorbar for reference\n    cbar = plt.colorbar()\n    cbar.set_label('Predicted SWE')\n\n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    #reference_nc_file = nc.Dataset('/home/chetana/gridmet_test_run/gridmet_climatology/etr_2023.nc')\n\n    reference_date = datetime(1900, 1, 1)\n    #day = reference_nc_file.variables['day'][:]\n    #day_value = day[-1]\n    day_value = day_index\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    \n\n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15)\n    # Show the plot or save it to a file\n    plt.savefig(f'/home/chetana/gridmet_test_run/predicted_swe-{timestamp_string}-{uuid.uuid4().hex}.png')\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "today date = 2023-08-11\n/home/chetana\nTraceback (most recent call last):\n  File \"/home/chetana/gw-workspace/53gcEY1x0tFj/convert_results_to_images.py\", line 99, in <module>\n    convert_csvs_to_images()\n  File \"/home/chetana/gw-workspace/53gcEY1x0tFj/convert_results_to_images.py\", line 39, in convert_csvs_to_images\n    colors = np.where(data['predicted_swe'] == 0, 'white', plt.cm.Blues(data['predicted_swe'] / data['predicted_swe'].max()))\n  File \"<__array_function__ internals>\", line 180, in where\nValueError: operands could not be broadcast together with shapes (310570,) () (310570,4) \n",
  "history_begin_time" : 1691789616830,
  "history_end_time" : 1691789623001,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "7jczqfDFM4Ju",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nimport netCDF4 as nc\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport pyproj\nimport uuid\nfrom snowcast_utils import day_index\n\nreference_date = datetime(1900, 1, 1)\n# day_value = convert_date_from_1900(test_start_date)\nresult_date = reference_date + timedelta(days=day_index)\ncurrent_datetime = result_date.strftime(\"%Y-%m-%d\")\n# current_datetime = datetime.now()\ntimestamp_string = current_datetime\n\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\ndef convert_csvs_to_images():\n    # Load the CSV data into a DataFrame\n    data = pd.read_csv('/home/chetana/gridmet_test_run/test_data_prediected.csv')\n    data.loc[data['AMSR_SWE'] == 0, 'predicted_swe'] = 0\n\n    # Define the map boundaries for the Western US\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    # Create the Basemap instance\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    # Convert lon/lat to map coordinates\n    x, y = m(data['lon'].values, data['lat'].values)\n\n    # Plot the data using vibrant colors based on predicted_swe\n    plt.scatter(x, y, c=data['predicted_swe'], cmap='coolwarm', s=30, edgecolors='none', alpha=0.7)\n\n    # Add colorbar for reference\n    cbar = plt.colorbar()\n    cbar.set_label('Predicted SWE')\n\n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    #reference_nc_file = nc.Dataset('/home/chetana/gridmet_test_run/gridmet_climatology/etr_2023.nc')\n\n    reference_date = datetime(1900, 1, 1)\n    #day = reference_nc_file.variables['day'][:]\n    #day_value = day[-1]\n    day_value = day_index\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    \n\n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15)\n    # Show the plot or save it to a file\n    plt.savefig(f'/home/chetana/gridmet_test_run/predicted_swe-{timestamp_string}-{uuid.uuid4().hex}.png')\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "today date = 2023-08-11\n/home/chetana\n",
  "history_begin_time" : 1691776340824,
  "history_end_time" : 1691776348871,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "vmcKfUDkZ6ix",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nimport netCDF4 as nc\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport pyproj\nimport uuid\nfrom snowcast_utils import day_index\n\nreference_date = datetime(1900, 1, 1)\n# day_value = convert_date_from_1900(test_start_date)\nresult_date = reference_date + timedelta(days=day_index)\ncurrent_datetime = result_date.strftime(\"%Y-%m-%d\")\n# current_datetime = datetime.now()\ntimestamp_string = current_datetime\n\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\ndef convert_csvs_to_images():\n    # Load the CSV data into a DataFrame\n    data = pd.read_csv('/home/chetana/gridmet_test_run/test_data_prediected.csv')\n    data.loc[df['AMSR_SWE'] == 0, 'predicted_swe'] = 0\n\n    # Define the map boundaries for the Western US\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    # Create the Basemap instance\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    # Convert lon/lat to map coordinates\n    x, y = m(data['lon'].values, data['lat'].values)\n\n    # Plot the data using vibrant colors based on predicted_swe\n    plt.scatter(x, y, c=data['predicted_swe'], cmap='coolwarm', s=30, edgecolors='none', alpha=0.7)\n\n    # Add colorbar for reference\n    cbar = plt.colorbar()\n    cbar.set_label('Predicted SWE')\n\n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    #reference_nc_file = nc.Dataset('/home/chetana/gridmet_test_run/gridmet_climatology/etr_2023.nc')\n\n    reference_date = datetime(1900, 1, 1)\n    #day = reference_nc_file.variables['day'][:]\n    #day_value = day[-1]\n    day_value = day_index\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    \n\n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15)\n    # Show the plot or save it to a file\n    plt.savefig(f'/home/chetana/gridmet_test_run/predicted_swe-{timestamp_string}-{uuid.uuid4().hex}.png')\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "today date = 2023-08-11\n/home/chetana\nTraceback (most recent call last):\n  File \"/home/chetana/gw-workspace/vmcKfUDkZ6ix/convert_results_to_images.py\", line 97, in <module>\n    convert_csvs_to_images()\n  File \"/home/chetana/gw-workspace/vmcKfUDkZ6ix/convert_results_to_images.py\", line 25, in convert_csvs_to_images\n    data.loc[df['AMSR_SWE'] == 0, 'predicted_swe'] = 0\nNameError: name 'df' is not defined\n",
  "history_begin_time" : 1691776247530,
  "history_end_time" : 1691776250227,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "oBniq9JrNnZK",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nimport netCDF4 as nc\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport pyproj\nimport uuid\nfrom snowcast_utils import day_index\n\nreference_date = datetime(1900, 1, 1)\n# day_value = convert_date_from_1900(test_start_date)\nresult_date = reference_date + timedelta(days=day_index)\ncurrent_datetime = result_date.strftime(\"%Y-%m-%d\")\n# current_datetime = datetime.now()\ntimestamp_string = current_datetime\n\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\ndef convert_csvs_to_images():\n    # Load the CSV data into a DataFrame\n    data = pd.read_csv('/home/chetana/gridmet_test_run/test_data_prediected.csv')\n\n    # Define the map boundaries for the Western US\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    # Create the Basemap instance\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    # Convert lon/lat to map coordinates\n    x, y = m(data['lon'].values, data['lat'].values)\n\n    # Plot the data using vibrant colors based on predicted_swe\n    plt.scatter(x, y, c=data['predicted_swe'], cmap='coolwarm', s=30, edgecolors='none', alpha=0.7)\n\n    # Add colorbar for reference\n    cbar = plt.colorbar()\n    cbar.set_label('Predicted SWE')\n\n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    #reference_nc_file = nc.Dataset('/home/chetana/gridmet_test_run/gridmet_climatology/etr_2023.nc')\n\n    reference_date = datetime(1900, 1, 1)\n    #day = reference_nc_file.variables['day'][:]\n    #day_value = day[-1]\n    day_value = day_index\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    \n\n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15)\n    # Show the plot or save it to a file\n    plt.savefig(f'/home/chetana/gridmet_test_run/predicted_swe-{timestamp_string}-{uuid.uuid4().hex}.png')\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "today date = 2023-08-11\n/home/chetana\n",
  "history_begin_time" : 1691774579291,
  "history_end_time" : 1691774588217,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "HCohGk4JptCy",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nimport netCDF4 as nc\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport pyproj\nimport uuid\nfrom snowcast_utils import day_index\n\nreference_date = datetime(1900, 1, 1)\n# day_value = convert_date_from_1900(test_start_date)\nresult_date = reference_date + timedelta(days=day_index)\ncurrent_datetime = result_date.strftime(\"%Y-%m-%d\")\n# current_datetime = datetime.now()\ntimestamp_string = current_datetime\n\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\ndef convert_csvs_to_images():\n    # Load the CSV data into a DataFrame\n    data = pd.read_csv('/home/chetana/gridmet_test_run/test_data_prediected.csv')\n\n    # Define the map boundaries for the Western US\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    # Create the Basemap instance\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    # Convert lon/lat to map coordinates\n    x, y = m(data['lon'].values, data['lat'].values)\n\n    # Plot the data using vibrant colors based on predicted_swe\n    plt.scatter(x, y, c=data['predicted_swe'], cmap='coolwarm', s=30, edgecolors='none', alpha=0.7)\n\n    # Add colorbar for reference\n    cbar = plt.colorbar()\n    cbar.set_label('Predicted SWE')\n\n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_nc_file = nc.Dataset('/home/chetana/gridmet_test_run/gridmet_climatology/etr_2023.nc')\n\n    reference_date = datetime(1900, 1, 1)\n    day = reference_nc_file.variables['day'][:]\n    day_value = day[-1]\n    day_value = day_index\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    \n\n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15)\n    # Show the plot or save it to a file\n    plt.savefig(f'/home/chetana/gridmet_test_run/predicted_swe-{timestamp_string}-{uuid.uuid4().hex}.png')\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "today date = 2023-08-11\n/home/chetana\nTraceback (most recent call last):\n  File \"/home/chetana/gw-workspace/HCohGk4JptCy/convert_results_to_images.py\", line 96, in <module>\n    convert_csvs_to_images()\n  File \"/home/chetana/gw-workspace/HCohGk4JptCy/convert_results_to_images.py\", line 49, in convert_csvs_to_images\n    reference_nc_file = nc.Dataset('/home/chetana/gridmet_test_run/gridmet_climatology/etr_2023.nc')\n  File \"src/netCDF4/_netCDF4.pyx\", line 2464, in netCDF4._netCDF4.Dataset.__init__\n  File \"src/netCDF4/_netCDF4.pyx\", line 2027, in netCDF4._netCDF4._ensure_nc_success\nFileNotFoundError: [Errno 2] No such file or directory: '/home/chetana/gridmet_test_run/gridmet_climatology/etr_2023.nc'\n",
  "history_begin_time" : 1691774548112,
  "history_end_time" : 1691774553016,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "bc6aDS1LgTkg",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nimport netCDF4 as nc\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport pyproj\nimport uuid\nfrom snowcast_utils import day_index\n\nreference_date = datetime(1900, 1, 1)\n# day_value = convert_date_from_1900(test_start_date)\nresult_date = reference_date + timedelta(days=day_index)\ncurrent_datetime = result_date.strftime(\"%Y-%m-%d\")\n# current_datetime = datetime.now()\ntimestamp_string = current_datetime\n\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\ndef convert_csvs_to_images():\n    # Load the CSV data into a DataFrame\n    data = pd.read_csv('/home/chetana/gridmet_test_run/test_data_prediected.csv')\n\n    # Define the map boundaries for the Western US\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    # Create the Basemap instance\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    # Convert lon/lat to map coordinates\n    x, y = m(data['lon'].values, data['lat'].values)\n\n    # Plot the data using vibrant colors based on predicted_swe\n    plt.scatter(x, y, c=data['predicted_swe'], cmap='coolwarm', s=30, edgecolors='none', alpha=0.7)\n\n    # Add colorbar for reference\n    cbar = plt.colorbar()\n    cbar.set_label('Predicted SWE')\n\n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_nc_file = nc.Dataset('/home/chetana/gridmet_test_run/gridmet_climatology/etr_2023.nc')\n\n    reference_date = datetime(1900, 1, 1)\n    day = reference_nc_file.variables['day'][:]\n    day_value = day[-1]\n    day_value = day_index\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    \n\n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15)\n    # Show the plot or save it to a file\n    plt.savefig(f'/home/chetana/gridmet_test_run/predicted_swe-{timestamp_string}-{uuid.uuid4().hex}.png')\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "today date = 2023-08-11\n/home/chetana\nTraceback (most recent call last):\n  File \"/home/chetana/gw-workspace/bc6aDS1LgTkg/convert_results_to_images.py\", line 96, in <module>\n    convert_csvs_to_images()\n  File \"/home/chetana/gw-workspace/bc6aDS1LgTkg/convert_results_to_images.py\", line 49, in convert_csvs_to_images\n    reference_nc_file = nc.Dataset('/home/chetana/gridmet_test_run/gridmet_climatology/etr_2023.nc')\n  File \"src/netCDF4/_netCDF4.pyx\", line 2464, in netCDF4._netCDF4.Dataset.__init__\n  File \"src/netCDF4/_netCDF4.pyx\", line 2027, in netCDF4._netCDF4._ensure_nc_success\nFileNotFoundError: [Errno 2] No such file or directory: '/home/chetana/gridmet_test_run/gridmet_climatology/etr_2023.nc'\n",
  "history_begin_time" : 1691774480058,
  "history_end_time" : 1691774485958,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "WvUL3HpfS2vE",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nimport netCDF4 as nc\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport pyproj\nimport uuid\nfrom snowcast_utils import day_index\n\nreference_date = datetime(1900, 1, 1)\nday_value = convert_date_from_1900(test_start_date)\nresult_date = reference_date + timedelta(days=day_index)\ncurrent_datetime = result_date.strftime(\"%Y-%m-%d\")\n# current_datetime = datetime.now()\ntimestamp_string = current_datetime\n\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\ndef convert_csvs_to_images():\n    # Load the CSV data into a DataFrame\n    data = pd.read_csv('/home/chetana/gridmet_test_run/test_data_prediected.csv')\n\n    # Define the map boundaries for the Western US\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    # Create the Basemap instance\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    # Convert lon/lat to map coordinates\n    x, y = m(data['lon'].values, data['lat'].values)\n\n    # Plot the data using vibrant colors based on predicted_swe\n    plt.scatter(x, y, c=data['predicted_swe'], cmap='coolwarm', s=30, edgecolors='none', alpha=0.7)\n\n    # Add colorbar for reference\n    cbar = plt.colorbar()\n    cbar.set_label('Predicted SWE')\n\n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_nc_file = nc.Dataset('/home/chetana/gridmet_test_run/gridmet_climatology/etr_2023.nc')\n\n    reference_date = datetime(1900, 1, 1)\n    day = reference_nc_file.variables['day'][:]\n    day_value = day[-1]\n    day_value = day_index\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    \n\n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15)\n    # Show the plot or save it to a file\n    plt.savefig(f'/home/chetana/gridmet_test_run/predicted_swe-{timestamp_string}-{uuid.uuid4().hex}.png')\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "today date = 2023-08-11\n/home/chetana\nTraceback (most recent call last):\n  File \"/home/chetana/gw-workspace/WvUL3HpfS2vE/convert_results_to_images.py\", line 12, in <module>\n    day_value = convert_date_from_1900(test_start_date)\nNameError: name 'convert_date_from_1900' is not defined\n",
  "history_begin_time" : 1691774387639,
  "history_end_time" : 1691774389592,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "QLcTg2OiIr6s",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nimport netCDF4 as nc\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport pyproj\nimport uuid\nfrom snowcast_utils import day_index\n\nreference_date = datetime(1900, 1, 1)\nday_value = convert_date_from_1900(test_start_date)\nresult_date = reference_date + timedelta(days=day_index)\ncurrent_datetime = result_date.strftime(\"%Y-%m-%d\")\n# current_datetime = datetime.now()\ntimestamp_string = current_datetime\n\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\ndef convert_csvs_to_images():\n    # Load the CSV data into a DataFrame\n    data = pd.read_csv('/home/chetana/gridmet_test_run/test_data_prediected.csv')\n\n    # Define the map boundaries for the Western US\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    # Create the Basemap instance\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    # Convert lon/lat to map coordinates\n    x, y = m(data['lon'].values, data['lat'].values)\n\n    # Plot the data using vibrant colors based on predicted_swe\n    plt.scatter(x, y, c=data['predicted_swe'], cmap='coolwarm', s=30, edgecolors='none', alpha=0.7)\n\n    # Add colorbar for reference\n    cbar = plt.colorbar()\n    cbar.set_label('Predicted SWE')\n\n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_nc_file = nc.Dataset('/home/chetana/gridmet_test_run/gridmet_climatology/etr_2023.nc')\n\n    reference_date = datetime(1900, 1, 1)\n    day = reference_nc_file.variables['day'][:]\n    day_value = day[-1]\n    day_value = convert_date_from_1900(test_start_date)\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    \n\n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15)\n    # Show the plot or save it to a file\n    plt.savefig(f'/home/chetana/gridmet_test_run/predicted_swe-{timestamp_string}-{uuid.uuid4().hex}.png')\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "today date = 2023-08-11\n/home/chetana\nTraceback (most recent call last):\n  File \"/home/chetana/gw-workspace/QLcTg2OiIr6s/convert_results_to_images.py\", line 12, in <module>\n    day_value = convert_date_from_1900(test_start_date)\nNameError: name 'convert_date_from_1900' is not defined\n",
  "history_begin_time" : 1691774295997,
  "history_end_time" : 1691774297878,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "UrGIZoPMyfYx",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nimport netCDF4 as nc\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport pyproj\nimport uuid\nfrom snowcast_utils import convert_date_from_1900, test_start_date\n\nreference_date = datetime(1900, 1, 1)\nday_value = convert_date_from_1900(test_start_date)\nresult_date = reference_date + timedelta(days=day_value)\ncurrent_datetime = result_date.strftime(\"%Y-%m-%d\")\n# current_datetime = datetime.now()\ntimestamp_string = current_datetime\n\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\ndef convert_csvs_to_images():\n    # Load the CSV data into a DataFrame\n    data = pd.read_csv('/home/chetana/gridmet_test_run/test_data_prediected.csv')\n\n    # Define the map boundaries for the Western US\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    # Create the Basemap instance\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    # Convert lon/lat to map coordinates\n    x, y = m(data['lon'].values, data['lat'].values)\n\n    # Plot the data using vibrant colors based on predicted_swe\n    plt.scatter(x, y, c=data['predicted_swe'], cmap='coolwarm', s=30, edgecolors='none', alpha=0.7)\n\n    # Add colorbar for reference\n    cbar = plt.colorbar()\n    cbar.set_label('Predicted SWE')\n\n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_nc_file = nc.Dataset('/home/chetana/gridmet_test_run/gridmet_climatology/etr_2023.nc')\n\n    reference_date = datetime(1900, 1, 1)\n    day = reference_nc_file.variables['day'][:]\n    day_value = day[-1]\n    day_value = convert_date_from_1900(test_start_date)\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    \n\n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15)\n    # Show the plot or save it to a file\n    plt.savefig(f'/home/chetana/gridmet_test_run/predicted_swe-{timestamp_string}-{uuid.uuid4().hex}.png')\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "today date = 2023-08-11\n/home/chetana\nTraceback (most recent call last):\n  File \"/home/chetana/gw-workspace/UrGIZoPMyfYx/convert_results_to_images.py\", line 12, in <module>\n    day_value = convert_date_from_1900(test_start_date)\n  File \"/home/chetana/gw-workspace/UrGIZoPMyfYx/snowcast_utils.py\", line 82, in convert_date_from_1900\n    result_date = reference_date + timedelta(days=day_value)\nTypeError: unsupported type for timedelta days component: str\n",
  "history_begin_time" : 1691774215934,
  "history_end_time" : 1691774217814,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "woz8Sp61SwKi",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nimport netCDF4 as nc\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport pyproj\nimport uuid\nfrom snowcast_utils import convert_date_from_1900, test_start_date\n\nreference_date = datetime(1900, 1, 1)\nday_value = convert_date_from_1900(test_start_date)\nresult_date = reference_date + timedelta(days=day_value)\ncurrent_datetime = result_date.strftime(\"%Y-%m-%d\")\n# current_datetime = datetime.now()\ntimestamp_string = current_datetime\n\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\ndef convert_csvs_to_images():\n    # Load the CSV data into a DataFrame\n    data = pd.read_csv('/home/chetana/gridmet_test_run/test_data_prediected.csv')\n\n    # Define the map boundaries for the Western US\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    # Create the Basemap instance\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    # Convert lon/lat to map coordinates\n    x, y = m(data['lon'].values, data['lat'].values)\n\n    # Plot the data using vibrant colors based on predicted_swe\n    plt.scatter(x, y, c=data['predicted_swe'], cmap='coolwarm', s=30, edgecolors='none', alpha=0.7)\n\n    # Add colorbar for reference\n    cbar = plt.colorbar()\n    cbar.set_label('Predicted SWE')\n\n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_nc_file = nc.Dataset('/home/chetana/gridmet_test_run/gridmet_climatology/etr_2023.nc')\n\n    reference_date = datetime(1900, 1, 1)\n    day = reference_nc_file.variables['day'][:]\n    day_value = day[-1]\n    day_value = convert_date_from_1900(test_start_date)\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    \n\n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15)\n    # Show the plot or save it to a file\n    plt.savefig(f'/home/chetana/gridmet_test_run/predicted_swe-{timestamp_string}-{uuid.uuid4().hex}.png')\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "today date = 2023-08-11\n/home/chetana\nTraceback (most recent call last):\n  File \"/home/chetana/gw-workspace/woz8Sp61SwKi/convert_results_to_images.py\", line 12, in <module>\n    day_value = convert_date_from_1900(test_start_date)\n  File \"/home/chetana/gw-workspace/woz8Sp61SwKi/snowcast_utils.py\", line 82, in convert_date_from_1900\n    result_date = reference_date + timedelta(days=day_value)\nNameError: name 'timedelta' is not defined\n",
  "history_begin_time" : 1691774188254,
  "history_end_time" : 1691774191031,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "U14a52riMitH",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nimport netCDF4 as nc\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport pyproj\nimport uuid\nfrom snowcast_utils import convert_date_from_1900, test_start_date\n\nreference_date = datetime(1900, 1, 1)\nday_value = convert_date_from_1900(test_start_date)\nresult_date = reference_date + timedelta(days=day_value)\ncurrent_datetime = result_date.strftime(\"%Y-%m-%d\")\n# current_datetime = datetime.now()\ntimestamp_string = current_datetime\n\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\ndef convert_csvs_to_images():\n    # Load the CSV data into a DataFrame\n    data = pd.read_csv('/home/chetana/gridmet_test_run/test_data_prediected.csv')\n\n    # Define the map boundaries for the Western US\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    # Create the Basemap instance\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    # Convert lon/lat to map coordinates\n    x, y = m(data['lon'].values, data['lat'].values)\n\n    # Plot the data using vibrant colors based on predicted_swe\n    plt.scatter(x, y, c=data['predicted_swe'], cmap='coolwarm', s=30, edgecolors='none', alpha=0.7)\n\n    # Add colorbar for reference\n    cbar = plt.colorbar()\n    cbar.set_label('Predicted SWE')\n\n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_nc_file = nc.Dataset('/home/chetana/gridmet_test_run/gridmet_climatology/etr_2023.nc')\n\n    reference_date = datetime(1900, 1, 1)\n    day = reference_nc_file.variables['day'][:]\n    day_value = day[-1]\n    \n\tday_value = convert_date_from_1900(test_start_date)\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    \n\n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15)\n    # Show the plot or save it to a file\n    plt.savefig(f'/home/chetana/gridmet_test_run/predicted_swe-{timestamp_string}-{uuid.uuid4().hex}.png')\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "  File \"/home/chetana/gw-workspace/U14a52riMitH/convert_results_to_images.py\", line 55\n    day_value = convert_date_from_1900(test_start_date)\nTabError: inconsistent use of tabs and spaces in indentation\n",
  "history_begin_time" : 1691774159086,
  "history_end_time" : 1691774160138,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "7j4d2p5na6j",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nimport netCDF4 as nc\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport pyproj\nimport uuid\nfrom snowcast_utils import convert_date_from_1900, test_start_date\n\nreference_date = datetime(1900, 1, 1)\nday_value = convert_date_from_1900(test_start_date)\nresult_date = reference_date + timedelta(days=day_value)\ncurrent_datetime = result_date.strftime(\"%Y-%m-%d\")\n# current_datetime = datetime.now()\ntimestamp_string = current_datetime\n\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\ndef convert_csvs_to_images():\n    # Load the CSV data into a DataFrame\n    data = pd.read_csv('/home/chetana/gridmet_test_run/test_data_prediected.csv')\n\n    # Define the map boundaries for the Western US\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    # Create the Basemap instance\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    # Convert lon/lat to map coordinates\n    x, y = m(data['lon'].values, data['lat'].values)\n\n    # Plot the data using vibrant colors based on predicted_swe\n    plt.scatter(x, y, c=data['predicted_swe'], cmap='coolwarm', s=30, edgecolors='none', alpha=0.7)\n\n    # Add colorbar for reference\n    cbar = plt.colorbar()\n    cbar.set_label('Predicted SWE')\n\n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_nc_file = nc.Dataset('/home/chetana/gridmet_test_run/gridmet_climatology/etr_2023.nc')\n\n    reference_date = datetime(1900, 1, 1)\n    day = reference_nc_file.variables['day'][:]\n    day_value = day[-1]\n    \n\tday_value = convert_date_from_1900(test_start_date)\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    \n\n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15)\n    # Show the plot or save it to a file\n    plt.savefig(f'/home/chetana/gridmet_test_run/predicted_swe-{timestamp_string}-{uuid.uuid4().hex}.png')\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "  File \"/home/chetana/gw-workspace/7j4d2p5na6j/convert_results_to_images.py\", line 55\n    day_value = convert_date_from_1900(test_start_date)\nTabError: inconsistent use of tabs and spaces in indentation\n",
  "history_begin_time" : 1691531388534,
  "history_end_time" : 1691531390606,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "tq3z35",
  "indicator" : "Failed"
},{
  "history_id" : "dg973doq1uf",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nimport netCDF4 as nc\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport pyproj\nimport uuid\nfrom snowcast_utils import convert_date_from_1900, test_start_date\n\nreference_date = datetime(1900, 1, 1)\nday_value = convert_date_from_1900(test_start_date)\nresult_date = reference_date + timedelta(days=day_value)\ncurrent_datetime = result_date.strftime(\"%Y-%m-%d\")\n# current_datetime = datetime.now()\ntimestamp_string = current_datetime\n\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\ndef convert_csvs_to_images():\n    # Load the CSV data into a DataFrame\n    data = pd.read_csv('/home/chetana/gridmet_test_run/test_data_prediected.csv')\n\n    # Define the map boundaries for the Western US\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    # Create the Basemap instance\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    # Convert lon/lat to map coordinates\n    x, y = m(data['lon'].values, data['lat'].values)\n\n    # Plot the data using vibrant colors based on predicted_swe\n    plt.scatter(x, y, c=data['predicted_swe'], cmap='coolwarm', s=30, edgecolors='none', alpha=0.7)\n\n    # Add colorbar for reference\n    cbar = plt.colorbar()\n    cbar.set_label('Predicted SWE')\n\n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_nc_file = nc.Dataset('/home/chetana/gridmet_test_run/gridmet_climatology/etr_2023.nc')\n\n    reference_date = datetime(1900, 1, 1)\n    day = reference_nc_file.variables['day'][:]\n    day_value = day[-1]\n    \n\tday_value = convert_date_from_1900(test_start_date)\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    \n\n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15)\n    # Show the plot or save it to a file\n    plt.savefig(f'/home/chetana/gridmet_test_run/predicted_swe-{timestamp_string}-{uuid.uuid4().hex}.png')\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "  File \"/home/chetana/gw-workspace/dg973doq1uf/convert_results_to_images.py\", line 55\n    day_value = convert_date_from_1900(test_start_date)\nTabError: inconsistent use of tabs and spaces in indentation\n",
  "history_begin_time" : 1691531315490,
  "history_end_time" : 1691531317637,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "tq3z35",
  "indicator" : "Failed"
},{
  "history_id" : "3dxlevivn7e",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nimport netCDF4 as nc\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport pyproj\nimport uuid\nfrom snowcast_utils import convert_date_from_1900, test_start_date\n\nreference_date = datetime(1900, 1, 1)\nday_value = convert_date_from_1900(test_start_date)\nresult_date = reference_date + timedelta(days=day_value)\ncurrent_datetime = result_date.strftime(\"%Y-%m-%d\")\n# current_datetime = datetime.now()\ntimestamp_string = current_datetime\n\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\ndef convert_csvs_to_images():\n    # Load the CSV data into a DataFrame\n    data = pd.read_csv('/home/chetana/gridmet_test_run/test_data_prediected.csv')\n\n    # Define the map boundaries for the Western US\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    # Create the Basemap instance\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    # Convert lon/lat to map coordinates\n    x, y = m(data['lon'].values, data['lat'].values)\n\n    # Plot the data using vibrant colors based on predicted_swe\n    plt.scatter(x, y, c=data['predicted_swe'], cmap='coolwarm', s=30, edgecolors='none', alpha=0.7)\n\n    # Add colorbar for reference\n    cbar = plt.colorbar()\n    cbar.set_label('Predicted SWE')\n\n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_nc_file = nc.Dataset('/home/chetana/gridmet_test_run/gridmet_climatology/etr_2023.nc')\n\n    reference_date = datetime(1900, 1, 1)\n    day = reference_nc_file.variables['day'][:]\n    day_value = day[-1]\n    \n\tday_value = convert_date_from_1900(test_start_date)\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    \n\n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15)\n    # Show the plot or save it to a file\n    plt.savefig(f'/home/chetana/gridmet_test_run/predicted_swe-{timestamp_string}-{uuid.uuid4().hex}.png')\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "  File \"/home/chetana/gw-workspace/3dxlevivn7e/convert_results_to_images.py\", line 55\n    day_value = convert_date_from_1900(test_start_date)\nTabError: inconsistent use of tabs and spaces in indentation\n",
  "history_begin_time" : 1691531219937,
  "history_end_time" : 1691531222036,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "tq3z35",
  "indicator" : "Failed"
},{
  "history_id" : "hhp9aogv46a",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nimport netCDF4 as nc\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport pyproj\nimport uuid\nfrom snowcast_utils import convert_date_from_1900, test_start_date\n\nreference_date = datetime(1900, 1, 1)\nday_value = convert_date_from_1900(test_start_date)\nresult_date = reference_date + timedelta(days=day_value)\ncurrent_datetime = result_date.strftime(\"%Y-%m-%d\")\n# current_datetime = datetime.now()\ntimestamp_string = current_datetime\n\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\ndef convert_csvs_to_images():\n    # Load the CSV data into a DataFrame\n    data = pd.read_csv('/home/chetana/gridmet_test_run/test_data_prediected.csv')\n\n    # Define the map boundaries for the Western US\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    # Create the Basemap instance\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    # Convert lon/lat to map coordinates\n    x, y = m(data['lon'].values, data['lat'].values)\n\n    # Plot the data using vibrant colors based on predicted_swe\n    plt.scatter(x, y, c=data['predicted_swe'], cmap='coolwarm', s=30, edgecolors='none', alpha=0.7)\n\n    # Add colorbar for reference\n    cbar = plt.colorbar()\n    cbar.set_label('Predicted SWE')\n\n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_nc_file = nc.Dataset('/home/chetana/gridmet_test_run/gridmet_climatology/etr_2023.nc')\n\n    reference_date = datetime(1900, 1, 1)\n    day = reference_nc_file.variables['day'][:]\n    day_value = day[-1]\n    \n\tday_value = convert_date_from_1900(test_start_date)\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    \n\n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15)\n    # Show the plot or save it to a file\n    plt.savefig(f'/home/chetana/gridmet_test_run/predicted_swe-{timestamp_string}-{uuid.uuid4().hex}.png')\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "  File \"/home/chetana/gw-workspace/hhp9aogv46a/convert_results_to_images.py\", line 55\n    day_value = convert_date_from_1900(test_start_date)\nTabError: inconsistent use of tabs and spaces in indentation\n",
  "history_begin_time" : 1691531145586,
  "history_end_time" : 1691531147709,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "tq3z35",
  "indicator" : "Failed"
},{
  "history_id" : "4tmwsw5ydrk",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nimport netCDF4 as nc\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport pyproj\nimport uuid\nfrom snowcast_utils import convert_date_from_1900, test_start_date\n\nreference_date = datetime(1900, 1, 1)\nday_value = convert_date_from_1900(test_start_date)\nresult_date = reference_date + timedelta(days=day_value)\ncurrent_datetime = result_date.strftime(\"%Y-%m-%d\")\n# current_datetime = datetime.now()\ntimestamp_string = current_datetime\n\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\ndef convert_csvs_to_images():\n    # Load the CSV data into a DataFrame\n    data = pd.read_csv('/home/chetana/gridmet_test_run/test_data_prediected.csv')\n\n    # Define the map boundaries for the Western US\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    # Create the Basemap instance\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    # Convert lon/lat to map coordinates\n    x, y = m(data['lon'].values, data['lat'].values)\n\n    # Plot the data using vibrant colors based on predicted_swe\n    plt.scatter(x, y, c=data['predicted_swe'], cmap='coolwarm', s=30, edgecolors='none', alpha=0.7)\n\n    # Add colorbar for reference\n    cbar = plt.colorbar()\n    cbar.set_label('Predicted SWE')\n\n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_nc_file = nc.Dataset('/home/chetana/gridmet_test_run/gridmet_climatology/etr_2023.nc')\n\n    reference_date = datetime(1900, 1, 1)\n    day = reference_nc_file.variables['day'][:]\n    day_value = day[-1]\n    \n\tday_value = convert_date_from_1900(test_start_date)\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    \n\n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15)\n    # Show the plot or save it to a file\n    plt.savefig(f'/home/chetana/gridmet_test_run/predicted_swe-{timestamp_string}-{uuid.uuid4().hex}.png')\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "  File \"/home/chetana/gw-workspace/4tmwsw5ydrk/convert_results_to_images.py\", line 55\n    day_value = convert_date_from_1900(test_start_date)\nTabError: inconsistent use of tabs and spaces in indentation\n",
  "history_begin_time" : 1691531087379,
  "history_end_time" : 1691531089489,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "tq3z35",
  "indicator" : "Failed"
},{
  "history_id" : "tgyimcu0112",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nimport netCDF4 as nc\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport pyproj\nimport uuid\nfrom snowcast_utils import convert_date_from_1900, test_start_date\n\nreference_date = datetime(1900, 1, 1)\nday_value = convert_date_from_1900(test_start_date)\nresult_date = reference_date + timedelta(days=day_value)\ncurrent_datetime = result_date.strftime(\"%Y-%m-%d\")\n# current_datetime = datetime.now()\ntimestamp_string = current_datetime\n\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\ndef convert_csvs_to_images():\n    # Load the CSV data into a DataFrame\n    data = pd.read_csv('/home/chetana/gridmet_test_run/test_data_prediected.csv')\n\n    # Define the map boundaries for the Western US\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    # Create the Basemap instance\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    # Convert lon/lat to map coordinates\n    x, y = m(data['lon'].values, data['lat'].values)\n\n    # Plot the data using vibrant colors based on predicted_swe\n    plt.scatter(x, y, c=data['predicted_swe'], cmap='coolwarm', s=30, edgecolors='none', alpha=0.7)\n\n    # Add colorbar for reference\n    cbar = plt.colorbar()\n    cbar.set_label('Predicted SWE')\n\n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_nc_file = nc.Dataset('/home/chetana/gridmet_test_run/gridmet_climatology/etr_2023.nc')\n\n    reference_date = datetime(1900, 1, 1)\n    day = reference_nc_file.variables['day'][:]\n    day_value = day[-1]\n    \n\tday_value = convert_date_from_1900(test_start_date)\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    \n\n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15)\n    # Show the plot or save it to a file\n    plt.savefig(f'/home/chetana/gridmet_test_run/predicted_swe-{timestamp_string}-{uuid.uuid4().hex}.png')\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "  File \"/home/chetana/gw-workspace/tgyimcu0112/convert_results_to_images.py\", line 55\n    day_value = convert_date_from_1900(test_start_date)\nTabError: inconsistent use of tabs and spaces in indentation\n",
  "history_begin_time" : 1691530870295,
  "history_end_time" : 1691530872485,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "tq3z35",
  "indicator" : "Failed"
},{
  "history_id" : "as68mtywn1m",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nimport netCDF4 as nc\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport pyproj\nimport uuid\nfrom snowcast_utils import convert_date_from_1900, test_start_date\n\nreference_date = datetime(1900, 1, 1)\nday_value = convert_date_from_1900(test_start_date)\nresult_date = reference_date + timedelta(days=day_value)\ncurrent_datetime = result_date.strftime(\"%Y-%m-%d\")\n# current_datetime = datetime.now()\ntimestamp_string = current_datetime\n\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\ndef convert_csvs_to_images():\n    # Load the CSV data into a DataFrame\n    data = pd.read_csv('/home/chetana/gridmet_test_run/test_data_prediected.csv')\n\n    # Define the map boundaries for the Western US\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    # Create the Basemap instance\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    # Convert lon/lat to map coordinates\n    x, y = m(data['lon'].values, data['lat'].values)\n\n    # Plot the data using vibrant colors based on predicted_swe\n    plt.scatter(x, y, c=data['predicted_swe'], cmap='coolwarm', s=30, edgecolors='none', alpha=0.7)\n\n    # Add colorbar for reference\n    cbar = plt.colorbar()\n    cbar.set_label('Predicted SWE')\n\n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_nc_file = nc.Dataset('/home/chetana/gridmet_test_run/gridmet_climatology/etr_2023.nc')\n\n    reference_date = datetime(1900, 1, 1)\n    day = reference_nc_file.variables['day'][:]\n    day_value = day[-1]\n    \n\tday_value = convert_date_from_1900(test_start_date)\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    \n\n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15)\n    # Show the plot or save it to a file\n    plt.savefig(f'/home/chetana/gridmet_test_run/predicted_swe-{timestamp_string}-{uuid.uuid4().hex}.png')\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "  File \"/home/chetana/gw-workspace/as68mtywn1m/convert_results_to_images.py\", line 55\n    day_value = convert_date_from_1900(test_start_date)\nTabError: inconsistent use of tabs and spaces in indentation\n",
  "history_begin_time" : 1691530714040,
  "history_end_time" : 1691530716750,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "tq3z35",
  "indicator" : "Stopped"
},{
  "history_id" : "lq9r1uao1un",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nimport netCDF4 as nc\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport pyproj\nimport uuid\nfrom snowcast_utils import convert_date_from_1900, test_start_date\n\nreference_date = datetime(1900, 1, 1)\nday_value = convert_date_from_1900(test_start_date)\nresult_date = reference_date + timedelta(days=day_value)\ncurrent_datetime = result_date.strftime(\"%Y-%m-%d\")\n# current_datetime = datetime.now()\ntimestamp_string = current_datetime\n\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\ndef convert_csvs_to_images():\n    # Load the CSV data into a DataFrame\n    data = pd.read_csv('/home/chetana/gridmet_test_run/test_data_prediected.csv')\n\n    # Define the map boundaries for the Western US\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    # Create the Basemap instance\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    # Convert lon/lat to map coordinates\n    x, y = m(data['lon'].values, data['lat'].values)\n\n    # Plot the data using vibrant colors based on predicted_swe\n    plt.scatter(x, y, c=data['predicted_swe'], cmap='coolwarm', s=30, edgecolors='none', alpha=0.7)\n\n    # Add colorbar for reference\n    cbar = plt.colorbar()\n    cbar.set_label('Predicted SWE')\n\n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_nc_file = nc.Dataset('/home/chetana/gridmet_test_run/gridmet_climatology/etr_2023.nc')\n\n    reference_date = datetime(1900, 1, 1)\n    day = reference_nc_file.variables['day'][:]\n    day_value = day[-1]\n    \n\tday_value = convert_date_from_1900(test_start_date)\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    \n\n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15)\n    # Show the plot or save it to a file\n    plt.savefig(f'/home/chetana/gridmet_test_run/predicted_swe-{timestamp_string}-{uuid.uuid4().hex}.png')\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "  File \"/home/chetana/gw-workspace/lq9r1uao1un/convert_results_to_images.py\", line 55\n    day_value = convert_date_from_1900(test_start_date)\nTabError: inconsistent use of tabs and spaces in indentation\n",
  "history_begin_time" : 1691530641313,
  "history_end_time" : 1691530643642,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "tq3z35",
  "indicator" : "Failed"
},{
  "history_id" : "liwJ5F3TlL9P",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nimport netCDF4 as nc\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport pyproj\nimport uuid\n\n\nreference_date = datetime(1900, 1, 1)\nday_value = 44998\nresult_date = reference_date + timedelta(days=day_value)\ncurrent_datetime = result_date.strftime(\"%Y-%m-%d\")\n# current_datetime = datetime.now()\ntimestamp_string = current_datetime\n\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\ndef convert_csvs_to_images():\n    # Load the CSV data into a DataFrame\n    data = pd.read_csv('/home/chetana/gridmet_test_run/test_data_prediected.csv')\n\n    # Define the map boundaries for the Western US\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    # Create the Basemap instance\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    # Convert lon/lat to map coordinates\n    x, y = m(data['lon'].values, data['lat'].values)\n\n    # Plot the data using vibrant colors based on predicted_swe\n    plt.scatter(x, y, c=data['predicted_swe'], cmap='coolwarm', s=30, edgecolors='none', alpha=0.7)\n\n    # Add colorbar for reference\n    cbar = plt.colorbar()\n    cbar.set_label('Predicted SWE')\n\n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_nc_file = nc.Dataset('/home/chetana/gridmet_test_run/gridmet_climatology/etr_2023.nc')\n\n    reference_date = datetime(1900, 1, 1)\n    day = reference_nc_file.variables['day'][:]\n    day_value = day[-1]\n    \n    day_value = 44998\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    \n\n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15)\n    # Show the plot or save it to a file\n    plt.savefig(f'/home/chetana/gridmet_test_run/predicted_swe-{timestamp_string}-{uuid.uuid4().hex}.png')\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "",
  "history_begin_time" : 1690836912197,
  "history_end_time" : 1690836920412,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "Y6cAAFEKmuE1",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nimport netCDF4 as nc\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport pyproj\nimport uuid\n\n\nreference_date = datetime(1900, 1, 1)\nday_value = 44998\nresult_date = reference_date + timedelta(days=day_value)\ncurrent_datetime = result_date.strftime(\"%Y-%m-%d\")\n# current_datetime = datetime.now()\ntimestamp_string = current_datetime\n\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\ndef convert_csvs_to_images():\n    # Load the CSV data into a DataFrame\n    data = pd.read_csv('/home/chetana/gridmet_test_run/test_data_prediected.csv')\n\n    # Define the map boundaries for the Western US\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    # Create the Basemap instance\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    # Convert lon/lat to map coordinates\n    x, y = m(data['lon'].values, data['lat'].values)\n\n    # Define the scale limits\n    scale_min = 10  # Set your desired minimum value here\n    scale_max = 50  # Adjusted to show until 50\n\n    # Plot the data using the 'jet' colormap\n    plt.scatter(x, y, c=data['predicted_swe'], cmap='jet', s=30, edgecolors='none', alpha=0.7, vmin=scale_min, vmax=scale_max)\n\n    # Add colorbar for reference\n    cbar = plt.colorbar()\n    cbar.set_label('Predicted SWE')\n\n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_nc_file = nc.Dataset('/home/chetana/gridmet_test_run/gridmet_climatology/etr_2023.nc')\n\n    reference_date = datetime(1900, 1, 1)\n    day = reference_nc_file.variables['day'][:]\n    day_value = day[-1]\n    \n    day_value = 44998\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    \n\n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15)\n    # Show the plot or save it to a file\n    plt.savefig(f'/home/chetana/gridmet_test_run/predicted_swe-{timestamp_string}-{uuid.uuid4().hex}.png')\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "",
  "history_begin_time" : 1690836800105,
  "history_end_time" : 1690836808067,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "9yygseR4r1l3",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nimport netCDF4 as nc\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport pyproj\nimport uuid\n\n\nreference_date = datetime(1900, 1, 1)\nday_value = 44998\nresult_date = reference_date + timedelta(days=day_value)\ncurrent_datetime = result_date.strftime(\"%Y-%m-%d\")\n# current_datetime = datetime.now()\ntimestamp_string = current_datetime\n\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\ndef convert_csvs_to_images():\n    # Load the CSV data into a DataFrame\n    data = pd.read_csv('/home/chetana/gridmet_test_run/test_data_prediected.csv')\n\n    # Define the map boundaries for the Western US\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    # Create the Basemap instance\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    # Convert lon/lat to map coordinates\n    x, y = m(data['lon'].values, data['lat'].values)\n\n    # Define the scale limits\n    scale_min = 0\n    scale_max = 50  # Adjusted to show until 50\n\n    # Plot the data using the 'viridis' colormap\n    plt.scatter(x, y, c=data['predicted_swe'], cmap='viridis', s=30, edgecolors='none', alpha=0.7, vmin=scale_min, vmax=scale_max)\n\n    # Add colorbar for reference\n    cbar = plt.colorbar()\n    cbar.set_label('Predicted SWE')\n\n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_nc_file = nc.Dataset('/home/chetana/gridmet_test_run/gridmet_climatology/etr_2023.nc')\n\n    reference_date = datetime(1900, 1, 1)\n    day = reference_nc_file.variables['day'][:]\n    day_value = day[-1]\n    \n    day_value = 44998\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    \n\n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15)\n    # Show the plot or save it to a file\n    plt.savefig(f'/home/chetana/gridmet_test_run/predicted_swe-{timestamp_string}-{uuid.uuid4().hex}.png')\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "",
  "history_begin_time" : 1690836621131,
  "history_end_time" : 1690836628879,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "peRp25jo43MO",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nimport netCDF4 as nc\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport pyproj\nimport uuid\n\n\nreference_date = datetime(1900, 1, 1)\nday_value = 44998\nresult_date = reference_date + timedelta(days=day_value)\ncurrent_datetime = result_date.strftime(\"%Y-%m-%d\")\n# current_datetime = datetime.now()\ntimestamp_string = current_datetime\n\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\ndef convert_csvs_to_images():\n    # Load the CSV data into a DataFrame\n    data = pd.read_csv('/home/chetana/gridmet_test_run/test_data_prediected.csv')\n\n    # Define the map boundaries for the Western US\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    # Create the Basemap instance\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    # Convert lon/lat to map coordinates\n    x, y = m(data['lon'].values, data['lat'].values)\n\n    # Define the scale limits\n    scale_min = 0\n    scale_max = 50  # Adjusted to show until 50\n\n    # Create a custom colormap with shades of blue and white\n    num_colors = 100  # Number of colors to create\n    cmap_colors = plt.cm.Blues(np.linspace(0, 1, num_colors))\n    cmap_colors[0:20] = [1, 1, 1, 1]  # Replace lower values with white\n    cmap = plt.cm.colors.ListedColormap(cmap_colors)\n\n    # Plot the data using shades of blue based on predicted_swe\n    plt.scatter(x, y, c=data['predicted_swe'], cmap=cmap, s=30, edgecolors='none', alpha=0.7, vmin=scale_min, vmax=scale_max)\n\n    # Add colorbar for reference\n    cbar = plt.colorbar()\n    cbar.set_label('Predicted SWE')\n\n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_nc_file = nc.Dataset('/home/chetana/gridmet_test_run/gridmet_climatology/etr_2023.nc')\n\n    reference_date = datetime(1900, 1, 1)\n    day = reference_nc_file.variables['day'][:]\n    day_value = day[-1]\n    \n    day_value = 44998\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    \n\n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15)\n    # Show the plot or save it to a file\n    plt.savefig(f'/home/chetana/gridmet_test_run/predicted_swe-{timestamp_string}-{uuid.uuid4().hex}.png')\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "",
  "history_begin_time" : 1690836482872,
  "history_end_time" : 1690836490682,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "3A0k6M7l532s",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nimport netCDF4 as nc\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport pyproj\nimport uuid\n\n\nreference_date = datetime(1900, 1, 1)\nday_value = 44998\nresult_date = reference_date + timedelta(days=day_value)\ncurrent_datetime = result_date.strftime(\"%Y-%m-%d\")\n# current_datetime = datetime.now()\ntimestamp_string = current_datetime\n\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\ndef convert_csvs_to_images():\n    # Load the CSV data into a DataFrame\n    data = pd.read_csv('/home/chetana/gridmet_test_run/test_data_prediected.csv')\n\n    # Define the map boundaries for the Western US\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    # Create the Basemap instance\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    # Convert lon/lat to map coordinates\n    x, y = m(data['lon'].values, data['lat'].values)\n\n    # Define the scale limits\n    scale_min = 0\n    scale_max = data['predicted_swe'].max()\n\n    # Create a custom colormap with shades of blue and white\n    num_colors = 100  # Number of colors to create\n    cmap_colors = plt.cm.Blues(np.linspace(0, 1, num_colors))\n    cmap_colors[0:20] = [1, 1, 1, 1]  # Replace lower values with white\n    cmap = plt.cm.colors.ListedColormap(cmap_colors)\n\n    # Plot the data using shades of blue based on predicted_swe\n    plt.scatter(x, y, c=data['predicted_swe'], cmap=cmap, s=30, edgecolors='none', alpha=0.7, vmin=scale_min, vmax=scale_max)\n\n    # Add colorbar for reference\n    cbar = plt.colorbar()\n    cbar.set_label('Predicted SWE')\n\n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_nc_file = nc.Dataset('/home/chetana/gridmet_test_run/gridmet_climatology/etr_2023.nc')\n\n    reference_date = datetime(1900, 1, 1)\n    day = reference_nc_file.variables['day'][:]\n    day_value = day[-1]\n    \n    day_value = 44998\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    \n\n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15)\n    # Show the plot or save it to a file\n    plt.savefig(f'/home/chetana/gridmet_test_run/predicted_swe-{timestamp_string}-{uuid.uuid4().hex}.png')\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "",
  "history_begin_time" : 1690836199538,
  "history_end_time" : 1690836207242,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "GL70uAAzir3m",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nimport netCDF4 as nc\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport pyproj\nimport uuid\n\n\nreference_date = datetime(1900, 1, 1)\nday_value = 44998\nresult_date = reference_date + timedelta(days=day_value)\ncurrent_datetime = result_date.strftime(\"%Y-%m-%d\")\n# current_datetime = datetime.now()\ntimestamp_string = current_datetime\n\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\ndef convert_csvs_to_images():\n    # Load the CSV data into a DataFrame\n    data = pd.read_csv('/home/chetana/gridmet_test_run/test_data_prediected.csv')\n\n    # Define the map boundaries for the Western US\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    # Create the Basemap instance\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    # Convert lon/lat to map coordinates\n    x, y = m(data['lon'].values, data['lat'].values)\n\n    # Define the scale limits\n    scale_min = 0\n    scale_max = data['predicted_swe'].max()\n\n    # Create a custom colormap with only white and blue colors\n    cmap = plt.cm.colors.ListedColormap(['white', 'blue'])\n\n    # Plot the data using shades of blue based on predicted_swe\n    plt.scatter(x, y, c=data['predicted_swe'], cmap=cmap, s=30, edgecolors='none', alpha=0.7, vmin=scale_min, vmax=scale_max)\n\n    # Add colorbar for reference\n    cbar = plt.colorbar()\n    cbar.set_label('Predicted SWE')\n\n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_nc_file = nc.Dataset('/home/chetana/gridmet_test_run/gridmet_climatology/etr_2023.nc')\n\n    reference_date = datetime(1900, 1, 1)\n    day = reference_nc_file.variables['day'][:]\n    day_value = day[-1]\n    \n    day_value = 44998\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    \n\n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15)\n    # Show the plot or save it to a file\n    plt.savefig(f'/home/chetana/gridmet_test_run/predicted_swe-{timestamp_string}-{uuid.uuid4().hex}.png')\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "",
  "history_begin_time" : 1690836119402,
  "history_end_time" : 1690836127298,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "oT39ih9NMA6o",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nimport netCDF4 as nc\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport pyproj\nimport uuid\n\n\nreference_date = datetime(1900, 1, 1)\nday_value = 44998\nresult_date = reference_date + timedelta(days=day_value)\ncurrent_datetime = result_date.strftime(\"%Y-%m-%d\")\n# current_datetime = datetime.now()\ntimestamp_string = current_datetime\n\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\ndef convert_csvs_to_images():\n    # Load the CSV data into a DataFrame\n    data = pd.read_csv('/home/chetana/gridmet_test_run/test_data_prediected.csv')\n\n    # Define the map boundaries for the Western US\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    # Create the Basemap instance\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    # Convert lon/lat to map coordinates\n    x, y = m(data['lon'].values, data['lat'].values)\n\n    # Define the scale limits\n    scale_min = 0\n    scale_max = data['predicted_swe'].max()\n\n    # Plot the data using shades of blue based on predicted_swe\n    plt.scatter(x, y, c=data['predicted_swe'], cmap='Blues', s=30, edgecolors='none', alpha=0.7, vmin=scale_min, vmax=scale_max)\n\n    # Add colorbar for reference\n    cbar = plt.colorbar()\n    cbar.set_label('Predicted SWE')\n\n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_nc_file = nc.Dataset('/home/chetana/gridmet_test_run/gridmet_climatology/etr_2023.nc')\n\n    reference_date = datetime(1900, 1, 1)\n    day = reference_nc_file.variables['day'][:]\n    day_value = day[-1]\n    \n    day_value = 44998\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    \n\n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15)\n    # Show the plot or save it to a file\n    plt.savefig(f'/home/chetana/gridmet_test_run/predicted_swe-{timestamp_string}-{uuid.uuid4().hex}.png')\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "",
  "history_begin_time" : 1690836012151,
  "history_end_time" : 1690836020034,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "AFEbUzMUzuFW",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nimport netCDF4 as nc\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport pyproj\nimport uuid\n\n\nreference_date = datetime(1900, 1, 1)\nday_value = 44998\nresult_date = reference_date + timedelta(days=day_value)\ncurrent_datetime = result_date.strftime(\"%Y-%m-%d\")\n# current_datetime = datetime.now()\ntimestamp_string = current_datetime\n\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\ndef convert_csvs_to_images():\n    # Load the CSV data into a DataFrame\n    data = pd.read_csv('/home/chetana/gridmet_test_run/test_data_prediected.csv')\n\n    # Define the map boundaries for the Western US\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    # Create the Basemap instance\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    # Convert lon/lat to map coordinates\n    x, y = m(data['lon'].values, data['lat'].values)\n\n    # Plot the data using shades of blue based on predicted_swe\n    plt.scatter(x, y, c=data['predicted_swe'], cmap='Blues', s=30, edgecolors='none', alpha=0.7)\n\n    # Add colorbar for reference\n    cbar = plt.colorbar()\n    cbar.set_label('Predicted SWE')\n\n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_nc_file = nc.Dataset('/home/chetana/gridmet_test_run/gridmet_climatology/etr_2023.nc')\n\n    reference_date = datetime(1900, 1, 1)\n    day = reference_nc_file.variables['day'][:]\n    day_value = day[-1]\n    \n    day_value = 44998\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    \n\n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15)\n    # Show the plot or save it to a file\n    plt.savefig(f'/home/chetana/gridmet_test_run/predicted_swe-{timestamp_string}-{uuid.uuid4().hex}.png')\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "",
  "history_begin_time" : 1690820118617,
  "history_end_time" : 1690820126539,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "lYR5MfpfPdX1",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nimport netCDF4 as nc\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport pyproj\nimport uuid\n\nreference_date = datetime(1900, 1, 1)\nday_value = 44998\nresult_date = reference_date + timedelta(days=day_value)\ncurrent_datetime = result_date.strftime(\"%Y-%m-%d\")\n# current_datetime = datetime.now()\ntimestamp_string = current_datetime\n\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\ndef convert_csvs_to_images():\n    # Load the CSV data into a DataFrame\n    data = pd.read_csv('/home/chetana/gridmet_test_run/test_data_prediected.csv')\n\n    # Define the map boundaries for the Western US\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    # Create the Basemap instance\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    # Convert lon/lat to map coordinates\n    x, y = m(data['lon'].values, data['lat'].values)\n\n    # Plot the data using shades of blue based on predicted_swe\n    plt.scatter(x, y, c=data['predicted_swe'], cmap='Blues', s=30, edgecolors='none', alpha=0.7, vmin=0, vmax=50)\n\n    # Add colorbar for reference\n    cbar = plt.colorbar()\n    cbar.set_label('Predicted SWE')\n\n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_nc_file = nc.Dataset('/home/chetana/gridmet_test_run/gridmet_climatology/etr_2023.nc')\n\n    reference_date = datetime(1900, 1, 1)\n    day = reference_nc_file.variables['day'][:]\n    day_value = day[-1]\n    \n    day_value = 44998\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    \n\n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15)\n    # Show the plot or save it to a file\n    plt.savefig(f'/home/chetana/gridmet_test_run/predicted_swe-{timestamp_string}-{uuid.uuid4().hex}.png')\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "",
  "history_begin_time" : 1690820079122,
  "history_end_time" : 1690820087144,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "oYVGLVv5LMDR",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nimport netCDF4 as nc\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport pyproj\nimport uuid\n\n\nreference_date = datetime(1900, 1, 1)\nday_value = 44998\nresult_date = reference_date + timedelta(days=day_value)\ncurrent_datetime = result_date.strftime(\"%Y-%m-%d\")\n# current_datetime = datetime.now()\ntimestamp_string = current_datetime\n\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\ndef convert_csvs_to_images():\n    # Load the CSV data into a DataFrame\n    data = pd.read_csv('/home/chetana/gridmet_test_run/test_data_prediected.csv')\n\n    # Define the map boundaries for the Western US\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    # Create the Basemap instance\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    # Convert lon/lat to map coordinates\n    x, y = m(data['lon'].values, data['lat'].values)\n\n    # Plot the data using shades of blue based on predicted_swe\n    plt.scatter(x, y, c=data['predicted_swe'], cmap='Blues', s=30, edgecolors='none', alpha=0.7)\n\n    # Add colorbar for reference\n    cbar = plt.colorbar()\n    cbar.set_label('Predicted SWE')\n\n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_nc_file = nc.Dataset('/home/chetana/gridmet_test_run/gridmet_climatology/etr_2023.nc')\n\n    reference_date = datetime(1900, 1, 1)\n    day = reference_nc_file.variables['day'][:]\n    day_value = day[-1]\n    \n    day_value = 44998\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    \n\n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15)\n    # Show the plot or save it to a file\n    plt.savefig(f'/home/chetana/gridmet_test_run/predicted_swe-{timestamp_string}-{uuid.uuid4().hex}.png')\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "",
  "history_begin_time" : 1690819699602,
  "history_end_time" : 1690819707612,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "kchvmSAinBJ3",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nimport netCDF4 as nc\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport pyproj\nimport uuid\n\n\nreference_date = datetime(1900, 1, 1)\nday_value = 44998\nresult_date = reference_date + timedelta(days=day_value)\ncurrent_datetime = result_date.strftime(\"%Y-%m-%d\")\n# current_datetime = datetime.now()\ntimestamp_string = current_datetime\n\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\ndef convert_csvs_to_images():\n    # Load the CSV data into a DataFrame\n    data = pd.read_csv('/home/chetana/gridmet_test_run/test_data_prediected.csv')\n\n    # Define the map boundaries for the Western US\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    # Create the Basemap instance\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    # Convert lon/lat to map coordinates\n    x, y = m(data['lon'].values, data['lat'].values)\n\n    # Plot the data using vibrant colors based on predicted_swe\n    plt.scatter(x, y, c=data['predicted_swe'], cmap='coolwarm', s=30, edgecolors='none', alpha=0.7)\n\n    # Add colorbar for reference\n    cbar = plt.colorbar()\n    cbar.set_label('Predicted SWE')\n\n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_nc_file = nc.Dataset('/home/chetana/gridmet_test_run/gridmet_climatology/etr_2023.nc')\n\n    reference_date = datetime(1900, 1, 1)\n    day = reference_nc_file.variables['day'][:]\n    day_value = day[-1]\n    \n    day_value = 44998\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    \n\n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15)\n    # Show the plot or save it to a file\n    plt.savefig(f'/home/chetana/gridmet_test_run/predicted_swe-{timestamp_string}-{uuid.uuid4().hex}.png')\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "",
  "history_begin_time" : 1690819540914,
  "history_end_time" : 1690819551318,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "zUKiRIxwgDrk",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nimport netCDF4 as nc\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport pyproj\nimport uuid\n\n\nreference_date = datetime(1900, 1, 1)\nday_value = 44998\nresult_date = reference_date + timedelta(days=day_value)\ncurrent_datetime = result_date.strftime(\"%Y-%m-%d\")\n# current_datetime = datetime.now()\ntimestamp_string = current_datetime\n\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\ndef convert_csvs_to_images():\n    # Load the CSV data into a DataFrame\n    data = pd.read_csv('/home/chetana/gridmet_test_run/test_data_prediected.csv')\n\n    # Define the map boundaries for the Western US\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    # Create the Basemap instance\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    # Convert lon/lat to map coordinates\n    x, y = m(data['lon'].values, data['lat'].values)\n\n    # Plot the data using vibrant colors based on predicted_swe\n    plt.scatter(x, y, c=data['predicted_swe'], cmap='coolwarm', s=30, edgecolors='none', alpha=0.7)\n\n    # Add colorbar for reference\n    cbar = plt.colorbar()\n    cbar.set_label('Predicted SWE')\n\n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_nc_file = nc.Dataset('/home/chetana/gridmet_test_run/gridmet_climatology/etr_2023.nc')\n\n    reference_date = datetime(1900, 1, 1)\n    day = reference_nc_file.variables['day'][:]\n    day_value = day[-1]\n    \n    day_value = 44998\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    \n\n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15)\n    # Show the plot or save it to a file\n    plt.savefig(f'/home/chetana/gridmet_test_run/predicted_swe-{timestamp_string}-{uuid.uuid4().hex}.png')\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "",
  "history_begin_time" : 1690678451714,
  "history_end_time" : 1690678461544,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "04IzS0lJPa4S",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nimport netCDF4 as nc\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport pyproj\nimport uuid\n\n\nreference_date = datetime(1900, 1, 1)\nday_value = 44938\nresult_date = reference_date + timedelta(days=day_value)\ncurrent_datetime = result_date.strftime(\"%Y-%m-%d\")\n# current_datetime = datetime.now()\ntimestamp_string = current_datetime\n\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\ndef convert_csvs_to_images():\n    # Load the CSV data into a DataFrame\n    data = pd.read_csv('/home/chetana/gridmet_test_run/test_data_prediected.csv')\n\n    # Define the map boundaries for the Western US\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    # Create the Basemap instance\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    # Convert lon/lat to map coordinates\n    x, y = m(data['lon'].values, data['lat'].values)\n\n    # Plot the data using vibrant colors based on predicted_swe\n    plt.scatter(x, y, c=data['predicted_swe'], cmap='coolwarm', s=30, edgecolors='none', alpha=0.7)\n\n    # Add colorbar for reference\n    cbar = plt.colorbar()\n    cbar.set_label('Predicted SWE')\n\n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_nc_file = nc.Dataset('/home/chetana/gridmet_test_run/gridmet_climatology/etr_2023.nc')\n\n    reference_date = datetime(1900, 1, 1)\n    day = reference_nc_file.variables['day'][:]\n    day_value = day[-1]\n    \n    day_value = 44938\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    \n\n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15)\n    # Show the plot or save it to a file\n    plt.savefig(f'/home/chetana/gridmet_test_run/predicted_swe-{timestamp_string}-{uuid.uuid4().hex}.png')\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "",
  "history_begin_time" : 1690678278789,
  "history_end_time" : 1690678288963,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "J0TdFZh4SAC0",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nimport netCDF4 as nc\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport pyproj\nimport uuid\n\n\nreference_date = datetime(1900, 1, 1)\nday_value = 44969\nresult_date = reference_date + timedelta(days=day_value)\ncurrent_datetime = result_date.strftime(\"%Y-%m-%d\")\n# current_datetime = datetime.now()\ntimestamp_string = current_datetime\n\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\ndef convert_csvs_to_images():\n    # Load the CSV data into a DataFrame\n    data = pd.read_csv('/home/chetana/gridmet_test_run/test_data_prediected.csv')\n\n    # Define the map boundaries for the Western US\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    # Create the Basemap instance\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    # Convert lon/lat to map coordinates\n    x, y = m(data['lon'].values, data['lat'].values)\n\n    # Plot the data using vibrant colors based on predicted_swe\n    plt.scatter(x, y, c=data['predicted_swe'], cmap='coolwarm', s=30, edgecolors='none', alpha=0.7)\n\n    # Add colorbar for reference\n    cbar = plt.colorbar()\n    cbar.set_label('Predicted SWE')\n\n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_nc_file = nc.Dataset('/home/chetana/gridmet_test_run/gridmet_climatology/etr_2023.nc')\n\n    reference_date = datetime(1900, 1, 1)\n    day = reference_nc_file.variables['day'][:]\n    day_value = day[-1]\n    \n    day_value = 44969\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    \n\n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15)\n    # Show the plot or save it to a file\n    plt.savefig(f'/home/chetana/gridmet_test_run/predicted_swe-{timestamp_string}-{uuid.uuid4().hex}.png')\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "",
  "history_begin_time" : 1690678154357,
  "history_end_time" : 1690678164134,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "T2pch0SXLBcP",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nimport netCDF4 as nc\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport pyproj\nimport uuid\n\n\nreference_date = datetime(1900, 1, 1)\nday_value = 44604\nresult_date = reference_date + timedelta(days=day_value)\ncurrent_datetime = result_date.strftime(\"%Y-%m-%d\")\n# current_datetime = datetime.now()\ntimestamp_string = current_datetime\n\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\ndef convert_csvs_to_images():\n    # Load the CSV data into a DataFrame\n    data = pd.read_csv('/home/chetana/gridmet_test_run/test_data_prediected.csv')\n\n    # Define the map boundaries for the Western US\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    # Create the Basemap instance\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    # Convert lon/lat to map coordinates\n    x, y = m(data['lon'].values, data['lat'].values)\n\n    # Plot the data using vibrant colors based on predicted_swe\n    plt.scatter(x, y, c=data['predicted_swe'], cmap='coolwarm', s=30, edgecolors='none', alpha=0.7)\n\n    # Add colorbar for reference\n    cbar = plt.colorbar()\n    cbar.set_label('Predicted SWE')\n\n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_nc_file = nc.Dataset('/home/chetana/gridmet_test_run/gridmet_climatology/etr_2023.nc')\n\n    reference_date = datetime(1900, 1, 1)\n    day = reference_nc_file.variables['day'][:]\n    day_value = day[-1]\n    \n    day_value = 44604\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    \n\n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15)\n    # Show the plot or save it to a file\n    plt.savefig(f'/home/chetana/gridmet_test_run/predicted_swe-{timestamp_string}-{uuid.uuid4().hex}.png')\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "",
  "history_begin_time" : 1690677967950,
  "history_end_time" : 1690677977799,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "aQ39V5FyPIEL",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nimport netCDF4 as nc\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport pyproj\nimport uuid\n\n\nreference_date = datetime(1900, 1, 1)\nday_value = 44574\nresult_date = reference_date + timedelta(days=day_value)\ncurrent_datetime = result_date.strftime(\"%Y-%m-%d\")\n# current_datetime = datetime.now()\ntimestamp_string = current_datetime\n\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\ndef convert_csvs_to_images():\n    # Load the CSV data into a DataFrame\n    data = pd.read_csv('/home/chetana/gridmet_test_run/test_data_prediected.csv')\n\n    # Define the map boundaries for the Western US\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    # Create the Basemap instance\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    # Convert lon/lat to map coordinates\n    x, y = m(data['lon'].values, data['lat'].values)\n\n    # Plot the data using vibrant colors based on predicted_swe\n    plt.scatter(x, y, c=data['predicted_swe'], cmap='coolwarm', s=30, edgecolors='none', alpha=0.7)\n\n    # Add colorbar for reference\n    cbar = plt.colorbar()\n    cbar.set_label('Predicted SWE')\n\n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_nc_file = nc.Dataset('/home/chetana/gridmet_test_run/gridmet_climatology/etr_2023.nc')\n\n    reference_date = datetime(1900, 1, 1)\n    day = reference_nc_file.variables['day'][:]\n    day_value = day[-1]\n    \n    day_value = 44574\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    \n\n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15)\n    # Show the plot or save it to a file\n    plt.savefig(f'/home/chetana/gridmet_test_run/predicted_swe-{timestamp_string}-{uuid.uuid4().hex}.png')\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "",
  "history_begin_time" : 1690677850165,
  "history_end_time" : 1690677859910,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "aAXN9y3IWvsI",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nimport netCDF4 as nc\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport pyproj\nimport uuid\n\n\nreference_date = datetime(1900, 1, 1)\nday_value = 44554\nresult_date = reference_date + timedelta(days=day_value)\ncurrent_datetime = result_date.strftime(\"%Y-%m-%d\")\n# current_datetime = datetime.now()\ntimestamp_string = current_datetime\n\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\ndef convert_csvs_to_images():\n    # Load the CSV data into a DataFrame\n    data = pd.read_csv('/home/chetana/gridmet_test_run/test_data_prediected.csv')\n\n    # Define the map boundaries for the Western US\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    # Create the Basemap instance\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    # Convert lon/lat to map coordinates\n    x, y = m(data['lon'].values, data['lat'].values)\n\n    # Plot the data using vibrant colors based on predicted_swe\n    plt.scatter(x, y, c=data['predicted_swe'], cmap='coolwarm', s=30, edgecolors='none', alpha=0.7)\n\n    # Add colorbar for reference\n    cbar = plt.colorbar()\n    cbar.set_label('Predicted SWE')\n\n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_nc_file = nc.Dataset('/home/chetana/gridmet_test_run/gridmet_climatology/etr_2023.nc')\n\n    reference_date = datetime(1900, 1, 1)\n    day = reference_nc_file.variables['day'][:]\n    day_value = day[-1]\n    \n    day_value = 44574\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    \n\n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15)\n    # Show the plot or save it to a file\n    plt.savefig(f'/home/chetana/gridmet_test_run/predicted_swe-{timestamp_string}-{uuid.uuid4().hex}.png')\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "",
  "history_begin_time" : 1690677726826,
  "history_end_time" : 1690677735097,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "9oVgTe9mNwgr",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nimport netCDF4 as nc\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport pyproj\nimport uuid\n\n\nreference_date = datetime(1900, 1, 1)\nday_value = 44554\nresult_date = reference_date + timedelta(days=day_value)\ncurrent_datetime = result_date.strftime(\"%Y-%m-%d\")\n# current_datetime = datetime.now()\ntimestamp_string = current_datetime\n\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\ndef convert_csvs_to_images():\n    # Load the CSV data into a DataFrame\n    data = pd.read_csv('/home/chetana/gridmet_test_run/test_data_prediected.csv')\n\n    # Define the map boundaries for the Western US\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    # Create the Basemap instance\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    # Convert lon/lat to map coordinates\n    x, y = m(data['lon'].values, data['lat'].values)\n\n    # Plot the data using vibrant colors based on predicted_swe\n    plt.scatter(x, y, c=data['predicted_swe'], cmap='coolwarm', s=30, edgecolors='none', alpha=0.7)\n\n    # Add colorbar for reference\n    cbar = plt.colorbar()\n    cbar.set_label('Predicted SWE')\n\n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_nc_file = nc.Dataset('/home/chetana/gridmet_test_run/gridmet_climatology/etr_2023.nc')\n\n    reference_date = datetime(1900, 1, 1)\n    day = reference_nc_file.variables['day'][:]\n    day_value = day[-1]\n    \n    day_value = 44554\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    \n\n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15)\n    # Show the plot or save it to a file\n    plt.savefig(f'/home/chetana/gridmet_test_run/predicted_swe-{timestamp_string}-{uuid.uuid4().hex}.png')\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "",
  "history_begin_time" : 1690677714653,
  "history_end_time" : 1690677723425,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "ifLVjj2L7gOa",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nimport netCDF4 as nc\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport pyproj\nimport uuid\n\n\nreference_date = datetime(1900, 1, 1)\nday_value = 44554\nresult_date = reference_date + timedelta(days=day_value)\ncurrent_datetime = result_date.strftime(\"%Y-%m-%d\")\n# current_datetime = datetime.now()\ntimestamp_string = current_datetime\n\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\ndef convert_csvs_to_images():\n    # Load the CSV data into a DataFrame\n    data = pd.read_csv('/home/chetana/gridmet_test_run/test_data_prediected.csv')\n\n    # Define the map boundaries for the Western US\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    # Create the Basemap instance\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    # Convert lon/lat to map coordinates\n    x, y = m(data['lon'].values, data['lat'].values)\n\n    # Plot the data using vibrant colors based on predicted_swe\n    plt.scatter(x, y, c=data['predicted_swe'], cmap='coolwarm', s=30, edgecolors='none', alpha=0.7)\n\n    # Add colorbar for reference\n    cbar = plt.colorbar()\n    cbar.set_label('Predicted SWE')\n\n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_nc_file = nc.Dataset('/home/chetana/gridmet_test_run/gridmet_climatology/etr_2023.nc')\n\n    reference_date = datetime(1900, 1, 1)\n    day = reference_nc_file.variables['day'][:]\n    day_value = day[-1]\n    \n    day_value = 44554\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    \n\n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15)\n    # Show the plot or save it to a file\n    plt.savefig(f'/home/chetana/gridmet_test_run/predicted_swe-{timestamp_string}-{uuid.uuid4().hex}.png')\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "",
  "history_begin_time" : 1690676990724,
  "history_end_time" : 1690677000574,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "N4tcMSyxdlZt",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nimport netCDF4 as nc\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport pyproj\nimport uuid\n\n\nreference_date = datetime(1900, 1, 1)\nday_value = 44554\nresult_date = reference_date + timedelta(days=day_value)\ncurrent_datetime = result_date.strftime(\"%Y-%m-%d\")\n# current_datetime = datetime.now()\ntimestamp_string = current_datetime\n\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\ndef convert_csvs_to_images():\n    # Load the CSV data into a DataFrame\n    data = pd.read_csv('/home/chetana/gridmet_test_run/test_data_prediected.csv')\n\n    # Define the map boundaries for the Western US\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    # Create the Basemap instance\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    # Convert lon/lat to map coordinates\n    x, y = m(data['lon'].values, data['lat'].values)\n\n    # Plot the data using vibrant colors based on predicted_swe\n    plt.scatter(x, y, c=data['predicted_swe'], cmap='coolwarm', s=30, edgecolors='none', alpha=0.7)\n\n    # Add colorbar for reference\n    cbar = plt.colorbar()\n    cbar.set_label('Predicted SWE')\n\n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_nc_file = nc.Dataset('/home/chetana/gridmet_test_run/gridmet_climatology/etr_2023.nc')\n\n    reference_date = datetime(1900, 1, 1)\n    day = reference_nc_file.variables['day'][:]\n    day_value = day[-1]\n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n\n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15)\n    # Show the plot or save it to a file\n    plt.savefig(f'/home/chetana/gridmet_test_run/predicted_swe-{timestamp_string}-{uuid.uuid4().hex}.png')\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "",
  "history_begin_time" : 1690676874331,
  "history_end_time" : 1690676884498,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "s4xHQXntaVyJ",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nimport netCDF4 as nc\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport pyproj\nimport uuid\n\n\nreference_date = datetime(1900, 1, 1)\nday_value = 44554\nresult_date = reference_date + timedelta(days=day_value)\ncurrent_datetime = result_date.strftime(\"%Y-%m-%d\")\n# current_datetime = datetime.now()\ntimestamp_string = current_datetime\n\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\ndef convert_csvs_to_images():\n    # Load the CSV data into a DataFrame\n    data = pd.read_csv('/home/chetana/gridmet_test_run/test_data_prediected.csv')\n\n    # Define the map boundaries for the Western US\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    # Create the Basemap instance\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    # Convert lon/lat to map coordinates\n    x, y = m(data['lon'].values, data['lat'].values)\n\n    # Plot the data using vibrant colors based on predicted_swe\n    plt.scatter(x, y, c=data['predicted_swe'], cmap='coolwarm', s=30, edgecolors='none', alpha=0.7)\n\n    # Add colorbar for reference\n    cbar = plt.colorbar()\n    cbar.set_label('Predicted SWE')\n\n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_nc_file = nc.Dataset('/home/chetana/gridmet_test_run/gridmet_climatology/etr_2023.nc')\n\n    reference_date = datetime(1900, 1, 1)\n    day = reference_nc_file.variables['day'][:]\n    day_value = day[-1]\n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n\n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15)\n    # Show the plot or save it to a file\n    plt.savefig(f'/home/chetana/gridmet_test_run/predicted_swe-{timestamp_string}-{uuid.uuid4().hex}.png')\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "",
  "history_begin_time" : 1690676824867,
  "history_end_time" : 1690676834866,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "eG3PbZqk4nh0",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nimport netCDF4 as nc\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport pyproj\nimport uuid\n\n\nreference_date = datetime(1900, 1, 1)\nday_value = 44554\nresult_date = reference_date + timedelta(days=day_value)\ncurrent_datetime = result_date.strftime(\"%Y-%m-%d\")\n# current_datetime = datetime.now()\n\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\ndef convert_csvs_to_images():\n    # Load the CSV data into a DataFrame\n    data = pd.read_csv('/home/chetana/gridmet_test_run/test_data_prediected.csv')\n\n    # Define the map boundaries for the Western US\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    # Create the Basemap instance\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    # Convert lon/lat to map coordinates\n    x, y = m(data['lon'].values, data['lat'].values)\n\n    # Plot the data using vibrant colors based on predicted_swe\n    plt.scatter(x, y, c=data['predicted_swe'], cmap='coolwarm', s=30, edgecolors='none', alpha=0.7)\n\n    # Add colorbar for reference\n    cbar = plt.colorbar()\n    cbar.set_label('Predicted SWE')\n\n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_nc_file = nc.Dataset('/home/chetana/gridmet_test_run/gridmet_climatology/etr_2023.nc')\n\n    reference_date = datetime(1900, 1, 1)\n    day = reference_nc_file.variables['day'][:]\n    day_value = day[-1]\n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n\n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15)\n    # Show the plot or save it to a file\n    plt.savefig(f'/home/chetana/gridmet_test_run/predicted_swe-{timestamp_string}-{uuid.uuid4().hex}.png')\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "Traceback (most recent call last):\n  File \"/home/chetana/gw-workspace/eG3PbZqk4nh0/convert_results_to_images.py\", line 92, in <module>\n    convert_csvs_to_images()\n  File \"/home/chetana/gw-workspace/eG3PbZqk4nh0/convert_results_to_images.py\", line 89, in convert_csvs_to_images\n    plt.savefig(f'/home/chetana/gridmet_test_run/predicted_swe-{timestamp_string}-{uuid.uuid4().hex}.png')\nNameError: name 'timestamp_string' is not defined\n",
  "history_begin_time" : 1690676775513,
  "history_end_time" : 1690676780969,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "lU5fha7JfIzn",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nimport netCDF4 as nc\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport pyproj\nimport uuid\n\n\nreference_date = datetime(1900, 1, 1)\nday = reference_nc_file.variables['day'][:]\n\nday_value = day[-1]\nday_value = 44554\n\nresult_date = reference_date + timedelta(days=day_value)\ncurrent_datetime = result_date.strftime(\"%Y-%m-%d\")\n# current_datetime = datetime.now()\n\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\ndef convert_csvs_to_images():\n    # Load the CSV data into a DataFrame\n    data = pd.read_csv('/home/chetana/gridmet_test_run/test_data_prediected.csv')\n\n    # Define the map boundaries for the Western US\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    # Create the Basemap instance\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    # Convert lon/lat to map coordinates\n    x, y = m(data['lon'].values, data['lat'].values)\n\n    # Plot the data using vibrant colors based on predicted_swe\n    plt.scatter(x, y, c=data['predicted_swe'], cmap='coolwarm', s=30, edgecolors='none', alpha=0.7)\n\n    # Add colorbar for reference\n    cbar = plt.colorbar()\n    cbar.set_label('Predicted SWE')\n\n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_nc_file = nc.Dataset('/home/chetana/gridmet_test_run/gridmet_climatology/etr_2023.nc')\n\n    reference_date = datetime(1900, 1, 1)\n    day = reference_nc_file.variables['day'][:]\n    day_value = day[-1]\n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n\n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15)\n    # Show the plot or save it to a file\n    plt.savefig(f'/home/chetana/gridmet_test_run/predicted_swe-{timestamp_string}-{uuid.uuid4().hex}.png')\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "Traceback (most recent call last):\n  File \"/home/chetana/gw-workspace/lU5fha7JfIzn/convert_results_to_images.py\", line 12, in <module>\n    day = reference_nc_file.variables['day'][:]\nNameError: name 'reference_nc_file' is not defined\n",
  "history_begin_time" : 1690676747029,
  "history_end_time" : 1690676748986,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "JvyEHKvu1gbf",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nimport netCDF4 as nc\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport pyproj\nimport uuid\n\n\nreference_date = datetime(1900, 1, 1)\n# Convert the datetime object to a timestamp string\ntimestamp_string = current_datetime.strftime(\"%Y-%m-%d\")\n# current_datetime = datetime.now()\ncurrent_datetime = timestamp_string\n\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\ndef convert_csvs_to_images():\n    # Load the CSV data into a DataFrame\n    data = pd.read_csv('/home/chetana/gridmet_test_run/test_data_prediected.csv')\n\n    # Define the map boundaries for the Western US\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    # Create the Basemap instance\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    # Convert lon/lat to map coordinates\n    x, y = m(data['lon'].values, data['lat'].values)\n\n    # Plot the data using vibrant colors based on predicted_swe\n    plt.scatter(x, y, c=data['predicted_swe'], cmap='coolwarm', s=30, edgecolors='none', alpha=0.7)\n\n    # Add colorbar for reference\n    cbar = plt.colorbar()\n    cbar.set_label('Predicted SWE')\n\n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_nc_file = nc.Dataset('/home/chetana/gridmet_test_run/gridmet_climatology/etr_2023.nc')\n\n    reference_date = datetime(1900, 1, 1)\n    day = reference_nc_file.variables['day'][:]\n    day_value = day[-1]\n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n\n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15)\n    # Show the plot or save it to a file\n    plt.savefig(f'/home/chetana/gridmet_test_run/predicted_swe-{timestamp_string}-{uuid.uuid4().hex}.png')\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "Traceback (most recent call last):\n  File \"/home/chetana/gw-workspace/JvyEHKvu1gbf/convert_results_to_images.py\", line 13, in <module>\n    timestamp_string = current_datetime.strftime(\"%Y-%m-%d\")\nNameError: name 'current_datetime' is not defined\n",
  "history_begin_time" : 1690676665278,
  "history_end_time" : 1690676667201,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "hsXFcZe8pEbH",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nimport netCDF4 as nc\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport pyproj\nimport uuid\n\ncurrent_datetime = datetime.now()\n\n# Convert the datetime object to a timestamp string\ntimestamp_string = current_datetime.strftime(\"%Y-%m-%d %H:%M:%S\")\n\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\ndef convert_csvs_to_images():\n    # Load the CSV data into a DataFrame\n    data = pd.read_csv('/home/chetana/gridmet_test_run/test_data_prediected.csv')\n\n    # Define the map boundaries for the Western US\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    # Create the Basemap instance\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    # Convert lon/lat to map coordinates\n    x, y = m(data['lon'].values, data['lat'].values)\n\n    # Plot the data using vibrant colors based on predicted_swe\n    plt.scatter(x, y, c=data['predicted_swe'], cmap='coolwarm', s=30, edgecolors='none', alpha=0.7)\n\n    # Add colorbar for reference\n    cbar = plt.colorbar()\n    cbar.set_label('Predicted SWE')\n\n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_nc_file = nc.Dataset('/home/chetana/gridmet_test_run/gridmet_climatology/etr_2023.nc')\n\n    reference_date = datetime(1900, 1, 1)\n    day = reference_nc_file.variables['day'][:]\n    day_value = day[-1]\n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n\n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15)\n    # Show the plot or save it to a file\n    plt.savefig(f'/home/chetana/gridmet_test_run/predicted_swe-{timestamp_string}-{uuid.uuid4().hex}.png')\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "",
  "history_begin_time" : 1690676453646,
  "history_end_time" : 1690676463772,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "97nGC8wB15f7",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nimport netCDF4 as nc\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport pyproj\nimport uuid\n\ncurrent_datetime = datetime.now()\n\n# Convert the datetime object to a timestamp string\ntimestamp_string = current_datetime.strftime(\"%Y-%m-%d %H:%M:%S\")\n\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\ndef convert_csvs_to_images():\n    # Load the CSV data into a DataFrame\n    data = pd.read_csv('/home/chetana/gridmet_test_run/test_data_prediected.csv')\n\n    # Define the map boundaries for the Western US\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    # Create the Basemap instance\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    # Convert lon/lat to map coordinates\n    x, y = m(data['lon'].values, data['lat'].values)\n\n    # Plot the data using vibrant colors based on predicted_swe\n    plt.scatter(x, y, c=data['predicted_swe'], cmap='coolwarm', s=30, edgecolors='none', alpha=0.7)\n\n    # Add colorbar for reference\n    cbar = plt.colorbar()\n    cbar.set_label('Predicted SWE')\n\n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_nc_file = nc.Dataset('/home/chetana/gridmet_test_run/gridmet_climatology/etr_2023.nc')\n\n    reference_date = datetime(1900, 1, 1)\n    day = reference_nc_file.variables['day'][:]\n    day_value = day[-1]\n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n\n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15)\n    # Show the plot or save it to a file\n    plt.savefig(f'/home/chetana/gridmet_test_run/predicted_swe-{timestamp_string}-{uuid.uuid4().hex}.png')\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "",
  "history_begin_time" : 1690676029191,
  "history_end_time" : 1690676039810,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "Kjk8vEWa8GWj",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nimport netCDF4 as nc\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport pyproj\nimport uuid\n\ncurrent_datetime = datetime.now()\n\n# Convert the datetime object to a timestamp string\ntimestamp_string = current_datetime.strftime(\"%Y-%m-%d %H:%M:%S\")\n\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\ndef convert_csvs_to_images():\n    # Load the CSV data into a DataFrame\n    data = pd.read_csv('/home/chetana/gridmet_test_run/test_data_prediected.csv')\n\n    # Define the map boundaries for the Western US\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    # Create the Basemap instance\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    # Convert lon/lat to map coordinates\n    x, y = m(data['lon'].values, data['lat'].values)\n\n    # Plot the data using vibrant colors based on predicted_swe\n    plt.scatter(x, y, c=data['predicted_swe'], cmap='coolwarm', s=30, edgecolors='none', alpha=0.7)\n\n    # Add colorbar for reference\n    cbar = plt.colorbar()\n    cbar.set_label('Predicted SWE')\n\n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_nc_file = nc.Dataset('/home/chetana/gridmet_test_run/gridmet_climatology/etr_2023.nc')\n\n    reference_date = datetime(1900, 1, 1)\n    day = reference_nc_file.variables['day'][:]\n    day_value = day[-1]\n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n\n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15)\n    # Show the plot or save it to a file\n    plt.savefig(f'/home/chetana/gridmet_test_run/predicted_swe-{timestamp_string}-{uuid.uuid4().hex}.png')\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "",
  "history_begin_time" : 1690644877718,
  "history_end_time" : 1690644887307,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "GnIpICvdE7cT",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nimport netCDF4 as nc\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport pyproj\n\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\ndef convert_csvs_to_images():\n    # Load the CSV data into a DataFrame\n    data = pd.read_csv('/home/chetana/gridmet_test_run/test_data_prediected.csv')\n\n    # Define the map boundaries for the Western US\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    # Create the Basemap instance\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    # Convert lon/lat to map coordinates\n    x, y = m(data['lon'].values, data['lat'].values)\n\n    # Plot the data using vibrant colors based on predicted_swe\n    plt.scatter(x, y, c=data['predicted_swe'], cmap='coolwarm', s=30, edgecolors='none', alpha=0.7)\n\n    # Add colorbar for reference\n    cbar = plt.colorbar()\n    cbar.set_label('Predicted SWE')\n\n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_nc_file = nc.Dataset('/home/chetana/gridmet_test_run/gridmet_climatology/etr_2023.nc')\n\n    reference_date = datetime(1900, 1, 1)\n    day = reference_nc_file.variables['day'][:]\n    day_value = day[-1]\n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n\n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15)\n    # Show the plot or save it to a file\n    plt.savefig('/home/chetana/gridmet_test_run/predicted_swe.png')\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "",
  "history_begin_time" : 1690643670083,
  "history_end_time" : 1690643682971,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "pBrMzld1imNW",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nimport netCDF4 as nc\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport pyproj\n\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\ndef convert_csvs_to_images():\n    # Load the CSV data into a DataFrame\n    data = pd.read_csv('/home/chetana/gridmet_test_run/test_data_prediected.csv')\n\n    # Define the map boundaries for the Western US\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    # Create the Basemap instance\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    # Convert lon/lat to map coordinates\n    x, y = m(data['lon'].values, data['lat'].values)\n\n    # Plot the data using vibrant colors based on predicted_swe\n    plt.scatter(x, y, c=data['predicted_swe'], cmap='coolwarm', s=30, edgecolors='none', alpha=0.7)\n\n    # Add colorbar for reference\n    cbar = plt.colorbar()\n    cbar.set_label('Predicted SWE')\n\n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_nc_file = nc.Dataset('/home/chetana/gridmet_test_run/gridmet_climatology/etr_2023.nc')\n\n    reference_date = datetime(1900, 1, 1)\n    day = reference_nc_file.variables['day'][:]\n    day_value = day[-1]\n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n\n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15)\n    # Show the plot or save it to a file\n    plt.savefig('/home/chetana/gridmet_test_run/predicted_swe.png')\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "",
  "history_begin_time" : 1690483212356,
  "history_end_time" : 1690483222212,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "NB8zj6z0XwdY",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nimport netCDF4 as nc\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport pyproj\n\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\ndef convert_csvs_to_images():\n    # Load the CSV data into a DataFrame\n    data = pd.read_csv('/home/chetana/gridmet_test_run/test_data_prediected.csv')\n\n    # Define the map boundaries for the Western US\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    # Create the Basemap instance\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    # Convert lon/lat to map coordinates\n    x, y = m(data['lon'].values, data['lat'].values)\n\n    # Plot the data using vibrant colors based on predicted_swe\n    plt.scatter(x, y, c=data['predicted_swe'], cmap='coolwarm', s=30, edgecolors='none', alpha=0.7)\n\n    # Add colorbar for reference\n    cbar = plt.colorbar()\n    cbar.set_label('Predicted SWE')\n\n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_nc_file = nc.Dataset('/home/chetana/gridmet_test_run/gridmet_climatology/etr_2023.nc')\n\n    reference_date = datetime(1900, 1, 1)\n    day = reference_nc_file.variables['day'][:]\n    day_value = day[-1]\n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n\n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.2)\n    # Show the plot or save it to a file\n    plt.savefig('/home/chetana/gridmet_test_run/predicted_swe.png')\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "",
  "history_begin_time" : 1690483177053,
  "history_end_time" : 1690483186599,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "58mKehP7xVoV",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nimport netCDF4 as nc\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport pyproj\n\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\ndef convert_csvs_to_images():\n    # Load the CSV data into a DataFrame\n    data = pd.read_csv('/home/chetana/gridmet_test_run/test_data_prediected.csv')\n\n    # Define the map boundaries for the Western US\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    # Create the Basemap instance\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    # Convert lon/lat to map coordinates\n    x, y = m(data['lon'].values, data['lat'].values)\n\n    # Plot the data using vibrant colors based on predicted_swe\n    plt.scatter(x, y, c=data['predicted_swe'], cmap='coolwarm', s=30, edgecolors='none', alpha=0.7)\n\n    # Add colorbar for reference\n    cbar = plt.colorbar()\n    cbar.set_label('Predicted SWE')\n\n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_nc_file = nc.Dataset('/home/chetana/gridmet_test_run/gridmet_climatology/etr_2023.nc')\n\n    reference_date = datetime(1900, 1, 1)\n    day = reference_nc_file.variables['day'][:]\n    day_value = day[-1]\n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n\n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}')\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.2, top=0.85)\n    # Show the plot or save it to a file\n    plt.savefig('/home/chetana/gridmet_test_run/predicted_swe.png')\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "",
  "history_begin_time" : 1690483090647,
  "history_end_time" : 1690483100400,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "ApTzDHmNhMLZ",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nimport netCDF4 as nc\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport pyproj\n\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\ndef convert_csvs_to_images():\n    # Load the CSV data into a DataFrame\n    data = pd.read_csv('/home/chetana/gridmet_test_run/test_data_prediected.csv')\n\n    # Define the map boundaries for the Western US\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    # Create the Basemap instance\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    # Convert lon/lat to map coordinates\n    x, y = m(data['lon'].values, data['lat'].values)\n\n    # Plot the data using vibrant colors based on predicted_swe\n    plt.scatter(x, y, c=data['predicted_swe'], cmap='coolwarm', s=30, edgecolors='none', alpha=0.7)\n\n    # Add colorbar for reference\n    cbar = plt.colorbar()\n    cbar.set_label('Predicted SWE')\n\n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_nc_file = nc.Dataset('/home/chetana/gridmet_test_run/gridmet_climatology/etr_2023.nc')\n\n    reference_date = datetime(1900, 1, 1)\n    day = reference_nc_file.variables['day'][:]\n    day_value = day[-1]\n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n\n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}')\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    # Add a caption at the bottom right of the plot\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Adjust the bottom margin to provide more space at the bottom of the plot\n    plt.subplots_adjust(bottom=0.15, top=0.02)\n    # Show the plot or save it to a file\n    plt.savefig('/home/chetana/gridmet_test_run/predicted_swe.png')\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "Traceback (most recent call last):\n  File \"/home/chetana/gw-workspace/ApTzDHmNhMLZ/convert_results_to_images.py\", line 85, in <module>\n    convert_csvs_to_images()\n  File \"/home/chetana/gw-workspace/ApTzDHmNhMLZ/convert_results_to_images.py\", line 80, in convert_csvs_to_images\n    plt.subplots_adjust(bottom=0.15, top=0.02)\n  File \"/home/chetana/gridmet_test_run/pycrate/lib/python3.9/site-packages/matplotlib/pyplot.py\", line 2335, in subplots_adjust\n    return gcf().subplots_adjust(\n  File \"/home/chetana/gridmet_test_run/pycrate/lib/python3.9/site-packages/matplotlib/figure.py\", line 1353, in subplots_adjust\n    self.subplotpars.update(left, bottom, right, top, wspace, hspace)\n  File \"/home/chetana/gridmet_test_run/pycrate/lib/python3.9/site-packages/matplotlib/figure.py\", line 166, in update\n    raise ValueError('bottom cannot be >= top')\nValueError: bottom cannot be >= top\n",
  "history_begin_time" : 1690483056938,
  "history_end_time" : 1690483062150,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "95HAc7ioq7eq",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nimport netCDF4 as nc\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport pyproj\n\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\ndef convert_csvs_to_images():\n    # Load the CSV data into a DataFrame\n    data = pd.read_csv('/home/chetana/gridmet_test_run/test_data_prediected.csv')\n\n    # Define the map boundaries for the Western US\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    # Create the Basemap instance\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    # Convert lon/lat to map coordinates\n    x, y = m(data['lon'].values, data['lat'].values)\n\n    # Plot the data using vibrant colors based on predicted_swe\n    plt.scatter(x, y, c=data['predicted_swe'], cmap='coolwarm', s=30, edgecolors='none', alpha=0.7)\n\n    # Add colorbar for reference\n    cbar = plt.colorbar()\n    cbar.set_label('Predicted SWE')\n\n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_nc_file = nc.Dataset('/home/chetana/gridmet_test_run/gridmet_climatology/etr_2023.nc')\n\n    reference_date = datetime(1900, 1, 1)\n    day = reference_nc_file.variables['day'][:]\n    day_value = day[-1]\n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n\n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}')\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    # Add a caption at the bottom right of the plot\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Adjust the bottom margin to provide more space at the bottom of the plot\n    plt.subplots_adjust(bottom=0.15, top=2.0)\n    # Show the plot or save it to a file\n    plt.savefig('/home/chetana/gridmet_test_run/predicted_swe.png')\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "",
  "history_begin_time" : 1690483011721,
  "history_end_time" : 1690483021077,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "WPWthtVFGHhT",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nimport netCDF4 as nc\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport pyproj\n\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\ndef convert_csvs_to_images():\n    # Load the CSV data into a DataFrame\n    data = pd.read_csv('/home/chetana/gridmet_test_run/test_data_prediected.csv')\n\n    # Define the map boundaries for the Western US\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    # Create the Basemap instance\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    # Convert lon/lat to map coordinates\n    x, y = m(data['lon'].values, data['lat'].values)\n\n    # Plot the data using vibrant colors based on predicted_swe\n    plt.scatter(x, y, c=data['predicted_swe'], cmap='coolwarm', s=30, edgecolors='none', alpha=0.7)\n\n    # Add colorbar for reference\n    cbar = plt.colorbar()\n    cbar.set_label('Predicted SWE')\n\n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_nc_file = nc.Dataset('/home/chetana/gridmet_test_run/gridmet_climatology/etr_2023.nc')\n\n    reference_date = datetime(1900, 1, 1)\n    day = reference_nc_file.variables['day'][:]\n    day_value = day[-1]\n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n\n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}')\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    # Add a caption at the bottom right of the plot\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Adjust the bottom margin to provide more space at the bottom of the plot\n    plt.subplots_adjust(bottom=0.15, top=0.9)\n    # Show the plot or save it to a file\n    plt.savefig('/home/chetana/gridmet_test_run/predicted_swe.png')\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "",
  "history_begin_time" : 1690482972627,
  "history_end_time" : 1690482982418,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "sWYLWYfVt24W",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nimport netCDF4 as nc\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport pyproj\n\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\ndef convert_csvs_to_images():\n    # Load the CSV data into a DataFrame\n    data = pd.read_csv('/home/chetana/gridmet_test_run/test_data_prediected.csv')\n\n    # Define the map boundaries for the Western US\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    # Create the Basemap instance\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    # Convert lon/lat to map coordinates\n    x, y = m(data['lon'].values, data['lat'].values)\n\n    # Plot the data using vibrant colors based on predicted_swe\n    plt.scatter(x, y, c=data['predicted_swe'], cmap='coolwarm', s=30, edgecolors='none', alpha=0.7)\n\n    # Add colorbar for reference\n    cbar = plt.colorbar()\n    cbar.set_label('Predicted SWE')\n\n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_nc_file = nc.Dataset('/home/chetana/gridmet_test_run/gridmet_climatology/etr_2023.nc')\n\n    reference_date = datetime(1900, 1, 1)\n    day = reference_nc_file.variables['day'][:]\n    day_value = day[-1]\n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n\n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}')\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    # Add a caption at the bottom right of the plot\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Adjust the bottom margin to provide more space at the bottom of the plot\n    plt.subplots_adjust(bottom=0.1)\n    # Show the plot or save it to a file\n    plt.savefig('/home/chetana/gridmet_test_run/predicted_swe.png')\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "",
  "history_begin_time" : 1690482918663,
  "history_end_time" : 1690482928320,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "gvp48MoBdtXr",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nimport netCDF4 as nc\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport pyproj\n\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\ndef convert_csvs_to_images():\n    # Load the CSV data into a DataFrame\n    data = pd.read_csv('/home/chetana/gridmet_test_run/test_data_prediected.csv')\n\n    # Define the map boundaries for the Western US\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    # Create the Basemap instance\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    # Convert lon/lat to map coordinates\n    x, y = m(data['lon'].values, data['lat'].values)\n\n    # Plot the data using vibrant colors based on predicted_swe\n    plt.scatter(x, y, c=data['predicted_swe'], cmap='coolwarm', s=30, edgecolors='none', alpha=0.7)\n\n    # Add colorbar for reference\n    cbar = plt.colorbar()\n    cbar.set_label('Predicted SWE')\n\n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_nc_file = nc.Dataset('/home/chetana/gridmet_test_run/gridmet_climatology/etr_2023.nc')\n\n    reference_date = datetime(1900, 1, 1)\n    day = reference_nc_file.variables['day'][:]\n    day_value = day[-1]\n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n\n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}')\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    # Add a caption at the bottom right of the plot\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Adjust the bottom margin to provide more space at the bottom of the plot\n    plt.subplots_adjust(bottom=0.3)\n    # Show the plot or save it to a file\n    plt.savefig('/home/chetana/gridmet_test_run/predicted_swe.png')\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "",
  "history_begin_time" : 1690481529581,
  "history_end_time" : 1690481539184,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "OAMiBj0fr0T4",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nimport netCDF4 as nc\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport pyproj\n\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\ndef convert_csvs_to_images():\n    # Load the CSV data into a DataFrame\n    data = pd.read_csv('/home/chetana/gridmet_test_run/test_data_prediected.csv')\n\n    # Define the map boundaries for the Western US\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    # Create the Basemap instance\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    # Convert lon/lat to map coordinates\n    x, y = m(data['lon'].values, data['lat'].values)\n\n    # Plot the data using vibrant colors based on predicted_swe\n    plt.scatter(x, y, c=data['predicted_swe'], cmap='coolwarm', s=30, edgecolors='none', alpha=0.7)\n\n    # Add colorbar for reference\n    cbar = plt.colorbar()\n    cbar.set_label('Predicted SWE')\n\n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_nc_file = nc.Dataset('/home/chetana/gridmet_test_run/gridmet_climatology/etr_2023.nc')\n\n    reference_date = datetime(1900, 1, 1)\n    day = reference_nc_file.variables['day'][:]\n    day_value = day[-1]\n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n\n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}')\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    # Add a caption at the bottom right of the plot\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Adjust the bottom margin to provide more space at the bottom of the plot\n    plt.subplots_adjust(bottom=0.1)\n    # Show the plot or save it to a file\n    plt.savefig('/home/chetana/gridmet_test_run/predicted_swe.png')\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "",
  "history_begin_time" : 1690481444258,
  "history_end_time" : 1690481456786,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "33FrKWoVuHBi",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nimport netCDF4 as nc\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport pyproj\n\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\ndef convert_csvs_to_images():\n    # Load the CSV data into a DataFrame\n    data = pd.read_csv('/home/chetana/gridmet_test_run/test_data_prediected.csv')\n\n    # Define the map boundaries for the Western US\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    # Create the Basemap instance\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    # Convert lon/lat to map coordinates\n    x, y = m(data['lon'].values, data['lat'].values)\n\n    # Plot the data using vibrant colors based on predicted_swe\n    plt.scatter(x, y, c=data['predicted_swe'], cmap='coolwarm', s=30, edgecolors='none', alpha=0.7)\n\n    # Add colorbar for reference\n    cbar = plt.colorbar()\n    cbar.set_label('Predicted SWE')\n\n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_nc_file = nc.Dataset('/home/chetana/gridmet_test_run/gridmet_climatology/etr_2023.nc')\n\n    reference_date = datetime(1900, 1, 1)\n    day = reference_nc_file.variables['day'][:]\n    day_value = day[-1]\n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n\n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}')\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    # Add a caption at the bottom right of the plot\n\tplt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Adjust the bottom margin to provide more space at the bottom of the plot\n    plt.subplots_adjust(bottom=0.1)\n    # Show the plot or save it to a file\n    plt.savefig('/home/chetana/gridmet_test_run/predicted_swe.png')\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "  File \"/home/chetana/gw-workspace/33FrKWoVuHBi/convert_results_to_images.py\", line 75\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\nTabError: inconsistent use of tabs and spaces in indentation\n",
  "history_begin_time" : 1690481330585,
  "history_end_time" : 1690481331606,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "QvQnH8kH6pqS",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nimport netCDF4 as nc\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport pyproj\n\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\ndef convert_csvs_to_images():\n    # Load the CSV data into a DataFrame\n    data = pd.read_csv('/home/chetana/gridmet_test_run/test_data_prediected.csv')\n\n    # Define the map boundaries for the Western US\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    # Create the Basemap instance\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    # Convert lon/lat to map coordinates\n    x, y = m(data['lon'].values, data['lat'].values)\n\n    # Plot the data using vibrant colors based on predicted_swe\n    plt.scatter(x, y, c=data['predicted_swe'], cmap='coolwarm', s=30, edgecolors='none', alpha=0.7)\n\n    # Add colorbar for reference\n    cbar = plt.colorbar()\n    cbar.set_label('Predicted SWE')\n\n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_nc_file = nc.Dataset('/home/chetana/gridmet_test_run/gridmet_climatology/etr_2023.nc')\n\n    reference_date = datetime(1900, 1, 1)\n    day = reference_nc_file.variables['day'][:]\n    day_value = day[-1]\n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n\n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}')\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    # Add a caption at the bottom right of the plot\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n    # Show the plot or save it to a file\n    plt.savefig('/home/chetana/gridmet_test_run/predicted_swe.png')\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "",
  "history_begin_time" : 1690472839524,
  "history_end_time" : 1690472849641,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "HQVItE0b2whm",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nimport netCDF4 as nc\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport pyproj\n\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\ndef convert_csvs_to_images():\n    # Load the CSV data into a DataFrame\n    data = pd.read_csv('/home/chetana/gridmet_test_run/test_data_prediected.csv')\n\n    # Define the map boundaries for the Western US\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    # Create the Basemap instance\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    # Convert lon/lat to map coordinates\n    x, y = m(data['lon'].values, data['lat'].values)\n\n    # Plot the data using vibrant colors based on predicted_swe\n    plt.scatter(x, y, c=data['predicted_swe'], cmap='coolwarm', s=30, edgecolors='none', alpha=0.7)\n\n    # Add colorbar for reference\n    cbar = plt.colorbar()\n    cbar.set_label('Predicted SWE')\n\n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_nc_file = nc.Dataset('/home/chetana/gridmet_test_run/gridmet_climatology/etr_2023.nc')\n\n    reference_date = datetime(1900, 1, 1)\n    day = reference_nc_file.variables['day'][:]\n    day_value = day[-1]\n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n\n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}')\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    # Add a caption at the bottom right of the plot\n    plt.text(0.98, 0.98, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='top',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n    # Show the plot or save it to a file\n    plt.savefig('/home/chetana/gridmet_test_run/predicted_swe.png')\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "",
  "history_begin_time" : 1690472766248,
  "history_end_time" : 1690472775958,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "FV6dtxOfco8m",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nimport netCDF4 as nc\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport pyproj\n\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\ndef convert_csvs_to_images():\n    # Load the CSV data into a DataFrame\n    data = pd.read_csv('/home/chetana/gridmet_test_run/test_data_prediected.csv')\n\n    # Define the map boundaries for the Western US\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    # Create the Basemap instance\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    # Convert lon/lat to map coordinates\n    x, y = m(data['lon'].values, data['lat'].values)\n\n    # Plot the data using vibrant colors based on predicted_swe\n    plt.scatter(x, y, c=data['predicted_swe'], cmap='coolwarm', s=30, edgecolors='none', alpha=0.7)\n\n    # Add colorbar for reference\n    cbar = plt.colorbar()\n    cbar.set_label('Predicted SWE')\n\n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_nc_file = nc.Dataset('/home/chetana/gridmet_test_run/gridmet_climatology/etr_2023.nc')\n\n    reference_date = datetime(1900, 1, 1)\n    day = reference_nc_file.variables['day'][:]\n    day_value = day[-1]\n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n\n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}')\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    # Add a caption at the bottom right of the plot\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gca().transAxes, fontsize=6)\n    plt.subplots_adjust(bottom=0.12)\n    # Show the plot or save it to a file\n    plt.savefig('/home/chetana/gridmet_test_run/predicted_swe.png')\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "",
  "history_begin_time" : 1690472354362,
  "history_end_time" : 1690472364289,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "DyAtf2JGBXnu",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nimport netCDF4 as nc\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport pyproj\n\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\ndef convert_csvs_to_images():\n    # Load the CSV data into a DataFrame\n    data = pd.read_csv('/home/chetana/gridmet_test_run/test_data_prediected.csv')\n\n    # Define the map boundaries for the Western US\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    # Create the Basemap instance\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    # Convert lon/lat to map coordinates\n    x, y = m(data['lon'].values, data['lat'].values)\n\n    # Plot the data using vibrant colors based on predicted_swe\n    plt.scatter(x, y, c=data['predicted_swe'], cmap='coolwarm', s=30, edgecolors='none', alpha=0.7)\n\n    # Add colorbar for reference\n    cbar = plt.colorbar()\n    cbar.set_label('Predicted SWE')\n\n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_nc_file = nc.Dataset('/home/chetana/gridmet_test_run/gridmet_climatology/etr_2023.nc')\n\n    reference_date = datetime(1900, 1, 1)\n    day = reference_nc_file.variables['day'][:]\n    day_value = day[-1]\n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n\n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}')\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    # Add a caption at the bottom right of the plot\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gca().transAxes, fontsize=6)\n\tplt.subplots_adjust(bottom=0.12)\n    # Show the plot or save it to a file\n    plt.savefig('/home/chetana/gridmet_test_run/predicted_swe.png')\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "  File \"/home/chetana/gw-workspace/DyAtf2JGBXnu/convert_results_to_images.py\", line 78\n    plt.subplots_adjust(bottom=0.12)\nTabError: inconsistent use of tabs and spaces in indentation\n",
  "history_begin_time" : 1690472341161,
  "history_end_time" : 1690472342194,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "XWn0m1dTgP99",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nimport netCDF4 as nc\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport pyproj\n\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\ndef convert_csvs_to_images():\n    # Load the CSV data into a DataFrame\n    data = pd.read_csv('/home/chetana/gridmet_test_run/test_data_prediected.csv')\n\n    # Define the map boundaries for the Western US\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    # Create the Basemap instance\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    # Convert lon/lat to map coordinates\n    x, y = m(data['lon'].values, data['lat'].values)\n\n    # Plot the data using vibrant colors based on predicted_swe\n    plt.scatter(x, y, c=data['predicted_swe'], cmap='coolwarm', s=30, edgecolors='none', alpha=0.7)\n\n    # Add colorbar for reference\n    cbar = plt.colorbar()\n    cbar.set_label('Predicted SWE')\n\n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_nc_file = nc.Dataset('/home/chetana/gridmet_test_run/gridmet_climatology/etr_2023.nc')\n\n    reference_date = datetime(1900, 1, 1)\n    day = reference_nc_file.variables['day'][:]\n    day_value = day[-1]\n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n\n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}')\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    # Add a caption at the bottom right of the plot\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gca().transAxes, fontsize=6)\n\n    # Show the plot or save it to a file\n    plt.savefig('/home/chetana/gridmet_test_run/predicted_swe.png')\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "",
  "history_begin_time" : 1690471092074,
  "history_end_time" : 1690471101807,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "nwAGyTRJa0us",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nimport netCDF4 as nc\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport pyproj\n\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\ndef convert_csvs_to_images():\n    # Load the CSV data into a DataFrame\n    data = pd.read_csv('/home/chetana/gridmet_test_run/test_data_prediected.csv')\n\n    # Define the map boundaries for the Western US\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    # Create the Basemap instance\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    # Convert lon/lat to map coordinates\n    x, y = m(data['lon'].values, data['lat'].values)\n\n    # Plot the data using vibrant colors based on predicted_swe\n    plt.scatter(x, y, c=data['predicted_swe'], cmap='coolwarm', s=30, edgecolors='none', alpha=0.7)\n\n    # Add colorbar for reference\n    cbar = plt.colorbar()\n    cbar.set_label('Predicted SWE')\n\n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_nc_file = nc.Dataset('/home/chetana/gridmet_test_run/gridmet_climatology/etr_2023.nc')\n\n    reference_date = datetime(1900, 1, 1)\n    day = reference_nc_file.variables['day'][:]\n    day_value = day[-1]\n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n\n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}')\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    # Add a caption at the bottom of the plot\n    plt.text(0.5, -0.1, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='center', verticalalignment='center',\n             transform=plt.gca().transAxes, fontsize=6)\n\n    # Show the plot or save it to a file\n    plt.savefig('/home/chetana/gridmet_test_run/predicted_swe.png')\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "",
  "history_begin_time" : 1690470882261,
  "history_end_time" : 1690470891978,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "I63u5YFiLlbi",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nimport netCDF4 as nc\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport pyproj\n\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\ndef convert_csvs_to_images():\n    # Load the CSV data into a DataFrame\n    data = pd.read_csv('/home/chetana/gridmet_test_run/test_data_prediected.csv')\n\n    # Define the map boundaries for the Western US\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    # Create the Basemap instance\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    # Convert lon/lat to map coordinates\n    x, y = m(data['lon'].values, data['lat'].values)\n\n    # Plot the data using vibrant colors based on predicted_swe\n    plt.scatter(x, y, c=data['predicted_swe'], cmap='coolwarm', s=30, edgecolors='none', alpha=0.7)\n\n    # Add colorbar for reference\n    cbar = plt.colorbar()\n    cbar.set_label('Predicted SWE')\n\n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_nc_file = nc.Dataset('/home/chetana/gridmet_test_run/gridmet_climatology/etr_2023.nc')\n\n    reference_date = datetime(1900, 1, 1)\n    day = reference_nc_file.variables['day'][:]\n    day_value = day[-1]\n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n\n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}')\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    # Add a caption at the bottom of the plot\n    plt.text(0.5, -0.1, 'Plot generated by swe_wormhole team',\n             horizontalalignment='center', verticalalignment='center',\n             transform=plt.gca().transAxes, fontsize=6)\n\n    # Show the plot or save it to a file\n    plt.savefig('/home/chetana/gridmet_test_run/predicted_swe.png')\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "",
  "history_begin_time" : 1690470745794,
  "history_end_time" : 1690470755428,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "8mx1m6vQlK1C",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nimport netCDF4 as nc\nfrom datetime import timedelta, datetime\nimport numpy as np\n\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\ndef convert_csvs_to_images():\n    # Load the CSV data into a DataFrame\n    data = pd.read_csv('/home/chetana/gridmet_test_run/test_data_prediected.csv')\n\n    # Define the map boundaries for the Western US\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    # Create the Basemap instance\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    # Convert lon/lat to map coordinates\n    x, y = m(data['lon'].values, data['lat'].values)\n\n    # Plot the data using vibrant colors based on predicted_swe\n    plt.scatter(x, y, c=data['predicted_swe'], cmap='coolwarm', s=30, edgecolors='none', alpha=0.7)\n\n    # Add colorbar for reference\n    cbar = plt.colorbar()\n    cbar.set_label('Predicted SWE')\n\n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_nc_file = nc.Dataset('/home/chetana/gridmet_test_run/gridmet_climatology/etr_2023.nc')\n\n    reference_date = datetime(1900, 1, 1)\n    day = reference_nc_file.variables['day'][:]\n    day_value = day[-1]\n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n\n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}')\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates(lon_min, y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    # Add a caption at the bottom of the plot\n    plt.text(0.5, -0.1, 'Plot generated by swe_wormhole team',\n             horizontalalignment='center', verticalalignment='center',\n             transform=plt.gca().transAxes, fontsize=6)\n\n    # Show the plot or save it to a file\n    plt.savefig('/home/chetana/gridmet_test_run/predicted_swe.png')\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "Traceback (most recent call last):\n  File \"/home/chetana/gw-workspace/8mx1m6vQlK1C/convert_results_to_images.py\", line 82, in <module>\n    convert_csvs_to_images()\n  File \"/home/chetana/gw-workspace/8mx1m6vQlK1C/convert_results_to_images.py\", line 68, in convert_csvs_to_images\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates(lon_min, y_tick_positions, m)\n  File \"/home/chetana/gw-workspace/8mx1m6vQlK1C/convert_results_to_images.py\", line 9, in lat_lon_to_map_coordinates\n    x, y = m(lon, lat)\n  File \"/home/chetana/gridmet_test_run/pycrate/lib/python3.9/site-packages/mpl_toolkits/basemap/__init__.py\", line 1195, in __call__\n    xout,yout = self.projtran(x,y,inverse=inverse)\n  File \"/home/chetana/gridmet_test_run/pycrate/lib/python3.9/site-packages/mpl_toolkits/basemap/proj.py\", line 295, in __call__\n    outx,outy = self._proj4(x, y, inverse=inverse)\n  File \"/home/chetana/gridmet_test_run/pycrate/lib/python3.9/site-packages/pyproj/proj.py\", line 195, in __call__\n    return self.transform(\n  File \"/home/chetana/gridmet_test_run/pycrate/lib/python3.9/site-packages/pyproj/transformer.py\", line 835, in transform\n    self._transformer._transform(\n  File \"pyproj/_transformer.pyx\", line 692, in pyproj._transformer._Transformer._transform\npyproj.exceptions.ProjError: x, y, z, and time must be same size if included.\n",
  "history_begin_time" : 1690470681913,
  "history_end_time" : 1690470687306,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "7OMjYWfwTA4f",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nimport netCDF4 as nc\nfrom datetime import timedelta, datetime\nimport numpy as np\n\ndef convert_csvs_to_images():\n    # Load the CSV data into a DataFrame\n    data = pd.read_csv('/home/chetana/gridmet_test_run/test_data_prediected.csv')\n\n    # Define the map boundaries for the Western US\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    # Create the Basemap instance\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    # Convert lon/lat to map coordinates\n    x, y = m(data['lon'].values, data['lat'].values)\n\n    # Plot the data using vibrant colors based on predicted_swe\n    plt.scatter(x, y, c=data['predicted_swe'], cmap='coolwarm', s=30, edgecolors='none', alpha=0.7)\n\n    # Add colorbar for reference\n    cbar = plt.colorbar()\n    cbar.set_label('Predicted SWE')\n\n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_nc_file = nc.Dataset('/home/chetana/gridmet_test_run/gridmet_climatology/etr_2023.nc')\n\n    reference_date = datetime(1900, 1, 1)\n    day = reference_nc_file.variables['day'][:]\n    day_value = day[-1]\n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n\n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}')\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Add a caption at the bottom of the plot\n    plt.text(0.5, -0.1, 'Plot generated by swe_wormhole team',\n             horizontalalignment='center', verticalalignment='center',\n             transform=plt.gca().transAxes, fontsize=6)\n\n    # Show the plot or save it to a file\n    plt.savefig('/home/chetana/gridmet_test_run/predicted_swe.png')\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "",
  "history_begin_time" : 1690470486335,
  "history_end_time" : 1690470496183,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "HkFNj0QJnlOC",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nimport netCDF4 as nc\nfrom datetime import timedelta, datetime\nimport numpy as np\n\ndef convert_csvs_to_images():\n    # Load the CSV data into a DataFrame\n    data = pd.read_csv('/home/chetana/gridmet_test_run/test_data_prediected.csv')\n\n    # Define the map boundaries for the Western US\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    # Create the Basemap instance\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    # Convert lon/lat to map coordinates\n    x, y = m(data['lon'].values, data['lat'].values)\n\n    # Plot the data using vibrant colors based on predicted_swe\n    plt.scatter(x, y, c=data['predicted_swe'], cmap='viridis', s=30, edgecolors='none', alpha=0.7)\n\n    # Add colorbar for reference\n    cbar = plt.colorbar()\n    cbar.set_label('Predicted SWE')\n\n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_nc_file = nc.Dataset('/home/chetana/gridmet_test_run/gridmet_climatology/etr_2023.nc')\n\n    reference_date = datetime(1900, 1, 1)\n    day = reference_nc_file.variables['day'][:]\n    day_value = day[-1]\n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n\n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}')\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Add a caption at the bottom of the plot\n    plt.text(0.5, -0.1, 'Plot generated by swe_wormhole team',\n             horizontalalignment='center', verticalalignment='center',\n             transform=plt.gca().transAxes, fontsize=6)\n\n    # Show the plot or save it to a file\n    plt.savefig('/home/chetana/gridmet_test_run/predicted_swe.png')\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "",
  "history_begin_time" : 1690470407565,
  "history_end_time" : 1690470417196,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "OA3tLsNyIV8J",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nimport netCDF4 as nc\nfrom datetime import timedelta, datetime\nimport numpy as np\n\ndef convert_csvs_to_images():\n    # Load the CSV data into a DataFrame\n    data = pd.read_csv('/home/chetana/gridmet_test_run/test_data_prediected.csv')\n\n    # Define the map boundaries for the Western US\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    # Create the Basemap instance\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    # Convert lon/lat to map coordinates\n    x, y = m(data['lon'].values, data['lat'].values)\n\n    # Plot the data using vibrant colors based on predicted_swe\n    plt.scatter(x, y, c=data['predicted_swe'], cmap='plasma', s=30, edgecolors='none', alpha=0.7)\n\n    # Add colorbar for reference\n    cbar = plt.colorbar()\n    cbar.set_label('Predicted SWE')\n\n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_nc_file = nc.Dataset('/home/chetana/gridmet_test_run/gridmet_climatology/etr_2023.nc')\n\n    reference_date = datetime(1900, 1, 1)\n    day = reference_nc_file.variables['day'][:]\n    day_value = day[-1]\n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n\n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}')\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Add a caption at the bottom of the plot\n    plt.text(0.5, -0.1, 'Plot generated by swe_wormhole team',\n             horizontalalignment='center', verticalalignment='center',\n             transform=plt.gca().transAxes, fontsize=6)\n\n    # Show the plot or save it to a file\n    plt.savefig('/home/chetana/gridmet_test_run/predicted_swe.png')\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "",
  "history_begin_time" : 1690470310545,
  "history_end_time" : 1690470320491,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "68uCFakuhPlb",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nimport netCDF4 as nc\nfrom datetime import timedelta, datetime\nimport numpy as np\n\ndef convert_csvs_to_images():\n    # Load the CSV data into a DataFrame\n    data = pd.read_csv('/home/chetana/gridmet_test_run/test_data_prediected.csv')\n\n    # Define the map boundaries for the Western US\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    # Create the Basemap instance\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    # Convert lon/lat to map coordinates\n    x, y = m(data['lon'].values, data['lat'].values)\n\n    # Plot the data using vibrant colors based on predicted_swe\n    plt.scatter(x, y, c=data['predicted_swe'], cmap='plasma', s=30, edgecolors='none', alpha=0.7)\n\n    # Add colorbar for reference\n    cbar = plt.colorbar()\n    cbar.set_label('Predicted SWE')\n\n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_nc_file = nc.Dataset('/home/chetana/gridmet_test_run/gridmet_climatology/etr_2023.nc')\n\n    reference_date = datetime(1900, 1, 1)\n    day = reference_nc_file.variables['day'][:]\n    day_value = day[-1]\n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n\n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}')\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Add a caption at the bottom of the plot\n    plt.text(0.5, -0.1, 'Plot generated by swe_wormhole team',\n             horizontalalignment='center', verticalalignment='center',\n             transform=plt.gca().transAxes, fontsize=6)\n\n    # Show the plot or save it to a file\n    plt.savefig('/home/chetana/gridmet_test_run/predicted_swe.png')\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "",
  "history_begin_time" : 1690470155899,
  "history_end_time" : 1690470165704,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "i0p0gn0ulWvj",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nimport netCDF4 as nc\nfrom datetime import timedelta, datetime\nimport numpy as np\n\ndef convert_csvs_to_images():\n    # Load the CSV data into a DataFrame\n    data = pd.read_csv('/home/chetana/gridmet_test_run/test_data_prediected.csv')\n\n    # Define the map boundaries for the Western US\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    # Create the Basemap instance\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    # Convert lon/lat to map coordinates\n    x, y = m(data['lon'].values, data['lat'].values)\n\n    # Plot the data using vibrant colors based on predicted_swe\n    plt.scatter(x, y, c=data['predicted_swe'], cmap='plasma', s=30, edgecolors='none', alpha=0.7)\n\n    # Add colorbar for reference\n    cbar = plt.colorbar()\n    cbar.set_label('Predicted SWE')\n\n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_nc_file = nc.Dataset('/home/chetana/gridmet_test_run/gridmet_climatology/etr_2023.nc')\n\n    reference_date = datetime(1900, 1, 1)\n    day = reference_nc_file.variables['day'][:]\n    day_value = day[-1]\n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n\n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}')\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Add a caption at the bottom of the plot\n    plt.text(0.5, -0.1, 'Plot generated by swe_wormhole team',\n             horizontalalignment='center', verticalalignment='center',\n             transform=plt.gca().transAxes, fontsize=6)\n\n    # Show the plot or save it to a file\n    plt.savefig('/home/chetana/gridmet_test_run/predicted_swe.png')\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "",
  "history_begin_time" : 1690470054781,
  "history_end_time" : 1690470064567,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "nOn0dx97skhR",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nimport netCDF4 as nc\nfrom datetime import timedelta, datetime\nimport numpy as np\n\ndef convert_csvs_to_images():\n    # Load the CSV data into a DataFrame\n    data = pd.read_csv('/home/chetana/gridmet_test_run/test_data_prediected.csv')\n\n    # Define the map boundaries for the Western US\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    # Create the Basemap instance\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    # Convert lon/lat to map coordinates\n    x, y = m(data['lon'].values, data['lat'].values)\n\n    # Plot the data using vibrant colors based on predicted_swe\n    plt.scatter(x, y, c=data['predicted_swe'], cmap='plasma', s=30, edgecolors='none', alpha=0.7)\n\n    # Add colorbar for reference\n    cbar = plt.colorbar()\n    cbar.set_label('Predicted SWE')\n\n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_nc_file = nc.Dataset('/home/chetana/gridmet_test_run/gridmet_climatology/etr_2023.nc')\n\n    reference_date = datetime(1900, 1, 1)\n    day = reference_nc_file.variables['day'][:]\n    day_value = day[-1]\n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n\n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}')\n\n    # Add labels for latitude and longitude on x and y axes\n    plt.xlabel('Longitude', fontsize=10)\n    plt.ylabel('Latitude', fontsize=10)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=8, rotation=45)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Remove tick labels on the y-axis\n    plt.gca().set_yticklabels([])\n\n    # Add a caption at the bottom of the plot\n    plt.text(0.5, -0.1, 'Plot generated by swe_wormhole team',\n             horizontalalignment='center', verticalalignment='center',\n             transform=plt.gca().transAxes, fontsize=8)\n\n    # Show the plot or save it to a file\n    plt.savefig('/home/chetana/gridmet_test_run/predicted_swe.png')\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "",
  "history_begin_time" : 1690469951631,
  "history_end_time" : 1690469961248,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "R89bYwMEtPwN",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nimport netCDF4 as nc\nfrom datetime import timedelta, datetime\nimport numpy as np\n\ndef convert_csvs_to_images():\n    # Load the CSV data into a DataFrame\n    data = pd.read_csv('/home/chetana/gridmet_test_run/test_data_prediected.csv')\n\n    # Define the map boundaries for the Western US\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    # Create the Basemap instance\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    # Convert lon/lat to map coordinates\n    x, y = m(data['lon'].values, data['lat'].values)\n\n    # Plot the data using vibrant colors based on predicted_swe\n    plt.scatter(x, y, c=data['predicted_swe'], cmap='plasma', s=30, edgecolors='none', alpha=0.7)\n\n    # Add colorbar for reference\n    cbar = plt.colorbar()\n    cbar.set_label('Predicted SWE')\n\n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_nc_file = nc.Dataset('/home/chetana/gridmet_test_run/gridmet_climatology/etr_2023.nc')\n\n    reference_date = datetime(1900, 1, 1)\n    day = reference_nc_file.variables['day'][:]\n    day_value = day[-1]\n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n\n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}')\n\n    # Add labels for latitude and longitude on x and y axes\n    plt.xlabel('Longitude', fontsize=10)\n    plt.ylabel('Latitude', fontsize=10)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), labels=x_tick_labels_str, fontsize=8, rotation=45)\n\n    # Remove tick labels on the y-axis\n    plt.gca().set_yticklabels([])\n\n    # Add a caption at the bottom of the plot\n    plt.text(0.5, -0.1, 'Plot generated by swe_wormhole team',\n             horizontalalignment='center', verticalalignment='center',\n             transform=plt.gca().transAxes, fontsize=8)\n\n    # Show the plot or save it to a file\n    plt.savefig('/home/chetana/gridmet_test_run/predicted_swe.png')\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "Traceback (most recent call last):\n  File \"/home/chetana/gw-workspace/R89bYwMEtPwN/convert_results_to_images.py\", line 67, in <module>\n    convert_csvs_to_images()\n  File \"/home/chetana/gw-workspace/R89bYwMEtPwN/convert_results_to_images.py\", line 53, in convert_csvs_to_images\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), labels=x_tick_labels_str, fontsize=8, rotation=45)\nTypeError: xticks() got multiple values for argument 'labels'\n",
  "history_begin_time" : 1690469891514,
  "history_end_time" : 1690469896713,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "uhGTTT4DY11r",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nimport netCDF4 as nc\nfrom datetime import timedelta, datetime\nimport numpy as np\n\ndef convert_csvs_to_images():\n    # Load the CSV data into a DataFrame\n    data = pd.read_csv('/home/chetana/gridmet_test_run/test_data_prediected.csv')\n\n    # Define the map boundaries for the Western US\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    # Create the Basemap instance\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    # Convert lon/lat to map coordinates\n    x, y = m(data['lon'].values, data['lat'].values)\n\n    # Plot the data using vibrant colors based on predicted_swe\n    plt.scatter(x, y, c=data['predicted_swe'], cmap='plasma', s=30, edgecolors='none', alpha=0.7)\n\n    # Add colorbar for reference\n    cbar = plt.colorbar()\n    cbar.set_label('Predicted SWE')\n\n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_nc_file = nc.Dataset('/home/chetana/gridmet_test_run/gridmet_climatology/etr_2023.nc')\n\n    reference_date = datetime(1900, 1, 1)\n    day = reference_nc_file.variables['day'][:]\n    day_value = day[-1]\n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n\n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}')\n\n    # Add labels for latitude and longitude on x and y axes\n    plt.xlabel('Longitude', fontsize=12)\n    plt.ylabel('Latitude', fontsize=12)\n\n    # Add latitude and longitude values to the x and y axes\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n\n    # Convert longitude values to a formatted string\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    # Convert latitude values to a formatted string\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), rotation=45)\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels))\n\n    # Set the tick labels for x and y axes\n    plt.gca().set_xticklabels(x_tick_labels_str, fontsize=10)\n    plt.gca().set_yticklabels(y_tick_labels_str, fontsize=10)\n\n    # Add a caption at the bottom of the plot\n    plt.text(0.5, -0.1, 'Plot generated by swe_wormhole team',\n             horizontalalignment='center', verticalalignment='center',\n             transform=plt.gca().transAxes, fontsize=10)\n\n    # Show the plot or save it to a file\n    plt.savefig('/home/chetana/gridmet_test_run/predicted_swe.png')\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "",
  "history_begin_time" : 1690469734666,
  "history_end_time" : 1690469744374,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "jXg8nXGDDkDX",
  "history_input" : "import pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nimport netCDF4 as nc\nfrom datetime import timedelta, datetime\n\ndef convert_csvs_to_images():\n    # Load the CSV data into a DataFrame\n    data = pd.read_csv('/home/chetana/gridmet_test_run/test_data_prediected.csv')\n\n    # Define the map boundaries for the Western US\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    # Create the Basemap instance\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    # Convert lon/lat to map coordinates\n    x, y = m(data['lon'].values, data['lat'].values)\n\n    # Plot the data using vibrant colors based on predicted_swe\n    plt.scatter(x, y, c=data['predicted_swe'], cmap='plasma', s=30, edgecolors='none', alpha=0.7)\n\n    # Add colorbar for reference\n    cbar = plt.colorbar()\n    cbar.set_label('Predicted SWE')\n\n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_nc_file = nc.Dataset('/home/chetana/gridmet_test_run/gridmet_climatology/etr_2023.nc')\n\n    reference_date = datetime(1900, 1, 1)\n    day = reference_nc_file.variables['day'][:]\n    day_value = day[-1]\n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n\n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}')\n\n    # Add labels for latitude and longitude on x and y axes\n    plt.xlabel('Longitude')\n    plt.ylabel('Latitude')\n\n    # Add a caption at the bottom of the plot\n    plt.text(0.5, -0.1, 'Plot generated by swe_wormhole team',\n             horizontalalignment='center', verticalalignment='center',\n             transform=plt.gca().transAxes, fontsize=10)\n\n    # Add latitude and longitude values to the x and y axes\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), rotation=45)\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels))\n\n    # Show the plot or save it to a file\n    plt.savefig('/home/chetana/gridmet_test_run/predicted_swe.png')\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "",
  "history_begin_time" : 1690469512047,
  "history_end_time" : 1690469521681,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "L5lgGNoOFuLt",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nimport netCDF4 as nc\nfrom datetime import timedelta, datetime\n\ndef convert_csvs_to_images():\n    # Load the CSV data into a DataFrame\n    data = pd.read_csv('/home/chetana/gridmet_test_run/test_data_prediected.csv')\n\n    # Define the map boundaries for the Western US\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    # Create the Basemap instance\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    # Convert lon/lat to map coordinates\n    x, y = m(data['lon'].values, data['lat'].values)\n\n    # Plot the data using vibrant colors based on predicted_swe\n    plt.scatter(x, y, c=data['predicted_swe'], cmap='plasma', s=30, edgecolors='none', alpha=0.7)\n\n    # Add colorbar for reference\n    cbar = plt.colorbar()\n    cbar.set_label('Predicted SWE')\n\n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_nc_file = nc.Dataset('/home/chetana/gridmet_test_run/gridmet_climatology/etr_2023.nc')\n\n    reference_date = datetime(1900, 1, 1)\n    day = reference_nc_file.variables['day'][:]\n    day_value = day[-1]\n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n\n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}')\n\n    # Add labels for latitude and longitude on x and y axes\n    plt.xlabel('Longitude')\n    plt.ylabel('Latitude')\n\n    # Add a caption at the bottom of the plot\n    plt.text(0.5, -0.1, 'Plot generated by swe_wormhole team',\n             horizontalalignment='center', verticalalignment='center',\n             transform=plt.gca().transAxes, fontsize=10)\n\n    # Add latitude and longitude values to the x and y axes\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), rotation=45)\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels))\n\n    # Show the plot or save it to a file\n    plt.savefig('/home/chetana/gridmet_test_run/predicted_swe.png')\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "Traceback (most recent call last):\n  File \"/home/chetana/gw-workspace/L5lgGNoOFuLt/convert_results_to_images.py\", line 64, in <module>\n    convert_csvs_to_images()\n  File \"/home/chetana/gw-workspace/L5lgGNoOFuLt/convert_results_to_images.py\", line 55, in convert_csvs_to_images\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\nNameError: name 'np' is not defined\n",
  "history_begin_time" : 1690469493785,
  "history_end_time" : 1690469499013,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "YrnWP97xlvtL",
  "history_input" : "def convert_csvs_to_images():\n    # Load the CSV data into a DataFrame\n    data = pd.read_csv('/home/chetana/gridmet_test_run/test_data_prediected.csv')\n\n    # Define the map boundaries for the Western US\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    # Create the Basemap instance\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    # Convert lon/lat to map coordinates\n    x, y = m(data['lon'].values, data['lat'].values)\n\n    # Plot the data using vibrant colors based on predicted_swe\n    plt.scatter(x, y, c=data['predicted_swe'], cmap='plasma', s=30, edgecolors='none', alpha=0.7)\n\n    # Add colorbar for reference\n    cbar = plt.colorbar()\n    cbar.set_label('Predicted SWE')\n\n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_nc_file = nc.Dataset('/home/chetana/gridmet_test_run/gridmet_climatology/etr_2023.nc')\n\n    reference_date = datetime(1900, 1, 1)\n    day = reference_nc_file.variables['day'][:]\n    day_value = day[-1]\n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n\n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}')\n\n    # Add labels for latitude and longitude on x and y axes\n    plt.xlabel('Longitude')\n    plt.ylabel('Latitude')\n\n    # Add a caption at the bottom of the plot\n    plt.text(0.5, -0.1, 'Plot generated by swe_wormhole team',\n             horizontalalignment='center', verticalalignment='center',\n             transform=plt.gca().transAxes, fontsize=10)\n\n    # Add latitude and longitude values to the x and y axes\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), rotation=45)\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels))\n\n    # Show the plot or save it to a file\n    plt.savefig('/home/chetana/gridmet_test_run/predicted_swe.png')\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "Traceback (most recent call last):\n  File \"/home/chetana/gw-workspace/YrnWP97xlvtL/convert_results_to_images.py\", line 58, in <module>\n    convert_csvs_to_images()\n  File \"/home/chetana/gw-workspace/YrnWP97xlvtL/convert_results_to_images.py\", line 3, in convert_csvs_to_images\n    data = pd.read_csv('/home/chetana/gridmet_test_run/test_data_prediected.csv')\nNameError: name 'pd' is not defined\n",
  "history_begin_time" : 1690469436669,
  "history_end_time" : 1690469437713,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "gHamHFOuq39h",
  "history_input" : "# convert the model prediction into images. The testing.csv will be resulted in a corresponding csv with the values for all the coordinates. \nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nimport netCDF4 as nc\nfrom datetime import timedelta, datetime\n\n\ndef convert_csvs_to_images():\n  # Load the CSV data into a DataFrame\n  data = pd.read_csv('/home/chetana/gridmet_test_run/test_data_prediected.csv')\n\n  # Define the map boundaries for the Western US\n  lon_min, lon_max = -125, -100\n  lat_min, lat_max = 25, 49.5\n\n  # Create the Basemap instance\n  m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n              projection='merc', resolution='i')\n\n  # Convert lon/lat to map coordinates\n  x, y = m(data['lon'].values, data['lat'].values)\n\n  # Plot the data using vibrant colors based on predicted_swe\n  plt.scatter(x, y, c=data['predicted_swe'], cmap='plasma', s=30, edgecolors='none', alpha=0.7)\n\n  # Add colorbar for reference\n  cbar = plt.colorbar()\n  cbar.set_label('Predicted SWE')\n\n  # Draw coastlines and other map features\n  m.drawcoastlines()\n  m.drawcountries()\n  m.drawstates()\n  \n  reference_nc_file = nc.Dataset('/home/chetana/gridmet_test_run/gridmet_climatology/etr_2023.nc')\n\n  reference_date = datetime(1900, 1, 1)\n  day = reference_nc_file.variables['day'][:]\n  day_value = day[-1]\n  result_date = reference_date + timedelta(days=day_value)\n  today = result_date.strftime(\"%Y-%m-%d\")\n\n\t# Add a title\n  plt.title(f'Predicted SWE in the Western US - {today}')\n  # Show the plot\n  plt.savefig('/home/chetana/gridmet_test_run/predicted_swe.png')\n\n            \n\n\nconvert_csvs_to_images()\n\n\n\n",
  "history_output" : "",
  "history_begin_time" : 1690467306321,
  "history_end_time" : 1690467318837,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "1zdRjRRFMWxL",
  "history_input" : "# convert the model prediction into images. The testing.csv will be resulted in a corresponding csv with the values for all the coordinates. \nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nimport netCDF4 as nc\nfrom datetime import timedelta, datetime\n\n\ndef convert_csvs_to_images():\n  # Load the CSV data into a DataFrame\n  data = pd.read_csv('/home/chetana/gridmet_test_run/test_data_prediected.csv')\n\n  # Define the map boundaries for the Western US\n  lon_min, lon_max = -125, -100\n  lat_min, lat_max = 25, 49.5\n\n  # Create the Basemap instance\n  m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n              projection='merc', resolution='i')\n\n  # Convert lon/lat to map coordinates\n  x, y = m(data['lon'].values, data['lat'].values)\n\n  # Plot the data using vibrant colors based on predicted_swe\n  plt.scatter(x, y, c=data['predicted_swe'], cmap='plasma', s=30, edgecolors='none', alpha=0.7)\n\n  # Add colorbar for reference\n  cbar = plt.colorbar()\n  cbar.set_label('Predicted SWE')\n\n  # Draw coastlines and other map features\n  m.drawcoastlines()\n  m.drawcountries()\n  m.drawstates()\n  \n  reference_nc_file = nc.Dataset('/home/chetana/gridmet_test_run/gridmet_climatology/etr_2023.nc')\n\n  reference_date = datetime(1900, 1, 1)\n  day = reference_nc_file.variables['day'][:]\n  day_value = day[-1]\n  result_date = reference_date + timedelta(days=given_days)\n  today = result_date.strftime(\"%Y-%m-%d\")\n\n\t# Add a title\n  plt.title(f'Predicted SWE in the Western US - {today}')\n  # Show the plot\n  plt.savefig('/home/chetana/gridmet_test_run/predicted_swe.png')\n\n            \n\n\nconvert_csvs_to_images()\n\n\n\n",
  "history_output" : "Traceback (most recent call last):\n  File \"/home/chetana/gw-workspace/1zdRjRRFMWxL/convert_results_to_images.py\", line 52, in <module>\n    convert_csvs_to_images()\n  File \"/home/chetana/gw-workspace/1zdRjRRFMWxL/convert_results_to_images.py\", line 41, in convert_csvs_to_images\n    result_date = reference_date + timedelta(days=given_days)\nNameError: name 'given_days' is not defined\n",
  "history_begin_time" : 1690467163397,
  "history_end_time" : 1690467172185,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "HTJLkO8xL3Oj",
  "history_input" : "# convert the model prediction into images. The testing.csv will be resulted in a corresponding csv with the values for all the coordinates. \nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\n\n\ndef convert_csvs_to_images():\n  # Load the CSV data into a DataFrame\n  data = pd.read_csv('/home/chetana/gridmet_test_run/test_data_prediected.csv')\n\n  # Define the map boundaries for the Western US\n  lon_min, lon_max = -125, -100\n  lat_min, lat_max = 25, 49.5\n\n  # Create the Basemap instance\n  m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n              projection='merc', resolution='i')\n\n  # Convert lon/lat to map coordinates\n  x, y = m(data['lon'].values, data['lat'].values)\n\n  # Plot the data using vibrant colors based on predicted_swe\n  plt.scatter(x, y, c=data['predicted_swe'], cmap='plasma', s=30, edgecolors='none', alpha=0.7)\n\n  # Add colorbar for reference\n  cbar = plt.colorbar()\n  cbar.set_label('Predicted SWE')\n\n  # Draw coastlines and other map features\n  m.drawcoastlines()\n  m.drawcountries()\n  m.drawstates()\n\n\t# Add a title\n  plt.title('Predicted SWE in the Western US')\n\n  # Show the plot\n  plt.savefig('/home/chetana/gridmet_test_run/predicted_swe.png')\n\n            \n\n\nconvert_csvs_to_images()\n\n\n\n",
  "history_output" : "",
  "history_begin_time" : 1690380798053,
  "history_end_time" : 1690380808407,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "VZN9wlssHUNp",
  "history_input" : "# convert the model prediction into images. The testing.csv will be resulted in a corresponding csv with the values for all the coordinates. \nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\n\n\ndef convert_csvs_to_images():\n  # Load the CSV data into a DataFrame\n  data = pd.read_csv('/home/chetana/gridmet_test_run/test_data_prediected.csv')\n\n  # Define the map boundaries for the Western US\n  lon_min, lon_max = -125, -125\n  lat_min, lat_max = 25, 49.5\n\n  # Create the Basemap instance\n  m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n              projection='merc', resolution='i')\n\n  # Convert lon/lat to map coordinates\n  x, y = m(data['lon'].values, data['lat'].values)\n\n  # Plot the data using vibrant colors based on predicted_swe\n  plt.scatter(x, y, c=data['predicted_swe'], cmap='plasma', s=30, edgecolors='none', alpha=0.7)\n\n  # Add colorbar for reference\n  cbar = plt.colorbar()\n  cbar.set_label('Predicted SWE')\n\n  # Draw coastlines and other map features\n  m.drawcoastlines()\n  m.drawcountries()\n  m.drawstates()\n\n\t# Add a title\n  plt.title('Predicted SWE in the Western US')\n\n  # Show the plot\n  plt.savefig('/home/chetana/gridmet_test_run/predicted_swe.png')\n\n            \n\n\nconvert_csvs_to_images()\n\n\n\n",
  "history_output" : "Traceback (most recent call last):\n  File \"/home/chetana/gw-workspace/VZN9wlssHUNp/convert_results_to_images.py\", line 43, in <module>\n    convert_csvs_to_images()\n  File \"/home/chetana/gw-workspace/VZN9wlssHUNp/convert_results_to_images.py\", line 16, in convert_csvs_to_images\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n  File \"/home/chetana/gridmet_test_run/pycrate/lib/python3.9/site-packages/mpl_toolkits/basemap/__init__.py\", line 1034, in __init__\n    self.aspect = (proj.ymax-proj.ymin)/(proj.xmax-proj.xmin)\nZeroDivisionError: float division by zero\n",
  "history_begin_time" : 1690380650924,
  "history_end_time" : 1690380655678,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "by7XYNzpvrgS",
  "history_input" : "# convert the model prediction into images. The testing.csv will be resulted in a corresponding csv with the values for all the coordinates. \nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\n\n\ndef convert_csvs_to_images():\n  # Load the CSV data into a DataFrame\n  data = pd.read_csv('/home/chetana/gridmet_test_run/test_data_prediected.csv')\n\n  # Define the map boundaries for the Western US\n  lon_min, lon_max = -125.5, -116.5\n  lat_min, lat_max = 31.5, 49.5\n\n  # Create the Basemap instance\n  m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n              projection='merc', resolution='i')\n\n  # Convert lon/lat to map coordinates\n  x, y = m(data['lon'].values, data['lat'].values)\n\n  # Plot the data using vibrant colors based on predicted_swe\n  plt.scatter(x, y, c=data['predicted_swe'], cmap='plasma', s=30, edgecolors='none', alpha=0.7)\n\n  # Add colorbar for reference\n  cbar = plt.colorbar()\n  cbar.set_label('Predicted SWE')\n\n  # Draw coastlines and other map features\n  m.drawcoastlines()\n  m.drawcountries()\n  m.drawstates()\n\n\t# Add a title\n  plt.title('Predicted SWE in the Western US')\n\n  # Show the plot\n  plt.savefig('/home/chetana/gridmet_test_run/predicted_swe.png')\n\n            \n\n\nconvert_csvs_to_images()\n\n\n\n",
  "history_output" : "",
  "history_begin_time" : 1690353371041,
  "history_end_time" : 1690353379356,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "KbNZMp0tad7m",
  "history_input" : "# convert the model prediction into images. The testing.csv will be resulted in a corresponding csv with the values for all the coordinates. \nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\n\n\ndef convert_csvs_to_images():\n  # Load the CSV data into a DataFrame\n  data = pd.read_csv('/home/chetana/gridmet_test_run/test_data_prediected.csv')\n\n  # Define the map boundaries for the Western US\n  lon_min, lon_max = -125.5, -116.5\n  lat_min, lat_max = 31.5, 49.5\n\n  # Create the Basemap instance\n  m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n              projection='merc', resolution='i')\n\n  # Convert lon/lat to map coordinates\n  x, y = m(data['lon'].values, data['lat'].values)\n\n  # Plot the data using vibrant colors based on predicted_swe\n  plt.scatter(x, y, c=data['predicted_swe'], cmap='plasma', s=30, edgecolors='none', alpha=0.7)\n\n  # Add colorbar for reference\n  cbar = plt.colorbar()\n  cbar.set_label('Predicted SWE')\n\n  # Draw coastlines and other map features\n  m.drawcoastlines()\n  m.drawcountries()\n  m.drawstates()\n\n# Add a title\nplt.title('Predicted SWE in the Western US')\n\n# Show the plot\nplt.savefig('/home/chetana/gridmet_test_run/predicted_swe.png')\n\n            \n\nif __name__ == \"__main__\":\n    # Replace with the actual path to your folder\n    convert_csvs_to_images()\n\n\n\n",
  "history_output" : "",
  "history_begin_time" : 1690353342147,
  "history_end_time" : 1690353347269,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "X5lPe8hpvVn7",
  "history_input" : "# convert the model prediction into images. The testing.csv will be resulted in a corresponding csv with the values for all the coordinates. \nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\n\n\ndef convert_csvs_to_images():\n  # Load the CSV data into a DataFrame\n  data = pd.read_csv('/home/chetana/gridmet_test_run/test_data_prediected.csv')\n\n  # Define the map boundaries for the Western US\n  lon_min, lon_max = -125.5, -116.5\n  lat_min, lat_max = 31.5, 49.5\n\n  # Create the Basemap instance\n  m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n              projection='merc', resolution='i')\n\n  # Convert lon/lat to map coordinates\n  x, y = m(data['lon'].values, data['lat'].values)\n\n  # Plot the data using vibrant colors based on predicted_swe\n  plt.scatter(x, y, c=data['predicted_swe'], cmap='plasma', s=30, edgecolors='none', alpha=0.7)\n\n  # Add colorbar for reference\n  cbar = plt.colorbar()\n  cbar.set_label('Predicted SWE')\n\n  # Draw coastlines and other map features\n  m.drawcoastlines()\n  m.drawcountries()\n  m.drawstates()\n\n# Add a title\nplt.title('Predicted SWE in the Western US')\n\n# Show the plot\nplt.savefig('/home/chetana/gridmet_test_run/predicted_swe.png')\n\n            \n\nif __name__ == \"__main__\":\n    # Replace with the actual path to your folder\n    convert_csvs_to_images()\n\n\n\n",
  "history_output" : "",
  "history_begin_time" : 1690353260372,
  "history_end_time" : 1690353269592,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "ldse9vf819d",
  "history_input" : null,
  "history_output" : "Authentication Failed. Wrong Password.",
  "history_begin_time" : 1689632043451,
  "history_end_time" : 1689632044894,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "100001",
  "indicator" : "Failed"
},{
  "history_id" : "1j5b2o3jvui",
  "history_input" : "# Deploy model to service\n\nprint(\"deploy model to service\")\n",
  "history_output" : "deploy model to service\n",
  "history_begin_time" : 1689631649928,
  "history_end_time" : 1689631651993,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "tq3z35",
  "indicator" : "Done"
},{
  "history_id" : "7mqlk2j2rgd",
  "history_input" : null,
  "history_output" : "Authentication Failed. Wrong Password.",
  "history_begin_time" : 1689135074866,
  "history_end_time" : 1689135076728,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "100001",
  "indicator" : "Failed"
},{
  "history_id" : "mzpdomr4kr8",
  "history_input" : "# Deploy model to service\n\nprint(\"deploy model to service\")\n",
  "history_output" : "deploy model to service\n",
  "history_begin_time" : 1687547311585,
  "history_end_time" : 1687547311694,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "100001",
  "indicator" : "Done"
},{
  "history_id" : "nwe5hdoxx4p",
  "history_input" : null,
  "history_output" : "Authentication Failed. Wrong Password.",
  "history_begin_time" : 1687463699542,
  "history_end_time" : 1687463700965,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "100001",
  "indicator" : "Failed"
},{
  "history_id" : "3990qxbi51p",
  "history_input" : null,
  "history_output" : "Authentication Failed. Wrong Password.",
  "history_begin_time" : 1687463654164,
  "history_end_time" : 1687463655631,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "100001",
  "indicator" : "Failed"
},{
  "history_id" : "mtrinmye7ur",
  "history_input" : "# Deploy model to service\n\nprint(\"deploy model to service\")\n",
  "history_output" : "sh: /home/chetana/anaconda3/condabin/python: No such file or directory\n",
  "history_begin_time" : 1686235982757,
  "history_end_time" : 1686235985399,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "jf7wuu",
  "indicator" : "Stopped"
},{
  "history_id" : "41hmaysoci0",
  "history_input" : "# Deploy model to service\n\nprint(\"deploy model to service\")\n",
  "history_output" : "deploy model to service\n",
  "history_begin_time" : 1686235553915,
  "history_end_time" : 1686235556289,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "jf7wuu",
  "indicator" : "Done"
},{
  "history_id" : "nz20itaw8yu",
  "history_input" : "# Deploy model to service\n\nprint(\"deploy model to service\")\n",
  "history_output" : "deploy model to service\n",
  "history_begin_time" : 1686153688571,
  "history_end_time" : 1686153690978,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "jf7wuu",
  "indicator" : "Done"
},{
  "history_id" : "zqlt2cmrvat",
  "history_input" : null,
  "history_output" : "Authentication Failed. Wrong Password.",
  "history_begin_time" : 1681516936498,
  "history_end_time" : 1681516937950,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "100001",
  "indicator" : "Failed"
},{
  "history_id" : "aqfswg22enc",
  "history_input" : null,
  "history_output" : "Authentication Failed. Wrong Password.",
  "history_begin_time" : 1681039719459,
  "history_end_time" : 1681039720897,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "100001",
  "indicator" : "Failed"
},{
  "history_id" : "30uf7yfv9ca",
  "history_input" : null,
  "history_output" : "Authentication Failed. Wrong Password.",
  "history_begin_time" : 1681007829649,
  "history_end_time" : 1681007831073,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "100001",
  "indicator" : "Failed"
},{
  "history_id" : "dhmb7j1sjmu",
  "history_input" : "# Deploy model to service\n\nprint(\"deploy model to service\")\n",
  "history_output" : "deploy model to service\n",
  "history_begin_time" : 1679442760857,
  "history_end_time" : 1679442762934,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "jf7wuu",
  "indicator" : "Done"
},{
  "history_id" : "d8ovl4alcw6",
  "history_input" : "# Deploy model to service\n\nprint(\"deploy model to service\")\n",
  "history_output" : "deploy model to service\n",
  "history_begin_time" : 1679332603639,
  "history_end_time" : 1679332606054,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "jf7wuu",
  "indicator" : "Done"
},{
  "history_id" : "omj0e1g6j9n",
  "history_input" : "# Deploy model to service\n\nprint(\"deploy model to service\")\n",
  "history_output" : "deploy model to service\n",
  "history_begin_time" : 1679191272847,
  "history_end_time" : 1679191275207,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "2jifky",
  "indicator" : "Done"
},{
  "history_id" : "fmn46wslldx",
  "history_input" : null,
  "history_output" : "Authentication Failed. Wrong Password.",
  "history_begin_time" : 1678748560562,
  "history_end_time" : 1678748562031,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "100001",
  "indicator" : "Failed"
},{
  "history_id" : "9i9po8n9b20",
  "history_input" : "# Deploy model to service\n\nprint(\"deploy model to service\")\n",
  "history_output" : "deploy model to service\n",
  "history_begin_time" : 1678747870780,
  "history_end_time" : 1678747873588,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Done"
},{
  "history_id" : "ivujluw9hv9",
  "history_input" : "# Deploy model to service\n\nprint(\"deploy model to service\")\n",
  "history_output" : "deploy model to service\n",
  "history_begin_time" : 1678743791504,
  "history_end_time" : 1678743794786,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Done"
},{
  "history_id" : "vn3hx1l9zu4",
  "history_input" : "# Deploy model to service\n\nprint(\"deploy model to service\")\n",
  "history_output" : "deploy model to service\n",
  "history_begin_time" : 1678742675575,
  "history_end_time" : 1678742678216,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Done"
},{
  "history_id" : "8v5yi7d5e5q",
  "history_input" : "# Deploy model to service\n\nprint(\"deploy model to service\")\n",
  "history_output" : "deploy model to service\n",
  "history_begin_time" : 1678725460139,
  "history_end_time" : 1678725463128,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Done"
},{
  "history_id" : "t2lexm3h3hd",
  "history_input" : "# Deploy model to service\n\nprint(\"deploy model to service\")\n",
  "history_output" : "deploy model to service\n",
  "history_begin_time" : 1678649631016,
  "history_end_time" : 1678649633836,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Done"
},{
  "history_id" : "cdhidm8zrcn",
  "history_input" : "# Deploy model to service\n\nprint(\"deploy model to service\")\n",
  "history_output" : "deploy model to service\n",
  "history_begin_time" : 1678648422662,
  "history_end_time" : 1678648426137,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Done"
},{
  "history_id" : "ygi0pc2sokv",
  "history_input" : "# Deploy model to service\n\nprint(\"deploy model to service\")\n",
  "history_output" : "deploy model to service\n",
  "history_begin_time" : 1678565132221,
  "history_end_time" : 1678565134718,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Done"
},{
  "history_id" : "g9zm7ykf909",
  "history_input" : "# Deploy model to service\n\nprint(\"deploy model to service\")\n",
  "history_output" : "deploy model to service\n",
  "history_begin_time" : 1678564686602,
  "history_end_time" : 1678564689199,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Done"
},{
  "history_id" : "amvl1pd2lo3",
  "history_input" : "# Deploy model to service\n\nprint(\"deploy model to service\")\n",
  "history_output" : "deploy model to service\n",
  "history_begin_time" : 1678557796871,
  "history_end_time" : 1678557898784,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Stopped"
},{
  "history_id" : "zdf56w22yyg",
  "history_input" : "# Deploy model to service\n\nprint(\"deploy model to service\")\n",
  "history_output" : "deploy model to service\n",
  "history_begin_time" : 1678497654726,
  "history_end_time" : 1678497657421,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Done"
},{
  "history_id" : "2ucdtlzg2in",
  "history_input" : "# Deploy model to service\n\nprint(\"deploy model to service\")\n",
  "history_output" : "deploy model to service\n",
  "history_begin_time" : 1678330790468,
  "history_end_time" : 1678330793154,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Done"
},{
  "history_id" : "babqku2d94y",
  "history_input" : "# Deploy model to service\n\nprint(\"deploy model to service\")\n",
  "history_output" : "deploy model to service\n",
  "history_begin_time" : 1678312629435,
  "history_end_time" : 1678312632063,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Done"
},{
  "history_id" : "it97senojc1",
  "history_input" : "# Deploy model to service\n\nprint(\"deploy model to service\")\n",
  "history_output" : "deploy model to service\n",
  "history_begin_time" : 1678312065371,
  "history_end_time" : 1678312067942,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Done"
},{
  "history_id" : "piew2yod9ur",
  "history_input" : "# Deploy model to service\n\nprint(\"deploy model to service\")\n",
  "history_output" : "deploy model to service\n",
  "history_begin_time" : 1678285602914,
  "history_end_time" : 1678285605072,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Done"
},{
  "history_id" : "3pu9lo74r0n",
  "history_input" : "# Deploy model to service\n\nprint(\"deploy model to service\")\n",
  "history_output" : "deploy model to service\n",
  "history_begin_time" : 1678202254111,
  "history_end_time" : 1678202257027,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Done"
},{
  "history_id" : "0zwtlwh9ujc",
  "history_input" : "# Deploy model to service\n\nprint(\"deploy model to service\")\n",
  "history_output" : "deploy model to service\n",
  "history_begin_time" : 1678155321362,
  "history_end_time" : 1678155323831,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Done"
},{
  "history_id" : "6dnkkfqyv7p",
  "history_input" : "# Deploy model to service\n\nprint(\"deploy model to service\")\n",
  "history_output" : "deploy model to service\n",
  "history_begin_time" : 1677791579049,
  "history_end_time" : 1677791581731,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Done"
},{
  "history_id" : "uqx42kmbkw5",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1677784204219,
  "history_end_time" : 1677784272018,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Stopped"
},{
  "history_id" : "qee90agx4c8",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1677782901795,
  "history_end_time" : 1677782901795,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Skipped"
},{
  "history_id" : "cx2lp81lyi0",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1677781745155,
  "history_end_time" : 1677781745155,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Skipped"
},{
  "history_id" : "4qka03ni1rh",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1677719046567,
  "history_end_time" : 1677719046567,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Skipped"
},{
  "history_id" : "tmnvugidok0",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1677718179080,
  "history_end_time" : 1677718179080,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Skipped"
},{
  "history_id" : "yys7qyvlzm5",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1677679556253,
  "history_end_time" : 1677679556253,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Skipped"
},{
  "history_id" : "j97u188zbmz",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1677679507356,
  "history_end_time" : 1677679549075,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Stopped"
},{
  "history_id" : "7m3ssfk04eg",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1677636286811,
  "history_end_time" : 1677636286811,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Skipped"
},{
  "history_id" : "v0dnrfltchb",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1677636150346,
  "history_end_time" : 1677636150346,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Skipped"
},{
  "history_id" : "x6zy9t1nty1",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1677636137198,
  "history_end_time" : 1677636142807,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Stopped"
},{
  "history_id" : "gdiaupttlu8",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1677636063734,
  "history_end_time" : 1677636063734,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Skipped"
},{
  "history_id" : "7t7ckk1ljv7",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1677635881792,
  "history_end_time" : 1677635881792,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Skipped"
},{
  "history_id" : "c35dhflhown",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1677617762748,
  "history_end_time" : 1677617762748,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Skipped"
},{
  "history_id" : "k20ksjnfl74",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1677606170851,
  "history_end_time" : 1677606170851,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Skipped"
},{
  "history_id" : "cdsntdo476a",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1677606114086,
  "history_end_time" : 1677606114086,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Skipped"
},{
  "history_id" : "d2opzevnn65",
  "history_input" : "# Deploy model to service\n\nprint(\"deploy model to service\")\n",
  "history_output" : "deploy model to service\n",
  "history_begin_time" : 1677582864952,
  "history_end_time" : 1677582865031,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "100001",
  "indicator" : "Done"
},{
  "history_id" : "ic3omz77bv0",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1677525425935,
  "history_end_time" : 1677525425935,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Skipped"
},{
  "history_id" : "ssc5p4wyiln",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1677462325745,
  "history_end_time" : 1694185608906,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Stopped"
},{
  "history_id" : "goi0bprwuyt",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1677462311617,
  "history_end_time" : 1694185608623,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Stopped"
},{
  "history_id" : "kier18job0a",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1677462265092,
  "history_end_time" : 1677462265092,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Skipped"
},{
  "history_id" : "4gll9yyq9li",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1677428742683,
  "history_end_time" : 1677428742683,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Skipped"
},{
  "history_id" : "q55iuo5t5k9",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1677428687295,
  "history_end_time" : 1677428687295,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Skipped"
},{
  "history_id" : "qd0cjyz624t",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1677426262704,
  "history_end_time" : 1677426262704,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Skipped"
},{
  "history_id" : "xyc54zccboq",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1677379889766,
  "history_end_time" : 1677379889766,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Skipped"
},{
  "history_id" : "3opfw8385hf",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1677379837758,
  "history_end_time" : 1677379837758,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Skipped"
},{
  "history_id" : "vth8me3n3sc",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1677352477933,
  "history_end_time" : 1677352477933,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Skipped"
},{
  "history_id" : "7ppt2voi65q",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1677352389867,
  "history_end_time" : 1677352389867,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Skipped"
},{
  "history_id" : "w78vu4kpfd7",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1677352335812,
  "history_end_time" : 1677352335812,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Skipped"
},{
  "history_id" : "22gd19rf2ct",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1677344119888,
  "history_end_time" : 1677344119888,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Skipped"
},{
  "history_id" : "whl5cxwfmw2",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1677282602533,
  "history_end_time" : 1677282602533,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Skipped"
},{
  "history_id" : "9g6ri340mcc",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1677273712204,
  "history_end_time" : 1677273712204,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Skipped"
},{
  "history_id" : "0d5pqu258nx",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1677273698725,
  "history_end_time" : 1677273703950,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Stopped"
},{
  "history_id" : "13aixewd58l",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1677273673894,
  "history_end_time" : 1677273679529,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Stopped"
},{
  "history_id" : "5s54pzuhbu0",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1677273657777,
  "history_end_time" : 1677273665446,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Stopped"
},{
  "history_id" : "4p5f1egy95a",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1677273535978,
  "history_end_time" : 1677273535978,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Skipped"
},{
  "history_id" : "anij6kg4q8g",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1677273519084,
  "history_end_time" : 1677273525482,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Stopped"
},{
  "history_id" : "19hz7winqpo",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1677273371283,
  "history_end_time" : 1677273371283,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Skipped"
},{
  "history_id" : "7kikskag44n",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1677273340412,
  "history_end_time" : 1677273345436,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Stopped"
},{
  "history_id" : "tme4ooojc5k",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1677273323462,
  "history_end_time" : 1677273332226,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Stopped"
},{
  "history_id" : "sdhjdna9lnj",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1677273146620,
  "history_end_time" : 1677273146620,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Skipped"
},{
  "history_id" : "fggb1vrn3iz",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1677273100195,
  "history_end_time" : 1677273134479,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Stopped"
},{
  "history_id" : "xu0iejq32kz",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1677201275373,
  "history_end_time" : 1677201275373,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Skipped"
},{
  "history_id" : "0gn12iqpow9",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1677192311031,
  "history_end_time" : 1677192311031,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Skipped"
},{
  "history_id" : "8g4jpa7lre9",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1677192268349,
  "history_end_time" : 1677192268349,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Skipped"
},{
  "history_id" : "4do4rodf0n0",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1677191916701,
  "history_end_time" : 1677191916701,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Skipped"
},{
  "history_id" : "nv4radnme1w",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1677184296660,
  "history_end_time" : 1677184296660,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Skipped"
},{
  "history_id" : "5ldrlon449x",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1677184173513,
  "history_end_time" : 1677184173513,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Skipped"
},{
  "history_id" : "q64qgrqxcqs",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1677113476431,
  "history_end_time" : 1677113476431,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Skipped"
},{
  "history_id" : "fagnv8ysdhw",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1677108238573,
  "history_end_time" : 1677108238573,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Skipped"
},{
  "history_id" : "qdk0lci85zn",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1677108212449,
  "history_end_time" : 1677108228694,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Stopped"
},{
  "history_id" : "3m89qeq0wzi",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1677107869786,
  "history_end_time" : 1677107869786,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Skipped"
},{
  "history_id" : "gte4oqfw759",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1677107757936,
  "history_end_time" : 1677107757936,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Skipped"
},{
  "history_id" : "ktzy98wqv1b",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1677107718282,
  "history_end_time" : 1677107718282,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Skipped"
},{
  "history_id" : "vesx8bj2l5w",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1677107637135,
  "history_end_time" : 1677107705671,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Stopped"
},{
  "history_id" : "8tobfk8h1ee",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1677107603999,
  "history_end_time" : 1677107608759,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Stopped"
},{
  "history_id" : "v2l06tdd6b5",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1677107556499,
  "history_end_time" : 1677107562714,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Stopped"
},{
  "history_id" : "x6yhpn2d21s",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1677107524967,
  "history_end_time" : 1677107538156,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Stopped"
},{
  "history_id" : "ly237j7gami",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1677107501069,
  "history_end_time" : 1677107501069,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Skipped"
},{
  "history_id" : "bdxo1p68dli",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1677107474131,
  "history_end_time" : 1677107474131,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Skipped"
},{
  "history_id" : "b3t16t55iui",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1677106516074,
  "history_end_time" : 1677106516074,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Skipped"
},{
  "history_id" : "8ygzg9kpsm7",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1677106477022,
  "history_end_time" : 1677106477022,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Skipped"
},{
  "history_id" : "kon20335aho",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1677106431010,
  "history_end_time" : 1677106431010,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Skipped"
},{
  "history_id" : "euywk2wj2im",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1677106134852,
  "history_end_time" : 1677106147544,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Stopped"
},{
  "history_id" : "7kyw02qybao",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1677106010917,
  "history_end_time" : 1677106010917,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Skipped"
},{
  "history_id" : "sq0z6ad2psr",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1677030843457,
  "history_end_time" : 1677030843457,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Skipped"
},{
  "history_id" : "zir158jdi54",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1677030771118,
  "history_end_time" : 1677030771118,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Skipped"
},{
  "history_id" : "3f0u5xlu2v6",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1677030672608,
  "history_end_time" : 1677030672608,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Skipped"
},{
  "history_id" : "97fld6x3fey",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1677030562136,
  "history_end_time" : 1677030562136,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Skipped"
},{
  "history_id" : "pg1dwrlz195",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1677025528626,
  "history_end_time" : 1677025528626,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Skipped"
},{
  "history_id" : "bsai78c7es6",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1677025466360,
  "history_end_time" : 1677025466360,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Skipped"
},{
  "history_id" : "63j2dess9f4",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1677017826392,
  "history_end_time" : 1677017826392,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Skipped"
},{
  "history_id" : "7pe9b4p3jyw",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1677017218399,
  "history_end_time" : 1677017218399,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Skipped"
},{
  "history_id" : "pdr88ka6f1b",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1677016681285,
  "history_end_time" : 1677016681285,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Skipped"
},{
  "history_id" : "6q6kqjdmb0g",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1677016142970,
  "history_end_time" : 1677016142970,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Skipped"
},{
  "history_id" : "q6uzmri4lft",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1677016063935,
  "history_end_time" : 1677016063935,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Skipped"
},{
  "history_id" : "7lb2h4xlx91",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1677015787617,
  "history_end_time" : 1677015787617,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Skipped"
},{
  "history_id" : "rwpdz7lhzdz",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1677015739916,
  "history_end_time" : 1677015739916,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Skipped"
},{
  "history_id" : "5700yvup5ah",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1677014884899,
  "history_end_time" : 1677014884899,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Skipped"
},{
  "history_id" : "ipga6mbeqyz",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1677014795542,
  "history_end_time" : 1677014795542,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Skipped"
},{
  "history_id" : "k5qc12iq8oi",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1677014227938,
  "history_end_time" : 1677014227938,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Skipped"
},{
  "history_id" : "cohq3c15q4j",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1677013908387,
  "history_end_time" : 1677013908387,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Skipped"
},{
  "history_id" : "ocsbr7bvvmu",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1677013832963,
  "history_end_time" : 1677013832963,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Skipped"
},{
  "history_id" : "bx738408feo",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1677011872992,
  "history_end_time" : 1677011872992,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Skipped"
},{
  "history_id" : "qgwye4urzhl",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1677008198529,
  "history_end_time" : 1677008198529,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Skipped"
},{
  "history_id" : "mw82bbsc1p5",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1677008162856,
  "history_end_time" : 1677008162856,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Skipped"
},{
  "history_id" : "dthf53d1iwa",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1677001999542,
  "history_end_time" : 1677001999542,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Skipped"
},{
  "history_id" : "rzbwan9jzm0",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1677001732205,
  "history_end_time" : 1677001732205,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "xajm7hz75ae",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1677001593745,
  "history_end_time" : 1677001593745,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "lbc4kgtcqbc",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1677000536747,
  "history_end_time" : 1677000536747,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "q8tfmqg73c9",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1676999722063,
  "history_end_time" : 1676999722063,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "yb51al",
  "indicator" : "Skipped"
},{
  "history_id" : "wr4piihbdyu",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1676999599014,
  "history_end_time" : 1676999599014,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "62kz7bxhlwm",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1676862212256,
  "history_end_time" : 1676862212256,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "5h4ttf3zsvs",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1676329536214,
  "history_end_time" : 1676329536214,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "hqct9wd8bvs",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1676329491712,
  "history_end_time" : 1676329491712,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "slev0n13pap",
  "history_input" : "# Deploy model to service\n\nprint(\"deploy model to service\")\n",
  "history_output" : "deploy model to service\n",
  "history_begin_time" : 1676063638589,
  "history_end_time" : 1676063638664,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "100001",
  "indicator" : "Done"
},{
  "history_id" : "i0qu80d74pq",
  "history_input" : "# Deploy model to service\n\nprint(\"deploy model to service\")\n",
  "history_output" : "deploy model to service\n",
  "history_begin_time" : 1675783805024,
  "history_end_time" : 1675783805097,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "100001",
  "indicator" : "Done"
},{
  "history_id" : "99w64muecu7",
  "history_input" : "# Deploy model to service\n\nprint(\"deploy model to service\")\n",
  "history_output" : "deploy model to service\n",
  "history_begin_time" : 1672015051123,
  "history_end_time" : 1672015051222,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "100001",
  "indicator" : "Done"
},{
  "history_id" : "03b0a4inmxi",
  "history_input" : "# Deploy model to service\n\nprint(\"deploy model to service\")\n",
  "history_output" : "deploy model to service\n",
  "history_begin_time" : 1671944455675,
  "history_end_time" : 1671944455774,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "100001",
  "indicator" : "Done"
},{
  "history_id" : "kyyswtv6f6n",
  "history_input" : "# Deploy model to service\n\nprint(\"deploy model to service\")\n",
  "history_output" : "deploy model to service\n",
  "history_begin_time" : 1670910686194,
  "history_end_time" : 1670910686312,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "100001",
  "indicator" : "Done"
},{
  "history_id" : "pbdda5dueo6",
  "history_input" : "# Deploy model to service\n\nprint(\"deploy model to service\")\n",
  "history_output" : "deploy model to service\n",
  "history_begin_time" : 1670910570451,
  "history_end_time" : 1670910570606,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "100001",
  "indicator" : "Done"
},{
  "history_id" : "pht5fk3a9rg",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1670910268427,
  "history_end_time" : 1670910268427,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "g3vumogaldi",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1670019638804,
  "history_end_time" : 1670019638804,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "cupzlogng1p",
  "history_input" : "# Deploy model to service\n\nprint(\"deploy model to service\")\n",
  "history_output" : "deploy model to service\n",
  "history_begin_time" : 1667484736940,
  "history_end_time" : 1667484737052,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "100001",
  "indicator" : "Done"
},{
  "history_id" : "xt6t35bodpe",
  "history_input" : "# Deploy model to service\n\nprint(\"deploy model to service\")\n",
  "history_output" : "deploy model to service\n",
  "history_begin_time" : 1667410808925,
  "history_end_time" : 1667410809071,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "100001",
  "indicator" : "Done"
},{
  "history_id" : "jh9ydimw0cm",
  "history_input" : "# Deploy model to service\n\nprint(\"deploy model to service\")\n",
  "history_output" : "deploy model to service\n",
  "history_begin_time" : 1654521115025,
  "history_end_time" : 1654521115144,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "100001",
  "indicator" : "Done"
},{
  "history_id" : "3fy8xfm8567",
  "history_input" : "# Deploy model to service\n\nprint(\"deploy model to service\")\n",
  "history_output" : "deploy model to service\n",
  "history_begin_time" : 1647826117273,
  "history_end_time" : 1647826117386,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "100001",
  "indicator" : "Done"
},{
  "history_id" : "nf2n7gtg3kz",
  "history_input" : "# Deploy model to service\n\nprint(\"deploy model to service\")\n",
  "history_output" : "deploy model to service\n",
  "history_begin_time" : 1647225952602,
  "history_end_time" : 1647225952698,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "100001",
  "indicator" : "Done"
},{
  "history_id" : "148a3mugiz2",
  "history_input" : "# Deploy model to service\n\nprint(\"deploy model to service\")\n",
  "history_output" : "deploy model to service\n",
  "history_begin_time" : 1646693033766,
  "history_end_time" : 1646693033896,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "100001",
  "indicator" : "Done"
},{
  "history_id" : "3buye4neevn",
  "history_input" : "# Deploy model to service\n\nprint(\"deploy model to service\")\n",
  "history_output" : "deploy model to service\n",
  "history_begin_time" : 1646604648073,
  "history_end_time" : 1646604648235,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "100001",
  "indicator" : "Done"
},{
  "history_id" : "56y4ftkt5yi",
  "history_input" : "# Deploy model to service\n\nprint(\"deploy model to service\")\n",
  "history_output" : "deploy model to service\n",
  "history_begin_time" : 1646272337859,
  "history_end_time" : 1646272337989,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "100001",
  "indicator" : "Done"
},{
  "history_id" : "k84eh83rkz6",
  "history_input" : "# Deploy model to service\n\nprint(\"deploy model to service\")\n",
  "history_output" : "deploy model to service\n",
  "history_begin_time" : 1645977675714,
  "history_end_time" : 1645977676764,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "je29f6",
  "indicator" : "Done"
},{
  "history_id" : "qcg3ken9a69",
  "history_input" : "# Deploy model to service\n\nprint(\"deploy model to service\")\n",
  "history_output" : "deploy model to service\n",
  "history_begin_time" : 1645977445591,
  "history_end_time" : 1645977446592,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "je29f6",
  "indicator" : "Done"
},{
  "history_id" : "argt5yqt0ad",
  "history_input" : "# Deploy model to service\n\nprint(\"deploy model to service\")\n",
  "history_output" : "deploy model to service\n",
  "history_begin_time" : 1642977866710,
  "history_end_time" : 1642977866827,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "100001",
  "indicator" : "Done"
},{
  "history_id" : "rilhyfolrey",
  "history_input" : "# Deploy model to service\n\nprint(\"deploy model to service\")\n",
  "history_output" : "deploy model to service\n",
  "history_begin_time" : 1642969781031,
  "history_end_time" : 1642969781150,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "100001",
  "indicator" : "Done"
},{
  "history_id" : "hs2g7ll5vhi",
  "history_input" : "# Deploy model to service\n\nprint(\"deploy model to service\")\n",
  "history_output" : "deploy model to service\n",
  "history_begin_time" : 1642455232511,
  "history_end_time" : 1642455232636,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "100001",
  "indicator" : "Done"
},{
  "history_id" : "67w94uwybuf",
  "history_input" : "# Deploy model to service\n\nprint(\"deploy model to service\")\n",
  "history_output" : "deploy model to service\n",
  "history_begin_time" : 1642454682946,
  "history_end_time" : 1642454683090,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "100001",
  "indicator" : "Done"
},{
  "history_id" : "hjle1g5ytv6",
  "history_input" : null,
  "history_output" : null,
  "history_begin_time" : null,
  "history_end_time" : 1667410703752,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "100001",
  "indicator" : "Stopped"
},{
  "history_id" : "z7orbzf2q86",
  "history_input" : null,
  "history_output" : null,
  "history_begin_time" : null,
  "history_end_time" : 1681039697758,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "100001",
  "indicator" : "Stopped"
},{
  "history_id" : "wnelzutjg6b",
  "history_input" : null,
  "history_output" : null,
  "history_begin_time" : null,
  "history_end_time" : 1677809171448,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Stopped"
},{
  "history_id" : "xyqhydlejwq",
  "history_input" : null,
  "history_output" : null,
  "history_begin_time" : null,
  "history_end_time" : 1678201703956,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Stopped"
},{
  "history_id" : "xsjc30d1lo8",
  "history_input" : null,
  "history_output" : null,
  "history_begin_time" : null,
  "history_end_time" : 1694185611210,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Stopped"
},{
  "history_id" : "xjapsb5584p",
  "history_input" : null,
  "history_output" : null,
  "history_begin_time" : null,
  "history_end_time" : 1677785529412,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Stopped"
},{
  "history_id" : "hcub6wuw65g",
  "history_input" : null,
  "history_output" : null,
  "history_begin_time" : null,
  "history_end_time" : 1677797113212,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Stopped"
},{
  "history_id" : "o8ifwayey87",
  "history_input" : null,
  "history_output" : null,
  "history_begin_time" : null,
  "history_end_time" : 1677809840714,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Stopped"
},{
  "history_id" : "17eu9njh4na",
  "history_input" : null,
  "history_output" : null,
  "history_begin_time" : null,
  "history_end_time" : 1677784516772,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Stopped"
},{
  "history_id" : "oly6kkgev5c",
  "history_input" : null,
  "history_output" : null,
  "history_begin_time" : null,
  "history_end_time" : 1677785383322,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Stopped"
},{
  "history_id" : "ogh9jii4gjd",
  "history_input" : null,
  "history_output" : null,
  "history_begin_time" : null,
  "history_end_time" : 1677786042624,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Stopped"
},{
  "history_id" : "0okqolarrst",
  "history_input" : null,
  "history_output" : null,
  "history_begin_time" : null,
  "history_end_time" : 1677796528249,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Stopped"
},{
  "history_id" : "a9duwxaoadw",
  "history_input" : null,
  "history_output" : null,
  "history_begin_time" : null,
  "history_end_time" : 1677809306570,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Stopped"
},{
  "history_id" : "v2nab86uerc",
  "history_input" : null,
  "history_output" : null,
  "history_begin_time" : null,
  "history_end_time" : 1677809554665,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Stopped"
},{
  "history_id" : "n5sw8d1fqzq",
  "history_input" : null,
  "history_output" : null,
  "history_begin_time" : null,
  "history_end_time" : 1677809573409,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Stopped"
},{
  "history_id" : "omkeql4en17",
  "history_input" : null,
  "history_output" : null,
  "history_begin_time" : null,
  "history_end_time" : 1677867648029,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Stopped"
},{
  "history_id" : "go9hw1tbtsx",
  "history_input" : null,
  "history_output" : null,
  "history_begin_time" : null,
  "history_end_time" : 1677958291180,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Stopped"
},{
  "history_id" : "rwwhycxlkia",
  "history_input" : null,
  "history_output" : null,
  "history_begin_time" : null,
  "history_end_time" : 1677958754101,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Stopped"
},{
  "history_id" : "gz3r5lbsea4",
  "history_input" : null,
  "history_output" : null,
  "history_begin_time" : null,
  "history_end_time" : 1677958849869,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Stopped"
},{
  "history_id" : "eh0ixx3ijv3",
  "history_input" : null,
  "history_output" : null,
  "history_begin_time" : null,
  "history_end_time" : 1677958952850,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Stopped"
},{
  "history_id" : "8g8fjg44qot",
  "history_input" : null,
  "history_output" : null,
  "history_begin_time" : null,
  "history_end_time" : 1677959583115,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Stopped"
},{
  "history_id" : "5uxzh9ohpg1",
  "history_input" : null,
  "history_output" : null,
  "history_begin_time" : null,
  "history_end_time" : 1677959722599,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Stopped"
},{
  "history_id" : "fq2nyae5zw8",
  "history_input" : null,
  "history_output" : null,
  "history_begin_time" : null,
  "history_end_time" : 1678154846097,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Stopped"
},{
  "history_id" : "bdfex5zgz73",
  "history_input" : null,
  "history_output" : null,
  "history_begin_time" : null,
  "history_end_time" : 1678201516407,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Stopped"
},{
  "history_id" : "wdk9lrqr79g",
  "history_input" : null,
  "history_output" : null,
  "history_begin_time" : null,
  "history_end_time" : 1678201687039,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Stopped"
},{
  "history_id" : "fr0vmmf960l",
  "history_input" : null,
  "history_output" : null,
  "history_begin_time" : null,
  "history_end_time" : 1678206143045,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Stopped"
},{
  "history_id" : "yzvuyfir7k3",
  "history_input" : null,
  "history_output" : null,
  "history_begin_time" : null,
  "history_end_time" : 1678206378222,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Stopped"
},{
  "history_id" : "tck34393nkc",
  "history_input" : null,
  "history_output" : null,
  "history_begin_time" : null,
  "history_end_time" : 1694185586124,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Stopped"
},{
  "history_id" : "mrq9cvhselx",
  "history_input" : null,
  "history_output" : null,
  "history_begin_time" : null,
  "history_end_time" : 1686235482619,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "jf7wuu",
  "indicator" : "Stopped"
},{
  "history_id" : "s9ilwqx4h8w",
  "history_input" : null,
  "history_output" : null,
  "history_begin_time" : null,
  "history_end_time" : 1686237909480,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "jf7wuu",
  "indicator" : "Stopped"
},{
  "history_id" : "gla2timsfi0",
  "history_input" : null,
  "history_output" : null,
  "history_begin_time" : null,
  "history_end_time" : 1686235423739,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "jf7wuu",
  "indicator" : "Stopped"
},{
  "history_id" : "cj35gziejw0",
  "history_input" : null,
  "history_output" : null,
  "history_begin_time" : null,
  "history_end_time" : 1682984800274,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "jf7wuu",
  "indicator" : "Stopped"
},{
  "history_id" : "jqkffbnp509",
  "history_input" : null,
  "history_output" : null,
  "history_begin_time" : null,
  "history_end_time" : 1678888215690,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Stopped"
},{
  "history_id" : "smii0n3impp",
  "history_input" : null,
  "history_output" : null,
  "history_begin_time" : null,
  "history_end_time" : 1678744167035,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Stopped"
},{
  "history_id" : "2umabwwn9og",
  "history_input" : null,
  "history_output" : null,
  "history_begin_time" : null,
  "history_end_time" : 1678883775417,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Stopped"
},{
  "history_id" : "nktkzqbvacg",
  "history_input" : null,
  "history_output" : null,
  "history_begin_time" : null,
  "history_end_time" : 1678557923629,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Stopped"
},{
  "history_id" : "ohho7mnyqux",
  "history_input" : null,
  "history_output" : null,
  "history_begin_time" : null,
  "history_end_time" : 1678648341597,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Stopped"
},{
  "history_id" : "ezk7a433lnf",
  "history_input" : null,
  "history_output" : null,
  "history_begin_time" : null,
  "history_end_time" : 1678725408335,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Stopped"
},{
  "history_id" : "xpinof6ov72",
  "history_input" : null,
  "history_output" : null,
  "history_begin_time" : null,
  "history_end_time" : 1678742571495,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Stopped"
},{
  "history_id" : "epkxk630byw",
  "history_input" : null,
  "history_output" : null,
  "history_begin_time" : null,
  "history_end_time" : 1678743615529,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Stopped"
},{
  "history_id" : "bxg3ks57h9w",
  "history_input" : null,
  "history_output" : null,
  "history_begin_time" : null,
  "history_end_time" : 1678746792969,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Stopped"
},{
  "history_id" : "lpp14u1amet",
  "history_input" : null,
  "history_output" : null,
  "history_begin_time" : null,
  "history_end_time" : 1678749935953,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Stopped"
},{
  "history_id" : "fwoz43itog1",
  "history_input" : null,
  "history_output" : null,
  "history_begin_time" : null,
  "history_end_time" : 1678756684666,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Stopped"
},{
  "history_id" : "gjrbcwa19h0",
  "history_input" : null,
  "history_output" : null,
  "history_begin_time" : null,
  "history_end_time" : 1678884042256,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Stopped"
},{
  "history_id" : "icnh8gmckis",
  "history_input" : null,
  "history_output" : null,
  "history_begin_time" : null,
  "history_end_time" : 1678884140244,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Stopped"
},{
  "history_id" : "csn219nybkh",
  "history_input" : null,
  "history_output" : null,
  "history_begin_time" : null,
  "history_end_time" : 1678884438321,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Stopped"
},{
  "history_id" : "x3fygbgcqd3",
  "history_input" : null,
  "history_output" : null,
  "history_begin_time" : null,
  "history_end_time" : 1678884535323,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Stopped"
},{
  "history_id" : "xhscps6dgdi",
  "history_input" : null,
  "history_output" : null,
  "history_begin_time" : null,
  "history_end_time" : 1678884986353,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Stopped"
},{
  "history_id" : "2ji4m7g91zm",
  "history_input" : null,
  "history_output" : null,
  "history_begin_time" : null,
  "history_end_time" : 1678887010619,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Stopped"
},{
  "history_id" : "2bqs9w095cv",
  "history_input" : null,
  "history_output" : null,
  "history_begin_time" : null,
  "history_end_time" : 1678887836223,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Stopped"
},{
  "history_id" : "fvbppo4dcmg",
  "history_input" : null,
  "history_output" : null,
  "history_begin_time" : null,
  "history_end_time" : 1678887946439,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Stopped"
},{
  "history_id" : "zqjdkteas72",
  "history_input" : null,
  "history_output" : null,
  "history_begin_time" : null,
  "history_end_time" : 1679091533634,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Stopped"
},{
  "history_id" : "ozk80viacsk",
  "history_input" : null,
  "history_output" : null,
  "history_begin_time" : null,
  "history_end_time" : 1679091744923,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Stopped"
},{
  "history_id" : "qi9wapr7az8",
  "history_input" : null,
  "history_output" : null,
  "history_begin_time" : null,
  "history_end_time" : 1688416572957,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "jf7wuu",
  "indicator" : "Stopped"
},{
  "history_id" : "wi2wdnnwgti",
  "history_input" : null,
  "history_output" : null,
  "history_begin_time" : null,
  "history_end_time" : 1688416660660,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "jf7wuu",
  "indicator" : "Stopped"
},{
  "history_id" : "k679aai3gg5",
  "history_input" : null,
  "history_output" : null,
  "history_begin_time" : null,
  "history_end_time" : 1688416822940,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "jf7wuu",
  "indicator" : "Stopped"
},{
  "history_id" : "30guyp5kvan",
  "history_input" : null,
  "history_output" : null,
  "history_begin_time" : null,
  "history_end_time" : 1688416848464,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "jf7wuu",
  "indicator" : "Stopped"
},{
  "history_id" : "zxr544ek9z1",
  "history_input" : null,
  "history_output" : null,
  "history_begin_time" : null,
  "history_end_time" : 1688416907359,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "jf7wuu",
  "indicator" : "Stopped"
},{
  "history_id" : "0jpf3kvne09",
  "history_input" : null,
  "history_output" : null,
  "history_begin_time" : null,
  "history_end_time" : 1691530614284,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "tq3z35",
  "indicator" : "Stopped"
},{
  "history_id" : "vizbf4yt6w6",
  "history_input" : null,
  "history_output" : null,
  "history_begin_time" : null,
  "history_end_time" : 1691530622440,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "tq3z35",
  "indicator" : "Stopped"
},{
  "history_id" : "qnshf9ujhyx",
  "history_input" : null,
  "history_output" : null,
  "history_begin_time" : null,
  "history_end_time" : 1691530721106,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "tq3z35",
  "indicator" : "Stopped"
},{
  "history_id" : "ydcjgmbzhjj",
  "history_input" : null,
  "history_output" : null,
  "history_begin_time" : null,
  "history_end_time" : 1691531284901,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "tq3z35",
  "indicator" : "Stopped"
},{
  "history_id" : "3vt2n49zox2",
  "history_input" : null,
  "history_output" : null,
  "history_begin_time" : null,
  "history_end_time" : 1695054019274,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "100001",
  "indicator" : "Stopped"
},{
  "history_id" : "2j0550g4mrl",
  "history_input" : null,
  "history_output" : null,
  "history_begin_time" : null,
  "history_end_time" : 1695054033329,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "100001",
  "indicator" : "Stopped"
},{
  "history_id" : "g367rzrvq2q",
  "history_input" : null,
  "history_output" : null,
  "history_begin_time" : null,
  "history_end_time" : 1695827965222,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "100001",
  "indicator" : "Stopped"
},{
  "history_id" : "5xdewezhd48",
  "history_input" : null,
  "history_output" : null,
  "history_begin_time" : null,
  "history_end_time" : 1696432482234,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "100001",
  "indicator" : "Stopped"
},]
