[{
  "history_id" : "liwJ5F3TlL9P",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nimport netCDF4 as nc\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport pyproj\nimport uuid\n\n\nreference_date = datetime(1900, 1, 1)\nday_value = 44998\nresult_date = reference_date + timedelta(days=day_value)\ncurrent_datetime = result_date.strftime(\"%Y-%m-%d\")\n# current_datetime = datetime.now()\ntimestamp_string = current_datetime\n\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\ndef convert_csvs_to_images():\n    # Load the CSV data into a DataFrame\n    data = pd.read_csv('/home/chetana/gridmet_test_run/test_data_prediected.csv')\n\n    # Define the map boundaries for the Western US\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    # Create the Basemap instance\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    # Convert lon/lat to map coordinates\n    x, y = m(data['lon'].values, data['lat'].values)\n\n    # Plot the data using vibrant colors based on predicted_swe\n    plt.scatter(x, y, c=data['predicted_swe'], cmap='coolwarm', s=30, edgecolors='none', alpha=0.7)\n\n    # Add colorbar for reference\n    cbar = plt.colorbar()\n    cbar.set_label('Predicted SWE')\n\n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_nc_file = nc.Dataset('/home/chetana/gridmet_test_run/gridmet_climatology/etr_2023.nc')\n\n    reference_date = datetime(1900, 1, 1)\n    day = reference_nc_file.variables['day'][:]\n    day_value = day[-1]\n    \n    day_value = 44998\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    \n\n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15)\n    # Show the plot or save it to a file\n    plt.savefig(f'/home/chetana/gridmet_test_run/predicted_swe-{timestamp_string}-{uuid.uuid4().hex}.png')\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "",
  "history_begin_time" : 1690836912197,
  "history_end_time" : 1690836920412,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "Y6cAAFEKmuE1",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nimport netCDF4 as nc\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport pyproj\nimport uuid\n\n\nreference_date = datetime(1900, 1, 1)\nday_value = 44998\nresult_date = reference_date + timedelta(days=day_value)\ncurrent_datetime = result_date.strftime(\"%Y-%m-%d\")\n# current_datetime = datetime.now()\ntimestamp_string = current_datetime\n\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\ndef convert_csvs_to_images():\n    # Load the CSV data into a DataFrame\n    data = pd.read_csv('/home/chetana/gridmet_test_run/test_data_prediected.csv')\n\n    # Define the map boundaries for the Western US\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    # Create the Basemap instance\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    # Convert lon/lat to map coordinates\n    x, y = m(data['lon'].values, data['lat'].values)\n\n    # Define the scale limits\n    scale_min = 10  # Set your desired minimum value here\n    scale_max = 50  # Adjusted to show until 50\n\n    # Plot the data using the 'jet' colormap\n    plt.scatter(x, y, c=data['predicted_swe'], cmap='jet', s=30, edgecolors='none', alpha=0.7, vmin=scale_min, vmax=scale_max)\n\n    # Add colorbar for reference\n    cbar = plt.colorbar()\n    cbar.set_label('Predicted SWE')\n\n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_nc_file = nc.Dataset('/home/chetana/gridmet_test_run/gridmet_climatology/etr_2023.nc')\n\n    reference_date = datetime(1900, 1, 1)\n    day = reference_nc_file.variables['day'][:]\n    day_value = day[-1]\n    \n    day_value = 44998\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    \n\n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15)\n    # Show the plot or save it to a file\n    plt.savefig(f'/home/chetana/gridmet_test_run/predicted_swe-{timestamp_string}-{uuid.uuid4().hex}.png')\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "",
  "history_begin_time" : 1690836800105,
  "history_end_time" : 1690836808067,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "9yygseR4r1l3",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nimport netCDF4 as nc\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport pyproj\nimport uuid\n\n\nreference_date = datetime(1900, 1, 1)\nday_value = 44998\nresult_date = reference_date + timedelta(days=day_value)\ncurrent_datetime = result_date.strftime(\"%Y-%m-%d\")\n# current_datetime = datetime.now()\ntimestamp_string = current_datetime\n\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\ndef convert_csvs_to_images():\n    # Load the CSV data into a DataFrame\n    data = pd.read_csv('/home/chetana/gridmet_test_run/test_data_prediected.csv')\n\n    # Define the map boundaries for the Western US\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    # Create the Basemap instance\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    # Convert lon/lat to map coordinates\n    x, y = m(data['lon'].values, data['lat'].values)\n\n    # Define the scale limits\n    scale_min = 0\n    scale_max = 50  # Adjusted to show until 50\n\n    # Plot the data using the 'viridis' colormap\n    plt.scatter(x, y, c=data['predicted_swe'], cmap='viridis', s=30, edgecolors='none', alpha=0.7, vmin=scale_min, vmax=scale_max)\n\n    # Add colorbar for reference\n    cbar = plt.colorbar()\n    cbar.set_label('Predicted SWE')\n\n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_nc_file = nc.Dataset('/home/chetana/gridmet_test_run/gridmet_climatology/etr_2023.nc')\n\n    reference_date = datetime(1900, 1, 1)\n    day = reference_nc_file.variables['day'][:]\n    day_value = day[-1]\n    \n    day_value = 44998\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    \n\n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15)\n    # Show the plot or save it to a file\n    plt.savefig(f'/home/chetana/gridmet_test_run/predicted_swe-{timestamp_string}-{uuid.uuid4().hex}.png')\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "",
  "history_begin_time" : 1690836621131,
  "history_end_time" : 1690836628879,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "peRp25jo43MO",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nimport netCDF4 as nc\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport pyproj\nimport uuid\n\n\nreference_date = datetime(1900, 1, 1)\nday_value = 44998\nresult_date = reference_date + timedelta(days=day_value)\ncurrent_datetime = result_date.strftime(\"%Y-%m-%d\")\n# current_datetime = datetime.now()\ntimestamp_string = current_datetime\n\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\ndef convert_csvs_to_images():\n    # Load the CSV data into a DataFrame\n    data = pd.read_csv('/home/chetana/gridmet_test_run/test_data_prediected.csv')\n\n    # Define the map boundaries for the Western US\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    # Create the Basemap instance\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    # Convert lon/lat to map coordinates\n    x, y = m(data['lon'].values, data['lat'].values)\n\n    # Define the scale limits\n    scale_min = 0\n    scale_max = 50  # Adjusted to show until 50\n\n    # Create a custom colormap with shades of blue and white\n    num_colors = 100  # Number of colors to create\n    cmap_colors = plt.cm.Blues(np.linspace(0, 1, num_colors))\n    cmap_colors[0:20] = [1, 1, 1, 1]  # Replace lower values with white\n    cmap = plt.cm.colors.ListedColormap(cmap_colors)\n\n    # Plot the data using shades of blue based on predicted_swe\n    plt.scatter(x, y, c=data['predicted_swe'], cmap=cmap, s=30, edgecolors='none', alpha=0.7, vmin=scale_min, vmax=scale_max)\n\n    # Add colorbar for reference\n    cbar = plt.colorbar()\n    cbar.set_label('Predicted SWE')\n\n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_nc_file = nc.Dataset('/home/chetana/gridmet_test_run/gridmet_climatology/etr_2023.nc')\n\n    reference_date = datetime(1900, 1, 1)\n    day = reference_nc_file.variables['day'][:]\n    day_value = day[-1]\n    \n    day_value = 44998\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    \n\n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15)\n    # Show the plot or save it to a file\n    plt.savefig(f'/home/chetana/gridmet_test_run/predicted_swe-{timestamp_string}-{uuid.uuid4().hex}.png')\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "",
  "history_begin_time" : 1690836482872,
  "history_end_time" : 1690836490682,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "3A0k6M7l532s",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nimport netCDF4 as nc\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport pyproj\nimport uuid\n\n\nreference_date = datetime(1900, 1, 1)\nday_value = 44998\nresult_date = reference_date + timedelta(days=day_value)\ncurrent_datetime = result_date.strftime(\"%Y-%m-%d\")\n# current_datetime = datetime.now()\ntimestamp_string = current_datetime\n\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\ndef convert_csvs_to_images():\n    # Load the CSV data into a DataFrame\n    data = pd.read_csv('/home/chetana/gridmet_test_run/test_data_prediected.csv')\n\n    # Define the map boundaries for the Western US\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    # Create the Basemap instance\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    # Convert lon/lat to map coordinates\n    x, y = m(data['lon'].values, data['lat'].values)\n\n    # Define the scale limits\n    scale_min = 0\n    scale_max = data['predicted_swe'].max()\n\n    # Create a custom colormap with shades of blue and white\n    num_colors = 100  # Number of colors to create\n    cmap_colors = plt.cm.Blues(np.linspace(0, 1, num_colors))\n    cmap_colors[0:20] = [1, 1, 1, 1]  # Replace lower values with white\n    cmap = plt.cm.colors.ListedColormap(cmap_colors)\n\n    # Plot the data using shades of blue based on predicted_swe\n    plt.scatter(x, y, c=data['predicted_swe'], cmap=cmap, s=30, edgecolors='none', alpha=0.7, vmin=scale_min, vmax=scale_max)\n\n    # Add colorbar for reference\n    cbar = plt.colorbar()\n    cbar.set_label('Predicted SWE')\n\n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_nc_file = nc.Dataset('/home/chetana/gridmet_test_run/gridmet_climatology/etr_2023.nc')\n\n    reference_date = datetime(1900, 1, 1)\n    day = reference_nc_file.variables['day'][:]\n    day_value = day[-1]\n    \n    day_value = 44998\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    \n\n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15)\n    # Show the plot or save it to a file\n    plt.savefig(f'/home/chetana/gridmet_test_run/predicted_swe-{timestamp_string}-{uuid.uuid4().hex}.png')\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "",
  "history_begin_time" : 1690836199538,
  "history_end_time" : 1690836207242,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "GL70uAAzir3m",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nimport netCDF4 as nc\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport pyproj\nimport uuid\n\n\nreference_date = datetime(1900, 1, 1)\nday_value = 44998\nresult_date = reference_date + timedelta(days=day_value)\ncurrent_datetime = result_date.strftime(\"%Y-%m-%d\")\n# current_datetime = datetime.now()\ntimestamp_string = current_datetime\n\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\ndef convert_csvs_to_images():\n    # Load the CSV data into a DataFrame\n    data = pd.read_csv('/home/chetana/gridmet_test_run/test_data_prediected.csv')\n\n    # Define the map boundaries for the Western US\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    # Create the Basemap instance\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    # Convert lon/lat to map coordinates\n    x, y = m(data['lon'].values, data['lat'].values)\n\n    # Define the scale limits\n    scale_min = 0\n    scale_max = data['predicted_swe'].max()\n\n    # Create a custom colormap with only white and blue colors\n    cmap = plt.cm.colors.ListedColormap(['white', 'blue'])\n\n    # Plot the data using shades of blue based on predicted_swe\n    plt.scatter(x, y, c=data['predicted_swe'], cmap=cmap, s=30, edgecolors='none', alpha=0.7, vmin=scale_min, vmax=scale_max)\n\n    # Add colorbar for reference\n    cbar = plt.colorbar()\n    cbar.set_label('Predicted SWE')\n\n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_nc_file = nc.Dataset('/home/chetana/gridmet_test_run/gridmet_climatology/etr_2023.nc')\n\n    reference_date = datetime(1900, 1, 1)\n    day = reference_nc_file.variables['day'][:]\n    day_value = day[-1]\n    \n    day_value = 44998\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    \n\n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15)\n    # Show the plot or save it to a file\n    plt.savefig(f'/home/chetana/gridmet_test_run/predicted_swe-{timestamp_string}-{uuid.uuid4().hex}.png')\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "",
  "history_begin_time" : 1690836119402,
  "history_end_time" : 1690836127298,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "oT39ih9NMA6o",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nimport netCDF4 as nc\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport pyproj\nimport uuid\n\n\nreference_date = datetime(1900, 1, 1)\nday_value = 44998\nresult_date = reference_date + timedelta(days=day_value)\ncurrent_datetime = result_date.strftime(\"%Y-%m-%d\")\n# current_datetime = datetime.now()\ntimestamp_string = current_datetime\n\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\ndef convert_csvs_to_images():\n    # Load the CSV data into a DataFrame\n    data = pd.read_csv('/home/chetana/gridmet_test_run/test_data_prediected.csv')\n\n    # Define the map boundaries for the Western US\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    # Create the Basemap instance\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    # Convert lon/lat to map coordinates\n    x, y = m(data['lon'].values, data['lat'].values)\n\n    # Define the scale limits\n    scale_min = 0\n    scale_max = data['predicted_swe'].max()\n\n    # Plot the data using shades of blue based on predicted_swe\n    plt.scatter(x, y, c=data['predicted_swe'], cmap='Blues', s=30, edgecolors='none', alpha=0.7, vmin=scale_min, vmax=scale_max)\n\n    # Add colorbar for reference\n    cbar = plt.colorbar()\n    cbar.set_label('Predicted SWE')\n\n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_nc_file = nc.Dataset('/home/chetana/gridmet_test_run/gridmet_climatology/etr_2023.nc')\n\n    reference_date = datetime(1900, 1, 1)\n    day = reference_nc_file.variables['day'][:]\n    day_value = day[-1]\n    \n    day_value = 44998\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    \n\n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15)\n    # Show the plot or save it to a file\n    plt.savefig(f'/home/chetana/gridmet_test_run/predicted_swe-{timestamp_string}-{uuid.uuid4().hex}.png')\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "",
  "history_begin_time" : 1690836012151,
  "history_end_time" : 1690836020034,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "AFEbUzMUzuFW",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nimport netCDF4 as nc\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport pyproj\nimport uuid\n\n\nreference_date = datetime(1900, 1, 1)\nday_value = 44998\nresult_date = reference_date + timedelta(days=day_value)\ncurrent_datetime = result_date.strftime(\"%Y-%m-%d\")\n# current_datetime = datetime.now()\ntimestamp_string = current_datetime\n\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\ndef convert_csvs_to_images():\n    # Load the CSV data into a DataFrame\n    data = pd.read_csv('/home/chetana/gridmet_test_run/test_data_prediected.csv')\n\n    # Define the map boundaries for the Western US\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    # Create the Basemap instance\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    # Convert lon/lat to map coordinates\n    x, y = m(data['lon'].values, data['lat'].values)\n\n    # Plot the data using shades of blue based on predicted_swe\n    plt.scatter(x, y, c=data['predicted_swe'], cmap='Blues', s=30, edgecolors='none', alpha=0.7)\n\n    # Add colorbar for reference\n    cbar = plt.colorbar()\n    cbar.set_label('Predicted SWE')\n\n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_nc_file = nc.Dataset('/home/chetana/gridmet_test_run/gridmet_climatology/etr_2023.nc')\n\n    reference_date = datetime(1900, 1, 1)\n    day = reference_nc_file.variables['day'][:]\n    day_value = day[-1]\n    \n    day_value = 44998\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    \n\n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15)\n    # Show the plot or save it to a file\n    plt.savefig(f'/home/chetana/gridmet_test_run/predicted_swe-{timestamp_string}-{uuid.uuid4().hex}.png')\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "",
  "history_begin_time" : 1690820118617,
  "history_end_time" : 1690820126539,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "lYR5MfpfPdX1",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nimport netCDF4 as nc\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport pyproj\nimport uuid\n\nreference_date = datetime(1900, 1, 1)\nday_value = 44998\nresult_date = reference_date + timedelta(days=day_value)\ncurrent_datetime = result_date.strftime(\"%Y-%m-%d\")\n# current_datetime = datetime.now()\ntimestamp_string = current_datetime\n\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\ndef convert_csvs_to_images():\n    # Load the CSV data into a DataFrame\n    data = pd.read_csv('/home/chetana/gridmet_test_run/test_data_prediected.csv')\n\n    # Define the map boundaries for the Western US\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    # Create the Basemap instance\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    # Convert lon/lat to map coordinates\n    x, y = m(data['lon'].values, data['lat'].values)\n\n    # Plot the data using shades of blue based on predicted_swe\n    plt.scatter(x, y, c=data['predicted_swe'], cmap='Blues', s=30, edgecolors='none', alpha=0.7, vmin=0, vmax=50)\n\n    # Add colorbar for reference\n    cbar = plt.colorbar()\n    cbar.set_label('Predicted SWE')\n\n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_nc_file = nc.Dataset('/home/chetana/gridmet_test_run/gridmet_climatology/etr_2023.nc')\n\n    reference_date = datetime(1900, 1, 1)\n    day = reference_nc_file.variables['day'][:]\n    day_value = day[-1]\n    \n    day_value = 44998\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    \n\n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15)\n    # Show the plot or save it to a file\n    plt.savefig(f'/home/chetana/gridmet_test_run/predicted_swe-{timestamp_string}-{uuid.uuid4().hex}.png')\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "",
  "history_begin_time" : 1690820079122,
  "history_end_time" : 1690820087144,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "oYVGLVv5LMDR",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nimport netCDF4 as nc\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport pyproj\nimport uuid\n\n\nreference_date = datetime(1900, 1, 1)\nday_value = 44998\nresult_date = reference_date + timedelta(days=day_value)\ncurrent_datetime = result_date.strftime(\"%Y-%m-%d\")\n# current_datetime = datetime.now()\ntimestamp_string = current_datetime\n\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\ndef convert_csvs_to_images():\n    # Load the CSV data into a DataFrame\n    data = pd.read_csv('/home/chetana/gridmet_test_run/test_data_prediected.csv')\n\n    # Define the map boundaries for the Western US\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    # Create the Basemap instance\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    # Convert lon/lat to map coordinates\n    x, y = m(data['lon'].values, data['lat'].values)\n\n    # Plot the data using shades of blue based on predicted_swe\n    plt.scatter(x, y, c=data['predicted_swe'], cmap='Blues', s=30, edgecolors='none', alpha=0.7)\n\n    # Add colorbar for reference\n    cbar = plt.colorbar()\n    cbar.set_label('Predicted SWE')\n\n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_nc_file = nc.Dataset('/home/chetana/gridmet_test_run/gridmet_climatology/etr_2023.nc')\n\n    reference_date = datetime(1900, 1, 1)\n    day = reference_nc_file.variables['day'][:]\n    day_value = day[-1]\n    \n    day_value = 44998\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    \n\n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15)\n    # Show the plot or save it to a file\n    plt.savefig(f'/home/chetana/gridmet_test_run/predicted_swe-{timestamp_string}-{uuid.uuid4().hex}.png')\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "",
  "history_begin_time" : 1690819699602,
  "history_end_time" : 1690819707612,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "kchvmSAinBJ3",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nimport netCDF4 as nc\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport pyproj\nimport uuid\n\n\nreference_date = datetime(1900, 1, 1)\nday_value = 44998\nresult_date = reference_date + timedelta(days=day_value)\ncurrent_datetime = result_date.strftime(\"%Y-%m-%d\")\n# current_datetime = datetime.now()\ntimestamp_string = current_datetime\n\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\ndef convert_csvs_to_images():\n    # Load the CSV data into a DataFrame\n    data = pd.read_csv('/home/chetana/gridmet_test_run/test_data_prediected.csv')\n\n    # Define the map boundaries for the Western US\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    # Create the Basemap instance\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    # Convert lon/lat to map coordinates\n    x, y = m(data['lon'].values, data['lat'].values)\n\n    # Plot the data using vibrant colors based on predicted_swe\n    plt.scatter(x, y, c=data['predicted_swe'], cmap='coolwarm', s=30, edgecolors='none', alpha=0.7)\n\n    # Add colorbar for reference\n    cbar = plt.colorbar()\n    cbar.set_label('Predicted SWE')\n\n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_nc_file = nc.Dataset('/home/chetana/gridmet_test_run/gridmet_climatology/etr_2023.nc')\n\n    reference_date = datetime(1900, 1, 1)\n    day = reference_nc_file.variables['day'][:]\n    day_value = day[-1]\n    \n    day_value = 44998\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    \n\n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15)\n    # Show the plot or save it to a file\n    plt.savefig(f'/home/chetana/gridmet_test_run/predicted_swe-{timestamp_string}-{uuid.uuid4().hex}.png')\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "",
  "history_begin_time" : 1690819540914,
  "history_end_time" : 1690819551318,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "zUKiRIxwgDrk",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nimport netCDF4 as nc\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport pyproj\nimport uuid\n\n\nreference_date = datetime(1900, 1, 1)\nday_value = 44998\nresult_date = reference_date + timedelta(days=day_value)\ncurrent_datetime = result_date.strftime(\"%Y-%m-%d\")\n# current_datetime = datetime.now()\ntimestamp_string = current_datetime\n\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\ndef convert_csvs_to_images():\n    # Load the CSV data into a DataFrame\n    data = pd.read_csv('/home/chetana/gridmet_test_run/test_data_prediected.csv')\n\n    # Define the map boundaries for the Western US\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    # Create the Basemap instance\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    # Convert lon/lat to map coordinates\n    x, y = m(data['lon'].values, data['lat'].values)\n\n    # Plot the data using vibrant colors based on predicted_swe\n    plt.scatter(x, y, c=data['predicted_swe'], cmap='coolwarm', s=30, edgecolors='none', alpha=0.7)\n\n    # Add colorbar for reference\n    cbar = plt.colorbar()\n    cbar.set_label('Predicted SWE')\n\n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_nc_file = nc.Dataset('/home/chetana/gridmet_test_run/gridmet_climatology/etr_2023.nc')\n\n    reference_date = datetime(1900, 1, 1)\n    day = reference_nc_file.variables['day'][:]\n    day_value = day[-1]\n    \n    day_value = 44998\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    \n\n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15)\n    # Show the plot or save it to a file\n    plt.savefig(f'/home/chetana/gridmet_test_run/predicted_swe-{timestamp_string}-{uuid.uuid4().hex}.png')\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "",
  "history_begin_time" : 1690678451714,
  "history_end_time" : 1690678461544,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "04IzS0lJPa4S",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nimport netCDF4 as nc\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport pyproj\nimport uuid\n\n\nreference_date = datetime(1900, 1, 1)\nday_value = 44938\nresult_date = reference_date + timedelta(days=day_value)\ncurrent_datetime = result_date.strftime(\"%Y-%m-%d\")\n# current_datetime = datetime.now()\ntimestamp_string = current_datetime\n\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\ndef convert_csvs_to_images():\n    # Load the CSV data into a DataFrame\n    data = pd.read_csv('/home/chetana/gridmet_test_run/test_data_prediected.csv')\n\n    # Define the map boundaries for the Western US\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    # Create the Basemap instance\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    # Convert lon/lat to map coordinates\n    x, y = m(data['lon'].values, data['lat'].values)\n\n    # Plot the data using vibrant colors based on predicted_swe\n    plt.scatter(x, y, c=data['predicted_swe'], cmap='coolwarm', s=30, edgecolors='none', alpha=0.7)\n\n    # Add colorbar for reference\n    cbar = plt.colorbar()\n    cbar.set_label('Predicted SWE')\n\n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_nc_file = nc.Dataset('/home/chetana/gridmet_test_run/gridmet_climatology/etr_2023.nc')\n\n    reference_date = datetime(1900, 1, 1)\n    day = reference_nc_file.variables['day'][:]\n    day_value = day[-1]\n    \n    day_value = 44938\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    \n\n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15)\n    # Show the plot or save it to a file\n    plt.savefig(f'/home/chetana/gridmet_test_run/predicted_swe-{timestamp_string}-{uuid.uuid4().hex}.png')\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "",
  "history_begin_time" : 1690678278789,
  "history_end_time" : 1690678288963,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "J0TdFZh4SAC0",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nimport netCDF4 as nc\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport pyproj\nimport uuid\n\n\nreference_date = datetime(1900, 1, 1)\nday_value = 44969\nresult_date = reference_date + timedelta(days=day_value)\ncurrent_datetime = result_date.strftime(\"%Y-%m-%d\")\n# current_datetime = datetime.now()\ntimestamp_string = current_datetime\n\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\ndef convert_csvs_to_images():\n    # Load the CSV data into a DataFrame\n    data = pd.read_csv('/home/chetana/gridmet_test_run/test_data_prediected.csv')\n\n    # Define the map boundaries for the Western US\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    # Create the Basemap instance\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    # Convert lon/lat to map coordinates\n    x, y = m(data['lon'].values, data['lat'].values)\n\n    # Plot the data using vibrant colors based on predicted_swe\n    plt.scatter(x, y, c=data['predicted_swe'], cmap='coolwarm', s=30, edgecolors='none', alpha=0.7)\n\n    # Add colorbar for reference\n    cbar = plt.colorbar()\n    cbar.set_label('Predicted SWE')\n\n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_nc_file = nc.Dataset('/home/chetana/gridmet_test_run/gridmet_climatology/etr_2023.nc')\n\n    reference_date = datetime(1900, 1, 1)\n    day = reference_nc_file.variables['day'][:]\n    day_value = day[-1]\n    \n    day_value = 44969\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    \n\n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15)\n    # Show the plot or save it to a file\n    plt.savefig(f'/home/chetana/gridmet_test_run/predicted_swe-{timestamp_string}-{uuid.uuid4().hex}.png')\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "",
  "history_begin_time" : 1690678154357,
  "history_end_time" : 1690678164134,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "T2pch0SXLBcP",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nimport netCDF4 as nc\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport pyproj\nimport uuid\n\n\nreference_date = datetime(1900, 1, 1)\nday_value = 44604\nresult_date = reference_date + timedelta(days=day_value)\ncurrent_datetime = result_date.strftime(\"%Y-%m-%d\")\n# current_datetime = datetime.now()\ntimestamp_string = current_datetime\n\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\ndef convert_csvs_to_images():\n    # Load the CSV data into a DataFrame\n    data = pd.read_csv('/home/chetana/gridmet_test_run/test_data_prediected.csv')\n\n    # Define the map boundaries for the Western US\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    # Create the Basemap instance\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    # Convert lon/lat to map coordinates\n    x, y = m(data['lon'].values, data['lat'].values)\n\n    # Plot the data using vibrant colors based on predicted_swe\n    plt.scatter(x, y, c=data['predicted_swe'], cmap='coolwarm', s=30, edgecolors='none', alpha=0.7)\n\n    # Add colorbar for reference\n    cbar = plt.colorbar()\n    cbar.set_label('Predicted SWE')\n\n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_nc_file = nc.Dataset('/home/chetana/gridmet_test_run/gridmet_climatology/etr_2023.nc')\n\n    reference_date = datetime(1900, 1, 1)\n    day = reference_nc_file.variables['day'][:]\n    day_value = day[-1]\n    \n    day_value = 44604\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    \n\n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15)\n    # Show the plot or save it to a file\n    plt.savefig(f'/home/chetana/gridmet_test_run/predicted_swe-{timestamp_string}-{uuid.uuid4().hex}.png')\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "",
  "history_begin_time" : 1690677967950,
  "history_end_time" : 1690677977799,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "aQ39V5FyPIEL",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nimport netCDF4 as nc\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport pyproj\nimport uuid\n\n\nreference_date = datetime(1900, 1, 1)\nday_value = 44574\nresult_date = reference_date + timedelta(days=day_value)\ncurrent_datetime = result_date.strftime(\"%Y-%m-%d\")\n# current_datetime = datetime.now()\ntimestamp_string = current_datetime\n\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\ndef convert_csvs_to_images():\n    # Load the CSV data into a DataFrame\n    data = pd.read_csv('/home/chetana/gridmet_test_run/test_data_prediected.csv')\n\n    # Define the map boundaries for the Western US\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    # Create the Basemap instance\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    # Convert lon/lat to map coordinates\n    x, y = m(data['lon'].values, data['lat'].values)\n\n    # Plot the data using vibrant colors based on predicted_swe\n    plt.scatter(x, y, c=data['predicted_swe'], cmap='coolwarm', s=30, edgecolors='none', alpha=0.7)\n\n    # Add colorbar for reference\n    cbar = plt.colorbar()\n    cbar.set_label('Predicted SWE')\n\n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_nc_file = nc.Dataset('/home/chetana/gridmet_test_run/gridmet_climatology/etr_2023.nc')\n\n    reference_date = datetime(1900, 1, 1)\n    day = reference_nc_file.variables['day'][:]\n    day_value = day[-1]\n    \n    day_value = 44574\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    \n\n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15)\n    # Show the plot or save it to a file\n    plt.savefig(f'/home/chetana/gridmet_test_run/predicted_swe-{timestamp_string}-{uuid.uuid4().hex}.png')\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "",
  "history_begin_time" : 1690677850165,
  "history_end_time" : 1690677859910,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "aAXN9y3IWvsI",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nimport netCDF4 as nc\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport pyproj\nimport uuid\n\n\nreference_date = datetime(1900, 1, 1)\nday_value = 44554\nresult_date = reference_date + timedelta(days=day_value)\ncurrent_datetime = result_date.strftime(\"%Y-%m-%d\")\n# current_datetime = datetime.now()\ntimestamp_string = current_datetime\n\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\ndef convert_csvs_to_images():\n    # Load the CSV data into a DataFrame\n    data = pd.read_csv('/home/chetana/gridmet_test_run/test_data_prediected.csv')\n\n    # Define the map boundaries for the Western US\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    # Create the Basemap instance\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    # Convert lon/lat to map coordinates\n    x, y = m(data['lon'].values, data['lat'].values)\n\n    # Plot the data using vibrant colors based on predicted_swe\n    plt.scatter(x, y, c=data['predicted_swe'], cmap='coolwarm', s=30, edgecolors='none', alpha=0.7)\n\n    # Add colorbar for reference\n    cbar = plt.colorbar()\n    cbar.set_label('Predicted SWE')\n\n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_nc_file = nc.Dataset('/home/chetana/gridmet_test_run/gridmet_climatology/etr_2023.nc')\n\n    reference_date = datetime(1900, 1, 1)\n    day = reference_nc_file.variables['day'][:]\n    day_value = day[-1]\n    \n    day_value = 44574\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    \n\n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15)\n    # Show the plot or save it to a file\n    plt.savefig(f'/home/chetana/gridmet_test_run/predicted_swe-{timestamp_string}-{uuid.uuid4().hex}.png')\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "",
  "history_begin_time" : 1690677726826,
  "history_end_time" : 1690677735097,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "9oVgTe9mNwgr",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nimport netCDF4 as nc\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport pyproj\nimport uuid\n\n\nreference_date = datetime(1900, 1, 1)\nday_value = 44554\nresult_date = reference_date + timedelta(days=day_value)\ncurrent_datetime = result_date.strftime(\"%Y-%m-%d\")\n# current_datetime = datetime.now()\ntimestamp_string = current_datetime\n\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\ndef convert_csvs_to_images():\n    # Load the CSV data into a DataFrame\n    data = pd.read_csv('/home/chetana/gridmet_test_run/test_data_prediected.csv')\n\n    # Define the map boundaries for the Western US\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    # Create the Basemap instance\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    # Convert lon/lat to map coordinates\n    x, y = m(data['lon'].values, data['lat'].values)\n\n    # Plot the data using vibrant colors based on predicted_swe\n    plt.scatter(x, y, c=data['predicted_swe'], cmap='coolwarm', s=30, edgecolors='none', alpha=0.7)\n\n    # Add colorbar for reference\n    cbar = plt.colorbar()\n    cbar.set_label('Predicted SWE')\n\n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_nc_file = nc.Dataset('/home/chetana/gridmet_test_run/gridmet_climatology/etr_2023.nc')\n\n    reference_date = datetime(1900, 1, 1)\n    day = reference_nc_file.variables['day'][:]\n    day_value = day[-1]\n    \n    day_value = 44554\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    \n\n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15)\n    # Show the plot or save it to a file\n    plt.savefig(f'/home/chetana/gridmet_test_run/predicted_swe-{timestamp_string}-{uuid.uuid4().hex}.png')\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "",
  "history_begin_time" : 1690677714653,
  "history_end_time" : 1690677723425,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "ifLVjj2L7gOa",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nimport netCDF4 as nc\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport pyproj\nimport uuid\n\n\nreference_date = datetime(1900, 1, 1)\nday_value = 44554\nresult_date = reference_date + timedelta(days=day_value)\ncurrent_datetime = result_date.strftime(\"%Y-%m-%d\")\n# current_datetime = datetime.now()\ntimestamp_string = current_datetime\n\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\ndef convert_csvs_to_images():\n    # Load the CSV data into a DataFrame\n    data = pd.read_csv('/home/chetana/gridmet_test_run/test_data_prediected.csv')\n\n    # Define the map boundaries for the Western US\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    # Create the Basemap instance\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    # Convert lon/lat to map coordinates\n    x, y = m(data['lon'].values, data['lat'].values)\n\n    # Plot the data using vibrant colors based on predicted_swe\n    plt.scatter(x, y, c=data['predicted_swe'], cmap='coolwarm', s=30, edgecolors='none', alpha=0.7)\n\n    # Add colorbar for reference\n    cbar = plt.colorbar()\n    cbar.set_label('Predicted SWE')\n\n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_nc_file = nc.Dataset('/home/chetana/gridmet_test_run/gridmet_climatology/etr_2023.nc')\n\n    reference_date = datetime(1900, 1, 1)\n    day = reference_nc_file.variables['day'][:]\n    day_value = day[-1]\n    \n    day_value = 44554\n    \n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n    \n\n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15)\n    # Show the plot or save it to a file\n    plt.savefig(f'/home/chetana/gridmet_test_run/predicted_swe-{timestamp_string}-{uuid.uuid4().hex}.png')\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "",
  "history_begin_time" : 1690676990724,
  "history_end_time" : 1690677000574,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "N4tcMSyxdlZt",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nimport netCDF4 as nc\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport pyproj\nimport uuid\n\n\nreference_date = datetime(1900, 1, 1)\nday_value = 44554\nresult_date = reference_date + timedelta(days=day_value)\ncurrent_datetime = result_date.strftime(\"%Y-%m-%d\")\n# current_datetime = datetime.now()\ntimestamp_string = current_datetime\n\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\ndef convert_csvs_to_images():\n    # Load the CSV data into a DataFrame\n    data = pd.read_csv('/home/chetana/gridmet_test_run/test_data_prediected.csv')\n\n    # Define the map boundaries for the Western US\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    # Create the Basemap instance\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    # Convert lon/lat to map coordinates\n    x, y = m(data['lon'].values, data['lat'].values)\n\n    # Plot the data using vibrant colors based on predicted_swe\n    plt.scatter(x, y, c=data['predicted_swe'], cmap='coolwarm', s=30, edgecolors='none', alpha=0.7)\n\n    # Add colorbar for reference\n    cbar = plt.colorbar()\n    cbar.set_label('Predicted SWE')\n\n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_nc_file = nc.Dataset('/home/chetana/gridmet_test_run/gridmet_climatology/etr_2023.nc')\n\n    reference_date = datetime(1900, 1, 1)\n    day = reference_nc_file.variables['day'][:]\n    day_value = day[-1]\n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n\n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15)\n    # Show the plot or save it to a file\n    plt.savefig(f'/home/chetana/gridmet_test_run/predicted_swe-{timestamp_string}-{uuid.uuid4().hex}.png')\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "",
  "history_begin_time" : 1690676874331,
  "history_end_time" : 1690676884498,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "s4xHQXntaVyJ",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nimport netCDF4 as nc\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport pyproj\nimport uuid\n\n\nreference_date = datetime(1900, 1, 1)\nday_value = 44554\nresult_date = reference_date + timedelta(days=day_value)\ncurrent_datetime = result_date.strftime(\"%Y-%m-%d\")\n# current_datetime = datetime.now()\ntimestamp_string = current_datetime\n\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\ndef convert_csvs_to_images():\n    # Load the CSV data into a DataFrame\n    data = pd.read_csv('/home/chetana/gridmet_test_run/test_data_prediected.csv')\n\n    # Define the map boundaries for the Western US\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    # Create the Basemap instance\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    # Convert lon/lat to map coordinates\n    x, y = m(data['lon'].values, data['lat'].values)\n\n    # Plot the data using vibrant colors based on predicted_swe\n    plt.scatter(x, y, c=data['predicted_swe'], cmap='coolwarm', s=30, edgecolors='none', alpha=0.7)\n\n    # Add colorbar for reference\n    cbar = plt.colorbar()\n    cbar.set_label('Predicted SWE')\n\n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_nc_file = nc.Dataset('/home/chetana/gridmet_test_run/gridmet_climatology/etr_2023.nc')\n\n    reference_date = datetime(1900, 1, 1)\n    day = reference_nc_file.variables['day'][:]\n    day_value = day[-1]\n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n\n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15)\n    # Show the plot or save it to a file\n    plt.savefig(f'/home/chetana/gridmet_test_run/predicted_swe-{timestamp_string}-{uuid.uuid4().hex}.png')\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "",
  "history_begin_time" : 1690676824867,
  "history_end_time" : 1690676834866,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "eG3PbZqk4nh0",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nimport netCDF4 as nc\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport pyproj\nimport uuid\n\n\nreference_date = datetime(1900, 1, 1)\nday_value = 44554\nresult_date = reference_date + timedelta(days=day_value)\ncurrent_datetime = result_date.strftime(\"%Y-%m-%d\")\n# current_datetime = datetime.now()\n\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\ndef convert_csvs_to_images():\n    # Load the CSV data into a DataFrame\n    data = pd.read_csv('/home/chetana/gridmet_test_run/test_data_prediected.csv')\n\n    # Define the map boundaries for the Western US\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    # Create the Basemap instance\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    # Convert lon/lat to map coordinates\n    x, y = m(data['lon'].values, data['lat'].values)\n\n    # Plot the data using vibrant colors based on predicted_swe\n    plt.scatter(x, y, c=data['predicted_swe'], cmap='coolwarm', s=30, edgecolors='none', alpha=0.7)\n\n    # Add colorbar for reference\n    cbar = plt.colorbar()\n    cbar.set_label('Predicted SWE')\n\n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_nc_file = nc.Dataset('/home/chetana/gridmet_test_run/gridmet_climatology/etr_2023.nc')\n\n    reference_date = datetime(1900, 1, 1)\n    day = reference_nc_file.variables['day'][:]\n    day_value = day[-1]\n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n\n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15)\n    # Show the plot or save it to a file\n    plt.savefig(f'/home/chetana/gridmet_test_run/predicted_swe-{timestamp_string}-{uuid.uuid4().hex}.png')\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "Traceback (most recent call last):\n  File \"/home/chetana/gw-workspace/eG3PbZqk4nh0/convert_results_to_images.py\", line 92, in <module>\n    convert_csvs_to_images()\n  File \"/home/chetana/gw-workspace/eG3PbZqk4nh0/convert_results_to_images.py\", line 89, in convert_csvs_to_images\n    plt.savefig(f'/home/chetana/gridmet_test_run/predicted_swe-{timestamp_string}-{uuid.uuid4().hex}.png')\nNameError: name 'timestamp_string' is not defined\n",
  "history_begin_time" : 1690676775513,
  "history_end_time" : 1690676780969,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "lU5fha7JfIzn",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nimport netCDF4 as nc\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport pyproj\nimport uuid\n\n\nreference_date = datetime(1900, 1, 1)\nday = reference_nc_file.variables['day'][:]\n\nday_value = day[-1]\nday_value = 44554\n\nresult_date = reference_date + timedelta(days=day_value)\ncurrent_datetime = result_date.strftime(\"%Y-%m-%d\")\n# current_datetime = datetime.now()\n\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\ndef convert_csvs_to_images():\n    # Load the CSV data into a DataFrame\n    data = pd.read_csv('/home/chetana/gridmet_test_run/test_data_prediected.csv')\n\n    # Define the map boundaries for the Western US\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    # Create the Basemap instance\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    # Convert lon/lat to map coordinates\n    x, y = m(data['lon'].values, data['lat'].values)\n\n    # Plot the data using vibrant colors based on predicted_swe\n    plt.scatter(x, y, c=data['predicted_swe'], cmap='coolwarm', s=30, edgecolors='none', alpha=0.7)\n\n    # Add colorbar for reference\n    cbar = plt.colorbar()\n    cbar.set_label('Predicted SWE')\n\n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_nc_file = nc.Dataset('/home/chetana/gridmet_test_run/gridmet_climatology/etr_2023.nc')\n\n    reference_date = datetime(1900, 1, 1)\n    day = reference_nc_file.variables['day'][:]\n    day_value = day[-1]\n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n\n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15)\n    # Show the plot or save it to a file\n    plt.savefig(f'/home/chetana/gridmet_test_run/predicted_swe-{timestamp_string}-{uuid.uuid4().hex}.png')\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "Traceback (most recent call last):\n  File \"/home/chetana/gw-workspace/lU5fha7JfIzn/convert_results_to_images.py\", line 12, in <module>\n    day = reference_nc_file.variables['day'][:]\nNameError: name 'reference_nc_file' is not defined\n",
  "history_begin_time" : 1690676747029,
  "history_end_time" : 1690676748986,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "JvyEHKvu1gbf",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nimport netCDF4 as nc\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport pyproj\nimport uuid\n\n\nreference_date = datetime(1900, 1, 1)\n# Convert the datetime object to a timestamp string\ntimestamp_string = current_datetime.strftime(\"%Y-%m-%d\")\n# current_datetime = datetime.now()\ncurrent_datetime = timestamp_string\n\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\ndef convert_csvs_to_images():\n    # Load the CSV data into a DataFrame\n    data = pd.read_csv('/home/chetana/gridmet_test_run/test_data_prediected.csv')\n\n    # Define the map boundaries for the Western US\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    # Create the Basemap instance\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    # Convert lon/lat to map coordinates\n    x, y = m(data['lon'].values, data['lat'].values)\n\n    # Plot the data using vibrant colors based on predicted_swe\n    plt.scatter(x, y, c=data['predicted_swe'], cmap='coolwarm', s=30, edgecolors='none', alpha=0.7)\n\n    # Add colorbar for reference\n    cbar = plt.colorbar()\n    cbar.set_label('Predicted SWE')\n\n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_nc_file = nc.Dataset('/home/chetana/gridmet_test_run/gridmet_climatology/etr_2023.nc')\n\n    reference_date = datetime(1900, 1, 1)\n    day = reference_nc_file.variables['day'][:]\n    day_value = day[-1]\n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n\n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15)\n    # Show the plot or save it to a file\n    plt.savefig(f'/home/chetana/gridmet_test_run/predicted_swe-{timestamp_string}-{uuid.uuid4().hex}.png')\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "Traceback (most recent call last):\n  File \"/home/chetana/gw-workspace/JvyEHKvu1gbf/convert_results_to_images.py\", line 13, in <module>\n    timestamp_string = current_datetime.strftime(\"%Y-%m-%d\")\nNameError: name 'current_datetime' is not defined\n",
  "history_begin_time" : 1690676665278,
  "history_end_time" : 1690676667201,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "hsXFcZe8pEbH",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nimport netCDF4 as nc\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport pyproj\nimport uuid\n\ncurrent_datetime = datetime.now()\n\n# Convert the datetime object to a timestamp string\ntimestamp_string = current_datetime.strftime(\"%Y-%m-%d %H:%M:%S\")\n\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\ndef convert_csvs_to_images():\n    # Load the CSV data into a DataFrame\n    data = pd.read_csv('/home/chetana/gridmet_test_run/test_data_prediected.csv')\n\n    # Define the map boundaries for the Western US\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    # Create the Basemap instance\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    # Convert lon/lat to map coordinates\n    x, y = m(data['lon'].values, data['lat'].values)\n\n    # Plot the data using vibrant colors based on predicted_swe\n    plt.scatter(x, y, c=data['predicted_swe'], cmap='coolwarm', s=30, edgecolors='none', alpha=0.7)\n\n    # Add colorbar for reference\n    cbar = plt.colorbar()\n    cbar.set_label('Predicted SWE')\n\n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_nc_file = nc.Dataset('/home/chetana/gridmet_test_run/gridmet_climatology/etr_2023.nc')\n\n    reference_date = datetime(1900, 1, 1)\n    day = reference_nc_file.variables['day'][:]\n    day_value = day[-1]\n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n\n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15)\n    # Show the plot or save it to a file\n    plt.savefig(f'/home/chetana/gridmet_test_run/predicted_swe-{timestamp_string}-{uuid.uuid4().hex}.png')\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "",
  "history_begin_time" : 1690676453646,
  "history_end_time" : 1690676463772,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "97nGC8wB15f7",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nimport netCDF4 as nc\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport pyproj\nimport uuid\n\ncurrent_datetime = datetime.now()\n\n# Convert the datetime object to a timestamp string\ntimestamp_string = current_datetime.strftime(\"%Y-%m-%d %H:%M:%S\")\n\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\ndef convert_csvs_to_images():\n    # Load the CSV data into a DataFrame\n    data = pd.read_csv('/home/chetana/gridmet_test_run/test_data_prediected.csv')\n\n    # Define the map boundaries for the Western US\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    # Create the Basemap instance\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    # Convert lon/lat to map coordinates\n    x, y = m(data['lon'].values, data['lat'].values)\n\n    # Plot the data using vibrant colors based on predicted_swe\n    plt.scatter(x, y, c=data['predicted_swe'], cmap='coolwarm', s=30, edgecolors='none', alpha=0.7)\n\n    # Add colorbar for reference\n    cbar = plt.colorbar()\n    cbar.set_label('Predicted SWE')\n\n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_nc_file = nc.Dataset('/home/chetana/gridmet_test_run/gridmet_climatology/etr_2023.nc')\n\n    reference_date = datetime(1900, 1, 1)\n    day = reference_nc_file.variables['day'][:]\n    day_value = day[-1]\n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n\n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15)\n    # Show the plot or save it to a file\n    plt.savefig(f'/home/chetana/gridmet_test_run/predicted_swe-{timestamp_string}-{uuid.uuid4().hex}.png')\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "",
  "history_begin_time" : 1690676029191,
  "history_end_time" : 1690676039810,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "Kjk8vEWa8GWj",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nimport netCDF4 as nc\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport pyproj\nimport uuid\n\ncurrent_datetime = datetime.now()\n\n# Convert the datetime object to a timestamp string\ntimestamp_string = current_datetime.strftime(\"%Y-%m-%d %H:%M:%S\")\n\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\ndef convert_csvs_to_images():\n    # Load the CSV data into a DataFrame\n    data = pd.read_csv('/home/chetana/gridmet_test_run/test_data_prediected.csv')\n\n    # Define the map boundaries for the Western US\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    # Create the Basemap instance\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    # Convert lon/lat to map coordinates\n    x, y = m(data['lon'].values, data['lat'].values)\n\n    # Plot the data using vibrant colors based on predicted_swe\n    plt.scatter(x, y, c=data['predicted_swe'], cmap='coolwarm', s=30, edgecolors='none', alpha=0.7)\n\n    # Add colorbar for reference\n    cbar = plt.colorbar()\n    cbar.set_label('Predicted SWE')\n\n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_nc_file = nc.Dataset('/home/chetana/gridmet_test_run/gridmet_climatology/etr_2023.nc')\n\n    reference_date = datetime(1900, 1, 1)\n    day = reference_nc_file.variables['day'][:]\n    day_value = day[-1]\n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n\n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15)\n    # Show the plot or save it to a file\n    plt.savefig(f'/home/chetana/gridmet_test_run/predicted_swe-{timestamp_string}-{uuid.uuid4().hex}.png')\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "",
  "history_begin_time" : 1690644877718,
  "history_end_time" : 1690644887307,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "GnIpICvdE7cT",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nimport netCDF4 as nc\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport pyproj\n\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\ndef convert_csvs_to_images():\n    # Load the CSV data into a DataFrame\n    data = pd.read_csv('/home/chetana/gridmet_test_run/test_data_prediected.csv')\n\n    # Define the map boundaries for the Western US\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    # Create the Basemap instance\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    # Convert lon/lat to map coordinates\n    x, y = m(data['lon'].values, data['lat'].values)\n\n    # Plot the data using vibrant colors based on predicted_swe\n    plt.scatter(x, y, c=data['predicted_swe'], cmap='coolwarm', s=30, edgecolors='none', alpha=0.7)\n\n    # Add colorbar for reference\n    cbar = plt.colorbar()\n    cbar.set_label('Predicted SWE')\n\n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_nc_file = nc.Dataset('/home/chetana/gridmet_test_run/gridmet_climatology/etr_2023.nc')\n\n    reference_date = datetime(1900, 1, 1)\n    day = reference_nc_file.variables['day'][:]\n    day_value = day[-1]\n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n\n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15)\n    # Show the plot or save it to a file\n    plt.savefig('/home/chetana/gridmet_test_run/predicted_swe.png')\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "",
  "history_begin_time" : 1690643670083,
  "history_end_time" : 1690643682971,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "pBrMzld1imNW",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nimport netCDF4 as nc\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport pyproj\n\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\ndef convert_csvs_to_images():\n    # Load the CSV data into a DataFrame\n    data = pd.read_csv('/home/chetana/gridmet_test_run/test_data_prediected.csv')\n\n    # Define the map boundaries for the Western US\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    # Create the Basemap instance\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    # Convert lon/lat to map coordinates\n    x, y = m(data['lon'].values, data['lat'].values)\n\n    # Plot the data using vibrant colors based on predicted_swe\n    plt.scatter(x, y, c=data['predicted_swe'], cmap='coolwarm', s=30, edgecolors='none', alpha=0.7)\n\n    # Add colorbar for reference\n    cbar = plt.colorbar()\n    cbar.set_label('Predicted SWE')\n\n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_nc_file = nc.Dataset('/home/chetana/gridmet_test_run/gridmet_climatology/etr_2023.nc')\n\n    reference_date = datetime(1900, 1, 1)\n    day = reference_nc_file.variables['day'][:]\n    day_value = day[-1]\n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n\n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.15)\n    # Show the plot or save it to a file\n    plt.savefig('/home/chetana/gridmet_test_run/predicted_swe.png')\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "",
  "history_begin_time" : 1690483212356,
  "history_end_time" : 1690483222212,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "NB8zj6z0XwdY",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nimport netCDF4 as nc\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport pyproj\n\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\ndef convert_csvs_to_images():\n    # Load the CSV data into a DataFrame\n    data = pd.read_csv('/home/chetana/gridmet_test_run/test_data_prediected.csv')\n\n    # Define the map boundaries for the Western US\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    # Create the Basemap instance\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    # Convert lon/lat to map coordinates\n    x, y = m(data['lon'].values, data['lat'].values)\n\n    # Plot the data using vibrant colors based on predicted_swe\n    plt.scatter(x, y, c=data['predicted_swe'], cmap='coolwarm', s=30, edgecolors='none', alpha=0.7)\n\n    # Add colorbar for reference\n    cbar = plt.colorbar()\n    cbar.set_label('Predicted SWE')\n\n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_nc_file = nc.Dataset('/home/chetana/gridmet_test_run/gridmet_climatology/etr_2023.nc')\n\n    reference_date = datetime(1900, 1, 1)\n    day = reference_nc_file.variables['day'][:]\n    day_value = day[-1]\n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n\n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}', pad=20)\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.2)\n    # Show the plot or save it to a file\n    plt.savefig('/home/chetana/gridmet_test_run/predicted_swe.png')\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "",
  "history_begin_time" : 1690483177053,
  "history_end_time" : 1690483186599,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "58mKehP7xVoV",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nimport netCDF4 as nc\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport pyproj\n\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\ndef convert_csvs_to_images():\n    # Load the CSV data into a DataFrame\n    data = pd.read_csv('/home/chetana/gridmet_test_run/test_data_prediected.csv')\n\n    # Define the map boundaries for the Western US\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    # Create the Basemap instance\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    # Convert lon/lat to map coordinates\n    x, y = m(data['lon'].values, data['lat'].values)\n\n    # Plot the data using vibrant colors based on predicted_swe\n    plt.scatter(x, y, c=data['predicted_swe'], cmap='coolwarm', s=30, edgecolors='none', alpha=0.7)\n\n    # Add colorbar for reference\n    cbar = plt.colorbar()\n    cbar.set_label('Predicted SWE')\n\n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_nc_file = nc.Dataset('/home/chetana/gridmet_test_run/gridmet_climatology/etr_2023.nc')\n\n    reference_date = datetime(1900, 1, 1)\n    day = reference_nc_file.variables['day'][:]\n    day_value = day[-1]\n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n\n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}')\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Adjust the bottom and top margins to create more white space between the title and the plot\n    plt.subplots_adjust(bottom=0.2, top=0.85)\n    # Show the plot or save it to a file\n    plt.savefig('/home/chetana/gridmet_test_run/predicted_swe.png')\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "",
  "history_begin_time" : 1690483090647,
  "history_end_time" : 1690483100400,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "ApTzDHmNhMLZ",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nimport netCDF4 as nc\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport pyproj\n\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\ndef convert_csvs_to_images():\n    # Load the CSV data into a DataFrame\n    data = pd.read_csv('/home/chetana/gridmet_test_run/test_data_prediected.csv')\n\n    # Define the map boundaries for the Western US\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    # Create the Basemap instance\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    # Convert lon/lat to map coordinates\n    x, y = m(data['lon'].values, data['lat'].values)\n\n    # Plot the data using vibrant colors based on predicted_swe\n    plt.scatter(x, y, c=data['predicted_swe'], cmap='coolwarm', s=30, edgecolors='none', alpha=0.7)\n\n    # Add colorbar for reference\n    cbar = plt.colorbar()\n    cbar.set_label('Predicted SWE')\n\n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_nc_file = nc.Dataset('/home/chetana/gridmet_test_run/gridmet_climatology/etr_2023.nc')\n\n    reference_date = datetime(1900, 1, 1)\n    day = reference_nc_file.variables['day'][:]\n    day_value = day[-1]\n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n\n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}')\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    # Add a caption at the bottom right of the plot\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Adjust the bottom margin to provide more space at the bottom of the plot\n    plt.subplots_adjust(bottom=0.15, top=0.02)\n    # Show the plot or save it to a file\n    plt.savefig('/home/chetana/gridmet_test_run/predicted_swe.png')\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "Traceback (most recent call last):\n  File \"/home/chetana/gw-workspace/ApTzDHmNhMLZ/convert_results_to_images.py\", line 85, in <module>\n    convert_csvs_to_images()\n  File \"/home/chetana/gw-workspace/ApTzDHmNhMLZ/convert_results_to_images.py\", line 80, in convert_csvs_to_images\n    plt.subplots_adjust(bottom=0.15, top=0.02)\n  File \"/home/chetana/gridmet_test_run/pycrate/lib/python3.9/site-packages/matplotlib/pyplot.py\", line 2335, in subplots_adjust\n    return gcf().subplots_adjust(\n  File \"/home/chetana/gridmet_test_run/pycrate/lib/python3.9/site-packages/matplotlib/figure.py\", line 1353, in subplots_adjust\n    self.subplotpars.update(left, bottom, right, top, wspace, hspace)\n  File \"/home/chetana/gridmet_test_run/pycrate/lib/python3.9/site-packages/matplotlib/figure.py\", line 166, in update\n    raise ValueError('bottom cannot be >= top')\nValueError: bottom cannot be >= top\n",
  "history_begin_time" : 1690483056938,
  "history_end_time" : 1690483062150,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "95HAc7ioq7eq",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nimport netCDF4 as nc\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport pyproj\n\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\ndef convert_csvs_to_images():\n    # Load the CSV data into a DataFrame\n    data = pd.read_csv('/home/chetana/gridmet_test_run/test_data_prediected.csv')\n\n    # Define the map boundaries for the Western US\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    # Create the Basemap instance\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    # Convert lon/lat to map coordinates\n    x, y = m(data['lon'].values, data['lat'].values)\n\n    # Plot the data using vibrant colors based on predicted_swe\n    plt.scatter(x, y, c=data['predicted_swe'], cmap='coolwarm', s=30, edgecolors='none', alpha=0.7)\n\n    # Add colorbar for reference\n    cbar = plt.colorbar()\n    cbar.set_label('Predicted SWE')\n\n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_nc_file = nc.Dataset('/home/chetana/gridmet_test_run/gridmet_climatology/etr_2023.nc')\n\n    reference_date = datetime(1900, 1, 1)\n    day = reference_nc_file.variables['day'][:]\n    day_value = day[-1]\n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n\n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}')\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    # Add a caption at the bottom right of the plot\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Adjust the bottom margin to provide more space at the bottom of the plot\n    plt.subplots_adjust(bottom=0.15, top=2.0)\n    # Show the plot or save it to a file\n    plt.savefig('/home/chetana/gridmet_test_run/predicted_swe.png')\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "",
  "history_begin_time" : 1690483011721,
  "history_end_time" : 1690483021077,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "WPWthtVFGHhT",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nimport netCDF4 as nc\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport pyproj\n\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\ndef convert_csvs_to_images():\n    # Load the CSV data into a DataFrame\n    data = pd.read_csv('/home/chetana/gridmet_test_run/test_data_prediected.csv')\n\n    # Define the map boundaries for the Western US\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    # Create the Basemap instance\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    # Convert lon/lat to map coordinates\n    x, y = m(data['lon'].values, data['lat'].values)\n\n    # Plot the data using vibrant colors based on predicted_swe\n    plt.scatter(x, y, c=data['predicted_swe'], cmap='coolwarm', s=30, edgecolors='none', alpha=0.7)\n\n    # Add colorbar for reference\n    cbar = plt.colorbar()\n    cbar.set_label('Predicted SWE')\n\n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_nc_file = nc.Dataset('/home/chetana/gridmet_test_run/gridmet_climatology/etr_2023.nc')\n\n    reference_date = datetime(1900, 1, 1)\n    day = reference_nc_file.variables['day'][:]\n    day_value = day[-1]\n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n\n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}')\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    # Add a caption at the bottom right of the plot\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Adjust the bottom margin to provide more space at the bottom of the plot\n    plt.subplots_adjust(bottom=0.15, top=0.9)\n    # Show the plot or save it to a file\n    plt.savefig('/home/chetana/gridmet_test_run/predicted_swe.png')\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "",
  "history_begin_time" : 1690482972627,
  "history_end_time" : 1690482982418,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "sWYLWYfVt24W",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nimport netCDF4 as nc\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport pyproj\n\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\ndef convert_csvs_to_images():\n    # Load the CSV data into a DataFrame\n    data = pd.read_csv('/home/chetana/gridmet_test_run/test_data_prediected.csv')\n\n    # Define the map boundaries for the Western US\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    # Create the Basemap instance\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    # Convert lon/lat to map coordinates\n    x, y = m(data['lon'].values, data['lat'].values)\n\n    # Plot the data using vibrant colors based on predicted_swe\n    plt.scatter(x, y, c=data['predicted_swe'], cmap='coolwarm', s=30, edgecolors='none', alpha=0.7)\n\n    # Add colorbar for reference\n    cbar = plt.colorbar()\n    cbar.set_label('Predicted SWE')\n\n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_nc_file = nc.Dataset('/home/chetana/gridmet_test_run/gridmet_climatology/etr_2023.nc')\n\n    reference_date = datetime(1900, 1, 1)\n    day = reference_nc_file.variables['day'][:]\n    day_value = day[-1]\n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n\n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}')\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    # Add a caption at the bottom right of the plot\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Adjust the bottom margin to provide more space at the bottom of the plot\n    plt.subplots_adjust(bottom=0.1)\n    # Show the plot or save it to a file\n    plt.savefig('/home/chetana/gridmet_test_run/predicted_swe.png')\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "",
  "history_begin_time" : 1690482918663,
  "history_end_time" : 1690482928320,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "gvp48MoBdtXr",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nimport netCDF4 as nc\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport pyproj\n\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\ndef convert_csvs_to_images():\n    # Load the CSV data into a DataFrame\n    data = pd.read_csv('/home/chetana/gridmet_test_run/test_data_prediected.csv')\n\n    # Define the map boundaries for the Western US\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    # Create the Basemap instance\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    # Convert lon/lat to map coordinates\n    x, y = m(data['lon'].values, data['lat'].values)\n\n    # Plot the data using vibrant colors based on predicted_swe\n    plt.scatter(x, y, c=data['predicted_swe'], cmap='coolwarm', s=30, edgecolors='none', alpha=0.7)\n\n    # Add colorbar for reference\n    cbar = plt.colorbar()\n    cbar.set_label('Predicted SWE')\n\n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_nc_file = nc.Dataset('/home/chetana/gridmet_test_run/gridmet_climatology/etr_2023.nc')\n\n    reference_date = datetime(1900, 1, 1)\n    day = reference_nc_file.variables['day'][:]\n    day_value = day[-1]\n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n\n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}')\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    # Add a caption at the bottom right of the plot\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Adjust the bottom margin to provide more space at the bottom of the plot\n    plt.subplots_adjust(bottom=0.3)\n    # Show the plot or save it to a file\n    plt.savefig('/home/chetana/gridmet_test_run/predicted_swe.png')\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "",
  "history_begin_time" : 1690481529581,
  "history_end_time" : 1690481539184,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "OAMiBj0fr0T4",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nimport netCDF4 as nc\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport pyproj\n\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\ndef convert_csvs_to_images():\n    # Load the CSV data into a DataFrame\n    data = pd.read_csv('/home/chetana/gridmet_test_run/test_data_prediected.csv')\n\n    # Define the map boundaries for the Western US\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    # Create the Basemap instance\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    # Convert lon/lat to map coordinates\n    x, y = m(data['lon'].values, data['lat'].values)\n\n    # Plot the data using vibrant colors based on predicted_swe\n    plt.scatter(x, y, c=data['predicted_swe'], cmap='coolwarm', s=30, edgecolors='none', alpha=0.7)\n\n    # Add colorbar for reference\n    cbar = plt.colorbar()\n    cbar.set_label('Predicted SWE')\n\n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_nc_file = nc.Dataset('/home/chetana/gridmet_test_run/gridmet_climatology/etr_2023.nc')\n\n    reference_date = datetime(1900, 1, 1)\n    day = reference_nc_file.variables['day'][:]\n    day_value = day[-1]\n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n\n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}')\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    # Add a caption at the bottom right of the plot\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Adjust the bottom margin to provide more space at the bottom of the plot\n    plt.subplots_adjust(bottom=0.1)\n    # Show the plot or save it to a file\n    plt.savefig('/home/chetana/gridmet_test_run/predicted_swe.png')\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "",
  "history_begin_time" : 1690481444258,
  "history_end_time" : 1690481456786,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "33FrKWoVuHBi",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nimport netCDF4 as nc\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport pyproj\n\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\ndef convert_csvs_to_images():\n    # Load the CSV data into a DataFrame\n    data = pd.read_csv('/home/chetana/gridmet_test_run/test_data_prediected.csv')\n\n    # Define the map boundaries for the Western US\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    # Create the Basemap instance\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    # Convert lon/lat to map coordinates\n    x, y = m(data['lon'].values, data['lat'].values)\n\n    # Plot the data using vibrant colors based on predicted_swe\n    plt.scatter(x, y, c=data['predicted_swe'], cmap='coolwarm', s=30, edgecolors='none', alpha=0.7)\n\n    # Add colorbar for reference\n    cbar = plt.colorbar()\n    cbar.set_label('Predicted SWE')\n\n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_nc_file = nc.Dataset('/home/chetana/gridmet_test_run/gridmet_climatology/etr_2023.nc')\n\n    reference_date = datetime(1900, 1, 1)\n    day = reference_nc_file.variables['day'][:]\n    day_value = day[-1]\n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n\n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}')\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    # Add a caption at the bottom right of the plot\n\tplt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n\n    # Adjust the bottom margin to provide more space at the bottom of the plot\n    plt.subplots_adjust(bottom=0.1)\n    # Show the plot or save it to a file\n    plt.savefig('/home/chetana/gridmet_test_run/predicted_swe.png')\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "  File \"/home/chetana/gw-workspace/33FrKWoVuHBi/convert_results_to_images.py\", line 75\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\nTabError: inconsistent use of tabs and spaces in indentation\n",
  "history_begin_time" : 1690481330585,
  "history_end_time" : 1690481331606,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "QvQnH8kH6pqS",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nimport netCDF4 as nc\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport pyproj\n\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\ndef convert_csvs_to_images():\n    # Load the CSV data into a DataFrame\n    data = pd.read_csv('/home/chetana/gridmet_test_run/test_data_prediected.csv')\n\n    # Define the map boundaries for the Western US\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    # Create the Basemap instance\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    # Convert lon/lat to map coordinates\n    x, y = m(data['lon'].values, data['lat'].values)\n\n    # Plot the data using vibrant colors based on predicted_swe\n    plt.scatter(x, y, c=data['predicted_swe'], cmap='coolwarm', s=30, edgecolors='none', alpha=0.7)\n\n    # Add colorbar for reference\n    cbar = plt.colorbar()\n    cbar.set_label('Predicted SWE')\n\n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_nc_file = nc.Dataset('/home/chetana/gridmet_test_run/gridmet_climatology/etr_2023.nc')\n\n    reference_date = datetime(1900, 1, 1)\n    day = reference_nc_file.variables['day'][:]\n    day_value = day[-1]\n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n\n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}')\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    # Add a caption at the bottom right of the plot\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n    # Show the plot or save it to a file\n    plt.savefig('/home/chetana/gridmet_test_run/predicted_swe.png')\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "",
  "history_begin_time" : 1690472839524,
  "history_end_time" : 1690472849641,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "HQVItE0b2whm",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nimport netCDF4 as nc\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport pyproj\n\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\ndef convert_csvs_to_images():\n    # Load the CSV data into a DataFrame\n    data = pd.read_csv('/home/chetana/gridmet_test_run/test_data_prediected.csv')\n\n    # Define the map boundaries for the Western US\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    # Create the Basemap instance\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    # Convert lon/lat to map coordinates\n    x, y = m(data['lon'].values, data['lat'].values)\n\n    # Plot the data using vibrant colors based on predicted_swe\n    plt.scatter(x, y, c=data['predicted_swe'], cmap='coolwarm', s=30, edgecolors='none', alpha=0.7)\n\n    # Add colorbar for reference\n    cbar = plt.colorbar()\n    cbar.set_label('Predicted SWE')\n\n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_nc_file = nc.Dataset('/home/chetana/gridmet_test_run/gridmet_climatology/etr_2023.nc')\n\n    reference_date = datetime(1900, 1, 1)\n    day = reference_nc_file.variables['day'][:]\n    day_value = day[-1]\n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n\n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}')\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    # Add a caption at the bottom right of the plot\n    plt.text(0.98, 0.98, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='top',\n             transform=plt.gcf().transFigure, fontsize=6, color='black')\n    # Show the plot or save it to a file\n    plt.savefig('/home/chetana/gridmet_test_run/predicted_swe.png')\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "",
  "history_begin_time" : 1690472766248,
  "history_end_time" : 1690472775958,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "FV6dtxOfco8m",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nimport netCDF4 as nc\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport pyproj\n\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\ndef convert_csvs_to_images():\n    # Load the CSV data into a DataFrame\n    data = pd.read_csv('/home/chetana/gridmet_test_run/test_data_prediected.csv')\n\n    # Define the map boundaries for the Western US\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    # Create the Basemap instance\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    # Convert lon/lat to map coordinates\n    x, y = m(data['lon'].values, data['lat'].values)\n\n    # Plot the data using vibrant colors based on predicted_swe\n    plt.scatter(x, y, c=data['predicted_swe'], cmap='coolwarm', s=30, edgecolors='none', alpha=0.7)\n\n    # Add colorbar for reference\n    cbar = plt.colorbar()\n    cbar.set_label('Predicted SWE')\n\n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_nc_file = nc.Dataset('/home/chetana/gridmet_test_run/gridmet_climatology/etr_2023.nc')\n\n    reference_date = datetime(1900, 1, 1)\n    day = reference_nc_file.variables['day'][:]\n    day_value = day[-1]\n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n\n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}')\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    # Add a caption at the bottom right of the plot\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gca().transAxes, fontsize=6)\n    plt.subplots_adjust(bottom=0.12)\n    # Show the plot or save it to a file\n    plt.savefig('/home/chetana/gridmet_test_run/predicted_swe.png')\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "",
  "history_begin_time" : 1690472354362,
  "history_end_time" : 1690472364289,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "DyAtf2JGBXnu",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nimport netCDF4 as nc\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport pyproj\n\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\ndef convert_csvs_to_images():\n    # Load the CSV data into a DataFrame\n    data = pd.read_csv('/home/chetana/gridmet_test_run/test_data_prediected.csv')\n\n    # Define the map boundaries for the Western US\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    # Create the Basemap instance\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    # Convert lon/lat to map coordinates\n    x, y = m(data['lon'].values, data['lat'].values)\n\n    # Plot the data using vibrant colors based on predicted_swe\n    plt.scatter(x, y, c=data['predicted_swe'], cmap='coolwarm', s=30, edgecolors='none', alpha=0.7)\n\n    # Add colorbar for reference\n    cbar = plt.colorbar()\n    cbar.set_label('Predicted SWE')\n\n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_nc_file = nc.Dataset('/home/chetana/gridmet_test_run/gridmet_climatology/etr_2023.nc')\n\n    reference_date = datetime(1900, 1, 1)\n    day = reference_nc_file.variables['day'][:]\n    day_value = day[-1]\n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n\n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}')\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    # Add a caption at the bottom right of the plot\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gca().transAxes, fontsize=6)\n\tplt.subplots_adjust(bottom=0.12)\n    # Show the plot or save it to a file\n    plt.savefig('/home/chetana/gridmet_test_run/predicted_swe.png')\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "  File \"/home/chetana/gw-workspace/DyAtf2JGBXnu/convert_results_to_images.py\", line 78\n    plt.subplots_adjust(bottom=0.12)\nTabError: inconsistent use of tabs and spaces in indentation\n",
  "history_begin_time" : 1690472341161,
  "history_end_time" : 1690472342194,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "XWn0m1dTgP99",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nimport netCDF4 as nc\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport pyproj\n\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\ndef convert_csvs_to_images():\n    # Load the CSV data into a DataFrame\n    data = pd.read_csv('/home/chetana/gridmet_test_run/test_data_prediected.csv')\n\n    # Define the map boundaries for the Western US\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    # Create the Basemap instance\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    # Convert lon/lat to map coordinates\n    x, y = m(data['lon'].values, data['lat'].values)\n\n    # Plot the data using vibrant colors based on predicted_swe\n    plt.scatter(x, y, c=data['predicted_swe'], cmap='coolwarm', s=30, edgecolors='none', alpha=0.7)\n\n    # Add colorbar for reference\n    cbar = plt.colorbar()\n    cbar.set_label('Predicted SWE')\n\n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_nc_file = nc.Dataset('/home/chetana/gridmet_test_run/gridmet_climatology/etr_2023.nc')\n\n    reference_date = datetime(1900, 1, 1)\n    day = reference_nc_file.variables['day'][:]\n    day_value = day[-1]\n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n\n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}')\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    # Add a caption at the bottom right of the plot\n    plt.text(0.98, 0.02, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='right', verticalalignment='bottom',\n             transform=plt.gca().transAxes, fontsize=6)\n\n    # Show the plot or save it to a file\n    plt.savefig('/home/chetana/gridmet_test_run/predicted_swe.png')\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "",
  "history_begin_time" : 1690471092074,
  "history_end_time" : 1690471101807,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "nwAGyTRJa0us",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nimport netCDF4 as nc\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport pyproj\n\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\ndef convert_csvs_to_images():\n    # Load the CSV data into a DataFrame\n    data = pd.read_csv('/home/chetana/gridmet_test_run/test_data_prediected.csv')\n\n    # Define the map boundaries for the Western US\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    # Create the Basemap instance\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    # Convert lon/lat to map coordinates\n    x, y = m(data['lon'].values, data['lat'].values)\n\n    # Plot the data using vibrant colors based on predicted_swe\n    plt.scatter(x, y, c=data['predicted_swe'], cmap='coolwarm', s=30, edgecolors='none', alpha=0.7)\n\n    # Add colorbar for reference\n    cbar = plt.colorbar()\n    cbar.set_label('Predicted SWE')\n\n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_nc_file = nc.Dataset('/home/chetana/gridmet_test_run/gridmet_climatology/etr_2023.nc')\n\n    reference_date = datetime(1900, 1, 1)\n    day = reference_nc_file.variables['day'][:]\n    day_value = day[-1]\n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n\n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}')\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    # Add a caption at the bottom of the plot\n    plt.text(0.5, -0.1, 'Copyright © SWE Wormhole Team',\n             horizontalalignment='center', verticalalignment='center',\n             transform=plt.gca().transAxes, fontsize=6)\n\n    # Show the plot or save it to a file\n    plt.savefig('/home/chetana/gridmet_test_run/predicted_swe.png')\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "",
  "history_begin_time" : 1690470882261,
  "history_end_time" : 1690470891978,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "I63u5YFiLlbi",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nimport netCDF4 as nc\nfrom datetime import timedelta, datetime\nimport numpy as np\nimport pyproj\n\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\ndef convert_csvs_to_images():\n    # Load the CSV data into a DataFrame\n    data = pd.read_csv('/home/chetana/gridmet_test_run/test_data_prediected.csv')\n\n    # Define the map boundaries for the Western US\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    # Create the Basemap instance\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    # Convert lon/lat to map coordinates\n    x, y = m(data['lon'].values, data['lat'].values)\n\n    # Plot the data using vibrant colors based on predicted_swe\n    plt.scatter(x, y, c=data['predicted_swe'], cmap='coolwarm', s=30, edgecolors='none', alpha=0.7)\n\n    # Add colorbar for reference\n    cbar = plt.colorbar()\n    cbar.set_label('Predicted SWE')\n\n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_nc_file = nc.Dataset('/home/chetana/gridmet_test_run/gridmet_climatology/etr_2023.nc')\n\n    reference_date = datetime(1900, 1, 1)\n    day = reference_nc_file.variables['day'][:]\n    day_value = day[-1]\n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n\n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}')\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates([lon_min] * len(y_ticks_labels), y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    # Add a caption at the bottom of the plot\n    plt.text(0.5, -0.1, 'Plot generated by swe_wormhole team',\n             horizontalalignment='center', verticalalignment='center',\n             transform=plt.gca().transAxes, fontsize=6)\n\n    # Show the plot or save it to a file\n    plt.savefig('/home/chetana/gridmet_test_run/predicted_swe.png')\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "",
  "history_begin_time" : 1690470745794,
  "history_end_time" : 1690470755428,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "8mx1m6vQlK1C",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nimport netCDF4 as nc\nfrom datetime import timedelta, datetime\nimport numpy as np\n\ndef lat_lon_to_map_coordinates(lon, lat, m):\n    x, y = m(lon, lat)\n    return x, y\n\ndef convert_csvs_to_images():\n    # Load the CSV data into a DataFrame\n    data = pd.read_csv('/home/chetana/gridmet_test_run/test_data_prediected.csv')\n\n    # Define the map boundaries for the Western US\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    # Create the Basemap instance\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    # Convert lon/lat to map coordinates\n    x, y = m(data['lon'].values, data['lat'].values)\n\n    # Plot the data using vibrant colors based on predicted_swe\n    plt.scatter(x, y, c=data['predicted_swe'], cmap='coolwarm', s=30, edgecolors='none', alpha=0.7)\n\n    # Add colorbar for reference\n    cbar = plt.colorbar()\n    cbar.set_label('Predicted SWE')\n\n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_nc_file = nc.Dataset('/home/chetana/gridmet_test_run/gridmet_climatology/etr_2023.nc')\n\n    reference_date = datetime(1900, 1, 1)\n    day = reference_nc_file.variables['day'][:]\n    day_value = day[-1]\n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n\n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}')\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Convert map coordinates to latitude and longitude for y-axis labels\n    y_tick_positions = np.linspace(lat_min, lat_max, len(y_ticks_labels))\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates(lon_min, y_tick_positions, m)\n    y_tick_positions_lat, _ = m(y_tick_positions_map_x, y_tick_positions_map_y, inverse=True)\n    y_tick_positions_lat_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_tick_positions_lat]\n    plt.yticks(y_tick_positions_map_y, y_tick_positions_lat_str, fontsize=6)\n\n    # Add a caption at the bottom of the plot\n    plt.text(0.5, -0.1, 'Plot generated by swe_wormhole team',\n             horizontalalignment='center', verticalalignment='center',\n             transform=plt.gca().transAxes, fontsize=6)\n\n    # Show the plot or save it to a file\n    plt.savefig('/home/chetana/gridmet_test_run/predicted_swe.png')\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "Traceback (most recent call last):\n  File \"/home/chetana/gw-workspace/8mx1m6vQlK1C/convert_results_to_images.py\", line 82, in <module>\n    convert_csvs_to_images()\n  File \"/home/chetana/gw-workspace/8mx1m6vQlK1C/convert_results_to_images.py\", line 68, in convert_csvs_to_images\n    y_tick_positions_map_x, y_tick_positions_map_y = lat_lon_to_map_coordinates(lon_min, y_tick_positions, m)\n  File \"/home/chetana/gw-workspace/8mx1m6vQlK1C/convert_results_to_images.py\", line 9, in lat_lon_to_map_coordinates\n    x, y = m(lon, lat)\n  File \"/home/chetana/gridmet_test_run/pycrate/lib/python3.9/site-packages/mpl_toolkits/basemap/__init__.py\", line 1195, in __call__\n    xout,yout = self.projtran(x,y,inverse=inverse)\n  File \"/home/chetana/gridmet_test_run/pycrate/lib/python3.9/site-packages/mpl_toolkits/basemap/proj.py\", line 295, in __call__\n    outx,outy = self._proj4(x, y, inverse=inverse)\n  File \"/home/chetana/gridmet_test_run/pycrate/lib/python3.9/site-packages/pyproj/proj.py\", line 195, in __call__\n    return self.transform(\n  File \"/home/chetana/gridmet_test_run/pycrate/lib/python3.9/site-packages/pyproj/transformer.py\", line 835, in transform\n    self._transformer._transform(\n  File \"pyproj/_transformer.pyx\", line 692, in pyproj._transformer._Transformer._transform\npyproj.exceptions.ProjError: x, y, z, and time must be same size if included.\n",
  "history_begin_time" : 1690470681913,
  "history_end_time" : 1690470687306,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "7OMjYWfwTA4f",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nimport netCDF4 as nc\nfrom datetime import timedelta, datetime\nimport numpy as np\n\ndef convert_csvs_to_images():\n    # Load the CSV data into a DataFrame\n    data = pd.read_csv('/home/chetana/gridmet_test_run/test_data_prediected.csv')\n\n    # Define the map boundaries for the Western US\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    # Create the Basemap instance\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    # Convert lon/lat to map coordinates\n    x, y = m(data['lon'].values, data['lat'].values)\n\n    # Plot the data using vibrant colors based on predicted_swe\n    plt.scatter(x, y, c=data['predicted_swe'], cmap='coolwarm', s=30, edgecolors='none', alpha=0.7)\n\n    # Add colorbar for reference\n    cbar = plt.colorbar()\n    cbar.set_label('Predicted SWE')\n\n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_nc_file = nc.Dataset('/home/chetana/gridmet_test_run/gridmet_climatology/etr_2023.nc')\n\n    reference_date = datetime(1900, 1, 1)\n    day = reference_nc_file.variables['day'][:]\n    day_value = day[-1]\n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n\n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}')\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Add a caption at the bottom of the plot\n    plt.text(0.5, -0.1, 'Plot generated by swe_wormhole team',\n             horizontalalignment='center', verticalalignment='center',\n             transform=plt.gca().transAxes, fontsize=6)\n\n    # Show the plot or save it to a file\n    plt.savefig('/home/chetana/gridmet_test_run/predicted_swe.png')\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "",
  "history_begin_time" : 1690470486335,
  "history_end_time" : 1690470496183,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "HkFNj0QJnlOC",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nimport netCDF4 as nc\nfrom datetime import timedelta, datetime\nimport numpy as np\n\ndef convert_csvs_to_images():\n    # Load the CSV data into a DataFrame\n    data = pd.read_csv('/home/chetana/gridmet_test_run/test_data_prediected.csv')\n\n    # Define the map boundaries for the Western US\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    # Create the Basemap instance\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    # Convert lon/lat to map coordinates\n    x, y = m(data['lon'].values, data['lat'].values)\n\n    # Plot the data using vibrant colors based on predicted_swe\n    plt.scatter(x, y, c=data['predicted_swe'], cmap='viridis', s=30, edgecolors='none', alpha=0.7)\n\n    # Add colorbar for reference\n    cbar = plt.colorbar()\n    cbar.set_label('Predicted SWE')\n\n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_nc_file = nc.Dataset('/home/chetana/gridmet_test_run/gridmet_climatology/etr_2023.nc')\n\n    reference_date = datetime(1900, 1, 1)\n    day = reference_nc_file.variables['day'][:]\n    day_value = day[-1]\n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n\n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}')\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Add a caption at the bottom of the plot\n    plt.text(0.5, -0.1, 'Plot generated by swe_wormhole team',\n             horizontalalignment='center', verticalalignment='center',\n             transform=plt.gca().transAxes, fontsize=6)\n\n    # Show the plot or save it to a file\n    plt.savefig('/home/chetana/gridmet_test_run/predicted_swe.png')\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "",
  "history_begin_time" : 1690470407565,
  "history_end_time" : 1690470417196,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "OA3tLsNyIV8J",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nimport netCDF4 as nc\nfrom datetime import timedelta, datetime\nimport numpy as np\n\ndef convert_csvs_to_images():\n    # Load the CSV data into a DataFrame\n    data = pd.read_csv('/home/chetana/gridmet_test_run/test_data_prediected.csv')\n\n    # Define the map boundaries for the Western US\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    # Create the Basemap instance\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    # Convert lon/lat to map coordinates\n    x, y = m(data['lon'].values, data['lat'].values)\n\n    # Plot the data using vibrant colors based on predicted_swe\n    plt.scatter(x, y, c=data['predicted_swe'], cmap='plasma', s=30, edgecolors='none', alpha=0.7)\n\n    # Add colorbar for reference\n    cbar = plt.colorbar()\n    cbar.set_label('Predicted SWE')\n\n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_nc_file = nc.Dataset('/home/chetana/gridmet_test_run/gridmet_climatology/etr_2023.nc')\n\n    reference_date = datetime(1900, 1, 1)\n    day = reference_nc_file.variables['day'][:]\n    day_value = day[-1]\n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n\n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}')\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Add a caption at the bottom of the plot\n    plt.text(0.5, -0.1, 'Plot generated by swe_wormhole team',\n             horizontalalignment='center', verticalalignment='center',\n             transform=plt.gca().transAxes, fontsize=6)\n\n    # Show the plot or save it to a file\n    plt.savefig('/home/chetana/gridmet_test_run/predicted_swe.png')\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "",
  "history_begin_time" : 1690470310545,
  "history_end_time" : 1690470320491,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "68uCFakuhPlb",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nimport netCDF4 as nc\nfrom datetime import timedelta, datetime\nimport numpy as np\n\ndef convert_csvs_to_images():\n    # Load the CSV data into a DataFrame\n    data = pd.read_csv('/home/chetana/gridmet_test_run/test_data_prediected.csv')\n\n    # Define the map boundaries for the Western US\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    # Create the Basemap instance\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    # Convert lon/lat to map coordinates\n    x, y = m(data['lon'].values, data['lat'].values)\n\n    # Plot the data using vibrant colors based on predicted_swe\n    plt.scatter(x, y, c=data['predicted_swe'], cmap='plasma', s=30, edgecolors='none', alpha=0.7)\n\n    # Add colorbar for reference\n    cbar = plt.colorbar()\n    cbar.set_label('Predicted SWE')\n\n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_nc_file = nc.Dataset('/home/chetana/gridmet_test_run/gridmet_climatology/etr_2023.nc')\n\n    reference_date = datetime(1900, 1, 1)\n    day = reference_nc_file.variables['day'][:]\n    day_value = day[-1]\n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n\n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}')\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Add a caption at the bottom of the plot\n    plt.text(0.5, -0.1, 'Plot generated by swe_wormhole team',\n             horizontalalignment='center', verticalalignment='center',\n             transform=plt.gca().transAxes, fontsize=6)\n\n    # Show the plot or save it to a file\n    plt.savefig('/home/chetana/gridmet_test_run/predicted_swe.png')\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "",
  "history_begin_time" : 1690470155899,
  "history_end_time" : 1690470165704,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "i0p0gn0ulWvj",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nimport netCDF4 as nc\nfrom datetime import timedelta, datetime\nimport numpy as np\n\ndef convert_csvs_to_images():\n    # Load the CSV data into a DataFrame\n    data = pd.read_csv('/home/chetana/gridmet_test_run/test_data_prediected.csv')\n\n    # Define the map boundaries for the Western US\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    # Create the Basemap instance\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    # Convert lon/lat to map coordinates\n    x, y = m(data['lon'].values, data['lat'].values)\n\n    # Plot the data using vibrant colors based on predicted_swe\n    plt.scatter(x, y, c=data['predicted_swe'], cmap='plasma', s=30, edgecolors='none', alpha=0.7)\n\n    # Add colorbar for reference\n    cbar = plt.colorbar()\n    cbar.set_label('Predicted SWE')\n\n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_nc_file = nc.Dataset('/home/chetana/gridmet_test_run/gridmet_climatology/etr_2023.nc')\n\n    reference_date = datetime(1900, 1, 1)\n    day = reference_nc_file.variables['day'][:]\n    day_value = day[-1]\n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n\n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}')\n\n    # Add labels for latitude and longitude on x and y axes with smaller font size\n    plt.xlabel('Longitude', fontsize=6)\n    plt.ylabel('Latitude', fontsize=6)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=6)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Add latitude values to the y-axis and adjust font size\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels), fontsize=6)\n    plt.gca().set_yticklabels(y_tick_labels_str)\n\n    # Add a caption at the bottom of the plot\n    plt.text(0.5, -0.1, 'Plot generated by swe_wormhole team',\n             horizontalalignment='center', verticalalignment='center',\n             transform=plt.gca().transAxes, fontsize=6)\n\n    # Show the plot or save it to a file\n    plt.savefig('/home/chetana/gridmet_test_run/predicted_swe.png')\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "",
  "history_begin_time" : 1690470054781,
  "history_end_time" : 1690470064567,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "nOn0dx97skhR",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nimport netCDF4 as nc\nfrom datetime import timedelta, datetime\nimport numpy as np\n\ndef convert_csvs_to_images():\n    # Load the CSV data into a DataFrame\n    data = pd.read_csv('/home/chetana/gridmet_test_run/test_data_prediected.csv')\n\n    # Define the map boundaries for the Western US\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    # Create the Basemap instance\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    # Convert lon/lat to map coordinates\n    x, y = m(data['lon'].values, data['lat'].values)\n\n    # Plot the data using vibrant colors based on predicted_swe\n    plt.scatter(x, y, c=data['predicted_swe'], cmap='plasma', s=30, edgecolors='none', alpha=0.7)\n\n    # Add colorbar for reference\n    cbar = plt.colorbar()\n    cbar.set_label('Predicted SWE')\n\n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_nc_file = nc.Dataset('/home/chetana/gridmet_test_run/gridmet_climatology/etr_2023.nc')\n\n    reference_date = datetime(1900, 1, 1)\n    day = reference_nc_file.variables['day'][:]\n    day_value = day[-1]\n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n\n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}')\n\n    # Add labels for latitude and longitude on x and y axes\n    plt.xlabel('Longitude', fontsize=10)\n    plt.ylabel('Latitude', fontsize=10)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), fontsize=8, rotation=45)\n    plt.gca().set_xticklabels(x_tick_labels_str)\n\n    # Remove tick labels on the y-axis\n    plt.gca().set_yticklabels([])\n\n    # Add a caption at the bottom of the plot\n    plt.text(0.5, -0.1, 'Plot generated by swe_wormhole team',\n             horizontalalignment='center', verticalalignment='center',\n             transform=plt.gca().transAxes, fontsize=8)\n\n    # Show the plot or save it to a file\n    plt.savefig('/home/chetana/gridmet_test_run/predicted_swe.png')\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "",
  "history_begin_time" : 1690469951631,
  "history_end_time" : 1690469961248,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "R89bYwMEtPwN",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nimport netCDF4 as nc\nfrom datetime import timedelta, datetime\nimport numpy as np\n\ndef convert_csvs_to_images():\n    # Load the CSV data into a DataFrame\n    data = pd.read_csv('/home/chetana/gridmet_test_run/test_data_prediected.csv')\n\n    # Define the map boundaries for the Western US\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    # Create the Basemap instance\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    # Convert lon/lat to map coordinates\n    x, y = m(data['lon'].values, data['lat'].values)\n\n    # Plot the data using vibrant colors based on predicted_swe\n    plt.scatter(x, y, c=data['predicted_swe'], cmap='plasma', s=30, edgecolors='none', alpha=0.7)\n\n    # Add colorbar for reference\n    cbar = plt.colorbar()\n    cbar.set_label('Predicted SWE')\n\n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_nc_file = nc.Dataset('/home/chetana/gridmet_test_run/gridmet_climatology/etr_2023.nc')\n\n    reference_date = datetime(1900, 1, 1)\n    day = reference_nc_file.variables['day'][:]\n    day_value = day[-1]\n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n\n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}')\n\n    # Add labels for latitude and longitude on x and y axes\n    plt.xlabel('Longitude', fontsize=10)\n    plt.ylabel('Latitude', fontsize=10)\n\n    # Add longitude values to the x-axis and adjust font size\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), labels=x_tick_labels_str, fontsize=8, rotation=45)\n\n    # Remove tick labels on the y-axis\n    plt.gca().set_yticklabels([])\n\n    # Add a caption at the bottom of the plot\n    plt.text(0.5, -0.1, 'Plot generated by swe_wormhole team',\n             horizontalalignment='center', verticalalignment='center',\n             transform=plt.gca().transAxes, fontsize=8)\n\n    # Show the plot or save it to a file\n    plt.savefig('/home/chetana/gridmet_test_run/predicted_swe.png')\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "Traceback (most recent call last):\n  File \"/home/chetana/gw-workspace/R89bYwMEtPwN/convert_results_to_images.py\", line 67, in <module>\n    convert_csvs_to_images()\n  File \"/home/chetana/gw-workspace/R89bYwMEtPwN/convert_results_to_images.py\", line 53, in convert_csvs_to_images\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), labels=x_tick_labels_str, fontsize=8, rotation=45)\nTypeError: xticks() got multiple values for argument 'labels'\n",
  "history_begin_time" : 1690469891514,
  "history_end_time" : 1690469896713,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "uhGTTT4DY11r",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nimport netCDF4 as nc\nfrom datetime import timedelta, datetime\nimport numpy as np\n\ndef convert_csvs_to_images():\n    # Load the CSV data into a DataFrame\n    data = pd.read_csv('/home/chetana/gridmet_test_run/test_data_prediected.csv')\n\n    # Define the map boundaries for the Western US\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    # Create the Basemap instance\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    # Convert lon/lat to map coordinates\n    x, y = m(data['lon'].values, data['lat'].values)\n\n    # Plot the data using vibrant colors based on predicted_swe\n    plt.scatter(x, y, c=data['predicted_swe'], cmap='plasma', s=30, edgecolors='none', alpha=0.7)\n\n    # Add colorbar for reference\n    cbar = plt.colorbar()\n    cbar.set_label('Predicted SWE')\n\n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_nc_file = nc.Dataset('/home/chetana/gridmet_test_run/gridmet_climatology/etr_2023.nc')\n\n    reference_date = datetime(1900, 1, 1)\n    day = reference_nc_file.variables['day'][:]\n    day_value = day[-1]\n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n\n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}')\n\n    # Add labels for latitude and longitude on x and y axes\n    plt.xlabel('Longitude', fontsize=12)\n    plt.ylabel('Latitude', fontsize=12)\n\n    # Add latitude and longitude values to the x and y axes\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n\n    # Convert longitude values to a formatted string\n    x_tick_labels_str = [f\"{lon:.1f}°W\" if lon < 0 else f\"{lon:.1f}°E\" for lon in x_ticks_labels]\n    # Convert latitude values to a formatted string\n    y_tick_labels_str = [f\"{lat:.1f}°N\" if lat >= 0 else f\"{abs(lat):.1f}°S\" for lat in y_ticks_labels]\n\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), rotation=45)\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels))\n\n    # Set the tick labels for x and y axes\n    plt.gca().set_xticklabels(x_tick_labels_str, fontsize=10)\n    plt.gca().set_yticklabels(y_tick_labels_str, fontsize=10)\n\n    # Add a caption at the bottom of the plot\n    plt.text(0.5, -0.1, 'Plot generated by swe_wormhole team',\n             horizontalalignment='center', verticalalignment='center',\n             transform=plt.gca().transAxes, fontsize=10)\n\n    # Show the plot or save it to a file\n    plt.savefig('/home/chetana/gridmet_test_run/predicted_swe.png')\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "",
  "history_begin_time" : 1690469734666,
  "history_end_time" : 1690469744374,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "jXg8nXGDDkDX",
  "history_input" : "import pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nimport netCDF4 as nc\nfrom datetime import timedelta, datetime\n\ndef convert_csvs_to_images():\n    # Load the CSV data into a DataFrame\n    data = pd.read_csv('/home/chetana/gridmet_test_run/test_data_prediected.csv')\n\n    # Define the map boundaries for the Western US\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    # Create the Basemap instance\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    # Convert lon/lat to map coordinates\n    x, y = m(data['lon'].values, data['lat'].values)\n\n    # Plot the data using vibrant colors based on predicted_swe\n    plt.scatter(x, y, c=data['predicted_swe'], cmap='plasma', s=30, edgecolors='none', alpha=0.7)\n\n    # Add colorbar for reference\n    cbar = plt.colorbar()\n    cbar.set_label('Predicted SWE')\n\n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_nc_file = nc.Dataset('/home/chetana/gridmet_test_run/gridmet_climatology/etr_2023.nc')\n\n    reference_date = datetime(1900, 1, 1)\n    day = reference_nc_file.variables['day'][:]\n    day_value = day[-1]\n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n\n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}')\n\n    # Add labels for latitude and longitude on x and y axes\n    plt.xlabel('Longitude')\n    plt.ylabel('Latitude')\n\n    # Add a caption at the bottom of the plot\n    plt.text(0.5, -0.1, 'Plot generated by swe_wormhole team',\n             horizontalalignment='center', verticalalignment='center',\n             transform=plt.gca().transAxes, fontsize=10)\n\n    # Add latitude and longitude values to the x and y axes\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), rotation=45)\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels))\n\n    # Show the plot or save it to a file\n    plt.savefig('/home/chetana/gridmet_test_run/predicted_swe.png')\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "",
  "history_begin_time" : 1690469512047,
  "history_end_time" : 1690469521681,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "L5lgGNoOFuLt",
  "history_input" : "import pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nimport netCDF4 as nc\nfrom datetime import timedelta, datetime\n\ndef convert_csvs_to_images():\n    # Load the CSV data into a DataFrame\n    data = pd.read_csv('/home/chetana/gridmet_test_run/test_data_prediected.csv')\n\n    # Define the map boundaries for the Western US\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    # Create the Basemap instance\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    # Convert lon/lat to map coordinates\n    x, y = m(data['lon'].values, data['lat'].values)\n\n    # Plot the data using vibrant colors based on predicted_swe\n    plt.scatter(x, y, c=data['predicted_swe'], cmap='plasma', s=30, edgecolors='none', alpha=0.7)\n\n    # Add colorbar for reference\n    cbar = plt.colorbar()\n    cbar.set_label('Predicted SWE')\n\n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_nc_file = nc.Dataset('/home/chetana/gridmet_test_run/gridmet_climatology/etr_2023.nc')\n\n    reference_date = datetime(1900, 1, 1)\n    day = reference_nc_file.variables['day'][:]\n    day_value = day[-1]\n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n\n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}')\n\n    # Add labels for latitude and longitude on x and y axes\n    plt.xlabel('Longitude')\n    plt.ylabel('Latitude')\n\n    # Add a caption at the bottom of the plot\n    plt.text(0.5, -0.1, 'Plot generated by swe_wormhole team',\n             horizontalalignment='center', verticalalignment='center',\n             transform=plt.gca().transAxes, fontsize=10)\n\n    # Add latitude and longitude values to the x and y axes\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), rotation=45)\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels))\n\n    # Show the plot or save it to a file\n    plt.savefig('/home/chetana/gridmet_test_run/predicted_swe.png')\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "Traceback (most recent call last):\n  File \"/home/chetana/gw-workspace/L5lgGNoOFuLt/convert_results_to_images.py\", line 64, in <module>\n    convert_csvs_to_images()\n  File \"/home/chetana/gw-workspace/L5lgGNoOFuLt/convert_results_to_images.py\", line 55, in convert_csvs_to_images\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\nNameError: name 'np' is not defined\n",
  "history_begin_time" : 1690469493785,
  "history_end_time" : 1690469499013,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "YrnWP97xlvtL",
  "history_input" : "def convert_csvs_to_images():\n    # Load the CSV data into a DataFrame\n    data = pd.read_csv('/home/chetana/gridmet_test_run/test_data_prediected.csv')\n\n    # Define the map boundaries for the Western US\n    lon_min, lon_max = -125, -100\n    lat_min, lat_max = 25, 49.5\n\n    # Create the Basemap instance\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n                projection='merc', resolution='i')\n\n    # Convert lon/lat to map coordinates\n    x, y = m(data['lon'].values, data['lat'].values)\n\n    # Plot the data using vibrant colors based on predicted_swe\n    plt.scatter(x, y, c=data['predicted_swe'], cmap='plasma', s=30, edgecolors='none', alpha=0.7)\n\n    # Add colorbar for reference\n    cbar = plt.colorbar()\n    cbar.set_label('Predicted SWE')\n\n    # Draw coastlines and other map features\n    m.drawcoastlines()\n    m.drawcountries()\n    m.drawstates()\n\n    reference_nc_file = nc.Dataset('/home/chetana/gridmet_test_run/gridmet_climatology/etr_2023.nc')\n\n    reference_date = datetime(1900, 1, 1)\n    day = reference_nc_file.variables['day'][:]\n    day_value = day[-1]\n    result_date = reference_date + timedelta(days=day_value)\n    today = result_date.strftime(\"%Y-%m-%d\")\n\n    # Add a title\n    plt.title(f'Predicted SWE in the Western US - {today}')\n\n    # Add labels for latitude and longitude on x and y axes\n    plt.xlabel('Longitude')\n    plt.ylabel('Latitude')\n\n    # Add a caption at the bottom of the plot\n    plt.text(0.5, -0.1, 'Plot generated by swe_wormhole team',\n             horizontalalignment='center', verticalalignment='center',\n             transform=plt.gca().transAxes, fontsize=10)\n\n    # Add latitude and longitude values to the x and y axes\n    x_ticks_labels = np.arange(lon_min, lon_max + 5, 5)\n    y_ticks_labels = np.arange(lat_min, lat_max + 5, 5)\n    plt.xticks(*m(x_ticks_labels, [lat_min] * len(x_ticks_labels)), rotation=45)\n    plt.yticks(*m([lon_min] * len(y_ticks_labels), y_ticks_labels))\n\n    # Show the plot or save it to a file\n    plt.savefig('/home/chetana/gridmet_test_run/predicted_swe.png')\n    # plt.show()  # Uncomment this line if you want to display the plot directly instead of saving it to a file\n\nconvert_csvs_to_images()\n",
  "history_output" : "Traceback (most recent call last):\n  File \"/home/chetana/gw-workspace/YrnWP97xlvtL/convert_results_to_images.py\", line 58, in <module>\n    convert_csvs_to_images()\n  File \"/home/chetana/gw-workspace/YrnWP97xlvtL/convert_results_to_images.py\", line 3, in convert_csvs_to_images\n    data = pd.read_csv('/home/chetana/gridmet_test_run/test_data_prediected.csv')\nNameError: name 'pd' is not defined\n",
  "history_begin_time" : 1690469436669,
  "history_end_time" : 1690469437713,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "gHamHFOuq39h",
  "history_input" : "# convert the model prediction into images. The testing.csv will be resulted in a corresponding csv with the values for all the coordinates. \nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nimport netCDF4 as nc\nfrom datetime import timedelta, datetime\n\n\ndef convert_csvs_to_images():\n  # Load the CSV data into a DataFrame\n  data = pd.read_csv('/home/chetana/gridmet_test_run/test_data_prediected.csv')\n\n  # Define the map boundaries for the Western US\n  lon_min, lon_max = -125, -100\n  lat_min, lat_max = 25, 49.5\n\n  # Create the Basemap instance\n  m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n              projection='merc', resolution='i')\n\n  # Convert lon/lat to map coordinates\n  x, y = m(data['lon'].values, data['lat'].values)\n\n  # Plot the data using vibrant colors based on predicted_swe\n  plt.scatter(x, y, c=data['predicted_swe'], cmap='plasma', s=30, edgecolors='none', alpha=0.7)\n\n  # Add colorbar for reference\n  cbar = plt.colorbar()\n  cbar.set_label('Predicted SWE')\n\n  # Draw coastlines and other map features\n  m.drawcoastlines()\n  m.drawcountries()\n  m.drawstates()\n  \n  reference_nc_file = nc.Dataset('/home/chetana/gridmet_test_run/gridmet_climatology/etr_2023.nc')\n\n  reference_date = datetime(1900, 1, 1)\n  day = reference_nc_file.variables['day'][:]\n  day_value = day[-1]\n  result_date = reference_date + timedelta(days=day_value)\n  today = result_date.strftime(\"%Y-%m-%d\")\n\n\t# Add a title\n  plt.title(f'Predicted SWE in the Western US - {today}')\n  # Show the plot\n  plt.savefig('/home/chetana/gridmet_test_run/predicted_swe.png')\n\n            \n\n\nconvert_csvs_to_images()\n\n\n\n",
  "history_output" : "",
  "history_begin_time" : 1690467306321,
  "history_end_time" : 1690467318837,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "1zdRjRRFMWxL",
  "history_input" : "# convert the model prediction into images. The testing.csv will be resulted in a corresponding csv with the values for all the coordinates. \nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\nimport netCDF4 as nc\nfrom datetime import timedelta, datetime\n\n\ndef convert_csvs_to_images():\n  # Load the CSV data into a DataFrame\n  data = pd.read_csv('/home/chetana/gridmet_test_run/test_data_prediected.csv')\n\n  # Define the map boundaries for the Western US\n  lon_min, lon_max = -125, -100\n  lat_min, lat_max = 25, 49.5\n\n  # Create the Basemap instance\n  m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n              projection='merc', resolution='i')\n\n  # Convert lon/lat to map coordinates\n  x, y = m(data['lon'].values, data['lat'].values)\n\n  # Plot the data using vibrant colors based on predicted_swe\n  plt.scatter(x, y, c=data['predicted_swe'], cmap='plasma', s=30, edgecolors='none', alpha=0.7)\n\n  # Add colorbar for reference\n  cbar = plt.colorbar()\n  cbar.set_label('Predicted SWE')\n\n  # Draw coastlines and other map features\n  m.drawcoastlines()\n  m.drawcountries()\n  m.drawstates()\n  \n  reference_nc_file = nc.Dataset('/home/chetana/gridmet_test_run/gridmet_climatology/etr_2023.nc')\n\n  reference_date = datetime(1900, 1, 1)\n  day = reference_nc_file.variables['day'][:]\n  day_value = day[-1]\n  result_date = reference_date + timedelta(days=given_days)\n  today = result_date.strftime(\"%Y-%m-%d\")\n\n\t# Add a title\n  plt.title(f'Predicted SWE in the Western US - {today}')\n  # Show the plot\n  plt.savefig('/home/chetana/gridmet_test_run/predicted_swe.png')\n\n            \n\n\nconvert_csvs_to_images()\n\n\n\n",
  "history_output" : "Traceback (most recent call last):\n  File \"/home/chetana/gw-workspace/1zdRjRRFMWxL/convert_results_to_images.py\", line 52, in <module>\n    convert_csvs_to_images()\n  File \"/home/chetana/gw-workspace/1zdRjRRFMWxL/convert_results_to_images.py\", line 41, in convert_csvs_to_images\n    result_date = reference_date + timedelta(days=given_days)\nNameError: name 'given_days' is not defined\n",
  "history_begin_time" : 1690467163397,
  "history_end_time" : 1690467172185,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "HTJLkO8xL3Oj",
  "history_input" : "# convert the model prediction into images. The testing.csv will be resulted in a corresponding csv with the values for all the coordinates. \nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\n\n\ndef convert_csvs_to_images():\n  # Load the CSV data into a DataFrame\n  data = pd.read_csv('/home/chetana/gridmet_test_run/test_data_prediected.csv')\n\n  # Define the map boundaries for the Western US\n  lon_min, lon_max = -125, -100\n  lat_min, lat_max = 25, 49.5\n\n  # Create the Basemap instance\n  m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n              projection='merc', resolution='i')\n\n  # Convert lon/lat to map coordinates\n  x, y = m(data['lon'].values, data['lat'].values)\n\n  # Plot the data using vibrant colors based on predicted_swe\n  plt.scatter(x, y, c=data['predicted_swe'], cmap='plasma', s=30, edgecolors='none', alpha=0.7)\n\n  # Add colorbar for reference\n  cbar = plt.colorbar()\n  cbar.set_label('Predicted SWE')\n\n  # Draw coastlines and other map features\n  m.drawcoastlines()\n  m.drawcountries()\n  m.drawstates()\n\n\t# Add a title\n  plt.title('Predicted SWE in the Western US')\n\n  # Show the plot\n  plt.savefig('/home/chetana/gridmet_test_run/predicted_swe.png')\n\n            \n\n\nconvert_csvs_to_images()\n\n\n\n",
  "history_output" : "",
  "history_begin_time" : 1690380798053,
  "history_end_time" : 1690380808407,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "VZN9wlssHUNp",
  "history_input" : "# convert the model prediction into images. The testing.csv will be resulted in a corresponding csv with the values for all the coordinates. \nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\n\n\ndef convert_csvs_to_images():\n  # Load the CSV data into a DataFrame\n  data = pd.read_csv('/home/chetana/gridmet_test_run/test_data_prediected.csv')\n\n  # Define the map boundaries for the Western US\n  lon_min, lon_max = -125, -125\n  lat_min, lat_max = 25, 49.5\n\n  # Create the Basemap instance\n  m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n              projection='merc', resolution='i')\n\n  # Convert lon/lat to map coordinates\n  x, y = m(data['lon'].values, data['lat'].values)\n\n  # Plot the data using vibrant colors based on predicted_swe\n  plt.scatter(x, y, c=data['predicted_swe'], cmap='plasma', s=30, edgecolors='none', alpha=0.7)\n\n  # Add colorbar for reference\n  cbar = plt.colorbar()\n  cbar.set_label('Predicted SWE')\n\n  # Draw coastlines and other map features\n  m.drawcoastlines()\n  m.drawcountries()\n  m.drawstates()\n\n\t# Add a title\n  plt.title('Predicted SWE in the Western US')\n\n  # Show the plot\n  plt.savefig('/home/chetana/gridmet_test_run/predicted_swe.png')\n\n            \n\n\nconvert_csvs_to_images()\n\n\n\n",
  "history_output" : "Traceback (most recent call last):\n  File \"/home/chetana/gw-workspace/VZN9wlssHUNp/convert_results_to_images.py\", line 43, in <module>\n    convert_csvs_to_images()\n  File \"/home/chetana/gw-workspace/VZN9wlssHUNp/convert_results_to_images.py\", line 16, in convert_csvs_to_images\n    m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n  File \"/home/chetana/gridmet_test_run/pycrate/lib/python3.9/site-packages/mpl_toolkits/basemap/__init__.py\", line 1034, in __init__\n    self.aspect = (proj.ymax-proj.ymin)/(proj.xmax-proj.xmin)\nZeroDivisionError: float division by zero\n",
  "history_begin_time" : 1690380650924,
  "history_end_time" : 1690380655678,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "by7XYNzpvrgS",
  "history_input" : "# convert the model prediction into images. The testing.csv will be resulted in a corresponding csv with the values for all the coordinates. \nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\n\n\ndef convert_csvs_to_images():\n  # Load the CSV data into a DataFrame\n  data = pd.read_csv('/home/chetana/gridmet_test_run/test_data_prediected.csv')\n\n  # Define the map boundaries for the Western US\n  lon_min, lon_max = -125.5, -116.5\n  lat_min, lat_max = 31.5, 49.5\n\n  # Create the Basemap instance\n  m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n              projection='merc', resolution='i')\n\n  # Convert lon/lat to map coordinates\n  x, y = m(data['lon'].values, data['lat'].values)\n\n  # Plot the data using vibrant colors based on predicted_swe\n  plt.scatter(x, y, c=data['predicted_swe'], cmap='plasma', s=30, edgecolors='none', alpha=0.7)\n\n  # Add colorbar for reference\n  cbar = plt.colorbar()\n  cbar.set_label('Predicted SWE')\n\n  # Draw coastlines and other map features\n  m.drawcoastlines()\n  m.drawcountries()\n  m.drawstates()\n\n\t# Add a title\n  plt.title('Predicted SWE in the Western US')\n\n  # Show the plot\n  plt.savefig('/home/chetana/gridmet_test_run/predicted_swe.png')\n\n            \n\n\nconvert_csvs_to_images()\n\n\n\n",
  "history_output" : "",
  "history_begin_time" : 1690353371041,
  "history_end_time" : 1690353379356,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "KbNZMp0tad7m",
  "history_input" : "# convert the model prediction into images. The testing.csv will be resulted in a corresponding csv with the values for all the coordinates. \nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\n\n\ndef convert_csvs_to_images():\n  # Load the CSV data into a DataFrame\n  data = pd.read_csv('/home/chetana/gridmet_test_run/test_data_prediected.csv')\n\n  # Define the map boundaries for the Western US\n  lon_min, lon_max = -125.5, -116.5\n  lat_min, lat_max = 31.5, 49.5\n\n  # Create the Basemap instance\n  m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n              projection='merc', resolution='i')\n\n  # Convert lon/lat to map coordinates\n  x, y = m(data['lon'].values, data['lat'].values)\n\n  # Plot the data using vibrant colors based on predicted_swe\n  plt.scatter(x, y, c=data['predicted_swe'], cmap='plasma', s=30, edgecolors='none', alpha=0.7)\n\n  # Add colorbar for reference\n  cbar = plt.colorbar()\n  cbar.set_label('Predicted SWE')\n\n  # Draw coastlines and other map features\n  m.drawcoastlines()\n  m.drawcountries()\n  m.drawstates()\n\n# Add a title\nplt.title('Predicted SWE in the Western US')\n\n# Show the plot\nplt.savefig('/home/chetana/gridmet_test_run/predicted_swe.png')\n\n            \n\nif __name__ == \"__main__\":\n    # Replace with the actual path to your folder\n    convert_csvs_to_images()\n\n\n\n",
  "history_output" : "",
  "history_begin_time" : 1690353342147,
  "history_end_time" : 1690353347269,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "X5lPe8hpvVn7",
  "history_input" : "# convert the model prediction into images. The testing.csv will be resulted in a corresponding csv with the values for all the coordinates. \nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.basemap import Basemap\n\n\ndef convert_csvs_to_images():\n  # Load the CSV data into a DataFrame\n  data = pd.read_csv('/home/chetana/gridmet_test_run/test_data_prediected.csv')\n\n  # Define the map boundaries for the Western US\n  lon_min, lon_max = -125.5, -116.5\n  lat_min, lat_max = 31.5, 49.5\n\n  # Create the Basemap instance\n  m = Basemap(llcrnrlon=lon_min, llcrnrlat=lat_min, urcrnrlon=lon_max, urcrnrlat=lat_max,\n              projection='merc', resolution='i')\n\n  # Convert lon/lat to map coordinates\n  x, y = m(data['lon'].values, data['lat'].values)\n\n  # Plot the data using vibrant colors based on predicted_swe\n  plt.scatter(x, y, c=data['predicted_swe'], cmap='plasma', s=30, edgecolors='none', alpha=0.7)\n\n  # Add colorbar for reference\n  cbar = plt.colorbar()\n  cbar.set_label('Predicted SWE')\n\n  # Draw coastlines and other map features\n  m.drawcoastlines()\n  m.drawcountries()\n  m.drawstates()\n\n# Add a title\nplt.title('Predicted SWE in the Western US')\n\n# Show the plot\nplt.savefig('/home/chetana/gridmet_test_run/predicted_swe.png')\n\n            \n\nif __name__ == \"__main__\":\n    # Replace with the actual path to your folder\n    convert_csvs_to_images()\n\n\n\n",
  "history_output" : "",
  "history_begin_time" : 1690353260372,
  "history_end_time" : 1690353269592,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "ldse9vf819d",
  "history_input" : null,
  "history_output" : "Authentication Failed. Wrong Password.",
  "history_begin_time" : 1689632043451,
  "history_end_time" : 1689632044894,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "100001",
  "indicator" : "Failed"
},{
  "history_id" : "1j5b2o3jvui",
  "history_input" : "# Deploy model to service\n\nprint(\"deploy model to service\")\n",
  "history_output" : "deploy model to service\n",
  "history_begin_time" : 1689631649928,
  "history_end_time" : 1689631651993,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "tq3z35",
  "indicator" : "Done"
},{
  "history_id" : "7mqlk2j2rgd",
  "history_input" : null,
  "history_output" : "Authentication Failed. Wrong Password.",
  "history_begin_time" : 1689135074866,
  "history_end_time" : 1689135076728,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "100001",
  "indicator" : "Failed"
},{
  "history_id" : "mzpdomr4kr8",
  "history_input" : "# Deploy model to service\n\nprint(\"deploy model to service\")\n",
  "history_output" : "deploy model to service\n",
  "history_begin_time" : 1687547311585,
  "history_end_time" : 1687547311694,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "100001",
  "indicator" : "Done"
},{
  "history_id" : "nwe5hdoxx4p",
  "history_input" : null,
  "history_output" : "Authentication Failed. Wrong Password.",
  "history_begin_time" : 1687463699542,
  "history_end_time" : 1687463700965,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "100001",
  "indicator" : "Failed"
},{
  "history_id" : "3990qxbi51p",
  "history_input" : null,
  "history_output" : "Authentication Failed. Wrong Password.",
  "history_begin_time" : 1687463654164,
  "history_end_time" : 1687463655631,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "100001",
  "indicator" : "Failed"
},{
  "history_id" : "mtrinmye7ur",
  "history_input" : "# Deploy model to service\n\nprint(\"deploy model to service\")\n",
  "history_output" : "sh: /home/chetana/anaconda3/condabin/python: No such file or directory\n",
  "history_begin_time" : 1686235982757,
  "history_end_time" : 1686235985399,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "jf7wuu",
  "indicator" : "Stopped"
},{
  "history_id" : "41hmaysoci0",
  "history_input" : "# Deploy model to service\n\nprint(\"deploy model to service\")\n",
  "history_output" : "deploy model to service\n",
  "history_begin_time" : 1686235553915,
  "history_end_time" : 1686235556289,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "jf7wuu",
  "indicator" : "Done"
},{
  "history_id" : "nz20itaw8yu",
  "history_input" : "# Deploy model to service\n\nprint(\"deploy model to service\")\n",
  "history_output" : "deploy model to service\n",
  "history_begin_time" : 1686153688571,
  "history_end_time" : 1686153690978,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "jf7wuu",
  "indicator" : "Done"
},{
  "history_id" : "zqlt2cmrvat",
  "history_input" : null,
  "history_output" : "Authentication Failed. Wrong Password.",
  "history_begin_time" : 1681516936498,
  "history_end_time" : 1681516937950,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "100001",
  "indicator" : "Failed"
},{
  "history_id" : "aqfswg22enc",
  "history_input" : null,
  "history_output" : "Authentication Failed. Wrong Password.",
  "history_begin_time" : 1681039719459,
  "history_end_time" : 1681039720897,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "100001",
  "indicator" : "Failed"
},{
  "history_id" : "30uf7yfv9ca",
  "history_input" : null,
  "history_output" : "Authentication Failed. Wrong Password.",
  "history_begin_time" : 1681007829649,
  "history_end_time" : 1681007831073,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "100001",
  "indicator" : "Failed"
},{
  "history_id" : "dhmb7j1sjmu",
  "history_input" : "# Deploy model to service\n\nprint(\"deploy model to service\")\n",
  "history_output" : "deploy model to service\n",
  "history_begin_time" : 1679442760857,
  "history_end_time" : 1679442762934,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "jf7wuu",
  "indicator" : "Done"
},{
  "history_id" : "d8ovl4alcw6",
  "history_input" : "# Deploy model to service\n\nprint(\"deploy model to service\")\n",
  "history_output" : "deploy model to service\n",
  "history_begin_time" : 1679332603639,
  "history_end_time" : 1679332606054,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "jf7wuu",
  "indicator" : "Done"
},{
  "history_id" : "omj0e1g6j9n",
  "history_input" : "# Deploy model to service\n\nprint(\"deploy model to service\")\n",
  "history_output" : "deploy model to service\n",
  "history_begin_time" : 1679191272847,
  "history_end_time" : 1679191275207,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "2jifky",
  "indicator" : "Done"
},{
  "history_id" : "fmn46wslldx",
  "history_input" : null,
  "history_output" : "Authentication Failed. Wrong Password.",
  "history_begin_time" : 1678748560562,
  "history_end_time" : 1678748562031,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "100001",
  "indicator" : "Failed"
},{
  "history_id" : "9i9po8n9b20",
  "history_input" : "# Deploy model to service\n\nprint(\"deploy model to service\")\n",
  "history_output" : "deploy model to service\n",
  "history_begin_time" : 1678747870780,
  "history_end_time" : 1678747873588,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Done"
},{
  "history_id" : "ivujluw9hv9",
  "history_input" : "# Deploy model to service\n\nprint(\"deploy model to service\")\n",
  "history_output" : "deploy model to service\n",
  "history_begin_time" : 1678743791504,
  "history_end_time" : 1678743794786,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Done"
},{
  "history_id" : "vn3hx1l9zu4",
  "history_input" : "# Deploy model to service\n\nprint(\"deploy model to service\")\n",
  "history_output" : "deploy model to service\n",
  "history_begin_time" : 1678742675575,
  "history_end_time" : 1678742678216,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Done"
},{
  "history_id" : "8v5yi7d5e5q",
  "history_input" : "# Deploy model to service\n\nprint(\"deploy model to service\")\n",
  "history_output" : "deploy model to service\n",
  "history_begin_time" : 1678725460139,
  "history_end_time" : 1678725463128,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Done"
},{
  "history_id" : "t2lexm3h3hd",
  "history_input" : "# Deploy model to service\n\nprint(\"deploy model to service\")\n",
  "history_output" : "deploy model to service\n",
  "history_begin_time" : 1678649631016,
  "history_end_time" : 1678649633836,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Done"
},{
  "history_id" : "cdhidm8zrcn",
  "history_input" : "# Deploy model to service\n\nprint(\"deploy model to service\")\n",
  "history_output" : "deploy model to service\n",
  "history_begin_time" : 1678648422662,
  "history_end_time" : 1678648426137,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Done"
},{
  "history_id" : "ygi0pc2sokv",
  "history_input" : "# Deploy model to service\n\nprint(\"deploy model to service\")\n",
  "history_output" : "deploy model to service\n",
  "history_begin_time" : 1678565132221,
  "history_end_time" : 1678565134718,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Done"
},{
  "history_id" : "g9zm7ykf909",
  "history_input" : "# Deploy model to service\n\nprint(\"deploy model to service\")\n",
  "history_output" : "deploy model to service\n",
  "history_begin_time" : 1678564686602,
  "history_end_time" : 1678564689199,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Done"
},{
  "history_id" : "amvl1pd2lo3",
  "history_input" : "# Deploy model to service\n\nprint(\"deploy model to service\")\n",
  "history_output" : "deploy model to service\n",
  "history_begin_time" : 1678557796871,
  "history_end_time" : 1678557898784,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Stopped"
},{
  "history_id" : "zdf56w22yyg",
  "history_input" : "# Deploy model to service\n\nprint(\"deploy model to service\")\n",
  "history_output" : "deploy model to service\n",
  "history_begin_time" : 1678497654726,
  "history_end_time" : 1678497657421,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Done"
},{
  "history_id" : "2ucdtlzg2in",
  "history_input" : "# Deploy model to service\n\nprint(\"deploy model to service\")\n",
  "history_output" : "deploy model to service\n",
  "history_begin_time" : 1678330790468,
  "history_end_time" : 1678330793154,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Done"
},{
  "history_id" : "babqku2d94y",
  "history_input" : "# Deploy model to service\n\nprint(\"deploy model to service\")\n",
  "history_output" : "deploy model to service\n",
  "history_begin_time" : 1678312629435,
  "history_end_time" : 1678312632063,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Done"
},{
  "history_id" : "it97senojc1",
  "history_input" : "# Deploy model to service\n\nprint(\"deploy model to service\")\n",
  "history_output" : "deploy model to service\n",
  "history_begin_time" : 1678312065371,
  "history_end_time" : 1678312067942,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Done"
},{
  "history_id" : "piew2yod9ur",
  "history_input" : "# Deploy model to service\n\nprint(\"deploy model to service\")\n",
  "history_output" : "deploy model to service\n",
  "history_begin_time" : 1678285602914,
  "history_end_time" : 1678285605072,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Done"
},{
  "history_id" : "3pu9lo74r0n",
  "history_input" : "# Deploy model to service\n\nprint(\"deploy model to service\")\n",
  "history_output" : "deploy model to service\n",
  "history_begin_time" : 1678202254111,
  "history_end_time" : 1678202257027,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Done"
},{
  "history_id" : "0zwtlwh9ujc",
  "history_input" : "# Deploy model to service\n\nprint(\"deploy model to service\")\n",
  "history_output" : "deploy model to service\n",
  "history_begin_time" : 1678155321362,
  "history_end_time" : 1678155323831,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Done"
},{
  "history_id" : "6dnkkfqyv7p",
  "history_input" : "# Deploy model to service\n\nprint(\"deploy model to service\")\n",
  "history_output" : "deploy model to service\n",
  "history_begin_time" : 1677791579049,
  "history_end_time" : 1677791581731,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Done"
},{
  "history_id" : "uqx42kmbkw5",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1677784204219,
  "history_end_time" : 1677784272018,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Stopped"
},{
  "history_id" : "qee90agx4c8",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1677782901795,
  "history_end_time" : 1677782901795,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Skipped"
},{
  "history_id" : "cx2lp81lyi0",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1677781745155,
  "history_end_time" : 1677781745155,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Skipped"
},{
  "history_id" : "4qka03ni1rh",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1677719046567,
  "history_end_time" : 1677719046567,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Skipped"
},{
  "history_id" : "tmnvugidok0",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1677718179080,
  "history_end_time" : 1677718179080,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Skipped"
},{
  "history_id" : "yys7qyvlzm5",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1677679556253,
  "history_end_time" : 1677679556253,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Skipped"
},{
  "history_id" : "j97u188zbmz",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1677679507356,
  "history_end_time" : 1677679549075,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Stopped"
},{
  "history_id" : "7m3ssfk04eg",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1677636286811,
  "history_end_time" : 1677636286811,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Skipped"
},{
  "history_id" : "v0dnrfltchb",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1677636150346,
  "history_end_time" : 1677636150346,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Skipped"
},{
  "history_id" : "x6zy9t1nty1",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1677636137198,
  "history_end_time" : 1677636142807,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Stopped"
},{
  "history_id" : "gdiaupttlu8",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1677636063734,
  "history_end_time" : 1677636063734,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Skipped"
},{
  "history_id" : "7t7ckk1ljv7",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1677635881792,
  "history_end_time" : 1677635881792,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Skipped"
},{
  "history_id" : "c35dhflhown",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1677617762748,
  "history_end_time" : 1677617762748,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Skipped"
},{
  "history_id" : "k20ksjnfl74",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1677606170851,
  "history_end_time" : 1677606170851,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Skipped"
},{
  "history_id" : "cdsntdo476a",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1677606114086,
  "history_end_time" : 1677606114086,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Skipped"
},{
  "history_id" : "d2opzevnn65",
  "history_input" : "# Deploy model to service\n\nprint(\"deploy model to service\")\n",
  "history_output" : "deploy model to service\n",
  "history_begin_time" : 1677582864952,
  "history_end_time" : 1677582865031,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "100001",
  "indicator" : "Done"
},{
  "history_id" : "ic3omz77bv0",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1677525425935,
  "history_end_time" : 1677525425935,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Skipped"
},{
  "history_id" : "ssc5p4wyiln",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1677462325745,
  "history_end_time" : 1677462325745,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Skipped"
},{
  "history_id" : "goi0bprwuyt",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1677462311617,
  "history_end_time" : 1677462311617,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Skipped"
},{
  "history_id" : "kier18job0a",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1677462265092,
  "history_end_time" : 1677462265092,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Skipped"
},{
  "history_id" : "4gll9yyq9li",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1677428742683,
  "history_end_time" : 1677428742683,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Skipped"
},{
  "history_id" : "q55iuo5t5k9",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1677428687295,
  "history_end_time" : 1677428687295,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Skipped"
},{
  "history_id" : "qd0cjyz624t",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1677426262704,
  "history_end_time" : 1677426262704,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Skipped"
},{
  "history_id" : "xyc54zccboq",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1677379889766,
  "history_end_time" : 1677379889766,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Skipped"
},{
  "history_id" : "3opfw8385hf",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1677379837758,
  "history_end_time" : 1677379837758,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Skipped"
},{
  "history_id" : "vth8me3n3sc",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1677352477933,
  "history_end_time" : 1677352477933,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Skipped"
},{
  "history_id" : "7ppt2voi65q",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1677352389867,
  "history_end_time" : 1677352389867,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Skipped"
},{
  "history_id" : "w78vu4kpfd7",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1677352335812,
  "history_end_time" : 1677352335812,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Skipped"
},{
  "history_id" : "22gd19rf2ct",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1677344119888,
  "history_end_time" : 1677344119888,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Skipped"
},{
  "history_id" : "whl5cxwfmw2",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1677282602533,
  "history_end_time" : 1677282602533,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Skipped"
},{
  "history_id" : "9g6ri340mcc",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1677273712204,
  "history_end_time" : 1677273712204,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Skipped"
},{
  "history_id" : "0d5pqu258nx",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1677273698725,
  "history_end_time" : 1677273703950,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Stopped"
},{
  "history_id" : "13aixewd58l",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1677273673894,
  "history_end_time" : 1677273679529,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Stopped"
},{
  "history_id" : "5s54pzuhbu0",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1677273657777,
  "history_end_time" : 1677273665446,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Stopped"
},{
  "history_id" : "4p5f1egy95a",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1677273535978,
  "history_end_time" : 1677273535978,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Skipped"
},{
  "history_id" : "anij6kg4q8g",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1677273519084,
  "history_end_time" : 1677273525482,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Stopped"
},{
  "history_id" : "19hz7winqpo",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1677273371283,
  "history_end_time" : 1677273371283,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Skipped"
},{
  "history_id" : "7kikskag44n",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1677273340412,
  "history_end_time" : 1677273345436,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Stopped"
},{
  "history_id" : "tme4ooojc5k",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1677273323462,
  "history_end_time" : 1677273332226,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Stopped"
},{
  "history_id" : "sdhjdna9lnj",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1677273146620,
  "history_end_time" : 1677273146620,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Skipped"
},{
  "history_id" : "fggb1vrn3iz",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1677273100195,
  "history_end_time" : 1677273134479,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Stopped"
},{
  "history_id" : "xu0iejq32kz",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1677201275373,
  "history_end_time" : 1677201275373,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Skipped"
},{
  "history_id" : "0gn12iqpow9",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1677192311031,
  "history_end_time" : 1677192311031,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Skipped"
},{
  "history_id" : "8g4jpa7lre9",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1677192268349,
  "history_end_time" : 1677192268349,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Skipped"
},{
  "history_id" : "4do4rodf0n0",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1677191916701,
  "history_end_time" : 1677191916701,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Skipped"
},{
  "history_id" : "nv4radnme1w",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1677184296660,
  "history_end_time" : 1677184296660,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Skipped"
},{
  "history_id" : "5ldrlon449x",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1677184173513,
  "history_end_time" : 1677184173513,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Skipped"
},{
  "history_id" : "q64qgrqxcqs",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1677113476431,
  "history_end_time" : 1677113476431,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Skipped"
},{
  "history_id" : "fagnv8ysdhw",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1677108238573,
  "history_end_time" : 1677108238573,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Skipped"
},{
  "history_id" : "qdk0lci85zn",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1677108212449,
  "history_end_time" : 1677108228694,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Stopped"
},{
  "history_id" : "3m89qeq0wzi",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1677107869786,
  "history_end_time" : 1677107869786,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Skipped"
},{
  "history_id" : "gte4oqfw759",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1677107757936,
  "history_end_time" : 1677107757936,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Skipped"
},{
  "history_id" : "ktzy98wqv1b",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1677107718282,
  "history_end_time" : 1677107718282,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Skipped"
},{
  "history_id" : "vesx8bj2l5w",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1677107637135,
  "history_end_time" : 1677107705671,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Stopped"
},{
  "history_id" : "8tobfk8h1ee",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1677107603999,
  "history_end_time" : 1677107608759,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Stopped"
},{
  "history_id" : "v2l06tdd6b5",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1677107556499,
  "history_end_time" : 1677107562714,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Stopped"
},{
  "history_id" : "x6yhpn2d21s",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1677107524967,
  "history_end_time" : 1677107538156,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Stopped"
},{
  "history_id" : "ly237j7gami",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1677107501069,
  "history_end_time" : 1677107501069,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Skipped"
},{
  "history_id" : "bdxo1p68dli",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1677107474131,
  "history_end_time" : 1677107474131,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Skipped"
},{
  "history_id" : "b3t16t55iui",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1677106516074,
  "history_end_time" : 1677106516074,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Skipped"
},{
  "history_id" : "8ygzg9kpsm7",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1677106477022,
  "history_end_time" : 1677106477022,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Skipped"
},{
  "history_id" : "kon20335aho",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1677106431010,
  "history_end_time" : 1677106431010,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Skipped"
},{
  "history_id" : "euywk2wj2im",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1677106134852,
  "history_end_time" : 1677106147544,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Stopped"
},{
  "history_id" : "7kyw02qybao",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1677106010917,
  "history_end_time" : 1677106010917,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Skipped"
},{
  "history_id" : "sq0z6ad2psr",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1677030843457,
  "history_end_time" : 1677030843457,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Skipped"
},{
  "history_id" : "zir158jdi54",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1677030771118,
  "history_end_time" : 1677030771118,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Skipped"
},{
  "history_id" : "3f0u5xlu2v6",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1677030672608,
  "history_end_time" : 1677030672608,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Skipped"
},{
  "history_id" : "97fld6x3fey",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1677030562136,
  "history_end_time" : 1677030562136,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Skipped"
},{
  "history_id" : "pg1dwrlz195",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1677025528626,
  "history_end_time" : 1677025528626,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Skipped"
},{
  "history_id" : "bsai78c7es6",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1677025466360,
  "history_end_time" : 1677025466360,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Skipped"
},{
  "history_id" : "63j2dess9f4",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1677017826392,
  "history_end_time" : 1677017826392,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Skipped"
},{
  "history_id" : "7pe9b4p3jyw",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1677017218399,
  "history_end_time" : 1677017218399,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Skipped"
},{
  "history_id" : "pdr88ka6f1b",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1677016681285,
  "history_end_time" : 1677016681285,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Skipped"
},{
  "history_id" : "6q6kqjdmb0g",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1677016142970,
  "history_end_time" : 1677016142970,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Skipped"
},{
  "history_id" : "q6uzmri4lft",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1677016063935,
  "history_end_time" : 1677016063935,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Skipped"
},{
  "history_id" : "7lb2h4xlx91",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1677015787617,
  "history_end_time" : 1677015787617,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Skipped"
},{
  "history_id" : "rwpdz7lhzdz",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1677015739916,
  "history_end_time" : 1677015739916,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Skipped"
},{
  "history_id" : "5700yvup5ah",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1677014884899,
  "history_end_time" : 1677014884899,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Skipped"
},{
  "history_id" : "ipga6mbeqyz",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1677014795542,
  "history_end_time" : 1677014795542,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Skipped"
},{
  "history_id" : "k5qc12iq8oi",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1677014227938,
  "history_end_time" : 1677014227938,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Skipped"
},{
  "history_id" : "cohq3c15q4j",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1677013908387,
  "history_end_time" : 1677013908387,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Skipped"
},{
  "history_id" : "ocsbr7bvvmu",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1677013832963,
  "history_end_time" : 1677013832963,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Skipped"
},{
  "history_id" : "bx738408feo",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1677011872992,
  "history_end_time" : 1677011872992,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Skipped"
},{
  "history_id" : "qgwye4urzhl",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1677008198529,
  "history_end_time" : 1677008198529,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Skipped"
},{
  "history_id" : "mw82bbsc1p5",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1677008162856,
  "history_end_time" : 1677008162856,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Skipped"
},{
  "history_id" : "dthf53d1iwa",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1677001999542,
  "history_end_time" : 1677001999542,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Skipped"
},{
  "history_id" : "rzbwan9jzm0",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1677001732205,
  "history_end_time" : 1677001732205,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "xajm7hz75ae",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1677001593745,
  "history_end_time" : 1677001593745,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "lbc4kgtcqbc",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1677000536747,
  "history_end_time" : 1677000536747,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "q8tfmqg73c9",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1676999722063,
  "history_end_time" : 1676999722063,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "yb51al",
  "indicator" : "Skipped"
},{
  "history_id" : "wr4piihbdyu",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1676999599014,
  "history_end_time" : 1676999599014,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "62kz7bxhlwm",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1676862212256,
  "history_end_time" : 1676862212256,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "5h4ttf3zsvs",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1676329536214,
  "history_end_time" : 1676329536214,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "hqct9wd8bvs",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1676329491712,
  "history_end_time" : 1676329491712,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "slev0n13pap",
  "history_input" : "# Deploy model to service\n\nprint(\"deploy model to service\")\n",
  "history_output" : "deploy model to service\n",
  "history_begin_time" : 1676063638589,
  "history_end_time" : 1676063638664,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "100001",
  "indicator" : "Done"
},{
  "history_id" : "i0qu80d74pq",
  "history_input" : "# Deploy model to service\n\nprint(\"deploy model to service\")\n",
  "history_output" : "deploy model to service\n",
  "history_begin_time" : 1675783805024,
  "history_end_time" : 1675783805097,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "100001",
  "indicator" : "Done"
},{
  "history_id" : "99w64muecu7",
  "history_input" : "# Deploy model to service\n\nprint(\"deploy model to service\")\n",
  "history_output" : "deploy model to service\n",
  "history_begin_time" : 1672015051123,
  "history_end_time" : 1672015051222,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "100001",
  "indicator" : "Done"
},{
  "history_id" : "03b0a4inmxi",
  "history_input" : "# Deploy model to service\n\nprint(\"deploy model to service\")\n",
  "history_output" : "deploy model to service\n",
  "history_begin_time" : 1671944455675,
  "history_end_time" : 1671944455774,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "100001",
  "indicator" : "Done"
},{
  "history_id" : "kyyswtv6f6n",
  "history_input" : "# Deploy model to service\n\nprint(\"deploy model to service\")\n",
  "history_output" : "deploy model to service\n",
  "history_begin_time" : 1670910686194,
  "history_end_time" : 1670910686312,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "100001",
  "indicator" : "Done"
},{
  "history_id" : "pbdda5dueo6",
  "history_input" : "# Deploy model to service\n\nprint(\"deploy model to service\")\n",
  "history_output" : "deploy model to service\n",
  "history_begin_time" : 1670910570451,
  "history_end_time" : 1670910570606,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "100001",
  "indicator" : "Done"
},{
  "history_id" : "pht5fk3a9rg",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1670910268427,
  "history_end_time" : 1670910268427,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "g3vumogaldi",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1670019638804,
  "history_end_time" : 1670019638804,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "cupzlogng1p",
  "history_input" : "# Deploy model to service\n\nprint(\"deploy model to service\")\n",
  "history_output" : "deploy model to service\n",
  "history_begin_time" : 1667484736940,
  "history_end_time" : 1667484737052,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "100001",
  "indicator" : "Done"
},{
  "history_id" : "xt6t35bodpe",
  "history_input" : "# Deploy model to service\n\nprint(\"deploy model to service\")\n",
  "history_output" : "deploy model to service\n",
  "history_begin_time" : 1667410808925,
  "history_end_time" : 1667410809071,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "100001",
  "indicator" : "Done"
},{
  "history_id" : "jh9ydimw0cm",
  "history_input" : "# Deploy model to service\n\nprint(\"deploy model to service\")\n",
  "history_output" : "deploy model to service\n",
  "history_begin_time" : 1654521115025,
  "history_end_time" : 1654521115144,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "100001",
  "indicator" : "Done"
},{
  "history_id" : "3fy8xfm8567",
  "history_input" : "# Deploy model to service\n\nprint(\"deploy model to service\")\n",
  "history_output" : "deploy model to service\n",
  "history_begin_time" : 1647826117273,
  "history_end_time" : 1647826117386,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "100001",
  "indicator" : "Done"
},{
  "history_id" : "nf2n7gtg3kz",
  "history_input" : "# Deploy model to service\n\nprint(\"deploy model to service\")\n",
  "history_output" : "deploy model to service\n",
  "history_begin_time" : 1647225952602,
  "history_end_time" : 1647225952698,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "100001",
  "indicator" : "Done"
},{
  "history_id" : "148a3mugiz2",
  "history_input" : "# Deploy model to service\n\nprint(\"deploy model to service\")\n",
  "history_output" : "deploy model to service\n",
  "history_begin_time" : 1646693033766,
  "history_end_time" : 1646693033896,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "100001",
  "indicator" : "Done"
},{
  "history_id" : "3buye4neevn",
  "history_input" : "# Deploy model to service\n\nprint(\"deploy model to service\")\n",
  "history_output" : "deploy model to service\n",
  "history_begin_time" : 1646604648073,
  "history_end_time" : 1646604648235,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "100001",
  "indicator" : "Done"
},{
  "history_id" : "56y4ftkt5yi",
  "history_input" : "# Deploy model to service\n\nprint(\"deploy model to service\")\n",
  "history_output" : "deploy model to service\n",
  "history_begin_time" : 1646272337859,
  "history_end_time" : 1646272337989,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "100001",
  "indicator" : "Done"
},{
  "history_id" : "k84eh83rkz6",
  "history_input" : "# Deploy model to service\n\nprint(\"deploy model to service\")\n",
  "history_output" : "deploy model to service\n",
  "history_begin_time" : 1645977675714,
  "history_end_time" : 1645977676764,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "je29f6",
  "indicator" : "Done"
},{
  "history_id" : "qcg3ken9a69",
  "history_input" : "# Deploy model to service\n\nprint(\"deploy model to service\")\n",
  "history_output" : "deploy model to service\n",
  "history_begin_time" : 1645977445591,
  "history_end_time" : 1645977446592,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "je29f6",
  "indicator" : "Done"
},{
  "history_id" : "argt5yqt0ad",
  "history_input" : "# Deploy model to service\n\nprint(\"deploy model to service\")\n",
  "history_output" : "deploy model to service\n",
  "history_begin_time" : 1642977866710,
  "history_end_time" : 1642977866827,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "100001",
  "indicator" : "Done"
},{
  "history_id" : "rilhyfolrey",
  "history_input" : "# Deploy model to service\n\nprint(\"deploy model to service\")\n",
  "history_output" : "deploy model to service\n",
  "history_begin_time" : 1642969781031,
  "history_end_time" : 1642969781150,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "100001",
  "indicator" : "Done"
},{
  "history_id" : "hs2g7ll5vhi",
  "history_input" : "# Deploy model to service\n\nprint(\"deploy model to service\")\n",
  "history_output" : "deploy model to service\n",
  "history_begin_time" : 1642455232511,
  "history_end_time" : 1642455232636,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "100001",
  "indicator" : "Done"
},{
  "history_id" : "67w94uwybuf",
  "history_input" : "# Deploy model to service\n\nprint(\"deploy model to service\")\n",
  "history_output" : "deploy model to service\n",
  "history_begin_time" : 1642454682946,
  "history_end_time" : 1642454683090,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "100001",
  "indicator" : "Done"
},{
  "history_id" : "hjle1g5ytv6",
  "history_input" : null,
  "history_output" : null,
  "history_begin_time" : null,
  "history_end_time" : 1667410703752,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "100001",
  "indicator" : "Stopped"
},{
  "history_id" : "z7orbzf2q86",
  "history_input" : null,
  "history_output" : null,
  "history_begin_time" : null,
  "history_end_time" : 1681039697758,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "100001",
  "indicator" : "Stopped"
},{
  "history_id" : "wnelzutjg6b",
  "history_input" : null,
  "history_output" : null,
  "history_begin_time" : null,
  "history_end_time" : 1677809171448,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Stopped"
},{
  "history_id" : "xyqhydlejwq",
  "history_input" : null,
  "history_output" : null,
  "history_begin_time" : null,
  "history_end_time" : 1678201703956,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Stopped"
},{
  "history_id" : "xsjc30d1lo8",
  "history_input" : null,
  "history_output" : null,
  "history_begin_time" : null,
  "history_end_time" : 1677791865853,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Stopped"
},{
  "history_id" : "xjapsb5584p",
  "history_input" : null,
  "history_output" : null,
  "history_begin_time" : null,
  "history_end_time" : 1677785529412,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Stopped"
},{
  "history_id" : "hcub6wuw65g",
  "history_input" : null,
  "history_output" : null,
  "history_begin_time" : null,
  "history_end_time" : 1677797113212,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Stopped"
},{
  "history_id" : "o8ifwayey87",
  "history_input" : null,
  "history_output" : null,
  "history_begin_time" : null,
  "history_end_time" : 1677809840714,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Stopped"
},{
  "history_id" : "17eu9njh4na",
  "history_input" : null,
  "history_output" : null,
  "history_begin_time" : null,
  "history_end_time" : 1677784516772,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Stopped"
},{
  "history_id" : "oly6kkgev5c",
  "history_input" : null,
  "history_output" : null,
  "history_begin_time" : null,
  "history_end_time" : 1677785383322,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Stopped"
},{
  "history_id" : "ogh9jii4gjd",
  "history_input" : null,
  "history_output" : null,
  "history_begin_time" : null,
  "history_end_time" : 1677786042624,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Stopped"
},{
  "history_id" : "0okqolarrst",
  "history_input" : null,
  "history_output" : null,
  "history_begin_time" : null,
  "history_end_time" : 1677796528249,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Stopped"
},{
  "history_id" : "a9duwxaoadw",
  "history_input" : null,
  "history_output" : null,
  "history_begin_time" : null,
  "history_end_time" : 1677809306570,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Stopped"
},{
  "history_id" : "v2nab86uerc",
  "history_input" : null,
  "history_output" : null,
  "history_begin_time" : null,
  "history_end_time" : 1677809554665,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Stopped"
},{
  "history_id" : "n5sw8d1fqzq",
  "history_input" : null,
  "history_output" : null,
  "history_begin_time" : null,
  "history_end_time" : 1677809573409,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Stopped"
},{
  "history_id" : "omkeql4en17",
  "history_input" : null,
  "history_output" : null,
  "history_begin_time" : null,
  "history_end_time" : 1677867648029,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Stopped"
},{
  "history_id" : "go9hw1tbtsx",
  "history_input" : null,
  "history_output" : null,
  "history_begin_time" : null,
  "history_end_time" : 1677958291180,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Stopped"
},{
  "history_id" : "rwwhycxlkia",
  "history_input" : null,
  "history_output" : null,
  "history_begin_time" : null,
  "history_end_time" : 1677958754101,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Stopped"
},{
  "history_id" : "gz3r5lbsea4",
  "history_input" : null,
  "history_output" : null,
  "history_begin_time" : null,
  "history_end_time" : 1677958849869,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Stopped"
},{
  "history_id" : "eh0ixx3ijv3",
  "history_input" : null,
  "history_output" : null,
  "history_begin_time" : null,
  "history_end_time" : 1677958952850,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Stopped"
},{
  "history_id" : "8g8fjg44qot",
  "history_input" : null,
  "history_output" : null,
  "history_begin_time" : null,
  "history_end_time" : 1677959583115,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Stopped"
},{
  "history_id" : "5uxzh9ohpg1",
  "history_input" : null,
  "history_output" : null,
  "history_begin_time" : null,
  "history_end_time" : 1677959722599,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Stopped"
},{
  "history_id" : "fq2nyae5zw8",
  "history_input" : null,
  "history_output" : null,
  "history_begin_time" : null,
  "history_end_time" : 1678154846097,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Stopped"
},{
  "history_id" : "bdfex5zgz73",
  "history_input" : null,
  "history_output" : null,
  "history_begin_time" : null,
  "history_end_time" : 1678201516407,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Stopped"
},{
  "history_id" : "wdk9lrqr79g",
  "history_input" : null,
  "history_output" : null,
  "history_begin_time" : null,
  "history_end_time" : 1678201687039,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Stopped"
},{
  "history_id" : "fr0vmmf960l",
  "history_input" : null,
  "history_output" : null,
  "history_begin_time" : null,
  "history_end_time" : 1678206143045,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Stopped"
},{
  "history_id" : "yzvuyfir7k3",
  "history_input" : null,
  "history_output" : null,
  "history_begin_time" : null,
  "history_end_time" : 1678206378222,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Stopped"
},{
  "history_id" : "tck34393nkc",
  "history_input" : null,
  "history_output" : null,
  "history_begin_time" : null,
  "history_end_time" : 1678312026538,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Stopped"
},{
  "history_id" : "mrq9cvhselx",
  "history_input" : null,
  "history_output" : null,
  "history_begin_time" : null,
  "history_end_time" : 1686235482619,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "jf7wuu",
  "indicator" : "Stopped"
},{
  "history_id" : "s9ilwqx4h8w",
  "history_input" : null,
  "history_output" : null,
  "history_begin_time" : null,
  "history_end_time" : 1686237909480,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "jf7wuu",
  "indicator" : "Stopped"
},{
  "history_id" : "gla2timsfi0",
  "history_input" : null,
  "history_output" : null,
  "history_begin_time" : null,
  "history_end_time" : 1686235423739,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "jf7wuu",
  "indicator" : "Stopped"
},{
  "history_id" : "cj35gziejw0",
  "history_input" : null,
  "history_output" : null,
  "history_begin_time" : null,
  "history_end_time" : 1682984800274,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "jf7wuu",
  "indicator" : "Stopped"
},{
  "history_id" : "jqkffbnp509",
  "history_input" : null,
  "history_output" : null,
  "history_begin_time" : null,
  "history_end_time" : 1678888215690,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Stopped"
},{
  "history_id" : "smii0n3impp",
  "history_input" : null,
  "history_output" : null,
  "history_begin_time" : null,
  "history_end_time" : 1678744167035,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Stopped"
},{
  "history_id" : "2umabwwn9og",
  "history_input" : null,
  "history_output" : null,
  "history_begin_time" : null,
  "history_end_time" : 1678883775417,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Stopped"
},{
  "history_id" : "nktkzqbvacg",
  "history_input" : null,
  "history_output" : null,
  "history_begin_time" : null,
  "history_end_time" : 1678557923629,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Stopped"
},{
  "history_id" : "ohho7mnyqux",
  "history_input" : null,
  "history_output" : null,
  "history_begin_time" : null,
  "history_end_time" : 1678648341597,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Stopped"
},{
  "history_id" : "ezk7a433lnf",
  "history_input" : null,
  "history_output" : null,
  "history_begin_time" : null,
  "history_end_time" : 1678725408335,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Stopped"
},{
  "history_id" : "xpinof6ov72",
  "history_input" : null,
  "history_output" : null,
  "history_begin_time" : null,
  "history_end_time" : 1678742571495,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Stopped"
},{
  "history_id" : "epkxk630byw",
  "history_input" : null,
  "history_output" : null,
  "history_begin_time" : null,
  "history_end_time" : 1678743615529,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Stopped"
},{
  "history_id" : "bxg3ks57h9w",
  "history_input" : null,
  "history_output" : null,
  "history_begin_time" : null,
  "history_end_time" : 1678746792969,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Stopped"
},{
  "history_id" : "lpp14u1amet",
  "history_input" : null,
  "history_output" : null,
  "history_begin_time" : null,
  "history_end_time" : 1678749935953,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Stopped"
},{
  "history_id" : "fwoz43itog1",
  "history_input" : null,
  "history_output" : null,
  "history_begin_time" : null,
  "history_end_time" : 1678756684666,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Stopped"
},{
  "history_id" : "gjrbcwa19h0",
  "history_input" : null,
  "history_output" : null,
  "history_begin_time" : null,
  "history_end_time" : 1678884042256,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Stopped"
},{
  "history_id" : "icnh8gmckis",
  "history_input" : null,
  "history_output" : null,
  "history_begin_time" : null,
  "history_end_time" : 1678884140244,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Stopped"
},{
  "history_id" : "csn219nybkh",
  "history_input" : null,
  "history_output" : null,
  "history_begin_time" : null,
  "history_end_time" : 1678884438321,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Stopped"
},{
  "history_id" : "x3fygbgcqd3",
  "history_input" : null,
  "history_output" : null,
  "history_begin_time" : null,
  "history_end_time" : 1678884535323,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Stopped"
},{
  "history_id" : "xhscps6dgdi",
  "history_input" : null,
  "history_output" : null,
  "history_begin_time" : null,
  "history_end_time" : 1678884986353,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Stopped"
},{
  "history_id" : "2ji4m7g91zm",
  "history_input" : null,
  "history_output" : null,
  "history_begin_time" : null,
  "history_end_time" : 1678887010619,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Stopped"
},{
  "history_id" : "2bqs9w095cv",
  "history_input" : null,
  "history_output" : null,
  "history_begin_time" : null,
  "history_end_time" : 1678887836223,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Stopped"
},{
  "history_id" : "fvbppo4dcmg",
  "history_input" : null,
  "history_output" : null,
  "history_begin_time" : null,
  "history_end_time" : 1678887946439,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Stopped"
},{
  "history_id" : "zqjdkteas72",
  "history_input" : null,
  "history_output" : null,
  "history_begin_time" : null,
  "history_end_time" : 1679091533634,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Stopped"
},{
  "history_id" : "ozk80viacsk",
  "history_input" : null,
  "history_output" : null,
  "history_begin_time" : null,
  "history_end_time" : 1679091744923,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "45wlwr",
  "indicator" : "Stopped"
},{
  "history_id" : "qi9wapr7az8",
  "history_input" : null,
  "history_output" : null,
  "history_begin_time" : null,
  "history_end_time" : 1688416572957,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "jf7wuu",
  "indicator" : "Stopped"
},{
  "history_id" : "wi2wdnnwgti",
  "history_input" : null,
  "history_output" : null,
  "history_begin_time" : null,
  "history_end_time" : 1688416660660,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "jf7wuu",
  "indicator" : "Stopped"
},{
  "history_id" : "k679aai3gg5",
  "history_input" : null,
  "history_output" : null,
  "history_begin_time" : null,
  "history_end_time" : 1688416822940,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "jf7wuu",
  "indicator" : "Stopped"
},{
  "history_id" : "30guyp5kvan",
  "history_input" : null,
  "history_output" : null,
  "history_begin_time" : null,
  "history_end_time" : 1688416848464,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "jf7wuu",
  "indicator" : "Stopped"
},{
  "history_id" : "zxr544ek9z1",
  "history_input" : null,
  "history_output" : null,
  "history_begin_time" : null,
  "history_end_time" : 1688416907359,
  "history_notes" : null,
  "history_process" : "2wkl6e",
  "host_id" : "jf7wuu",
  "indicator" : "Stopped"
},]
