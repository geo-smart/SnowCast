[{
  "history_id" : "li34c92un80",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1719806410742,
  "history_end_time" : 1719806410742,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "sd0n6hk0d6j",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1719720012213,
  "history_end_time" : 1719720012213,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "xnnc8u3znlu",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1719633609324,
  "history_end_time" : 1719633609324,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "crs551lk1vj",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1719547210086,
  "history_end_time" : 1719547210086,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "0rd2cnp7dqq",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1719460810685,
  "history_end_time" : 1719460810685,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "wio10xw0hqr",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1719374413546,
  "history_end_time" : 1719374413546,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "8p5cw9r1v3p",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1719288011078,
  "history_end_time" : 1719288011078,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "qrwdzsh0x9r",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1719201615360,
  "history_end_time" : 1719201615360,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "b4jqppazuna",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1719115211720,
  "history_end_time" : 1719115211720,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "64lvjmg6q3u",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1719061831187,
  "history_end_time" : 1719061831187,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "kgls9g3ta99",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1719028809962,
  "history_end_time" : 1719028809962,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "sdhns4c5lbe",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1718992708772,
  "history_end_time" : 1719004828834,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Stopped"
},{
  "history_id" : "axk05wpfbrk",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1718942410269,
  "history_end_time" : 1718942410269,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "nuuhn8wo6c3",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1718856011544,
  "history_end_time" : 1718856011544,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "b3wg5jx4aje",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1718850065965,
  "history_end_time" : 1718850065965,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "9g5i8awd5ec",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1718821279609,
  "history_end_time" : 1718821279609,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "mdw1jurzn6z",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1718813272206,
  "history_end_time" : 1718813272206,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "vcq1k7qwebv",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1718778405582,
  "history_end_time" : 1718778405582,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "0edfg4iplok",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1718775386121,
  "history_end_time" : 1718775386121,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "ul070f9n3yu",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1718771671342,
  "history_end_time" : 1718771671342,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "a7lp6b90n5l",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1718769611297,
  "history_end_time" : 1718769611297,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "nvntcf3qd3u",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1718683212500,
  "history_end_time" : 1718683212500,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "7zkmbigzv97",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1718596812475,
  "history_end_time" : 1718596812475,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "uo3k0w28l3u",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1718510413318,
  "history_end_time" : 1718510413318,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "kgss97b2l02",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1718459775256,
  "history_end_time" : 1718459775256,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "lgkz75ifyuq",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1718424009636,
  "history_end_time" : 1718424009636,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "2p54xehg9ec",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1718373284953,
  "history_end_time" : 1718373284953,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "xdx88aflop6",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1718337613062,
  "history_end_time" : 1718337613062,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "j89s8v1fr48",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1718323441856,
  "history_end_time" : 1718323441856,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "n122wqh55q3",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1718302153548,
  "history_end_time" : 1718302153548,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "tx4au4w3bi0",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1718251216831,
  "history_end_time" : 1718251216831,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "m9hawaw6pg8",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1718178289062,
  "history_end_time" : 1718178289062,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "v5rmwuq9sa6",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1718174667274,
  "history_end_time" : 1718174667274,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "urkellp0twn",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1718164810312,
  "history_end_time" : 1718164810312,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "7w53i9pn4qp",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1718098293557,
  "history_end_time" : 1718098293557,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "tuzhn1hhua2",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1718089421268,
  "history_end_time" : 1718089421268,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "u1ygevcb1a2",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1718082200958,
  "history_end_time" : 1718082200958,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "x75iqv5q497",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1718078411201,
  "history_end_time" : 1718078411201,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "tj58pj6sn8q",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1718053277566,
  "history_end_time" : 1718053277566,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "csw5c2hg73t",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1717992010008,
  "history_end_time" : 1717992010008,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "lwwkdglzrim",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1717985376003,
  "history_end_time" : 1717985376003,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "0i0jwjsug0f",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1717917246788,
  "history_end_time" : 1717917246788,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "s72ukjv9pjw",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1717912483890,
  "history_end_time" : 1717912483890,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "r3w6tdmestk",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1717905610052,
  "history_end_time" : 1717905610052,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "wt2z4qlz2yz",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1717819210000,
  "history_end_time" : 1717819210000,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "p0u8tqbyh16",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1717732810218,
  "history_end_time" : 1717732810218,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "kwt6ygfz63r",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1717646410186,
  "history_end_time" : 1717646410186,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "d2czwflixlq",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1717599091178,
  "history_end_time" : 1717599091178,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "msjo0lymebg",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1717579163779,
  "history_end_time" : 1717579163779,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "ldi6twe60iy",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1717560009695,
  "history_end_time" : 1717579485507,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Stopped"
},{
  "history_id" : "1mk2tkacp3q",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1717473609537,
  "history_end_time" : 1717473609537,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "gnxg5565ad9",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1717387237003,
  "history_end_time" : 1717387237003,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "zx970u0dkbq",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1717300809931,
  "history_end_time" : 1717579483761,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Stopped"
},{
  "history_id" : "kaold6erybg",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1717214410057,
  "history_end_time" : 1717579482948,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Stopped"
},{
  "history_id" : "27rgifnv0qr",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1717128009975,
  "history_end_time" : 1717579482033,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Stopped"
},{
  "history_id" : "tbba8276j1v",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1717041609713,
  "history_end_time" : 1717041609713,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "p061185budh",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1716955209727,
  "history_end_time" : 1716955209727,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "dukymo0z1xw",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1716868810602,
  "history_end_time" : 1716868810602,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "pz0fuj8zz8k",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1716817415313,
  "history_end_time" : 1716817415313,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "m1gzexh19nf",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1716797560572,
  "history_end_time" : 1716797560572,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "32dpz9127ed",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1716782410990,
  "history_end_time" : 1716782410990,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "bsqge2ba8no",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1716777609601,
  "history_end_time" : 1716777609601,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "dlq1asgr42g",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1716774915317,
  "history_end_time" : 1716774915317,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "x3u8oxdhx0g",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1716754065147,
  "history_end_time" : 1716754065147,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "gl2w6injx9x",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1716751217887,
  "history_end_time" : 1716751217887,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "wgwivc0j4cl",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1716750881044,
  "history_end_time" : 1716751199702,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Stopped"
},{
  "history_id" : "dkplf4hrd3v",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1716746640534,
  "history_end_time" : 1716746640534,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "kkcg8liizbe",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1716696010502,
  "history_end_time" : 1716696010502,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "ok0mxy9dmlo",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1716618218986,
  "history_end_time" : 1716618218986,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "ldzop04rz9m",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1716609610903,
  "history_end_time" : 1716609610903,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "d4uz4l3qvm2",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1716563756502,
  "history_end_time" : 1716563756502,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "pnpf10aeqny",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1716524704881,
  "history_end_time" : 1716524704881,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "ev5ko3w03j4",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1716523210773,
  "history_end_time" : 1716523210773,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "4yqt9o520an",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1716521650148,
  "history_end_time" : 1716521650148,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "6krwwzv7c23",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1716519590161,
  "history_end_time" : 1716519590161,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "1ti2wihr9wn",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1716513818303,
  "history_end_time" : 1716513818303,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "lozzhubuv46",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1716471261866,
  "history_end_time" : 1716471261866,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "agi9emaue8a",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1716436813692,
  "history_end_time" : 1716799400432,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Stopped"
},{
  "history_id" : "z1eq0q38fq3",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1716422697981,
  "history_end_time" : 1716422827827,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Stopped"
},{
  "history_id" : "8ldlogfpemi",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1716422518588,
  "history_end_time" : 1716422518588,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "jrc95tlb5rs",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1716418166551,
  "history_end_time" : 1716418166551,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "b6t381p7bo7",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1716350423324,
  "history_end_time" : 1716418192163,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Stopped"
},{
  "history_id" : "wghxsrezaja",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1716264023622,
  "history_end_time" : 1716418191980,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Stopped"
},{
  "history_id" : "ih6sk5bdnn2",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1716215991363,
  "history_end_time" : 1716220261579,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Stopped"
},{
  "history_id" : "5a1ddce82vx",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1716184844638,
  "history_end_time" : 1716216036769,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Stopped"
},{
  "history_id" : "kfdt9h2obku",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1716177613661,
  "history_end_time" : 1716418191244,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Stopped"
},{
  "history_id" : "wt3twhya96h",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1716091213878,
  "history_end_time" : 1716418190526,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Stopped"
},{
  "history_id" : "upwphgtc8vv",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1716062448883,
  "history_end_time" : 1716124523788,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Stopped"
},{
  "history_id" : "wu7l7t6z6om",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1716043609974,
  "history_end_time" : 1716057482676,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Stopped"
},{
  "history_id" : "d7xc11v6hoh",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1716035693299,
  "history_end_time" : 1716036846654,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Stopped"
},{
  "history_id" : "ydg6adkmg0a",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1716004809725,
  "history_end_time" : 1716418193602,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Stopped"
},{
  "history_id" : "5k7wyle49x1",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1715982779431,
  "history_end_time" : 1716035691966,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Stopped"
},{
  "history_id" : "lxb3sydquud",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1715980750493,
  "history_end_time" : 1715982778738,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Stopped"
},{
  "history_id" : "gk9x8xcd814",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1715972396923,
  "history_end_time" : 1715980749615,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Stopped"
},{
  "history_id" : "gnetvxvtwrp",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1715967265169,
  "history_end_time" : 1715972396073,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Stopped"
},{
  "history_id" : "5sdgt5y9mxt",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1715960695185,
  "history_end_time" : 1715967264432,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Stopped"
},{
  "history_id" : "fq7ohqxz5n0",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1715957532874,
  "history_end_time" : 1715960694150,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Stopped"
},{
  "history_id" : "i3wu6llzvaj",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1715952722358,
  "history_end_time" : 1715957517336,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Stopped"
},{
  "history_id" : "mofyqnkhbgg",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1715939821387,
  "history_end_time" : 1716418196153,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Stopped"
},{
  "history_id" : "6klloa4hhgm",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1715937541730,
  "history_end_time" : 1715937541730,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "zy7nrp1cp56",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1715937326818,
  "history_end_time" : 1715937540105,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Stopped"
},{
  "history_id" : "r9kx9uq1kvi",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1715927549676,
  "history_end_time" : 1715927549676,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "pn80enn5bh0",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1715918413186,
  "history_end_time" : 1716418197751,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Stopped"
},{
  "history_id" : "pwup4g29iiy",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1715832029368,
  "history_end_time" : 1716418197456,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Stopped"
},{
  "history_id" : "zn44i3x5wwy",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1715799528241,
  "history_end_time" : 1716418198820,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Stopped"
},{
  "history_id" : "8rknpwki4x7",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1715798137953,
  "history_end_time" : 1715799518100,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Stopped"
},{
  "history_id" : "m0q9tq8k40m",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1715780310562,
  "history_end_time" : 1715780310562,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "c9522ve0i4h",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1715755079511,
  "history_end_time" : 1715780309796,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Stopped"
},{
  "history_id" : "rgzyd12zg3c",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1715745613520,
  "history_end_time" : 1716418200145,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Stopped"
},{
  "history_id" : "ia6lcicm3k0",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1715670775291,
  "history_end_time" : 1715670775291,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "c58h67mh1iy",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1715668379760,
  "history_end_time" : 1715668379760,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "w9q2h6vvwm9",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1715660606884,
  "history_end_time" : 1715660606884,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "a7vxslbz96l",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1715659214344,
  "history_end_time" : 1716418201347,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Stopped"
},{
  "history_id" : "pjlenmo7b43",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1715657268343,
  "history_end_time" : 1715657268343,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "llqbhttp4jp",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1715654494264,
  "history_end_time" : 1715654494264,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "zl3k1ocvzc8",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1715651069763,
  "history_end_time" : 1715654493189,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Stopped"
},{
  "history_id" : "pnym0l09sbj",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1715635694028,
  "history_end_time" : 1715635694028,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "t80c1t2sijo",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1715631991553,
  "history_end_time" : 1715631991553,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "h4gupl4jxy5",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1715593112675,
  "history_end_time" : 1715593112675,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "6u52aejaw8f",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1715588597344,
  "history_end_time" : 1715588597344,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "3nqt18th14o",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1715580981577,
  "history_end_time" : 1715588592982,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Stopped"
},{
  "history_id" : "i3m3wwivanw",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1715577232480,
  "history_end_time" : 1715577232480,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "n6gi2qai02u",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1715572813870,
  "history_end_time" : 1716418203315,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Stopped"
},{
  "history_id" : "z8ic3fatmnz",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1715569180269,
  "history_end_time" : 1715569180269,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "u9k739nv763",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1715566644956,
  "history_end_time" : 1715569179304,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Stopped"
},{
  "history_id" : "2r073qqvgh3",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1715564158907,
  "history_end_time" : 1715566643890,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Stopped"
},{
  "history_id" : "kl0q4af7nq3",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1715553269406,
  "history_end_time" : 1715553269406,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "okakdlyelum",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1715551757413,
  "history_end_time" : 1716418204195,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Stopped"
},{
  "history_id" : "o49902zozc3",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1715550036497,
  "history_end_time" : 1715551587882,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Stopped"
},{
  "history_id" : "uobwr08dbyq",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1715548411078,
  "history_end_time" : 1715551556688,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Stopped"
},{
  "history_id" : "pxrtyoike9j",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1715526734698,
  "history_end_time" : 1715548400452,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Stopped"
},{
  "history_id" : "n6l23r34hzr",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1715486409298,
  "history_end_time" : 1715486409298,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "ix5fvrwwur4",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1715400009913,
  "history_end_time" : 1715549424574,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Stopped"
},{
  "history_id" : "lhz9t64xdxv",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1715313616179,
  "history_end_time" : 1715549422993,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Stopped"
},{
  "history_id" : "i1v89qu4al6",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1715227214838,
  "history_end_time" : 1715549422463,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Stopped"
},{
  "history_id" : "gdmlhzj0pd1",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1715140819408,
  "history_end_time" : 1715549421781,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Stopped"
},{
  "history_id" : "zq4ffct6y2l",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1715054414162,
  "history_end_time" : 1715549421325,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Stopped"
},{
  "history_id" : "o26x9ls9kcl",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1715045815889,
  "history_end_time" : 1715045815889,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "hp117lsgcnx",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1715045635639,
  "history_end_time" : 1715045800473,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Stopped"
},{
  "history_id" : "5iyp943sdkc",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1714998835530,
  "history_end_time" : 1714998835530,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "t4tgps80d25",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1714977334975,
  "history_end_time" : 1714977334975,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "p95xbs5rgj1",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1714968022944,
  "history_end_time" : 1715549419170,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Stopped"
},{
  "history_id" : "548maxsocta",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1714956083288,
  "history_end_time" : 1714956340966,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "vbx6zc",
  "indicator" : "Stopped"
},{
  "history_id" : "9wapp520g39",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1714944531179,
  "history_end_time" : 1714944767098,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "vbx6zc",
  "indicator" : "Stopped"
},{
  "history_id" : "y7xlg9dmn69",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1714943546204,
  "history_end_time" : 1715549417765,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Stopped"
},{
  "history_id" : "d918x1hrcia",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1714897025187,
  "history_end_time" : 1714897025187,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "1dz02vhih71",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1714894044099,
  "history_end_time" : 1714895139363,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Stopped"
},{
  "history_id" : "ea3u6i4x7pk",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1714881609647,
  "history_end_time" : 1715549416931,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Stopped"
},{
  "history_id" : "00fzjumowuk",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1714409076769,
  "history_end_time" : 1714409076769,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "q2eogbdhbfw",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1714407283819,
  "history_end_time" : 1714407283819,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "sm9ggxub1am",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1714404800052,
  "history_end_time" : 1714404800052,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "8c07hafa5i0",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1714363210024,
  "history_end_time" : 1715549415895,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Stopped"
},{
  "history_id" : "m69riv6x1bm",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1714362032619,
  "history_end_time" : 1714362032619,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "xs57je2t5wj",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1714355595222,
  "history_end_time" : 1714355595222,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "qmlg9wvd360",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1714351396818,
  "history_end_time" : 1714351396818,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "k84l6h2m3rb",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1714348539262,
  "history_end_time" : 1714348539262,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "l4zgcbvmcx6",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1714345973201,
  "history_end_time" : 1714345973201,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "fosp2vy20kh",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1714343583829,
  "history_end_time" : 1714343583829,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "o8oo6mrt0dz",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1714340841760,
  "history_end_time" : 1714340841760,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "y1g6jv55wam",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1714332798078,
  "history_end_time" : 1714332798078,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "st6z83tbpeh",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1714328816158,
  "history_end_time" : 1714328816158,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "s6vy62il4w0",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1714323529065,
  "history_end_time" : 1714323529065,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "78sj0q3g1oz",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1714320354953,
  "history_end_time" : 1714320354953,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "f705ofd13r5",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1714315863052,
  "history_end_time" : 1714315863052,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "qa14fucvm4b",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1714283543354,
  "history_end_time" : 1714315861972,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Stopped"
},{
  "history_id" : "r3wk7467ddi",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1714281870873,
  "history_end_time" : 1714283515031,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Stopped"
},{
  "history_id" : "x89s270ebkd",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1714276838268,
  "history_end_time" : 1714315876847,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Stopped"
},{
  "history_id" : "0b6oeff40c6",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1714274662745,
  "history_end_time" : 1714281869543,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Stopped"
},{
  "history_id" : "rv7szflks9r",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1714272894693,
  "history_end_time" : 1714274352429,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Stopped"
},{
  "history_id" : "5wgkcu6ml3u",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1714265253406,
  "history_end_time" : 1714272892769,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Stopped"
},{
  "history_id" : "o0wkj4tpctz",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1714265112600,
  "history_end_time" : 1714265250904,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Stopped"
},{
  "history_id" : "q9o1phqvy9x",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1714192736141,
  "history_end_time" : 1714265111645,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Stopped"
},{
  "history_id" : "sn61g8zxkro",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1714190418175,
  "history_end_time" : 1714274350940,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Stopped"
},{
  "history_id" : "pi100nm0g8j",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1714104009340,
  "history_end_time" : 1714274350446,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Stopped"
},{
  "history_id" : "z66qvx2o6kn",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1714017609691,
  "history_end_time" : 1714274349900,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Stopped"
},{
  "history_id" : "frsmj9fyot6",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1713931210007,
  "history_end_time" : 1714274349309,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Stopped"
},{
  "history_id" : "87c1jgigua1",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1713844809702,
  "history_end_time" : 1714274348769,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Stopped"
},{
  "history_id" : "mt5s1o4x949",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1713758409290,
  "history_end_time" : 1714274347307,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Stopped"
},{
  "history_id" : "5s2qu37fix3",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1713672009724,
  "history_end_time" : 1714274346324,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Stopped"
},{
  "history_id" : "f5l1ecejjdy",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1713585609499,
  "history_end_time" : 1714274345805,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Stopped"
},{
  "history_id" : "7ughaqah9xt",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1713499209699,
  "history_end_time" : 1714274345258,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Stopped"
},{
  "history_id" : "mwgdd8ygund",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1713412808935,
  "history_end_time" : 1714274344696,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Stopped"
},{
  "history_id" : "ab73dl8gdf4",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1713326409055,
  "history_end_time" : 1714274343278,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Stopped"
},{
  "history_id" : "iubf1ghvbo3",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1713283461278,
  "history_end_time" : 1713283461278,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "cxu3075c2rs",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1713240009054,
  "history_end_time" : 1714274342585,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Stopped"
},{
  "history_id" : "1yeqgtzxky2",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1711771209614,
  "history_end_time" : 1711771209614,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "uuoyd2cetdn",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1711684813681,
  "history_end_time" : 1714282476010,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Stopped"
},{
  "history_id" : "vjxlxn2seym",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1711598415106,
  "history_end_time" : 1714282474554,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Stopped"
},{
  "history_id" : "jr3zkyjmvnz",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1711592280509,
  "history_end_time" : 1711592280509,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "3pew9nblhvb",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1711592081842,
  "history_end_time" : 1711592081842,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "8drjlv",
  "indicator" : "Skipped"
},{
  "history_id" : "ldorrtensxz",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1711512016344,
  "history_end_time" : 1711512016344,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "d60zhwum9jr",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1711425614176,
  "history_end_time" : 1714282483105,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Stopped"
},{
  "history_id" : "yyzu28nyap2",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1711339212718,
  "history_end_time" : 1714282483764,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Stopped"
},{
  "history_id" : "frjjz8nfkke",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1711252813504,
  "history_end_time" : 1711252813504,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "hg11thu0cis",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1711166414045,
  "history_end_time" : 1711166414045,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "d1b7b5cy9hp",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1711080009087,
  "history_end_time" : 1711080009087,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "q1657xe4jav",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1710993609720,
  "history_end_time" : 1714282484625,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Stopped"
},{
  "history_id" : "1sxef8vcqw8",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1710907209183,
  "history_end_time" : 1714282485250,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Stopped"
},{
  "history_id" : "y7ajg8gljy0",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1710820808846,
  "history_end_time" : 1714282486277,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Stopped"
},{
  "history_id" : "wiag75sf22z",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1710734409568,
  "history_end_time" : 1714282486948,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Stopped"
},{
  "history_id" : "luxhtyq572k",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1710690214161,
  "history_end_time" : 1710690214161,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "8drjlv",
  "indicator" : "Skipped"
},{
  "history_id" : "u0znb7bqmfi",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1710648009242,
  "history_end_time" : 1714282488915,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Stopped"
},{
  "history_id" : "agmi6phpxrp",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1710561608723,
  "history_end_time" : 1714282489527,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Stopped"
},{
  "history_id" : "ho8i2gm1c2s",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1710475209315,
  "history_end_time" : 1714282490288,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Stopped"
},{
  "history_id" : "342kw92gdly",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1710388809281,
  "history_end_time" : 1714282490840,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Stopped"
},{
  "history_id" : "o8r5609fb0p",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1710302409436,
  "history_end_time" : 1714282491502,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Stopped"
},{
  "history_id" : "c3vg2ka4c04",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1710216009490,
  "history_end_time" : 1714282492101,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Stopped"
},{
  "history_id" : "eepzdduzxc8",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1710172046523,
  "history_end_time" : 1710172046523,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "8drjlv",
  "indicator" : "Skipped"
},{
  "history_id" : "qu4phxayczm",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1710129609160,
  "history_end_time" : 1714282493726,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Stopped"
},{
  "history_id" : "2b6zuxx1r8b",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1710080234056,
  "history_end_time" : 1710080234056,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "8drjlv",
  "indicator" : "Skipped"
},{
  "history_id" : "70lb8rkoi8o",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1710043208833,
  "history_end_time" : 1714282495063,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Stopped"
},{
  "history_id" : "af50r9n90pk",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1709998716258,
  "history_end_time" : 1709998716258,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "z60oqcpl6wz",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1709956809041,
  "history_end_time" : 1714282495728,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Stopped"
},{
  "history_id" : "wsdxmdkrzn1",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1709924987561,
  "history_end_time" : 1709924987561,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "aoxj19468rz",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1709870410027,
  "history_end_time" : 1714282496796,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Stopped"
},{
  "history_id" : "zplzacild62",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1709845595309,
  "history_end_time" : 1709845595309,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "hfack26sq4g",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1709844621942,
  "history_end_time" : 1709844621942,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "fdluyki8zz1",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1709842923361,
  "history_end_time" : 1709842923361,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "5bxtsnq3264",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1709827652602,
  "history_end_time" : 1709844621147,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Stopped"
},{
  "history_id" : "f35skihzp5b",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1709826138677,
  "history_end_time" : 1709826138677,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "xw1ivntasya",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1709797240812,
  "history_end_time" : 1709797240812,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "myfwksiaucn",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1709791537993,
  "history_end_time" : 1709791537993,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "ib1ikvtd53g",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1709784009530,
  "history_end_time" : 1714282504664,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Stopped"
},{
  "history_id" : "cvdk6g20sau",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1709778056653,
  "history_end_time" : 1709778056653,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "do5uoqykkqd",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1709774843586,
  "history_end_time" : 1709774843586,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "de0dpczd05a",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1709765244650,
  "history_end_time" : 1709774842938,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Stopped"
},{
  "history_id" : "raes01fnrpl",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1709763117615,
  "history_end_time" : 1709765243440,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Stopped"
},{
  "history_id" : "mj4uf1myxlk",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1709751527364,
  "history_end_time" : 1709751527364,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "7wcaj6fo5oz",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1709751443156,
  "history_end_time" : 1709751495325,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Stopped"
},{
  "history_id" : "glqeedn9hik",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1709697609363,
  "history_end_time" : 1714282506649,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Stopped"
},{
  "history_id" : "1udoec27hj8",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1709611208827,
  "history_end_time" : 1714282507158,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Stopped"
},{
  "history_id" : "m8lvp7neop3",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1709524808953,
  "history_end_time" : 1714282507688,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Stopped"
},{
  "history_id" : "93lc61g3cgm",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1709438408720,
  "history_end_time" : 1709438408720,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "018t6k5l4rf",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1709352009129,
  "history_end_time" : 1709352009129,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "5dlad4wyj1z",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1709265609544,
  "history_end_time" : 1709265609544,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "fq6eyrep3gc",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1709179209471,
  "history_end_time" : 1709179209471,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "z4x59mup9kv",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1709137312919,
  "history_end_time" : 1709137312919,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "8drjlv",
  "indicator" : "Skipped"
},{
  "history_id" : "swovvofqgnz",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1709092809064,
  "history_end_time" : 1709092809064,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "jebble14uz3",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1709085684183,
  "history_end_time" : 1709085684183,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "8drjlv",
  "indicator" : "Skipped"
},{
  "history_id" : "zhsc3um7adk",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1709078942138,
  "history_end_time" : 1709085672805,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "8drjlv",
  "indicator" : "Stopped"
},{
  "history_id" : "a4dc6dyrplz",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1709038894853,
  "history_end_time" : 1709038894853,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "8drjlv",
  "indicator" : "Skipped"
},{
  "history_id" : "ic0ehakfoi1",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1709038872975,
  "history_end_time" : 1709038879063,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "8drjlv",
  "indicator" : "Stopped"
},{
  "history_id" : "i6jl55ksecr",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1709006408563,
  "history_end_time" : 1709006408563,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "utrgxwi7wi8",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1708971826179,
  "history_end_time" : 1708971826179,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "8drjlv",
  "indicator" : "Skipped"
},{
  "history_id" : "it744cdvxnw",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1708958410876,
  "history_end_time" : 1708958410876,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "8drjlv",
  "indicator" : "Skipped"
},{
  "history_id" : "z2vdc8b8v77",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1708954624208,
  "history_end_time" : 1708954624208,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "8drjlv",
  "indicator" : "Skipped"
},{
  "history_id" : "5d7zsn5b7q0",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1708920009511,
  "history_end_time" : 1708920009511,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "lx0bh3t4vos",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1708833609187,
  "history_end_time" : 1708833609187,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "vv7b7mwb5pf",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1708747208917,
  "history_end_time" : 1708747208917,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "qt66453bqxx",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1708660809091,
  "history_end_time" : 1708660809091,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "sajbh7hr2yv",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1708574409755,
  "history_end_time" : 1708574409755,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "jwlkal83kjh",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1708488010159,
  "history_end_time" : 1708488010159,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "x1f2dktd8n8",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1708401608978,
  "history_end_time" : 1708401608978,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "xoxrgd1kiok",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1708352215525,
  "history_end_time" : 1708352215525,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "8drjlv",
  "indicator" : "Skipped"
},{
  "history_id" : "ueg224a9ysh",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1708348193284,
  "history_end_time" : 1708352214869,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "8drjlv",
  "indicator" : "Stopped"
},{
  "history_id" : "qznixrv2ihm",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1708315209136,
  "history_end_time" : 1708315209136,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "i5j0qpkfbjc",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1708312689940,
  "history_end_time" : 1708312689940,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "8drjlv",
  "indicator" : "Skipped"
},{
  "history_id" : "ry93ub5jte9",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1708305309920,
  "history_end_time" : 1708312689128,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "8drjlv",
  "indicator" : "Stopped"
},{
  "history_id" : "2od439xql9j",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1708242679311,
  "history_end_time" : 1708242679311,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "8drjlv",
  "indicator" : "Skipped"
},{
  "history_id" : "6b3fdzft9ui",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1708240733523,
  "history_end_time" : 1708240733523,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "8drjlv",
  "indicator" : "Skipped"
},{
  "history_id" : "wj3kl13hlyv",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1708238769941,
  "history_end_time" : 1708238769941,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "8drjlv",
  "indicator" : "Skipped"
},{
  "history_id" : "rjqltpsqvxo",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1708237144888,
  "history_end_time" : 1708237144888,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "8drjlv",
  "indicator" : "Skipped"
},{
  "history_id" : "djy8fdx94y7",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1708235187239,
  "history_end_time" : 1708235187239,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "8drjlv",
  "indicator" : "Skipped"
},{
  "history_id" : "0730gz6xwz5",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1708233874642,
  "history_end_time" : 1708233874642,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "8drjlv",
  "indicator" : "Skipped"
},{
  "history_id" : "54uo7agptlo",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1708228809243,
  "history_end_time" : 1708228809243,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "02lamrwpw06",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1708227613812,
  "history_end_time" : 1708227613812,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "8drjlv",
  "indicator" : "Skipped"
},{
  "history_id" : "qg660w7s0sn",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1708142409454,
  "history_end_time" : 1708142409454,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "kydlpcl5a7r",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1708056009203,
  "history_end_time" : 1708056009203,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "m0ss15fpu8b",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1707969609108,
  "history_end_time" : 1707969609108,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "7uyiw0rku0k",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1707883208918,
  "history_end_time" : 1707883208918,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "yq7k64q4z89",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1707796809372,
  "history_end_time" : 1707796809372,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "rfowbduafs2",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1707750669744,
  "history_end_time" : 1707750669744,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "8drjlv",
  "indicator" : "Skipped"
},{
  "history_id" : "1h7h3aflcoz",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1707710409453,
  "history_end_time" : 1707710409453,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "ygndpcwb25v",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1707624009457,
  "history_end_time" : 1707624009457,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "gmwmizomsmu",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1707537608621,
  "history_end_time" : 1707537608621,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "jf97cln509l",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1707491746704,
  "history_end_time" : 1707491746704,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "8drjlv",
  "indicator" : "Skipped"
},{
  "history_id" : "z38mkrln4rv",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1707484657920,
  "history_end_time" : 1707484657920,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "8drjlv",
  "indicator" : "Skipped"
},{
  "history_id" : "o5fntkuuts4",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1707451209706,
  "history_end_time" : 1707451209706,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "ypu7vz4v9cx",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1707434644185,
  "history_end_time" : 1707434644185,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "8drjlv",
  "indicator" : "Skipped"
},{
  "history_id" : "dglq3npefrq",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1707432571806,
  "history_end_time" : 1707432571806,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "8drjlv",
  "indicator" : "Skipped"
},{
  "history_id" : "j84t1ynfyz9",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1707431129244,
  "history_end_time" : 1707432053951,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "8drjlv",
  "indicator" : "Stopped"
},{
  "history_id" : "l9fi1wxwhj2",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1707418188641,
  "history_end_time" : 1707418188641,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "mahjd7",
  "indicator" : "Skipped"
},{
  "history_id" : "fv3ylgwd42r",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1707413610297,
  "history_end_time" : 1707413610297,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "mahjd7",
  "indicator" : "Skipped"
},{
  "history_id" : "njcn2r81ln8",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1707364808720,
  "history_end_time" : 1707364808720,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "lpufiltdapm",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1707278408962,
  "history_end_time" : 1707278408962,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "7y1jjmfiqjs",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1707192718869,
  "history_end_time" : 1707192718869,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "2g5a973rxvj",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1707192009086,
  "history_end_time" : 1707448888644,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Stopped"
},{
  "history_id" : "feyfhtj4k86",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1707189399054,
  "history_end_time" : 1707189399054,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "5es44jv08p4",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1707105609188,
  "history_end_time" : 1707750639185,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Stopped"
},{
  "history_id" : "qo553hcz629",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1707019209219,
  "history_end_time" : 1707750639656,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Stopped"
},{
  "history_id" : "lmbdtinc0vu",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1706932809072,
  "history_end_time" : 1707750640201,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Stopped"
},{
  "history_id" : "zmebotp0sul",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1706846409557,
  "history_end_time" : 1707750640634,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Stopped"
},{
  "history_id" : "snd4nbyrras",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1706760009836,
  "history_end_time" : 1707750643272,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Stopped"
},{
  "history_id" : "cz0twdowb5o",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1706673609348,
  "history_end_time" : 1707750643794,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Stopped"
},{
  "history_id" : "z8cxp455pc6",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1706587209273,
  "history_end_time" : 1707750644976,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Stopped"
},{
  "history_id" : "1vcxkcl7in6",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1706500808885,
  "history_end_time" : 1707750645655,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Stopped"
},{
  "history_id" : "uo6fuogkka4",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1706414409212,
  "history_end_time" : 1707750646099,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Stopped"
},{
  "history_id" : "9sl04ol725j",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1706366105894,
  "history_end_time" : 1706366105894,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "9tki9tpo94u",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1706364888446,
  "history_end_time" : 1706364888446,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "ko9mk25q8oy",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1706328009379,
  "history_end_time" : 1707750646898,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Stopped"
},{
  "history_id" : "s241l89s8pw",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1706280497938,
  "history_end_time" : 1706280497938,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "f3l4e8hne4n",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1706244881225,
  "history_end_time" : 1706244881225,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "s2d6tsbnars",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1706241609594,
  "history_end_time" : 1706244810647,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Stopped"
},{
  "history_id" : "06tvqy3t902",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1706155209468,
  "history_end_time" : 1706244801311,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Stopped"
},{
  "history_id" : "t9rao1c032q",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1706068808975,
  "history_end_time" : 1706244800334,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Stopped"
},{
  "history_id" : "22wgpmjcurd",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1705982408885,
  "history_end_time" : 1706244799967,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Stopped"
},{
  "history_id" : "w7bnk3mm0lm",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1705896759064,
  "history_end_time" : 1706244799004,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Stopped"
},{
  "history_id" : "0xyhnpvtz8s",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1705896009660,
  "history_end_time" : 1706244798522,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Stopped"
},{
  "history_id" : "36bs5mfysus",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1705849063909,
  "history_end_time" : 1706244798011,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Stopped"
},{
  "history_id" : "lab5ttpwvdb",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1705809608825,
  "history_end_time" : 1705849649594,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Stopped"
},{
  "history_id" : "tfamraju3lt",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1705793526957,
  "history_end_time" : 1705849647054,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Stopped"
},{
  "history_id" : "az971wz8ynf",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1705790835071,
  "history_end_time" : 1705790835071,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "uvwv2jjqvwo",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1705770627933,
  "history_end_time" : 1705849642241,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Stopped"
},{
  "history_id" : "euz9rmgl4e6",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1705762760722,
  "history_end_time" : 1705849640885,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Stopped"
},{
  "history_id" : "m0yodp9d7mm",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1705723209348,
  "history_end_time" : 1705789738440,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Stopped"
},{
  "history_id" : "65hef0cvyrk",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1705636808712,
  "history_end_time" : 1705770636211,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Stopped"
},{
  "history_id" : "a0ojr9ikrr7",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1705550409149,
  "history_end_time" : 1705770635535,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Stopped"
},{
  "history_id" : "iikl2mgk7u9",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1705464008700,
  "history_end_time" : 1705770635041,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Stopped"
},{
  "history_id" : "jsq67htgy4h",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1705422422488,
  "history_end_time" : 1705422422488,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "crzb61dfc2s",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1705377609266,
  "history_end_time" : 1705770633035,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Stopped"
},{
  "history_id" : "jwg8fcir11p",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1705291208884,
  "history_end_time" : 1705770632152,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Stopped"
},{
  "history_id" : "rum8liakg6x",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1705278850574,
  "history_end_time" : 1705278850574,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "q0qs0wc9ky2",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1705270952762,
  "history_end_time" : 1705270952762,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "dgz5yvbsn6k",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1705204809386,
  "history_end_time" : 1705789661998,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Stopped"
},{
  "history_id" : "jnxdrk04hl5",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1705169057207,
  "history_end_time" : 1705169057207,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "yytt1mhidte",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1705118409489,
  "history_end_time" : 1705789660764,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Stopped"
},{
  "history_id" : "v3j33j70hih",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1705072448099,
  "history_end_time" : 1705072448099,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "wlh4r738dxp",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1705032009293,
  "history_end_time" : 1705789659536,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Stopped"
},{
  "history_id" : "rs6grtximvr",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1704979918328,
  "history_end_time" : 1704979918328,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "21mpwk58sv0",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1704945609526,
  "history_end_time" : 1705789658803,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Stopped"
},{
  "history_id" : "6hh7opugl7x",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1704918977665,
  "history_end_time" : 1704918977665,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "ph83r4h08p3",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1704908919684,
  "history_end_time" : 1704908919684,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "6wpc51rijot",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1704859207519,
  "history_end_time" : 1705789668251,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Stopped"
},{
  "history_id" : "dky7ne05o4q",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1704775840745,
  "history_end_time" : 1704775840745,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "smltw9tkw3g",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1704772806725,
  "history_end_time" : 1705789667280,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Stopped"
},{
  "history_id" : "70r03k6t6ne",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1704726161256,
  "history_end_time" : 1704727049024,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Stopped"
},{
  "history_id" : "1ihjgygtlze",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1704686408272,
  "history_end_time" : 1705789666641,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Stopped"
},{
  "history_id" : "a1v0ahxnegz",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1704644803708,
  "history_end_time" : 1704644803708,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "5l3cnyozzxx",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1704600008101,
  "history_end_time" : 1705789665912,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Stopped"
},{
  "history_id" : "ocwaywl4mbl",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1704566156619,
  "history_end_time" : 1704566156619,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "euxnc88sk1b",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1704565587376,
  "history_end_time" : 1704565587376,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "bopmesijx8o",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1704564424155,
  "history_end_time" : 1704564424155,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "u9vedpcpzt3",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1704562992171,
  "history_end_time" : 1704562992171,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "46i410swl6h",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1704561889791,
  "history_end_time" : 1704561889791,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "ygam6styrmi",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1704561861162,
  "history_end_time" : 1704561887034,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Stopped"
},{
  "history_id" : "6twlyxiz78x",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1704555479200,
  "history_end_time" : 1704555479200,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "yfsp59dxsxr",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1704555028191,
  "history_end_time" : 1704555028191,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "qqc2qo14djb",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1704553241763,
  "history_end_time" : 1704553241763,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "facu3ugno2v",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1704552254616,
  "history_end_time" : 1704552254616,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "ijcdu11qyix",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1704513607307,
  "history_end_time" : 1705789671091,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Stopped"
},{
  "history_id" : "w8vysyywdx9",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1704427207411,
  "history_end_time" : 1705789671864,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Stopped"
},{
  "history_id" : "d44hfsoq0iw",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1704340807481,
  "history_end_time" : 1705789673107,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Stopped"
},{
  "history_id" : "p3dnkl3d7eo",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1704330109298,
  "history_end_time" : 1704330109298,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "69e3ruyknkz",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1704329364845,
  "history_end_time" : 1704329364845,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "kqdxp6m0rnz",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1704254407408,
  "history_end_time" : 1705789675638,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Stopped"
},{
  "history_id" : "wdf3saubx8s",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1704208947953,
  "history_end_time" : 1704208947953,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "ntl95u7yuby",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1704207352014,
  "history_end_time" : 1704207352014,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "j71we96c98z",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1704205859367,
  "history_end_time" : 1704205859367,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "h0bgawarzvo",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1704168007319,
  "history_end_time" : 1705789676820,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Stopped"
},{
  "history_id" : "0ew489jxs67",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1704081607383,
  "history_end_time" : 1705789677609,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Stopped"
},{
  "history_id" : "r55y7px4up8",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1703995208229,
  "history_end_time" : 1705789678803,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Stopped"
},{
  "history_id" : "hibu2kx5yw0",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1703962871399,
  "history_end_time" : 1703962871399,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "x94v35vo8xg",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1703960265439,
  "history_end_time" : 1703960265439,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "56pltkykqgn",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1703959737837,
  "history_end_time" : 1703959737837,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "3hs0bfrpdd0",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1703958611582,
  "history_end_time" : 1703958611582,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "z8uj7q6pg4y",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1703955838219,
  "history_end_time" : 1703955838219,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "uwtlh9t9y5b",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1703954150359,
  "history_end_time" : 1703954150359,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "82g285y3jbz",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1703915768066,
  "history_end_time" : 1703915768066,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "7t78xt63oy3",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1703915283481,
  "history_end_time" : 1703915283481,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "428zcwanynb",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1703914476635,
  "history_end_time" : 1703914476635,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "ilxouhl39w9",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1703912302168,
  "history_end_time" : 1703912302168,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "z0ncnh88gmv",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1703908807031,
  "history_end_time" : 1705789681226,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Stopped"
},{
  "history_id" : "v8g9g1xrt5d",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1703906215373,
  "history_end_time" : 1703906215373,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "jesd82e8ajv",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1703900919138,
  "history_end_time" : 1703900919138,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "q9zo1m4qpb3",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1703899837760,
  "history_end_time" : 1703899837760,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "z3s30nh0twa",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1703897422944,
  "history_end_time" : 1703897422944,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "hnz7e6f8ei7",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1703896125577,
  "history_end_time" : 1703896125577,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "kxouojnlm9t",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1703890275985,
  "history_end_time" : 1703890275985,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "mxpc0z4nj5j",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1703886800803,
  "history_end_time" : 1703886800803,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "mypg76o9z12",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1703885997760,
  "history_end_time" : 1703885997760,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "8wcys7wqfbt",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1703880194709,
  "history_end_time" : 1703880194709,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "vsq1oe1lr0h",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1703872753028,
  "history_end_time" : 1703872753028,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "u9ti80avrcl",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1703869828231,
  "history_end_time" : 1703869828231,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "zogecvqlra5",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1703868616924,
  "history_end_time" : 1703868616924,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "jovvbkso28f",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1703867114041,
  "history_end_time" : 1703867114041,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "ccufx4q0a5r",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1703864885439,
  "history_end_time" : 1703864885439,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "mm46xp3b2x1",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1703862637351,
  "history_end_time" : 1703862637351,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "anmyghy3mwh",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1703827227327,
  "history_end_time" : 1703827227327,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "281nx3i4cgc",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1703822411363,
  "history_end_time" : 1703822411363,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "ggej7aifwsq",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1703786924629,
  "history_end_time" : 1703789718820,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Stopped"
},{
  "history_id" : "fvsg4okyjbq",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1703786053483,
  "history_end_time" : 1703786917610,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Stopped"
},{
  "history_id" : "xx2rlkm35fo",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1703778395387,
  "history_end_time" : 1703778395387,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "q26mveb29ab",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1703739034371,
  "history_end_time" : 1703739034371,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "zmzmt8vzl2z",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1703738754438,
  "history_end_time" : 1703792459277,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Stopped"
},{
  "history_id" : "fubz5mjr13b",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1703736166902,
  "history_end_time" : 1703737316878,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Stopped"
},{
  "history_id" : "wpp1d394cuc",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1703694763560,
  "history_end_time" : 1703694763560,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "wgnuxiyzchp",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1703659541197,
  "history_end_time" : 1703659541197,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "zj1h7z0dyyu",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1703658144688,
  "history_end_time" : 1703658144688,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "zu36mi5uaqn",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1703650855768,
  "history_end_time" : 1703650855768,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "km3nic65kbq",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1703646751530,
  "history_end_time" : 1703650812436,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Stopped"
},{
  "history_id" : "hv030vrfhim",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1703642120891,
  "history_end_time" : 1703646749621,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Stopped"
},{
  "history_id" : "99angbq1fz3",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1703641988930,
  "history_end_time" : 1703642074629,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Stopped"
},{
  "history_id" : "vtw2okzxyol",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1703629665502,
  "history_end_time" : 1703629665502,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "6hfdpjb8hgp",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1703626687978,
  "history_end_time" : 1703627783051,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Stopped"
},{
  "history_id" : "bgavze3tg4a",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1703625782091,
  "history_end_time" : 1703625782091,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "36tkw2locxu",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1703624783937,
  "history_end_time" : 1703624783937,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "77bofa4jbr0",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1702875592826,
  "history_end_time" : 1702875592826,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "axw46tf142c",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1702871264372,
  "history_end_time" : 1702871264372,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "c80ixswti0u",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1702867996387,
  "history_end_time" : 1702867996387,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "fchitul4zm9",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1702866593385,
  "history_end_time" : 1702866593385,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "9w26l2v5tcy",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1702866137612,
  "history_end_time" : 1702866137612,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "l9oo9p04k2c",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1702657305615,
  "history_end_time" : 1702657305615,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "34rymwfr5zc",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1702633223041,
  "history_end_time" : 1702633223041,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "876lp1u6z3z",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1702633156914,
  "history_end_time" : 1702633163896,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Stopped"
},{
  "history_id" : "fywt5kjgvzh",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1702274520879,
  "history_end_time" : 1702274520879,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "q619r9c2ucl",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1702257109196,
  "history_end_time" : 1702257109196,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "ricnwekw8sk",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1702253506509,
  "history_end_time" : 1702253506509,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "8ihi2uquvsu",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1702047800927,
  "history_end_time" : 1702047800927,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "snkdeksygao",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1702046671850,
  "history_end_time" : 1702047789481,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Stopped"
},{
  "history_id" : "qkp1awecc0z",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1701838624026,
  "history_end_time" : 1701838624026,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "w1xnnalhgqq",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1701272631472,
  "history_end_time" : 1701272875107,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Stopped"
},{
  "history_id" : "fig77kg44j8",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1701272152698,
  "history_end_time" : 1701272363349,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Stopped"
},{
  "history_id" : "goyqyxq5hq9",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1701269761329,
  "history_end_time" : 1701269761329,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "sk31vwxdgh8",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1701245472013,
  "history_end_time" : 1701245472013,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "ei6hgiy0bg9",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1701234300614,
  "history_end_time" : 1701234300614,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "5lxkb5064yt",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1701232375272,
  "history_end_time" : 1701234158041,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Stopped"
},{
  "history_id" : "w5tell2cnjk",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1701231048664,
  "history_end_time" : 1701231048664,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "a28xpk9hoz0",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1701230933460,
  "history_end_time" : 1701230952343,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Stopped"
},{
  "history_id" : "lexz99i727m",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1701230796329,
  "history_end_time" : 1701230932250,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Stopped"
},{
  "history_id" : "ifmglbzeokj",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1701230384881,
  "history_end_time" : 1701230384881,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "r88uu646t9d",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1701229983505,
  "history_end_time" : 1701229983505,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "2x0vso2jkqh",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1701228899368,
  "history_end_time" : 1701228899368,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "oj1nyya20kh",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1701228374799,
  "history_end_time" : 1701228374799,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "22bgn5uwbbm",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1701228236338,
  "history_end_time" : 1701228236338,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "2wrgtxoo9m2",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1701228118503,
  "history_end_time" : 1701228118503,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "3g295lx3ifv",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1701228056525,
  "history_end_time" : 1701228056525,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "yrm5z79lqr1",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1701227912513,
  "history_end_time" : 1701227912513,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "n6lnbgixkhz",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1701013937404,
  "history_end_time" : 1701015920037,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Stopped"
},{
  "history_id" : "siffu327omm",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1700974688692,
  "history_end_time" : 1700974688692,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "et0jop2crl2",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1700885116818,
  "history_end_time" : 1700885116818,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "cedyvbufeg2",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1700471590186,
  "history_end_time" : 1700471590186,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "j869pyb9d1g",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1700468936416,
  "history_end_time" : 1700468936416,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "RHRkULe9mepa",
  "history_input" : "import numpy as np\nimport pandas as pd\nfrom osgeo import gdal\nimport warnings\nimport rasterio\nimport csv\nfrom rasterio.transform import Affine\nfrom scipy.ndimage import sobel, gaussian_filter\n\nmile_to_meters = 1609.34\nfeet_to_meters = 0.3048\n\n# Set the warning filter globally to ignore the FutureWarning\nwarnings.simplefilter(\"ignore\", FutureWarning)\n\ndef lat_lon_to_pixel(lat, lon, geotransform):\n    \"\"\"\n    Convert latitude and longitude to pixel coordinates using a geotransform.\n\n    Args:\n        lat (float): Latitude.\n        lon (float): Longitude.\n        geotransform (tuple): Geotransform coefficients (e.g., (origin_x, pixel_width, 0, origin_y, 0, pixel_height)).\n\n    Returns:\n        tuple: Pixel coordinates (x, y).\n    \"\"\"\n    x = int((lon - geotransform[0]) / geotransform[1])\n    y = int((lat - geotransform[3]) / geotransform[5])\n    return x, y\n\ndef calculate_slope_aspect_for_single(elevation_data, pixel_size_x, pixel_size_y):\n    \"\"\"\n    Calculate slope and aspect for a single pixel using elevation data.\n\n    Args:\n        elevation_data (array): Elevation data.\n        pixel_size_x (float): Pixel size in the x-direction.\n        pixel_size_y (float): Pixel size in the y-direction.\n\n    Returns:\n        tuple: Slope (in degrees), aspect (in degrees).\n    \"\"\"\n    # Calculate slope using the Sobel operator\n    slope_x = np.gradient(elevation_data, pixel_size_x, axis=1)\n    slope_y = np.gradient(elevation_data, pixel_size_y, axis=0)\n    slope_rad = np.arctan(np.sqrt(slope_x ** 2 + slope_y ** 2))\n    slope_deg = np.degrees(slope_rad)\n\n    # Calculate aspect (direction of the steepest descent)\n    aspect_rad = np.arctan2(slope_y, -slope_x)\n    aspect_deg = (np.degrees(aspect_rad) + 360) % 360\n\n    return slope_deg, aspect_deg\n\ndef save_as_geotiff(data, output_file, src_file):\n    \"\"\"\n    Save data as a GeoTIFF file with metadata from the source file.\n\n    Args:\n        data (array): Data to be saved.\n        output_file (str): Path to the output GeoTIFF file.\n        src_file (str): Path to the source GeoTIFF file to inherit metadata from.\n    \"\"\"\n    with rasterio.open(src_file) as src_dataset:\n        profile = src_dataset.profile\n        transform = src_dataset.transform\n\n        # Update the data type, count, and set the transform for the new dataset\n        profile.update(dtype=rasterio.float32, count=1, transform=transform)\n\n        # Create the new GeoTIFF file\n        with rasterio.open(output_file, 'w', **profile) as dst_dataset:\n            # Write the data to the new GeoTIFF\n            dst_dataset.write(data, 1)\n\ndef print_statistics(data):\n    \"\"\"\n    Print basic statistics of a data array.\n\n    Args:\n        data (array): Data array to calculate statistics for.\n    \"\"\"\n    # Calculate multiple statistics in one line\n    data = data[~np.isnan(data)]\n    mean, median, min_val, max_val, sum_val, std_dev, variance = [np.mean(data), np.median(data), np.min(data), np.max(data), np.sum(data), np.std(data), np.var(data)]\n\n    # Print the calculated statistics\n    print(\"Mean:\", mean)\n    print(\"Median:\", median)\n    print(\"Minimum:\", min_val)\n    print(\"Maximum:\", max_val)\n    print(\"Sum:\", sum_val)\n    print(\"Standard Deviation:\", std_dev)\n    print(\"Variance:\", variance)\n\ndef calculate_slope(dem_file):\n    from osgeo import gdal\n    import numpy as np\n    import rasterio\n    gdal.DEMProcessing(f'{dem_file}_slope.tif', dem_file, 'slope')\n    with rasterio.open(f'{dem_file}_slope.tif') as dataset:\n        slope=dataset.read(1)\n    return slope\n  \ndef calculate_aspect(dem_file):\n    from osgeo import gdal\n    import numpy as np\n    import rasterio\n    gdal.DEMProcessing(f'{dem_file}_aspect.tif', dem_file, 'aspect')\n    with rasterio.open(f'{dem_file}_aspect.tif') as dataset:\n        aspect=dataset.read(1)\n    return aspect\n    \n    \ndef calculate_slope_aspect(dem_file):\n    \"\"\"\n    Calculate slope and aspect from a DEM (Digital Elevation Model) file.\n\n    Args:\n        dem_file (str): Path to the DEM GeoTIFF file.\n\n    Returns:\n        tuple: Slope array (in degrees), aspect array (in degrees).\n    \"\"\"\n    with rasterio.open(dem_file) as dataset:\n        # Read the DEM data as a numpy array\n        dem_data = dataset.read(1)\n\n        # Get the geotransform to convert pixel coordinates to geographic coordinates\n        transform = dataset.transform\n        # Calculate the slope and aspect using numpy\n        dx, dy = np.gradient(dem_data)\n#         print(\"dx : \", dx)\n#         print(\"dy : \", dy)\n        slope = np.arctan(np.sqrt(dx**2 + dy**2))\n        slope = 90 - np.degrees(slope)\n        aspect = np.degrees(np.arctan2(-dy, dx))\n\n        # Adjust aspect values to range from 0 to 360 degrees\n        aspect[aspect < 0] += 360\n\n    return slope, aspect\n\ndef calculate_curvature(elevation_data, pixel_size_x, pixel_size_y):\n    \"\"\"\n    Calculate curvature from elevation data using the Laplacian operator.\n\n    Args:\n        elevation_data (array): Elevation data.\n        pixel_size_x (float): Pixel size in the x-direction.\n        pixel_size_y (float): Pixel size in the y-direction.\n\n    Returns:\n        array: Curvature data.\n    \"\"\"\n    # Calculate curvature using the Laplacian operator\n    curvature_x = np.gradient(np.gradient(elevation_data, pixel_size_x, axis=1), pixel_size_x, axis=1)\n    curvature_y = np.gradient(np.gradient(elevation_data, pixel_size_y, axis=0), pixel_size_y, axis=0)\n    curvature = curvature_x + curvature_y\n\n    return curvature\n  \ndef calculate_curvature(dem_file, sigma=1):\n    with rasterio.open(dem_file) as dataset:\n        # Read the DEM data as a numpy array\n        dem_data = dataset.read(1)\n        \n        # the dem is in meter unit\n        dem_data = dem_data\n\n        # Calculate the gradient using the Sobel filter\n        dx = sobel(dem_data, axis=1, mode='constant')\n        dy = sobel(dem_data, axis=0, mode='constant')\n\n        # Calculate the second derivatives using the Sobel filter\n        dxx = sobel(dx, axis=1, mode='constant')\n        dyy = sobel(dy, axis=0, mode='constant')\n\n        # Calculate the curvature using the second derivatives\n        curvature = dxx + dyy\n\n        # Smooth the curvature using Gaussian filtering (optional)\n        curvature = gaussian_filter(curvature, sigma)\n\n    return curvature\n\ndef calculate_gradients(dem_file):\n    \"\"\"\n    Calculate Northness and Eastness gradients from a DEM (Digital Elevation Model) file.\n\n    Args:\n        dem_file (str): Path to the DEM GeoTIFF file.\n\n    Returns:\n        tuple: Northness array, Eastness array (both in radians).\n    \"\"\"\n    with rasterio.open(dem_file) as dataset:\n        # Read the DEM data as a numpy array\n        dem_data = dataset.read(1)\n\n        # Calculate the gradients along the North and East directions\n        dy, dx = np.gradient(dem_data, dataset.res[0], dataset.res[1])\n\n        # Calculate the Northness and Eastness\n        northness = np.arctan(dy / np.sqrt(dx**2 + dy**2))\n        eastness = np.arctan(dx / np.sqrt(dx**2 + dy**2))\n\n    return northness, eastness\n\ndef geotiff_to_csv(geotiff_file, csv_file, column_name):\n    \"\"\"\n    Convert a GeoTIFF file to a CSV file containing latitude, longitude, and image values.\n\n    Args:\n        geotiff_file (str): Path to the input GeoTIFF file.\n        csv_file (str): Path to the output CSV file.\n        column_name (str): Name for the image value column.\n    \"\"\"\n    # Open the GeoTIFF file\n    with rasterio.open(geotiff_file) as dataset:\n        # Get the pixel values as a 2D array\n        data = dataset.read(1)\n\n        if column_name == \"Elevation\":\n            # default unit is meter\n            data = data\n\n        # Get the geotransform to convert pixel coordinates to geographic coordinates\n        transform = dataset.transform\n\n        # Get the width and height of the GeoTIFF\n        height, width = data.shape\n\n        # Open the CSV file for writing\n        with open(csv_file, 'w', newline='') as csvfile:\n            csvwriter = csv.writer(csvfile)\n\n            # Write the CSV header\n            csvwriter.writerow(['Latitude', 'Longitude', 'x', 'y', column_name])\n\n            # Loop through each pixel and extract latitude, longitude, and image value\n            for y in range(height):\n                for x in range(width):\n                    # Get the pixel value\n                    image_value = data[y, x]\n\n                    # Convert pixel coordinates to geographic coordinates\n                    lon, lat = transform * (x, y)\n\n                    # Write the data to the CSV file\n                    csvwriter.writerow([lat, lon, x, y, image_value])\n\ndef read_elevation_data(file_path, result_dem_csv_path, result_dem_feature_csv_path):\n    \"\"\"\n    Read and process elevation data from a CSV file and save it to another CSV file with additional features.\n\n    Args:\n        file_path (str): Path to the input CSV file containing elevation data.\n        result_dem_csv_path (str): Path to the output CSV file for elevation data.\n        result_dem_feature_csv_path (str): Path to the output CSV file for elevation data with additional features.\n\n    Returns:\n        DataFrame: Merged dataframe with elevation and additional features.\n    \"\"\"\n    neighborhood_size = 4\n    df = pd.read_csv(file_path)\n    \n    dataset = rasterio.open(geotiff_file)\n    data = dataset.read(1)\n\n    # Get the width and height of the GeoTIFF\n    height, width = data.shape\n    \n    # Create an empty DataFrame with column names\n    columns = ['lat', 'lon', 'elevation', 'slope', 'aspect', 'curvature', 'northness', 'eastness']\n    all_df = pd.DataFrame(columns=columns)\n    \n    all_df.to_csv(result_dem_feature_csv_path)\n    print(f\"DEM and other columns are saved to file {result_dem_feature_csv_path}\")\n    return all_df\n\n  \n\n# Usage example:\nresult_dem_csv_path = \"/home/chetana/gridmet_test_run/dem_template.csv\"\nresult_dem_feature_csv_path = \"/home/chetana/gridmet_test_run/dem_all.csv\"\n\ndem_file = \"/home/chetana/gridmet_test_run/dem_file.tif\"\nslope_file = '/home/chetana/gridmet_test_run/dem_file.tif_slope.tif'\naspect_file = '/home/chetana/gridmet_test_run/dem_file.tif_aspect.tif'\ncurvature_file = '/home/chetana/gridmet_test_run/curvature_file.tif'\nnorthness_file = '/home/chetana/gridmet_test_run/northness_file.tif'\neastness_file = '/home/chetana/gridmet_test_run/eastness_file.tif'\n\nslope, aspect = calculate_slope_aspect(dem_file)\n# slope = calculate_slope(dem_file)\n# aspect = calculate_aspect(dem_file)\ncurvature = calculate_curvature(dem_file)\nnorthness, eastness = calculate_gradients(dem_file)\n\n# Save the slope and aspect as new GeoTIFF files\nsave_as_geotiff(slope, slope_file, dem_file)\nsave_as_geotiff(aspect, aspect_file, dem_file)\nsave_as_geotiff(curvature, curvature_file, dem_file)\nsave_as_geotiff(northness, northness_file, dem_file)\nsave_as_geotiff(eastness, eastness_file, dem_file)\n\ngeotiff_to_csv(dem_file, dem_file+\".csv\", \"Elevation\")\ngeotiff_to_csv(slope_file, slope_file+\".csv\", \"Slope\")\ngeotiff_to_csv(aspect_file, aspect_file+\".csv\", \"Aspect\")\ngeotiff_to_csv(curvature_file, curvature_file+\".csv\", \"Curvature\")\ngeotiff_to_csv(northness_file, northness_file+\".csv\", \"Northness\")\ngeotiff_to_csv(eastness_file, eastness_file+\".csv\", \"Eastness\")\n\n# List of file paths for the CSV files\ncsv_files = [dem_file+\".csv\", slope_file+\".csv\", aspect_file+\".csv\", \n             curvature_file+\".csv\", northness_file+\".csv\", eastness_file+\".csv\"]\n\n# Initialize an empty list to store all dataframes\ndfs = []\n\n# Read each CSV file into separate dataframes\nfor file in csv_files:\n    df = pd.read_csv(file, encoding='utf-8')\n    dfs.append(df)\n\n# Merge the dataframes based on the latitude and longitude columns\nmerged_df = dfs[0]  # Start with the first dataframe\nfor i in range(1, len(dfs)):\n    merged_df = pd.merge(merged_df, dfs[i], on=['Latitude', 'Longitude', 'x', 'y'])\n\n# check the statistics of the columns\nfor column in merged_df.columns:\n    merged_df[column] = pd.to_numeric(merged_df[column], errors='coerce')\n    print(merged_df[column].describe())\n    \n# Save the merged dataframe to a new CSV file\nmerged_df.to_csv(result_dem_feature_csv_path, index=False)\nprint(f\"New dem features are updated in {result_dem_feature_csv_path}\")\n",
  "history_output" : "/home/chetana/gw-workspace/RHRkULe9mepa/western_us_dem.py:206: RuntimeWarning: invalid value encountered in divide\n  northness = np.arctan(dy / np.sqrt(dx**2 + dy**2))\n/home/chetana/gw-workspace/RHRkULe9mepa/western_us_dem.py:207: RuntimeWarning: invalid value encountered in divide\n  eastness = np.arctan(dx / np.sqrt(dx**2 + dy**2))\ncount    462204.000000\nmean         37.030000\nstd           6.921275\nmin          25.060000\n25%          31.036000\n50%          37.030000\n75%          43.024000\nmax          49.000000\nName: Latitude, dtype: float64\ncount    462204.00000\nmean       -112.52600\nstd           7.21226\nmin        -125.00000\n25%        -118.77200\n50%        -112.52600\n75%        -106.28000\nmax        -100.05200\nName: Longitude, dtype: float64\ncount    462204.000000\nmean        346.500000\nstd         200.340552\nmin           0.000000\n25%         173.000000\n50%         346.500000\n75%         520.000000\nmax         693.000000\nName: x, dtype: float64\ncount    462204.000000\nmean        332.500000\nstd         192.257631\nmin           0.000000\n25%         166.000000\n50%         332.500000\n75%         499.000000\nmax         665.000000\nName: y, dtype: float64\ncount    462204.000000\nmean       1025.629083\nstd         808.945819\nmin         -82.938410\n25%         180.727250\n50%        1018.458080\n75%        1604.870600\nmax        4177.173000\nName: Elevation, dtype: float64\ncount    462204.000000\nmean         20.325396\nstd          35.542849\nmin           0.044037\n25%           0.521086\n50%           1.558445\n75%           7.970741\nmax          90.000000\nName: Slope, dtype: float64\ncount    462204.000000\nmean        136.166265\nstd         114.602953\nmin          -0.000000\n25%          19.602830\n50%         121.656295\n75%         232.066403\nmax         359.999360\nName: Aspect, dtype: float64\ncount    462204.000000\nmean        -49.124993\nstd        2819.341836\nmin      -41085.560000\n25%        -482.398620\n50%           0.000000\n75%         840.230590\nmax       21411.324000\nName: Curvature, dtype: float64\ncount    368579.000000\nmean         -0.012698\nstd           0.587101\nmin          -0.785398\n25%          -0.626382\n50%          -0.027939\n75%           0.608819\nmax           0.785398\nName: Northness, dtype: float64\ncount    368579.000000\nmean         -0.040279\nstd           0.583256\nmin          -0.785398\n25%          -0.643895\n50%          -0.087261\n75%           0.573790\nmax           0.785398\nName: Eastness, dtype: float64\nNew dem features are updated in /home/chetana/gridmet_test_run/dem_all.csv\n",
  "history_begin_time" : 1700467361273,
  "history_end_time" : 1700467381542,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "EEooEXX17GiT",
  "history_input" : "import numpy as np\nimport pandas as pd\nfrom osgeo import gdal\nimport warnings\nimport rasterio\nimport csv\nfrom rasterio.transform import Affine\nfrom scipy.ndimage import sobel, gaussian_filter\n\nmile_to_meters = 1609.34\nfeet_to_meters = 0.3048\n\n# Set the warning filter globally to ignore the FutureWarning\nwarnings.simplefilter(\"ignore\", FutureWarning)\n\ndef lat_lon_to_pixel(lat, lon, geotransform):\n    \"\"\"\n    Convert latitude and longitude to pixel coordinates using a geotransform.\n\n    Args:\n        lat (float): Latitude.\n        lon (float): Longitude.\n        geotransform (tuple): Geotransform coefficients (e.g., (origin_x, pixel_width, 0, origin_y, 0, pixel_height)).\n\n    Returns:\n        tuple: Pixel coordinates (x, y).\n    \"\"\"\n    x = int((lon - geotransform[0]) / geotransform[1])\n    y = int((lat - geotransform[3]) / geotransform[5])\n    return x, y\n\ndef calculate_slope_aspect_for_single(elevation_data, pixel_size_x, pixel_size_y):\n    \"\"\"\n    Calculate slope and aspect for a single pixel using elevation data.\n\n    Args:\n        elevation_data (array): Elevation data.\n        pixel_size_x (float): Pixel size in the x-direction.\n        pixel_size_y (float): Pixel size in the y-direction.\n\n    Returns:\n        tuple: Slope (in degrees), aspect (in degrees).\n    \"\"\"\n    # Calculate slope using the Sobel operator\n    slope_x = np.gradient(elevation_data, pixel_size_x, axis=1)\n    slope_y = np.gradient(elevation_data, pixel_size_y, axis=0)\n    slope_rad = np.arctan(np.sqrt(slope_x ** 2 + slope_y ** 2))\n    slope_deg = np.degrees(slope_rad)\n\n    # Calculate aspect (direction of the steepest descent)\n    aspect_rad = np.arctan2(slope_y, -slope_x)\n    aspect_deg = (np.degrees(aspect_rad) + 360) % 360\n\n    return slope_deg, aspect_deg\n\ndef save_as_geotiff(data, output_file, src_file):\n    \"\"\"\n    Save data as a GeoTIFF file with metadata from the source file.\n\n    Args:\n        data (array): Data to be saved.\n        output_file (str): Path to the output GeoTIFF file.\n        src_file (str): Path to the source GeoTIFF file to inherit metadata from.\n    \"\"\"\n    with rasterio.open(src_file) as src_dataset:\n        profile = src_dataset.profile\n        transform = src_dataset.transform\n\n        # Update the data type, count, and set the transform for the new dataset\n        profile.update(dtype=rasterio.float32, count=1, transform=transform)\n\n        # Create the new GeoTIFF file\n        with rasterio.open(output_file, 'w', **profile) as dst_dataset:\n            # Write the data to the new GeoTIFF\n            dst_dataset.write(data, 1)\n\ndef print_statistics(data):\n    \"\"\"\n    Print basic statistics of a data array.\n\n    Args:\n        data (array): Data array to calculate statistics for.\n    \"\"\"\n    # Calculate multiple statistics in one line\n    data = data[~np.isnan(data)]\n    mean, median, min_val, max_val, sum_val, std_dev, variance = [np.mean(data), np.median(data), np.min(data), np.max(data), np.sum(data), np.std(data), np.var(data)]\n\n    # Print the calculated statistics\n    print(\"Mean:\", mean)\n    print(\"Median:\", median)\n    print(\"Minimum:\", min_val)\n    print(\"Maximum:\", max_val)\n    print(\"Sum:\", sum_val)\n    print(\"Standard Deviation:\", std_dev)\n    print(\"Variance:\", variance)\n\ndef calculate_slope(dem_file):\n    from osgeo import gdal\n    import numpy as np\n    import rasterio\n    gdal.DEMProcessing(f'{dem_file}_slope.tif', dem_file, 'slope')\n    with rasterio.open(f'{dem_file}_slope.tif') as dataset:\n        slope=dataset.read(1)\n    return slope\n  \ndef calculate_aspect(dem_file):\n    from osgeo import gdal\n    import numpy as np\n    import rasterio\n    gdal.DEMProcessing(f'{dem_file}_aspect.tif', dem_file, 'aspect')\n    with rasterio.open(f'{dem_file}_aspect.tif') as dataset:\n        aspect=dataset.read(1)\n    return aspect\n    \n    \ndef calculate_slope_aspect(dem_file):\n    \"\"\"\n    Calculate slope and aspect from a DEM (Digital Elevation Model) file.\n\n    Args:\n        dem_file (str): Path to the DEM GeoTIFF file.\n\n    Returns:\n        tuple: Slope array (in degrees), aspect array (in degrees).\n    \"\"\"\n    with rasterio.open(dem_file) as dataset:\n        # Read the DEM data as a numpy array\n        dem_data = dataset.read(1)\n\n        # Get the geotransform to convert pixel coordinates to geographic coordinates\n        transform = dataset.transform\n        # Calculate the slope and aspect using numpy\n        dx, dy = np.gradient(dem_data)\n        print(\"dx : \", dx)\n        print(\"dy : \", dy)\n        slope = np.arctan(np.sqrt(dx**2 + dy**2))\n        slope = np.degrees(slope)\n        aspect = np.degrees(np.arctan2(-dy, dx))\n\n        # Adjust aspect values to range from 0 to 360 degrees\n        aspect[aspect < 0] += 360\n\n    return slope, aspect\n\ndef calculate_curvature(elevation_data, pixel_size_x, pixel_size_y):\n    \"\"\"\n    Calculate curvature from elevation data using the Laplacian operator.\n\n    Args:\n        elevation_data (array): Elevation data.\n        pixel_size_x (float): Pixel size in the x-direction.\n        pixel_size_y (float): Pixel size in the y-direction.\n\n    Returns:\n        array: Curvature data.\n    \"\"\"\n    # Calculate curvature using the Laplacian operator\n    curvature_x = np.gradient(np.gradient(elevation_data, pixel_size_x, axis=1), pixel_size_x, axis=1)\n    curvature_y = np.gradient(np.gradient(elevation_data, pixel_size_y, axis=0), pixel_size_y, axis=0)\n    curvature = curvature_x + curvature_y\n\n    return curvature\n  \ndef calculate_curvature(dem_file, sigma=1):\n    with rasterio.open(dem_file) as dataset:\n        # Read the DEM data as a numpy array\n        dem_data = dataset.read(1)\n        \n        # the dem is in meter unit\n        dem_data = dem_data\n\n        # Calculate the gradient using the Sobel filter\n        dx = sobel(dem_data, axis=1, mode='constant')\n        dy = sobel(dem_data, axis=0, mode='constant')\n\n        # Calculate the second derivatives using the Sobel filter\n        dxx = sobel(dx, axis=1, mode='constant')\n        dyy = sobel(dy, axis=0, mode='constant')\n\n        # Calculate the curvature using the second derivatives\n        curvature = dxx + dyy\n\n        # Smooth the curvature using Gaussian filtering (optional)\n        curvature = gaussian_filter(curvature, sigma)\n\n    return curvature\n\ndef calculate_gradients(dem_file):\n    \"\"\"\n    Calculate Northness and Eastness gradients from a DEM (Digital Elevation Model) file.\n\n    Args:\n        dem_file (str): Path to the DEM GeoTIFF file.\n\n    Returns:\n        tuple: Northness array, Eastness array (both in radians).\n    \"\"\"\n    with rasterio.open(dem_file) as dataset:\n        # Read the DEM data as a numpy array\n        dem_data = dataset.read(1)\n\n        # Calculate the gradients along the North and East directions\n        dy, dx = np.gradient(dem_data, dataset.res[0], dataset.res[1])\n\n        # Calculate the Northness and Eastness\n        northness = np.arctan(dy / np.sqrt(dx**2 + dy**2))\n        eastness = np.arctan(dx / np.sqrt(dx**2 + dy**2))\n\n    return northness, eastness\n\ndef geotiff_to_csv(geotiff_file, csv_file, column_name):\n    \"\"\"\n    Convert a GeoTIFF file to a CSV file containing latitude, longitude, and image values.\n\n    Args:\n        geotiff_file (str): Path to the input GeoTIFF file.\n        csv_file (str): Path to the output CSV file.\n        column_name (str): Name for the image value column.\n    \"\"\"\n    # Open the GeoTIFF file\n    with rasterio.open(geotiff_file) as dataset:\n        # Get the pixel values as a 2D array\n        data = dataset.read(1)\n\n        if column_name == \"Elevation\":\n            # default unit is meter\n            data = data\n\n        # Get the geotransform to convert pixel coordinates to geographic coordinates\n        transform = dataset.transform\n\n        # Get the width and height of the GeoTIFF\n        height, width = data.shape\n\n        # Open the CSV file for writing\n        with open(csv_file, 'w', newline='') as csvfile:\n            csvwriter = csv.writer(csvfile)\n\n            # Write the CSV header\n            csvwriter.writerow(['Latitude', 'Longitude', 'x', 'y', column_name])\n\n            # Loop through each pixel and extract latitude, longitude, and image value\n            for y in range(height):\n                for x in range(width):\n                    # Get the pixel value\n                    image_value = data[y, x]\n\n                    # Convert pixel coordinates to geographic coordinates\n                    lon, lat = transform * (x, y)\n\n                    # Write the data to the CSV file\n                    csvwriter.writerow([lat, lon, x, y, image_value])\n\ndef read_elevation_data(file_path, result_dem_csv_path, result_dem_feature_csv_path):\n    \"\"\"\n    Read and process elevation data from a CSV file and save it to another CSV file with additional features.\n\n    Args:\n        file_path (str): Path to the input CSV file containing elevation data.\n        result_dem_csv_path (str): Path to the output CSV file for elevation data.\n        result_dem_feature_csv_path (str): Path to the output CSV file for elevation data with additional features.\n\n    Returns:\n        DataFrame: Merged dataframe with elevation and additional features.\n    \"\"\"\n    neighborhood_size = 4\n    df = pd.read_csv(file_path)\n    \n    dataset = rasterio.open(geotiff_file)\n    data = dataset.read(1)\n\n    # Get the width and height of the GeoTIFF\n    height, width = data.shape\n    \n    # Create an empty DataFrame with column names\n    columns = ['lat', 'lon', 'elevation', 'slope', 'aspect', 'curvature', 'northness', 'eastness']\n    all_df = pd.DataFrame(columns=columns)\n    \n    all_df.to_csv(result_dem_feature_csv_path)\n    print(f\"DEM and other columns are saved to file {result_dem_feature_csv_path}\")\n    return all_df\n\n  \n\n# Usage example:\nresult_dem_csv_path = \"/home/chetana/gridmet_test_run/dem_template.csv\"\nresult_dem_feature_csv_path = \"/home/chetana/gridmet_test_run/dem_all.csv\"\n\ndem_file = \"/home/chetana/gridmet_test_run/dem_file.tif\"\nslope_file = '/home/chetana/gridmet_test_run/dem_file.tif_slope.tif'\naspect_file = '/home/chetana/gridmet_test_run/dem_file.tif_aspect.tif'\ncurvature_file = '/home/chetana/gridmet_test_run/curvature_file.tif'\nnorthness_file = '/home/chetana/gridmet_test_run/northness_file.tif'\neastness_file = '/home/chetana/gridmet_test_run/eastness_file.tif'\n\nslope, aspect = calculate_slope_aspect(dem_file)\n# slope = calculate_slope(dem_file)\n# aspect = calculate_aspect(dem_file)\ncurvature = calculate_curvature(dem_file)\nnorthness, eastness = calculate_gradients(dem_file)\n\n# Save the slope and aspect as new GeoTIFF files\nsave_as_geotiff(slope, slope_file, dem_file)\nsave_as_geotiff(aspect, aspect_file, dem_file)\nsave_as_geotiff(curvature, curvature_file, dem_file)\nsave_as_geotiff(northness, northness_file, dem_file)\nsave_as_geotiff(eastness, eastness_file, dem_file)\n\ngeotiff_to_csv(dem_file, dem_file+\".csv\", \"Elevation\")\ngeotiff_to_csv(slope_file, slope_file+\".csv\", \"Slope\")\ngeotiff_to_csv(aspect_file, aspect_file+\".csv\", \"Aspect\")\ngeotiff_to_csv(curvature_file, curvature_file+\".csv\", \"Curvature\")\ngeotiff_to_csv(northness_file, northness_file+\".csv\", \"Northness\")\ngeotiff_to_csv(eastness_file, eastness_file+\".csv\", \"Eastness\")\n\n# List of file paths for the CSV files\ncsv_files = [dem_file+\".csv\", slope_file+\".csv\", aspect_file+\".csv\", \n             curvature_file+\".csv\", northness_file+\".csv\", eastness_file+\".csv\"]\n\n# Initialize an empty list to store all dataframes\ndfs = []\n\n# Read each CSV file into separate dataframes\nfor file in csv_files:\n    df = pd.read_csv(file, encoding='utf-8')\n    dfs.append(df)\n\n# Merge the dataframes based on the latitude and longitude columns\nmerged_df = dfs[0]  # Start with the first dataframe\nfor i in range(1, len(dfs)):\n    merged_df = pd.merge(merged_df, dfs[i], on=['Latitude', 'Longitude', 'x', 'y'])\n\n# check the statistics of the columns\nfor column in merged_df.columns:\n    merged_df[column] = pd.to_numeric(merged_df[column], errors='coerce')\n    print(merged_df[column].describe())\n    \n# Save the merged dataframe to a new CSV file\nmerged_df.to_csv(result_dem_feature_csv_path, index=False)\nprint(f\"New dem features are updated in {result_dem_feature_csv_path}\")\n",
  "history_output" : "dx :  [[   4.9972086   32.28969     28.481323  ...  -25.388062   -43.703552\n   -30.98108  ]\n [  55.512062   135.11441    129.86824   ...   -9.886078   -24.946136\n   -26.845367 ]\n [ 283.49417     -5.7190933  171.96773   ...   -7.440399   -11.036621\n   -21.926819 ]\n ...\n [   0.           0.           0.        ... -292.2683     132.9397\n   456.74747  ]\n [   0.           0.           0.        ... -518.7943    -378.2367\n    -3.1396484]\n [   0.           0.           0.        ... -616.55273   -104.20337\n  -562.2511   ]]\ndy :  [[ 121.63807    121.81044    125.1941    ...   15.566803    23.453918\n    12.085266 ]\n [ 148.93056    133.55249    210.26384   ...    6.011261    20.65741\n    24.80774  ]\n [ 280.84277    196.16661   -136.21744   ...    5.9332275    6.494629\n     8.286804 ]\n ...\n [   0.           0.           0.        ...  464.23718   -303.22382\n  -675.0486   ]\n [   0.           0.           0.        ...   68.508484   185.28003\n   533.19324  ]\n [   0.           0.           0.        ...   60.56256    212.43085\n    75.14551  ]]\n/home/chetana/gw-workspace/EEooEXX17GiT/western_us_dem.py:206: RuntimeWarning: invalid value encountered in divide\n  northness = np.arctan(dy / np.sqrt(dx**2 + dy**2))\n/home/chetana/gw-workspace/EEooEXX17GiT/western_us_dem.py:207: RuntimeWarning: invalid value encountered in divide\n  eastness = np.arctan(dx / np.sqrt(dx**2 + dy**2))\ncount    462204.000000\nmean         37.030000\nstd           6.921275\nmin          25.060000\n25%          31.036000\n50%          37.030000\n75%          43.024000\nmax          49.000000\nName: Latitude, dtype: float64\ncount    462204.00000\nmean       -112.52600\nstd           7.21226\nmin        -125.00000\n25%        -118.77200\n50%        -112.52600\n75%        -106.28000\nmax        -100.05200\nName: Longitude, dtype: float64\ncount    462204.000000\nmean        346.500000\nstd         200.340552\nmin           0.000000\n25%         173.000000\n50%         346.500000\n75%         520.000000\nmax         693.000000\nName: x, dtype: float64\ncount    462204.000000\nmean        332.500000\nstd         192.257631\nmin           0.000000\n25%         166.000000\n50%         332.500000\n75%         499.000000\nmax         665.000000\nName: y, dtype: float64\ncount    462204.000000\nmean       1025.629083\nstd         808.945819\nmin         -82.938410\n25%         180.727250\n50%        1018.458080\n75%        1604.870600\nmax        4177.173000\nName: Elevation, dtype: float64\ncount    462204.000000\nmean         69.674604\nstd          35.542849\nmin           0.000000\n25%          82.029259\n50%          88.441555\n75%          89.478913\nmax          89.955960\nName: Slope, dtype: float64\ncount    462204.000000\nmean        136.166265\nstd         114.602953\nmin          -0.000000\n25%          19.602830\n50%         121.656295\n75%         232.066403\nmax         359.999360\nName: Aspect, dtype: float64\ncount    462204.000000\nmean        -49.124993\nstd        2819.341836\nmin      -41085.560000\n25%        -482.398620\n50%           0.000000\n75%         840.230590\nmax       21411.324000\nName: Curvature, dtype: float64\ncount    368579.000000\nmean         -0.012698\nstd           0.587101\nmin          -0.785398\n25%          -0.626382\n50%          -0.027939\n75%           0.608819\nmax           0.785398\nName: Northness, dtype: float64\ncount    368579.000000\nmean         -0.040279\nstd           0.583256\nmin          -0.785398\n25%          -0.643895\n50%          -0.087261\n75%           0.573790\nmax           0.785398\nName: Eastness, dtype: float64\nNew dem features are updated in /home/chetana/gridmet_test_run/dem_all.csv\n",
  "history_begin_time" : 1700467105493,
  "history_end_time" : 1700467123605,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "TH9pQRzJ1T1g",
  "history_input" : "import numpy as np\nimport pandas as pd\nfrom osgeo import gdal\nimport warnings\nimport rasterio\nimport csv\nfrom rasterio.transform import Affine\nfrom scipy.ndimage import sobel, gaussian_filter\n\nmile_to_meters = 1609.34\nfeet_to_meters = 0.3048\n\n# Set the warning filter globally to ignore the FutureWarning\nwarnings.simplefilter(\"ignore\", FutureWarning)\n\ndef lat_lon_to_pixel(lat, lon, geotransform):\n    \"\"\"\n    Convert latitude and longitude to pixel coordinates using a geotransform.\n\n    Args:\n        lat (float): Latitude.\n        lon (float): Longitude.\n        geotransform (tuple): Geotransform coefficients (e.g., (origin_x, pixel_width, 0, origin_y, 0, pixel_height)).\n\n    Returns:\n        tuple: Pixel coordinates (x, y).\n    \"\"\"\n    x = int((lon - geotransform[0]) / geotransform[1])\n    y = int((lat - geotransform[3]) / geotransform[5])\n    return x, y\n\ndef calculate_slope_aspect_for_single(elevation_data, pixel_size_x, pixel_size_y):\n    \"\"\"\n    Calculate slope and aspect for a single pixel using elevation data.\n\n    Args:\n        elevation_data (array): Elevation data.\n        pixel_size_x (float): Pixel size in the x-direction.\n        pixel_size_y (float): Pixel size in the y-direction.\n\n    Returns:\n        tuple: Slope (in degrees), aspect (in degrees).\n    \"\"\"\n    # Calculate slope using the Sobel operator\n    slope_x = np.gradient(elevation_data, pixel_size_x, axis=1)\n    slope_y = np.gradient(elevation_data, pixel_size_y, axis=0)\n    slope_rad = np.arctan(np.sqrt(slope_x ** 2 + slope_y ** 2))\n    slope_deg = np.degrees(slope_rad)\n\n    # Calculate aspect (direction of the steepest descent)\n    aspect_rad = np.arctan2(slope_y, -slope_x)\n    aspect_deg = (np.degrees(aspect_rad) + 360) % 360\n\n    return slope_deg, aspect_deg\n\ndef save_as_geotiff(data, output_file, src_file):\n    \"\"\"\n    Save data as a GeoTIFF file with metadata from the source file.\n\n    Args:\n        data (array): Data to be saved.\n        output_file (str): Path to the output GeoTIFF file.\n        src_file (str): Path to the source GeoTIFF file to inherit metadata from.\n    \"\"\"\n    with rasterio.open(src_file) as src_dataset:\n        profile = src_dataset.profile\n        transform = src_dataset.transform\n\n        # Update the data type, count, and set the transform for the new dataset\n        profile.update(dtype=rasterio.float32, count=1, transform=transform)\n\n        # Create the new GeoTIFF file\n        with rasterio.open(output_file, 'w', **profile) as dst_dataset:\n            # Write the data to the new GeoTIFF\n            dst_dataset.write(data, 1)\n\ndef print_statistics(data):\n    \"\"\"\n    Print basic statistics of a data array.\n\n    Args:\n        data (array): Data array to calculate statistics for.\n    \"\"\"\n    # Calculate multiple statistics in one line\n    data = data[~np.isnan(data)]\n    mean, median, min_val, max_val, sum_val, std_dev, variance = [np.mean(data), np.median(data), np.min(data), np.max(data), np.sum(data), np.std(data), np.var(data)]\n\n    # Print the calculated statistics\n    print(\"Mean:\", mean)\n    print(\"Median:\", median)\n    print(\"Minimum:\", min_val)\n    print(\"Maximum:\", max_val)\n    print(\"Sum:\", sum_val)\n    print(\"Standard Deviation:\", std_dev)\n    print(\"Variance:\", variance)\n\ndef calculate_slope(dem_file):\n    from osgeo import gdal\n    import numpy as np\n    import rasterio\n    gdal.DEMProcessing(f'{dem_file}_slope.tif', dem_file, 'slope')\n    with rasterio.open(f'{dem_file}_slope.tif') as dataset:\n        slope=dataset.read(1)\n    return slope\n  \ndef calculate_aspect(dem_file):\n    from osgeo import gdal\n    import numpy as np\n    import rasterio\n    gdal.DEMProcessing(f'{dem_file}_aspect.tif', dem_file, 'aspect')\n    with rasterio.open(f'{dem_file}_aspect.tif') as dataset:\n        aspect=dataset.read(1)\n    return aspect\n    \n    \ndef calculate_slope_aspect(dem_file):\n    \"\"\"\n    Calculate slope and aspect from a DEM (Digital Elevation Model) file.\n\n    Args:\n        dem_file (str): Path to the DEM GeoTIFF file.\n\n    Returns:\n        tuple: Slope array (in degrees), aspect array (in degrees).\n    \"\"\"\n    with rasterio.open(dem_file) as dataset:\n        # Read the DEM data as a numpy array\n        dem_data = dataset.read(1)\n\n        # Get the geotransform to convert pixel coordinates to geographic coordinates\n        transform = dataset.transform\n        # Calculate the slope and aspect using numpy\n        dx, dy = np.gradient(dem_data)\n        print(\"dx : \", dx)\n        print(\"dy : \", dy)\n        slope = np.arctan(np.sqrt(dx**2 + dy**2))\n#         slope = np.degrees(slope)\n        aspect = np.degrees(np.arctan2(-dy, dx))\n\n        # Adjust aspect values to range from 0 to 360 degrees\n        aspect[aspect < 0] += 360\n\n    return slope, aspect\n\ndef calculate_curvature(elevation_data, pixel_size_x, pixel_size_y):\n    \"\"\"\n    Calculate curvature from elevation data using the Laplacian operator.\n\n    Args:\n        elevation_data (array): Elevation data.\n        pixel_size_x (float): Pixel size in the x-direction.\n        pixel_size_y (float): Pixel size in the y-direction.\n\n    Returns:\n        array: Curvature data.\n    \"\"\"\n    # Calculate curvature using the Laplacian operator\n    curvature_x = np.gradient(np.gradient(elevation_data, pixel_size_x, axis=1), pixel_size_x, axis=1)\n    curvature_y = np.gradient(np.gradient(elevation_data, pixel_size_y, axis=0), pixel_size_y, axis=0)\n    curvature = curvature_x + curvature_y\n\n    return curvature\n  \ndef calculate_curvature(dem_file, sigma=1):\n    with rasterio.open(dem_file) as dataset:\n        # Read the DEM data as a numpy array\n        dem_data = dataset.read(1)\n        \n        # the dem is in meter unit\n        dem_data = dem_data\n\n        # Calculate the gradient using the Sobel filter\n        dx = sobel(dem_data, axis=1, mode='constant')\n        dy = sobel(dem_data, axis=0, mode='constant')\n\n        # Calculate the second derivatives using the Sobel filter\n        dxx = sobel(dx, axis=1, mode='constant')\n        dyy = sobel(dy, axis=0, mode='constant')\n\n        # Calculate the curvature using the second derivatives\n        curvature = dxx + dyy\n\n        # Smooth the curvature using Gaussian filtering (optional)\n        curvature = gaussian_filter(curvature, sigma)\n\n    return curvature\n\ndef calculate_gradients(dem_file):\n    \"\"\"\n    Calculate Northness and Eastness gradients from a DEM (Digital Elevation Model) file.\n\n    Args:\n        dem_file (str): Path to the DEM GeoTIFF file.\n\n    Returns:\n        tuple: Northness array, Eastness array (both in radians).\n    \"\"\"\n    with rasterio.open(dem_file) as dataset:\n        # Read the DEM data as a numpy array\n        dem_data = dataset.read(1)\n\n        # Calculate the gradients along the North and East directions\n        dy, dx = np.gradient(dem_data, dataset.res[0], dataset.res[1])\n\n        # Calculate the Northness and Eastness\n        northness = np.arctan(dy / np.sqrt(dx**2 + dy**2))\n        eastness = np.arctan(dx / np.sqrt(dx**2 + dy**2))\n\n    return northness, eastness\n\ndef geotiff_to_csv(geotiff_file, csv_file, column_name):\n    \"\"\"\n    Convert a GeoTIFF file to a CSV file containing latitude, longitude, and image values.\n\n    Args:\n        geotiff_file (str): Path to the input GeoTIFF file.\n        csv_file (str): Path to the output CSV file.\n        column_name (str): Name for the image value column.\n    \"\"\"\n    # Open the GeoTIFF file\n    with rasterio.open(geotiff_file) as dataset:\n        # Get the pixel values as a 2D array\n        data = dataset.read(1)\n\n        if column_name == \"Elevation\":\n            # default unit is meter\n            data = data\n\n        # Get the geotransform to convert pixel coordinates to geographic coordinates\n        transform = dataset.transform\n\n        # Get the width and height of the GeoTIFF\n        height, width = data.shape\n\n        # Open the CSV file for writing\n        with open(csv_file, 'w', newline='') as csvfile:\n            csvwriter = csv.writer(csvfile)\n\n            # Write the CSV header\n            csvwriter.writerow(['Latitude', 'Longitude', 'x', 'y', column_name])\n\n            # Loop through each pixel and extract latitude, longitude, and image value\n            for y in range(height):\n                for x in range(width):\n                    # Get the pixel value\n                    image_value = data[y, x]\n\n                    # Convert pixel coordinates to geographic coordinates\n                    lon, lat = transform * (x, y)\n\n                    # Write the data to the CSV file\n                    csvwriter.writerow([lat, lon, x, y, image_value])\n\ndef read_elevation_data(file_path, result_dem_csv_path, result_dem_feature_csv_path):\n    \"\"\"\n    Read and process elevation data from a CSV file and save it to another CSV file with additional features.\n\n    Args:\n        file_path (str): Path to the input CSV file containing elevation data.\n        result_dem_csv_path (str): Path to the output CSV file for elevation data.\n        result_dem_feature_csv_path (str): Path to the output CSV file for elevation data with additional features.\n\n    Returns:\n        DataFrame: Merged dataframe with elevation and additional features.\n    \"\"\"\n    neighborhood_size = 4\n    df = pd.read_csv(file_path)\n    \n    dataset = rasterio.open(geotiff_file)\n    data = dataset.read(1)\n\n    # Get the width and height of the GeoTIFF\n    height, width = data.shape\n    \n    # Create an empty DataFrame with column names\n    columns = ['lat', 'lon', 'elevation', 'slope', 'aspect', 'curvature', 'northness', 'eastness']\n    all_df = pd.DataFrame(columns=columns)\n    \n    all_df.to_csv(result_dem_feature_csv_path)\n    print(f\"DEM and other columns are saved to file {result_dem_feature_csv_path}\")\n    return all_df\n\n  \n\n# Usage example:\nresult_dem_csv_path = \"/home/chetana/gridmet_test_run/dem_template.csv\"\nresult_dem_feature_csv_path = \"/home/chetana/gridmet_test_run/dem_all.csv\"\n\ndem_file = \"/home/chetana/gridmet_test_run/dem_file.tif\"\nslope_file = '/home/chetana/gridmet_test_run/dem_file.tif_slope.tif'\naspect_file = '/home/chetana/gridmet_test_run/dem_file.tif_aspect.tif'\ncurvature_file = '/home/chetana/gridmet_test_run/curvature_file.tif'\nnorthness_file = '/home/chetana/gridmet_test_run/northness_file.tif'\neastness_file = '/home/chetana/gridmet_test_run/eastness_file.tif'\n\nslope, aspect = calculate_slope_aspect(dem_file)\n# slope = calculate_slope(dem_file)\n# aspect = calculate_aspect(dem_file)\ncurvature = calculate_curvature(dem_file)\nnorthness, eastness = calculate_gradients(dem_file)\n\n# Save the slope and aspect as new GeoTIFF files\nsave_as_geotiff(slope, slope_file, dem_file)\nsave_as_geotiff(aspect, aspect_file, dem_file)\nsave_as_geotiff(curvature, curvature_file, dem_file)\nsave_as_geotiff(northness, northness_file, dem_file)\nsave_as_geotiff(eastness, eastness_file, dem_file)\n\ngeotiff_to_csv(dem_file, dem_file+\".csv\", \"Elevation\")\ngeotiff_to_csv(slope_file, slope_file+\".csv\", \"Slope\")\ngeotiff_to_csv(aspect_file, aspect_file+\".csv\", \"Aspect\")\ngeotiff_to_csv(curvature_file, curvature_file+\".csv\", \"Curvature\")\ngeotiff_to_csv(northness_file, northness_file+\".csv\", \"Northness\")\ngeotiff_to_csv(eastness_file, eastness_file+\".csv\", \"Eastness\")\n\n# List of file paths for the CSV files\ncsv_files = [dem_file+\".csv\", slope_file+\".csv\", aspect_file+\".csv\", \n             curvature_file+\".csv\", northness_file+\".csv\", eastness_file+\".csv\"]\n\n# Initialize an empty list to store all dataframes\ndfs = []\n\n# Read each CSV file into separate dataframes\nfor file in csv_files:\n    df = pd.read_csv(file, encoding='utf-8')\n    dfs.append(df)\n\n# Merge the dataframes based on the latitude and longitude columns\nmerged_df = dfs[0]  # Start with the first dataframe\nfor i in range(1, len(dfs)):\n    merged_df = pd.merge(merged_df, dfs[i], on=['Latitude', 'Longitude', 'x', 'y'])\n\n# check the statistics of the columns\nfor column in merged_df.columns:\n    merged_df[column] = pd.to_numeric(merged_df[column], errors='coerce')\n    print(merged_df[column].describe())\n    \n# Save the merged dataframe to a new CSV file\nmerged_df.to_csv(result_dem_feature_csv_path, index=False)\nprint(f\"New dem features are updated in {result_dem_feature_csv_path}\")\n",
  "history_output" : "dx :  [[   4.9972086   32.28969     28.481323  ...  -25.388062   -43.703552\n   -30.98108  ]\n [  55.512062   135.11441    129.86824   ...   -9.886078   -24.946136\n   -26.845367 ]\n [ 283.49417     -5.7190933  171.96773   ...   -7.440399   -11.036621\n   -21.926819 ]\n ...\n [   0.           0.           0.        ... -292.2683     132.9397\n   456.74747  ]\n [   0.           0.           0.        ... -518.7943    -378.2367\n    -3.1396484]\n [   0.           0.           0.        ... -616.55273   -104.20337\n  -562.2511   ]]\ndy :  [[ 121.63807    121.81044    125.1941    ...   15.566803    23.453918\n    12.085266 ]\n [ 148.93056    133.55249    210.26384   ...    6.011261    20.65741\n    24.80774  ]\n [ 280.84277    196.16661   -136.21744   ...    5.9332275    6.494629\n     8.286804 ]\n ...\n [   0.           0.           0.        ...  464.23718   -303.22382\n  -675.0486   ]\n [   0.           0.           0.        ...   68.508484   185.28003\n   533.19324  ]\n [   0.           0.           0.        ...   60.56256    212.43085\n    75.14551  ]]\n/home/chetana/gw-workspace/TH9pQRzJ1T1g/western_us_dem.py:206: RuntimeWarning: invalid value encountered in divide\n  northness = np.arctan(dy / np.sqrt(dx**2 + dy**2))\n/home/chetana/gw-workspace/TH9pQRzJ1T1g/western_us_dem.py:207: RuntimeWarning: invalid value encountered in divide\n  eastness = np.arctan(dx / np.sqrt(dx**2 + dy**2))\ncount    462204.000000\nmean         37.030000\nstd           6.921275\nmin          25.060000\n25%          31.036000\n50%          37.030000\n75%          43.024000\nmax          49.000000\nName: Latitude, dtype: float64\ncount    462204.00000\nmean       -112.52600\nstd           7.21226\nmin        -125.00000\n25%        -118.77200\n50%        -112.52600\n75%        -106.28000\nmax        -100.05200\nName: Longitude, dtype: float64\ncount    462204.000000\nmean        346.500000\nstd         200.340552\nmin           0.000000\n25%         173.000000\n50%         346.500000\n75%         520.000000\nmax         693.000000\nName: x, dtype: float64\ncount    462204.000000\nmean        332.500000\nstd         192.257631\nmin           0.000000\n25%         166.000000\n50%         332.500000\n75%         499.000000\nmax         665.000000\nName: y, dtype: float64\ncount    462204.000000\nmean       1025.629083\nstd         808.945819\nmin         -82.938410\n25%         180.727250\n50%        1018.458080\n75%        1604.870600\nmax        4177.173000\nName: Elevation, dtype: float64\ncount    462204.000000\nmean          1.216051\nstd           0.620340\nmin           0.000000\n25%           1.431681\n50%           1.543596\n75%           1.561702\nmax           1.570028\nName: Slope, dtype: float64\ncount    462204.000000\nmean        136.166265\nstd         114.602953\nmin          -0.000000\n25%          19.602830\n50%         121.656295\n75%         232.066403\nmax         359.999360\nName: Aspect, dtype: float64\ncount    462204.000000\nmean        -49.124993\nstd        2819.341836\nmin      -41085.560000\n25%        -482.398620\n50%           0.000000\n75%         840.230590\nmax       21411.324000\nName: Curvature, dtype: float64\ncount    368579.000000\nmean         -0.012698\nstd           0.587101\nmin          -0.785398\n25%          -0.626382\n50%          -0.027939\n75%           0.608819\nmax           0.785398\nName: Northness, dtype: float64\ncount    368579.000000\nmean         -0.040279\nstd           0.583256\nmin          -0.785398\n25%          -0.643895\n50%          -0.087261\n75%           0.573790\nmax           0.785398\nName: Eastness, dtype: float64\nNew dem features are updated in /home/chetana/gridmet_test_run/dem_all.csv\n",
  "history_begin_time" : 1700467054916,
  "history_end_time" : 1700467072536,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "rZnAqJ1Bb318",
  "history_input" : "import numpy as np\nimport pandas as pd\nfrom osgeo import gdal\nimport warnings\nimport rasterio\nimport csv\nfrom rasterio.transform import Affine\nfrom scipy.ndimage import sobel, gaussian_filter\n\nmile_to_meters = 1609.34\nfeet_to_meters = 0.3048\n\n# Set the warning filter globally to ignore the FutureWarning\nwarnings.simplefilter(\"ignore\", FutureWarning)\n\ndef lat_lon_to_pixel(lat, lon, geotransform):\n    \"\"\"\n    Convert latitude and longitude to pixel coordinates using a geotransform.\n\n    Args:\n        lat (float): Latitude.\n        lon (float): Longitude.\n        geotransform (tuple): Geotransform coefficients (e.g., (origin_x, pixel_width, 0, origin_y, 0, pixel_height)).\n\n    Returns:\n        tuple: Pixel coordinates (x, y).\n    \"\"\"\n    x = int((lon - geotransform[0]) / geotransform[1])\n    y = int((lat - geotransform[3]) / geotransform[5])\n    return x, y\n\ndef calculate_slope_aspect_for_single(elevation_data, pixel_size_x, pixel_size_y):\n    \"\"\"\n    Calculate slope and aspect for a single pixel using elevation data.\n\n    Args:\n        elevation_data (array): Elevation data.\n        pixel_size_x (float): Pixel size in the x-direction.\n        pixel_size_y (float): Pixel size in the y-direction.\n\n    Returns:\n        tuple: Slope (in degrees), aspect (in degrees).\n    \"\"\"\n    # Calculate slope using the Sobel operator\n    slope_x = np.gradient(elevation_data, pixel_size_x, axis=1)\n    slope_y = np.gradient(elevation_data, pixel_size_y, axis=0)\n    slope_rad = np.arctan(np.sqrt(slope_x ** 2 + slope_y ** 2))\n    slope_deg = np.degrees(slope_rad)\n\n    # Calculate aspect (direction of the steepest descent)\n    aspect_rad = np.arctan2(slope_y, -slope_x)\n    aspect_deg = (np.degrees(aspect_rad) + 360) % 360\n\n    return slope_deg, aspect_deg\n\ndef save_as_geotiff(data, output_file, src_file):\n    \"\"\"\n    Save data as a GeoTIFF file with metadata from the source file.\n\n    Args:\n        data (array): Data to be saved.\n        output_file (str): Path to the output GeoTIFF file.\n        src_file (str): Path to the source GeoTIFF file to inherit metadata from.\n    \"\"\"\n    with rasterio.open(src_file) as src_dataset:\n        profile = src_dataset.profile\n        transform = src_dataset.transform\n\n        # Update the data type, count, and set the transform for the new dataset\n        profile.update(dtype=rasterio.float32, count=1, transform=transform)\n\n        # Create the new GeoTIFF file\n        with rasterio.open(output_file, 'w', **profile) as dst_dataset:\n            # Write the data to the new GeoTIFF\n            dst_dataset.write(data, 1)\n\ndef print_statistics(data):\n    \"\"\"\n    Print basic statistics of a data array.\n\n    Args:\n        data (array): Data array to calculate statistics for.\n    \"\"\"\n    # Calculate multiple statistics in one line\n    data = data[~np.isnan(data)]\n    mean, median, min_val, max_val, sum_val, std_dev, variance = [np.mean(data), np.median(data), np.min(data), np.max(data), np.sum(data), np.std(data), np.var(data)]\n\n    # Print the calculated statistics\n    print(\"Mean:\", mean)\n    print(\"Median:\", median)\n    print(\"Minimum:\", min_val)\n    print(\"Maximum:\", max_val)\n    print(\"Sum:\", sum_val)\n    print(\"Standard Deviation:\", std_dev)\n    print(\"Variance:\", variance)\n\ndef calculate_slope(dem_file):\n    from osgeo import gdal\n    import numpy as np\n    import rasterio\n    gdal.DEMProcessing(f'{dem_file}_slope.tif', dem_file, 'slope')\n    with rasterio.open(f'{dem_file}_slope.tif') as dataset:\n        slope=dataset.read(1)\n    return slope\n  \ndef calculate_aspect(dem_file):\n    from osgeo import gdal\n    import numpy as np\n    import rasterio\n    gdal.DEMProcessing(f'{dem_file}_aspect.tif', dem_file, 'aspect')\n    with rasterio.open(f'{dem_file}_aspect.tif') as dataset:\n        aspect=dataset.read(1)\n    return aspect\n    \n    \ndef calculate_slope_aspect(dem_file):\n    \"\"\"\n    Calculate slope and aspect from a DEM (Digital Elevation Model) file.\n\n    Args:\n        dem_file (str): Path to the DEM GeoTIFF file.\n\n    Returns:\n        tuple: Slope array (in degrees), aspect array (in degrees).\n    \"\"\"\n    with rasterio.open(dem_file) as dataset:\n        # Read the DEM data as a numpy array\n        dem_data = dataset.read(1)\n\n        # Get the geotransform to convert pixel coordinates to geographic coordinates\n        transform = dataset.transform\n        print(\"transform = \", transform)\n\n        # Calculate the slope and aspect using numpy\n        dx, dy = np.gradient(dem_data, transform[0], transform[4])\n        print(\"dx : \", dx)\n        print(\"dy : \", dy)\n        slope = np.arctan(np.sqrt(dx**2 + dy**2))\n#         slope = np.degrees(slope)\n        aspect = np.degrees(np.arctan2(-dy, dx))\n\n        # Adjust aspect values to range from 0 to 360 degrees\n        aspect[aspect < 0] += 360\n\n    return slope, aspect\n\ndef calculate_curvature(elevation_data, pixel_size_x, pixel_size_y):\n    \"\"\"\n    Calculate curvature from elevation data using the Laplacian operator.\n\n    Args:\n        elevation_data (array): Elevation data.\n        pixel_size_x (float): Pixel size in the x-direction.\n        pixel_size_y (float): Pixel size in the y-direction.\n\n    Returns:\n        array: Curvature data.\n    \"\"\"\n    # Calculate curvature using the Laplacian operator\n    curvature_x = np.gradient(np.gradient(elevation_data, pixel_size_x, axis=1), pixel_size_x, axis=1)\n    curvature_y = np.gradient(np.gradient(elevation_data, pixel_size_y, axis=0), pixel_size_y, axis=0)\n    curvature = curvature_x + curvature_y\n\n    return curvature\n  \ndef calculate_curvature(dem_file, sigma=1):\n    with rasterio.open(dem_file) as dataset:\n        # Read the DEM data as a numpy array\n        dem_data = dataset.read(1)\n        \n        # the dem is in meter unit\n        dem_data = dem_data\n\n        # Calculate the gradient using the Sobel filter\n        dx = sobel(dem_data, axis=1, mode='constant')\n        dy = sobel(dem_data, axis=0, mode='constant')\n\n        # Calculate the second derivatives using the Sobel filter\n        dxx = sobel(dx, axis=1, mode='constant')\n        dyy = sobel(dy, axis=0, mode='constant')\n\n        # Calculate the curvature using the second derivatives\n        curvature = dxx + dyy\n\n        # Smooth the curvature using Gaussian filtering (optional)\n        curvature = gaussian_filter(curvature, sigma)\n\n    return curvature\n\ndef calculate_gradients(dem_file):\n    \"\"\"\n    Calculate Northness and Eastness gradients from a DEM (Digital Elevation Model) file.\n\n    Args:\n        dem_file (str): Path to the DEM GeoTIFF file.\n\n    Returns:\n        tuple: Northness array, Eastness array (both in radians).\n    \"\"\"\n    with rasterio.open(dem_file) as dataset:\n        # Read the DEM data as a numpy array\n        dem_data = dataset.read(1)\n\n        # Calculate the gradients along the North and East directions\n        dy, dx = np.gradient(dem_data, dataset.res[0], dataset.res[1])\n\n        # Calculate the Northness and Eastness\n        northness = np.arctan(dy / np.sqrt(dx**2 + dy**2))\n        eastness = np.arctan(dx / np.sqrt(dx**2 + dy**2))\n\n    return northness, eastness\n\ndef geotiff_to_csv(geotiff_file, csv_file, column_name):\n    \"\"\"\n    Convert a GeoTIFF file to a CSV file containing latitude, longitude, and image values.\n\n    Args:\n        geotiff_file (str): Path to the input GeoTIFF file.\n        csv_file (str): Path to the output CSV file.\n        column_name (str): Name for the image value column.\n    \"\"\"\n    # Open the GeoTIFF file\n    with rasterio.open(geotiff_file) as dataset:\n        # Get the pixel values as a 2D array\n        data = dataset.read(1)\n\n        if column_name == \"Elevation\":\n            # default unit is meter\n            data = data\n\n        # Get the geotransform to convert pixel coordinates to geographic coordinates\n        transform = dataset.transform\n\n        # Get the width and height of the GeoTIFF\n        height, width = data.shape\n\n        # Open the CSV file for writing\n        with open(csv_file, 'w', newline='') as csvfile:\n            csvwriter = csv.writer(csvfile)\n\n            # Write the CSV header\n            csvwriter.writerow(['Latitude', 'Longitude', 'x', 'y', column_name])\n\n            # Loop through each pixel and extract latitude, longitude, and image value\n            for y in range(height):\n                for x in range(width):\n                    # Get the pixel value\n                    image_value = data[y, x]\n\n                    # Convert pixel coordinates to geographic coordinates\n                    lon, lat = transform * (x, y)\n\n                    # Write the data to the CSV file\n                    csvwriter.writerow([lat, lon, x, y, image_value])\n\ndef read_elevation_data(file_path, result_dem_csv_path, result_dem_feature_csv_path):\n    \"\"\"\n    Read and process elevation data from a CSV file and save it to another CSV file with additional features.\n\n    Args:\n        file_path (str): Path to the input CSV file containing elevation data.\n        result_dem_csv_path (str): Path to the output CSV file for elevation data.\n        result_dem_feature_csv_path (str): Path to the output CSV file for elevation data with additional features.\n\n    Returns:\n        DataFrame: Merged dataframe with elevation and additional features.\n    \"\"\"\n    neighborhood_size = 4\n    df = pd.read_csv(file_path)\n    \n    dataset = rasterio.open(geotiff_file)\n    data = dataset.read(1)\n\n    # Get the width and height of the GeoTIFF\n    height, width = data.shape\n    \n    # Create an empty DataFrame with column names\n    columns = ['lat', 'lon', 'elevation', 'slope', 'aspect', 'curvature', 'northness', 'eastness']\n    all_df = pd.DataFrame(columns=columns)\n    \n    all_df.to_csv(result_dem_feature_csv_path)\n    print(f\"DEM and other columns are saved to file {result_dem_feature_csv_path}\")\n    return all_df\n\n  \n\n# Usage example:\nresult_dem_csv_path = \"/home/chetana/gridmet_test_run/dem_template.csv\"\nresult_dem_feature_csv_path = \"/home/chetana/gridmet_test_run/dem_all.csv\"\n\ndem_file = \"/home/chetana/gridmet_test_run/dem_file.tif\"\nslope_file = '/home/chetana/gridmet_test_run/dem_file.tif_slope.tif'\naspect_file = '/home/chetana/gridmet_test_run/dem_file.tif_aspect.tif'\ncurvature_file = '/home/chetana/gridmet_test_run/curvature_file.tif'\nnorthness_file = '/home/chetana/gridmet_test_run/northness_file.tif'\neastness_file = '/home/chetana/gridmet_test_run/eastness_file.tif'\n\nslope, aspect = calculate_slope_aspect(dem_file)\n# slope = calculate_slope(dem_file)\n# aspect = calculate_aspect(dem_file)\ncurvature = calculate_curvature(dem_file)\nnorthness, eastness = calculate_gradients(dem_file)\n\n# Save the slope and aspect as new GeoTIFF files\nsave_as_geotiff(slope, slope_file, dem_file)\nsave_as_geotiff(aspect, aspect_file, dem_file)\nsave_as_geotiff(curvature, curvature_file, dem_file)\nsave_as_geotiff(northness, northness_file, dem_file)\nsave_as_geotiff(eastness, eastness_file, dem_file)\n\ngeotiff_to_csv(dem_file, dem_file+\".csv\", \"Elevation\")\ngeotiff_to_csv(slope_file, slope_file+\".csv\", \"Slope\")\ngeotiff_to_csv(aspect_file, aspect_file+\".csv\", \"Aspect\")\ngeotiff_to_csv(curvature_file, curvature_file+\".csv\", \"Curvature\")\ngeotiff_to_csv(northness_file, northness_file+\".csv\", \"Northness\")\ngeotiff_to_csv(eastness_file, eastness_file+\".csv\", \"Eastness\")\n\n# List of file paths for the CSV files\ncsv_files = [dem_file+\".csv\", slope_file+\".csv\", aspect_file+\".csv\", \n             curvature_file+\".csv\", northness_file+\".csv\", eastness_file+\".csv\"]\n\n# Initialize an empty list to store all dataframes\ndfs = []\n\n# Read each CSV file into separate dataframes\nfor file in csv_files:\n    df = pd.read_csv(file, encoding='utf-8')\n    dfs.append(df)\n\n# Merge the dataframes based on the latitude and longitude columns\nmerged_df = dfs[0]  # Start with the first dataframe\nfor i in range(1, len(dfs)):\n    merged_df = pd.merge(merged_df, dfs[i], on=['Latitude', 'Longitude', 'x', 'y'])\n\n# check the statistics of the columns\nfor column in merged_df.columns:\n    merged_df[column] = pd.to_numeric(merged_df[column], errors='coerce')\n    print(merged_df[column].describe())\n    \n# Save the merged dataframe to a new CSV file\nmerged_df.to_csv(result_dem_feature_csv_path, index=False)\nprint(f\"New dem features are updated in {result_dem_feature_csv_path}\")\n",
  "history_output" : "transform =  | 0.04, 0.00,-125.00|\n| 0.00,-0.04, 49.00|\n| 0.00, 0.00, 1.00|\ndx :  [[   138.81136    896.9358     791.1479  ...   -705.22394  -1213.9877\n    -860.5856 ]\n [  1542.0018    3753.1782    3607.4512  ...   -274.61328   -692.94824\n    -745.7047 ]\n [  7874.8384    -158.86371   4776.8813  ...   -206.67776   -306.5728\n    -609.0783 ]\n ...\n [     0.           0.           0.      ...  -8118.5645    3692.7695\n   12687.431  ]\n [     0.           0.           0.      ... -14410.954   -10506.575\n     -87.21246]\n [     0.           0.           0.      ... -17126.465    -2894.538\n  -15618.087  ]]\ndy :  [[ -3378.8354   -3383.6235   -3477.614   ...   -432.41122   -651.49774\n    -335.70184]\n [ -4136.96     -3709.7915   -5840.6626  ...   -166.97948   -573.81696\n    -689.1039 ]\n [ -7801.1885   -5449.0728    3783.8179  ...   -164.81189   -180.40637\n    -230.18901]\n ...\n [    -0.          -0.          -0.      ... -12895.478     8422.884\n   18751.35   ]\n [    -0.          -0.          -0.      ...  -1903.0135   -5146.6675\n  -14810.924  ]\n [    -0.          -0.          -0.      ...  -1682.2935   -5900.857\n   -2087.3752 ]]\n/home/chetana/gw-workspace/rZnAqJ1Bb318/western_us_dem.py:208: RuntimeWarning: invalid value encountered in divide\n  northness = np.arctan(dy / np.sqrt(dx**2 + dy**2))\n/home/chetana/gw-workspace/rZnAqJ1Bb318/western_us_dem.py:209: RuntimeWarning: invalid value encountered in divide\n  eastness = np.arctan(dx / np.sqrt(dx**2 + dy**2))\ncount    462204.000000\nmean         37.030000\nstd           6.921275\nmin          25.060000\n25%          31.036000\n50%          37.030000\n75%          43.024000\nmax          49.000000\nName: Latitude, dtype: float64\ncount    462204.00000\nmean       -112.52600\nstd           7.21226\nmin        -125.00000\n25%        -118.77200\n50%        -112.52600\n75%        -106.28000\nmax        -100.05200\nName: Longitude, dtype: float64\ncount    462204.000000\nmean        346.500000\nstd         200.340552\nmin           0.000000\n25%         173.000000\n50%         346.500000\n75%         520.000000\nmax         693.000000\nName: x, dtype: float64\ncount    462204.000000\nmean        332.500000\nstd         192.257631\nmin           0.000000\n25%         166.000000\n50%         332.500000\n75%         499.000000\nmax         665.000000\nName: y, dtype: float64\ncount    462204.000000\nmean       1025.629083\nstd         808.945819\nmin         -82.938410\n25%         180.727250\n50%        1018.458080\n75%        1604.870600\nmax        4177.173000\nName: Elevation, dtype: float64\ncount    462204.000000\nmean          1.250591\nstd           0.630813\nmin           0.000000\n25%           1.565756\n50%           1.569817\n75%           1.570469\nmax           1.570769\nName: Slope, dtype: float64\ncount    462204.000000\nmean        150.657475\nstd         119.139631\nmin           0.000000\n25%          22.385444\n50%         147.928925\n75%         258.982280\nmax         359.999600\nName: Aspect, dtype: float64\ncount    462204.000000\nmean        -49.124993\nstd        2819.341836\nmin      -41085.560000\n25%        -482.398620\n50%           0.000000\n75%         840.230590\nmax       21411.324000\nName: Curvature, dtype: float64\ncount    368579.000000\nmean         -0.012698\nstd           0.587101\nmin          -0.785398\n25%          -0.626382\n50%          -0.027939\n75%           0.608819\nmax           0.785398\nName: Northness, dtype: float64\ncount    368579.000000\nmean         -0.040279\nstd           0.583256\nmin          -0.785398\n25%          -0.643895\n50%          -0.087261\n75%           0.573790\nmax           0.785398\nName: Eastness, dtype: float64\nNew dem features are updated in /home/chetana/gridmet_test_run/dem_all.csv\n",
  "history_begin_time" : 1700466577594,
  "history_end_time" : 1700466595454,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "SWxC9bbaIdv9",
  "history_input" : "import numpy as np\nimport pandas as pd\nfrom osgeo import gdal\nimport warnings\nimport rasterio\nimport csv\nfrom rasterio.transform import Affine\nfrom scipy.ndimage import sobel, gaussian_filter\n\nmile_to_meters = 1609.34\nfeet_to_meters = 0.3048\n\n# Set the warning filter globally to ignore the FutureWarning\nwarnings.simplefilter(\"ignore\", FutureWarning)\n\ndef lat_lon_to_pixel(lat, lon, geotransform):\n    \"\"\"\n    Convert latitude and longitude to pixel coordinates using a geotransform.\n\n    Args:\n        lat (float): Latitude.\n        lon (float): Longitude.\n        geotransform (tuple): Geotransform coefficients (e.g., (origin_x, pixel_width, 0, origin_y, 0, pixel_height)).\n\n    Returns:\n        tuple: Pixel coordinates (x, y).\n    \"\"\"\n    x = int((lon - geotransform[0]) / geotransform[1])\n    y = int((lat - geotransform[3]) / geotransform[5])\n    return x, y\n\ndef calculate_slope_aspect_for_single(elevation_data, pixel_size_x, pixel_size_y):\n    \"\"\"\n    Calculate slope and aspect for a single pixel using elevation data.\n\n    Args:\n        elevation_data (array): Elevation data.\n        pixel_size_x (float): Pixel size in the x-direction.\n        pixel_size_y (float): Pixel size in the y-direction.\n\n    Returns:\n        tuple: Slope (in degrees), aspect (in degrees).\n    \"\"\"\n    # Calculate slope using the Sobel operator\n    slope_x = np.gradient(elevation_data, pixel_size_x, axis=1)\n    slope_y = np.gradient(elevation_data, pixel_size_y, axis=0)\n    slope_rad = np.arctan(np.sqrt(slope_x ** 2 + slope_y ** 2))\n    slope_deg = np.degrees(slope_rad)\n\n    # Calculate aspect (direction of the steepest descent)\n    aspect_rad = np.arctan2(slope_y, -slope_x)\n    aspect_deg = (np.degrees(aspect_rad) + 360) % 360\n\n    return slope_deg, aspect_deg\n\ndef save_as_geotiff(data, output_file, src_file):\n    \"\"\"\n    Save data as a GeoTIFF file with metadata from the source file.\n\n    Args:\n        data (array): Data to be saved.\n        output_file (str): Path to the output GeoTIFF file.\n        src_file (str): Path to the source GeoTIFF file to inherit metadata from.\n    \"\"\"\n    with rasterio.open(src_file) as src_dataset:\n        profile = src_dataset.profile\n        transform = src_dataset.transform\n\n        # Update the data type, count, and set the transform for the new dataset\n        profile.update(dtype=rasterio.float32, count=1, transform=transform)\n\n        # Create the new GeoTIFF file\n        with rasterio.open(output_file, 'w', **profile) as dst_dataset:\n            # Write the data to the new GeoTIFF\n            dst_dataset.write(data, 1)\n\ndef print_statistics(data):\n    \"\"\"\n    Print basic statistics of a data array.\n\n    Args:\n        data (array): Data array to calculate statistics for.\n    \"\"\"\n    # Calculate multiple statistics in one line\n    data = data[~np.isnan(data)]\n    mean, median, min_val, max_val, sum_val, std_dev, variance = [np.mean(data), np.median(data), np.min(data), np.max(data), np.sum(data), np.std(data), np.var(data)]\n\n    # Print the calculated statistics\n    print(\"Mean:\", mean)\n    print(\"Median:\", median)\n    print(\"Minimum:\", min_val)\n    print(\"Maximum:\", max_val)\n    print(\"Sum:\", sum_val)\n    print(\"Standard Deviation:\", std_dev)\n    print(\"Variance:\", variance)\n\ndef calculate_slope(dem_file):\n    from osgeo import gdal\n    import numpy as np\n    import rasterio\n    gdal.DEMProcessing(f'{dem_file}_slope.tif', dem_file, 'slope')\n    with rasterio.open(f'{dem_file}_slope.tif') as dataset:\n        slope=dataset.read(1)\n    return slope\n  \ndef calculate_aspect(dem_file):\n    from osgeo import gdal\n    import numpy as np\n    import rasterio\n    gdal.DEMProcessing(f'{dem_file}_aspect.tif', dem_file, 'aspect')\n    with rasterio.open(f'{dem_file}_aspect.tif') as dataset:\n        aspect=dataset.read(1)\n    return aspect\n    \n    \ndef calculate_slope_aspect(dem_file):\n    \"\"\"\n    Calculate slope and aspect from a DEM (Digital Elevation Model) file.\n\n    Args:\n        dem_file (str): Path to the DEM GeoTIFF file.\n\n    Returns:\n        tuple: Slope array (in degrees), aspect array (in degrees).\n    \"\"\"\n    with rasterio.open(dem_file) as dataset:\n        # Read the DEM data as a numpy array\n        dem_data = dataset.read(1)\n\n        # Get the geotransform to convert pixel coordinates to geographic coordinates\n        transform = dataset.transform\n\n        # Calculate the slope and aspect using numpy\n        dx, dy = np.gradient(dem_data, transform[0], transform[4])\n        print(\"dx : \", dx)\n        print(\"dy : \", dy)\n        slope = np.arctan(np.sqrt(dx**2 + dy**2))\n#         slope = np.degrees(slope)\n        aspect = np.degrees(np.arctan2(-dy, dx))\n\n        # Adjust aspect values to range from 0 to 360 degrees\n        aspect[aspect < 0] += 360\n\n    return slope, aspect\n\ndef calculate_curvature(elevation_data, pixel_size_x, pixel_size_y):\n    \"\"\"\n    Calculate curvature from elevation data using the Laplacian operator.\n\n    Args:\n        elevation_data (array): Elevation data.\n        pixel_size_x (float): Pixel size in the x-direction.\n        pixel_size_y (float): Pixel size in the y-direction.\n\n    Returns:\n        array: Curvature data.\n    \"\"\"\n    # Calculate curvature using the Laplacian operator\n    curvature_x = np.gradient(np.gradient(elevation_data, pixel_size_x, axis=1), pixel_size_x, axis=1)\n    curvature_y = np.gradient(np.gradient(elevation_data, pixel_size_y, axis=0), pixel_size_y, axis=0)\n    curvature = curvature_x + curvature_y\n\n    return curvature\n  \ndef calculate_curvature(dem_file, sigma=1):\n    with rasterio.open(dem_file) as dataset:\n        # Read the DEM data as a numpy array\n        dem_data = dataset.read(1)\n        \n        # the dem is in meter unit\n        dem_data = dem_data\n\n        # Calculate the gradient using the Sobel filter\n        dx = sobel(dem_data, axis=1, mode='constant')\n        dy = sobel(dem_data, axis=0, mode='constant')\n\n        # Calculate the second derivatives using the Sobel filter\n        dxx = sobel(dx, axis=1, mode='constant')\n        dyy = sobel(dy, axis=0, mode='constant')\n\n        # Calculate the curvature using the second derivatives\n        curvature = dxx + dyy\n\n        # Smooth the curvature using Gaussian filtering (optional)\n        curvature = gaussian_filter(curvature, sigma)\n\n    return curvature\n\ndef calculate_gradients(dem_file):\n    \"\"\"\n    Calculate Northness and Eastness gradients from a DEM (Digital Elevation Model) file.\n\n    Args:\n        dem_file (str): Path to the DEM GeoTIFF file.\n\n    Returns:\n        tuple: Northness array, Eastness array (both in radians).\n    \"\"\"\n    with rasterio.open(dem_file) as dataset:\n        # Read the DEM data as a numpy array\n        dem_data = dataset.read(1)\n\n        # Calculate the gradients along the North and East directions\n        dy, dx = np.gradient(dem_data, dataset.res[0], dataset.res[1])\n\n        # Calculate the Northness and Eastness\n        northness = np.arctan(dy / np.sqrt(dx**2 + dy**2))\n        eastness = np.arctan(dx / np.sqrt(dx**2 + dy**2))\n\n    return northness, eastness\n\ndef geotiff_to_csv(geotiff_file, csv_file, column_name):\n    \"\"\"\n    Convert a GeoTIFF file to a CSV file containing latitude, longitude, and image values.\n\n    Args:\n        geotiff_file (str): Path to the input GeoTIFF file.\n        csv_file (str): Path to the output CSV file.\n        column_name (str): Name for the image value column.\n    \"\"\"\n    # Open the GeoTIFF file\n    with rasterio.open(geotiff_file) as dataset:\n        # Get the pixel values as a 2D array\n        data = dataset.read(1)\n\n        if column_name == \"Elevation\":\n            # default unit is meter\n            data = data\n\n        # Get the geotransform to convert pixel coordinates to geographic coordinates\n        transform = dataset.transform\n\n        # Get the width and height of the GeoTIFF\n        height, width = data.shape\n\n        # Open the CSV file for writing\n        with open(csv_file, 'w', newline='') as csvfile:\n            csvwriter = csv.writer(csvfile)\n\n            # Write the CSV header\n            csvwriter.writerow(['Latitude', 'Longitude', 'x', 'y', column_name])\n\n            # Loop through each pixel and extract latitude, longitude, and image value\n            for y in range(height):\n                for x in range(width):\n                    # Get the pixel value\n                    image_value = data[y, x]\n\n                    # Convert pixel coordinates to geographic coordinates\n                    lon, lat = transform * (x, y)\n\n                    # Write the data to the CSV file\n                    csvwriter.writerow([lat, lon, x, y, image_value])\n\ndef read_elevation_data(file_path, result_dem_csv_path, result_dem_feature_csv_path):\n    \"\"\"\n    Read and process elevation data from a CSV file and save it to another CSV file with additional features.\n\n    Args:\n        file_path (str): Path to the input CSV file containing elevation data.\n        result_dem_csv_path (str): Path to the output CSV file for elevation data.\n        result_dem_feature_csv_path (str): Path to the output CSV file for elevation data with additional features.\n\n    Returns:\n        DataFrame: Merged dataframe with elevation and additional features.\n    \"\"\"\n    neighborhood_size = 4\n    df = pd.read_csv(file_path)\n    \n    dataset = rasterio.open(geotiff_file)\n    data = dataset.read(1)\n\n    # Get the width and height of the GeoTIFF\n    height, width = data.shape\n    \n    # Create an empty DataFrame with column names\n    columns = ['lat', 'lon', 'elevation', 'slope', 'aspect', 'curvature', 'northness', 'eastness']\n    all_df = pd.DataFrame(columns=columns)\n    \n    all_df.to_csv(result_dem_feature_csv_path)\n    print(f\"DEM and other columns are saved to file {result_dem_feature_csv_path}\")\n    return all_df\n\n  \n\n# Usage example:\nresult_dem_csv_path = \"/home/chetana/gridmet_test_run/dem_template.csv\"\nresult_dem_feature_csv_path = \"/home/chetana/gridmet_test_run/dem_all.csv\"\n\ndem_file = \"/home/chetana/gridmet_test_run/dem_file.tif\"\nslope_file = '/home/chetana/gridmet_test_run/dem_file.tif_slope.tif'\naspect_file = '/home/chetana/gridmet_test_run/dem_file.tif_aspect.tif'\ncurvature_file = '/home/chetana/gridmet_test_run/curvature_file.tif'\nnorthness_file = '/home/chetana/gridmet_test_run/northness_file.tif'\neastness_file = '/home/chetana/gridmet_test_run/eastness_file.tif'\n\nslope, aspect = calculate_slope_aspect(dem_file)\n# slope = calculate_slope(dem_file)\n# aspect = calculate_aspect(dem_file)\ncurvature = calculate_curvature(dem_file)\nnorthness, eastness = calculate_gradients(dem_file)\n\n# Save the slope and aspect as new GeoTIFF files\nsave_as_geotiff(slope, slope_file, dem_file)\nsave_as_geotiff(aspect, aspect_file, dem_file)\nsave_as_geotiff(curvature, curvature_file, dem_file)\nsave_as_geotiff(northness, northness_file, dem_file)\nsave_as_geotiff(eastness, eastness_file, dem_file)\n\ngeotiff_to_csv(dem_file, dem_file+\".csv\", \"Elevation\")\ngeotiff_to_csv(slope_file, slope_file+\".csv\", \"Slope\")\ngeotiff_to_csv(aspect_file, aspect_file+\".csv\", \"Aspect\")\ngeotiff_to_csv(curvature_file, curvature_file+\".csv\", \"Curvature\")\ngeotiff_to_csv(northness_file, northness_file+\".csv\", \"Northness\")\ngeotiff_to_csv(eastness_file, eastness_file+\".csv\", \"Eastness\")\n\n# List of file paths for the CSV files\ncsv_files = [dem_file+\".csv\", slope_file+\".csv\", aspect_file+\".csv\", \n             curvature_file+\".csv\", northness_file+\".csv\", eastness_file+\".csv\"]\n\n# Initialize an empty list to store all dataframes\ndfs = []\n\n# Read each CSV file into separate dataframes\nfor file in csv_files:\n    df = pd.read_csv(file, encoding='utf-8')\n    dfs.append(df)\n\n# Merge the dataframes based on the latitude and longitude columns\nmerged_df = dfs[0]  # Start with the first dataframe\nfor i in range(1, len(dfs)):\n    merged_df = pd.merge(merged_df, dfs[i], on=['Latitude', 'Longitude', 'x', 'y'])\n\n# check the statistics of the columns\nfor column in merged_df.columns:\n    merged_df[column] = pd.to_numeric(merged_df[column], errors='coerce')\n    print(merged_df[column].describe())\n    \n# Save the merged dataframe to a new CSV file\nmerged_df.to_csv(result_dem_feature_csv_path, index=False)\nprint(f\"New dem features are updated in {result_dem_feature_csv_path}\")\n",
  "history_output" : "dx :  [[   138.81136    896.9358     791.1479  ...   -705.22394  -1213.9877\n    -860.5856 ]\n [  1542.0018    3753.1782    3607.4512  ...   -274.61328   -692.94824\n    -745.7047 ]\n [  7874.8384    -158.86371   4776.8813  ...   -206.67776   -306.5728\n    -609.0783 ]\n ...\n [     0.           0.           0.      ...  -8118.5645    3692.7695\n   12687.431  ]\n [     0.           0.           0.      ... -14410.954   -10506.575\n     -87.21246]\n [     0.           0.           0.      ... -17126.465    -2894.538\n  -15618.087  ]]\ndy :  [[ -3378.8354   -3383.6235   -3477.614   ...   -432.41122   -651.49774\n    -335.70184]\n [ -4136.96     -3709.7915   -5840.6626  ...   -166.97948   -573.81696\n    -689.1039 ]\n [ -7801.1885   -5449.0728    3783.8179  ...   -164.81189   -180.40637\n    -230.18901]\n ...\n [    -0.          -0.          -0.      ... -12895.478     8422.884\n   18751.35   ]\n [    -0.          -0.          -0.      ...  -1903.0135   -5146.6675\n  -14810.924  ]\n [    -0.          -0.          -0.      ...  -1682.2935   -5900.857\n   -2087.3752 ]]\n/home/chetana/gw-workspace/SWxC9bbaIdv9/western_us_dem.py:207: RuntimeWarning: invalid value encountered in divide\n  northness = np.arctan(dy / np.sqrt(dx**2 + dy**2))\n/home/chetana/gw-workspace/SWxC9bbaIdv9/western_us_dem.py:208: RuntimeWarning: invalid value encountered in divide\n  eastness = np.arctan(dx / np.sqrt(dx**2 + dy**2))\ncount    462204.000000\nmean         37.030000\nstd           6.921275\nmin          25.060000\n25%          31.036000\n50%          37.030000\n75%          43.024000\nmax          49.000000\nName: Latitude, dtype: float64\ncount    462204.00000\nmean       -112.52600\nstd           7.21226\nmin        -125.00000\n25%        -118.77200\n50%        -112.52600\n75%        -106.28000\nmax        -100.05200\nName: Longitude, dtype: float64\ncount    462204.000000\nmean        346.500000\nstd         200.340552\nmin           0.000000\n25%         173.000000\n50%         346.500000\n75%         520.000000\nmax         693.000000\nName: x, dtype: float64\ncount    462204.000000\nmean        332.500000\nstd         192.257631\nmin           0.000000\n25%         166.000000\n50%         332.500000\n75%         499.000000\nmax         665.000000\nName: y, dtype: float64\ncount    462204.000000\nmean       1025.629083\nstd         808.945819\nmin         -82.938410\n25%         180.727250\n50%        1018.458080\n75%        1604.870600\nmax        4177.173000\nName: Elevation, dtype: float64\ncount    462204.000000\nmean          1.250591\nstd           0.630813\nmin           0.000000\n25%           1.565756\n50%           1.569817\n75%           1.570469\nmax           1.570769\nName: Slope, dtype: float64\ncount    462204.000000\nmean        150.657475\nstd         119.139631\nmin           0.000000\n25%          22.385444\n50%         147.928925\n75%         258.982280\nmax         359.999600\nName: Aspect, dtype: float64\ncount    462204.000000\nmean        -49.124993\nstd        2819.341836\nmin      -41085.560000\n25%        -482.398620\n50%           0.000000\n75%         840.230590\nmax       21411.324000\nName: Curvature, dtype: float64\ncount    368579.000000\nmean         -0.012698\nstd           0.587101\nmin          -0.785398\n25%          -0.626382\n50%          -0.027939\n75%           0.608819\nmax           0.785398\nName: Northness, dtype: float64\ncount    368579.000000\nmean         -0.040279\nstd           0.583256\nmin          -0.785398\n25%          -0.643895\n50%          -0.087261\n75%           0.573790\nmax           0.785398\nName: Eastness, dtype: float64\nNew dem features are updated in /home/chetana/gridmet_test_run/dem_all.csv\n",
  "history_begin_time" : 1700466476297,
  "history_end_time" : 1700466494223,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "etFoOpB4N8wc",
  "history_input" : "import numpy as np\nimport pandas as pd\nfrom osgeo import gdal\nimport warnings\nimport rasterio\nimport csv\nfrom rasterio.transform import Affine\nfrom scipy.ndimage import sobel, gaussian_filter\n\nmile_to_meters = 1609.34\nfeet_to_meters = 0.3048\n\n# Set the warning filter globally to ignore the FutureWarning\nwarnings.simplefilter(\"ignore\", FutureWarning)\n\ndef lat_lon_to_pixel(lat, lon, geotransform):\n    \"\"\"\n    Convert latitude and longitude to pixel coordinates using a geotransform.\n\n    Args:\n        lat (float): Latitude.\n        lon (float): Longitude.\n        geotransform (tuple): Geotransform coefficients (e.g., (origin_x, pixel_width, 0, origin_y, 0, pixel_height)).\n\n    Returns:\n        tuple: Pixel coordinates (x, y).\n    \"\"\"\n    x = int((lon - geotransform[0]) / geotransform[1])\n    y = int((lat - geotransform[3]) / geotransform[5])\n    return x, y\n\ndef calculate_slope_aspect_for_single(elevation_data, pixel_size_x, pixel_size_y):\n    \"\"\"\n    Calculate slope and aspect for a single pixel using elevation data.\n\n    Args:\n        elevation_data (array): Elevation data.\n        pixel_size_x (float): Pixel size in the x-direction.\n        pixel_size_y (float): Pixel size in the y-direction.\n\n    Returns:\n        tuple: Slope (in degrees), aspect (in degrees).\n    \"\"\"\n    # Calculate slope using the Sobel operator\n    slope_x = np.gradient(elevation_data, pixel_size_x, axis=1)\n    slope_y = np.gradient(elevation_data, pixel_size_y, axis=0)\n    slope_rad = np.arctan(np.sqrt(slope_x ** 2 + slope_y ** 2))\n    slope_deg = np.degrees(slope_rad)\n\n    # Calculate aspect (direction of the steepest descent)\n    aspect_rad = np.arctan2(slope_y, -slope_x)\n    aspect_deg = (np.degrees(aspect_rad) + 360) % 360\n\n    return slope_deg, aspect_deg\n\ndef save_as_geotiff(data, output_file, src_file):\n    \"\"\"\n    Save data as a GeoTIFF file with metadata from the source file.\n\n    Args:\n        data (array): Data to be saved.\n        output_file (str): Path to the output GeoTIFF file.\n        src_file (str): Path to the source GeoTIFF file to inherit metadata from.\n    \"\"\"\n    with rasterio.open(src_file) as src_dataset:\n        profile = src_dataset.profile\n        transform = src_dataset.transform\n\n        # Update the data type, count, and set the transform for the new dataset\n        profile.update(dtype=rasterio.float32, count=1, transform=transform)\n\n        # Create the new GeoTIFF file\n        with rasterio.open(output_file, 'w', **profile) as dst_dataset:\n            # Write the data to the new GeoTIFF\n            dst_dataset.write(data, 1)\n\ndef print_statistics(data):\n    \"\"\"\n    Print basic statistics of a data array.\n\n    Args:\n        data (array): Data array to calculate statistics for.\n    \"\"\"\n    # Calculate multiple statistics in one line\n    data = data[~np.isnan(data)]\n    mean, median, min_val, max_val, sum_val, std_dev, variance = [np.mean(data), np.median(data), np.min(data), np.max(data), np.sum(data), np.std(data), np.var(data)]\n\n    # Print the calculated statistics\n    print(\"Mean:\", mean)\n    print(\"Median:\", median)\n    print(\"Minimum:\", min_val)\n    print(\"Maximum:\", max_val)\n    print(\"Sum:\", sum_val)\n    print(\"Standard Deviation:\", std_dev)\n    print(\"Variance:\", variance)\n\ndef calculate_slope(dem_file):\n    from osgeo import gdal\n    import numpy as np\n    import rasterio\n    gdal.DEMProcessing(f'{dem_file}_slope.tif', dem_file, 'slope')\n    with rasterio.open(f'{dem_file}_slope.tif') as dataset:\n        slope=dataset.read(1)\n    return slope\n  \ndef calculate_aspect(dem_file):\n    from osgeo import gdal\n    import numpy as np\n    import rasterio\n    gdal.DEMProcessing(f'{dem_file}_aspect.tif', dem_file, 'aspect')\n    with rasterio.open(f'{dem_file}_aspect.tif') as dataset:\n        aspect=dataset.read(1)\n    return aspect\n    \n    \ndef calculate_slope_aspect(dem_file):\n    \"\"\"\n    Calculate slope and aspect from a DEM (Digital Elevation Model) file.\n\n    Args:\n        dem_file (str): Path to the DEM GeoTIFF file.\n\n    Returns:\n        tuple: Slope array (in degrees), aspect array (in degrees).\n    \"\"\"\n    with rasterio.open(dem_file) as dataset:\n        # Read the DEM data as a numpy array\n        dem_data = dataset.read(1)\n\n        # Get the geotransform to convert pixel coordinates to geographic coordinates\n        transform = dataset.transform\n\n        # Calculate the slope and aspect using numpy\n        dx, dy = np.gradient(dem_data, transform[0], transform[4])\n        slope = np.arctan(np.sqrt(dx**2 + dy**2))\n#         slope = np.degrees(slope)\n        aspect = np.degrees(np.arctan2(-dy, dx))\n\n        # Adjust aspect values to range from 0 to 360 degrees\n        aspect[aspect < 0] += 360\n\n    return slope, aspect\n\ndef calculate_curvature(elevation_data, pixel_size_x, pixel_size_y):\n    \"\"\"\n    Calculate curvature from elevation data using the Laplacian operator.\n\n    Args:\n        elevation_data (array): Elevation data.\n        pixel_size_x (float): Pixel size in the x-direction.\n        pixel_size_y (float): Pixel size in the y-direction.\n\n    Returns:\n        array: Curvature data.\n    \"\"\"\n    # Calculate curvature using the Laplacian operator\n    curvature_x = np.gradient(np.gradient(elevation_data, pixel_size_x, axis=1), pixel_size_x, axis=1)\n    curvature_y = np.gradient(np.gradient(elevation_data, pixel_size_y, axis=0), pixel_size_y, axis=0)\n    curvature = curvature_x + curvature_y\n\n    return curvature\n  \ndef calculate_curvature(dem_file, sigma=1):\n    with rasterio.open(dem_file) as dataset:\n        # Read the DEM data as a numpy array\n        dem_data = dataset.read(1)\n        \n        # the dem is in meter unit\n        dem_data = dem_data\n\n        # Calculate the gradient using the Sobel filter\n        dx = sobel(dem_data, axis=1, mode='constant')\n        dy = sobel(dem_data, axis=0, mode='constant')\n\n        # Calculate the second derivatives using the Sobel filter\n        dxx = sobel(dx, axis=1, mode='constant')\n        dyy = sobel(dy, axis=0, mode='constant')\n\n        # Calculate the curvature using the second derivatives\n        curvature = dxx + dyy\n\n        # Smooth the curvature using Gaussian filtering (optional)\n        curvature = gaussian_filter(curvature, sigma)\n\n    return curvature\n\ndef calculate_gradients(dem_file):\n    \"\"\"\n    Calculate Northness and Eastness gradients from a DEM (Digital Elevation Model) file.\n\n    Args:\n        dem_file (str): Path to the DEM GeoTIFF file.\n\n    Returns:\n        tuple: Northness array, Eastness array (both in radians).\n    \"\"\"\n    with rasterio.open(dem_file) as dataset:\n        # Read the DEM data as a numpy array\n        dem_data = dataset.read(1)\n\n        # Calculate the gradients along the North and East directions\n        dy, dx = np.gradient(dem_data, dataset.res[0], dataset.res[1])\n\n        # Calculate the Northness and Eastness\n        northness = np.arctan(dy / np.sqrt(dx**2 + dy**2))\n        eastness = np.arctan(dx / np.sqrt(dx**2 + dy**2))\n\n    return northness, eastness\n\ndef geotiff_to_csv(geotiff_file, csv_file, column_name):\n    \"\"\"\n    Convert a GeoTIFF file to a CSV file containing latitude, longitude, and image values.\n\n    Args:\n        geotiff_file (str): Path to the input GeoTIFF file.\n        csv_file (str): Path to the output CSV file.\n        column_name (str): Name for the image value column.\n    \"\"\"\n    # Open the GeoTIFF file\n    with rasterio.open(geotiff_file) as dataset:\n        # Get the pixel values as a 2D array\n        data = dataset.read(1)\n\n        if column_name == \"Elevation\":\n            # default unit is meter\n            data = data\n\n        # Get the geotransform to convert pixel coordinates to geographic coordinates\n        transform = dataset.transform\n\n        # Get the width and height of the GeoTIFF\n        height, width = data.shape\n\n        # Open the CSV file for writing\n        with open(csv_file, 'w', newline='') as csvfile:\n            csvwriter = csv.writer(csvfile)\n\n            # Write the CSV header\n            csvwriter.writerow(['Latitude', 'Longitude', 'x', 'y', column_name])\n\n            # Loop through each pixel and extract latitude, longitude, and image value\n            for y in range(height):\n                for x in range(width):\n                    # Get the pixel value\n                    image_value = data[y, x]\n\n                    # Convert pixel coordinates to geographic coordinates\n                    lon, lat = transform * (x, y)\n\n                    # Write the data to the CSV file\n                    csvwriter.writerow([lat, lon, x, y, image_value])\n\ndef read_elevation_data(file_path, result_dem_csv_path, result_dem_feature_csv_path):\n    \"\"\"\n    Read and process elevation data from a CSV file and save it to another CSV file with additional features.\n\n    Args:\n        file_path (str): Path to the input CSV file containing elevation data.\n        result_dem_csv_path (str): Path to the output CSV file for elevation data.\n        result_dem_feature_csv_path (str): Path to the output CSV file for elevation data with additional features.\n\n    Returns:\n        DataFrame: Merged dataframe with elevation and additional features.\n    \"\"\"\n    neighborhood_size = 4\n    df = pd.read_csv(file_path)\n    \n    dataset = rasterio.open(geotiff_file)\n    data = dataset.read(1)\n\n    # Get the width and height of the GeoTIFF\n    height, width = data.shape\n    \n    # Create an empty DataFrame with column names\n    columns = ['lat', 'lon', 'elevation', 'slope', 'aspect', 'curvature', 'northness', 'eastness']\n    all_df = pd.DataFrame(columns=columns)\n    \n    all_df.to_csv(result_dem_feature_csv_path)\n    print(f\"DEM and other columns are saved to file {result_dem_feature_csv_path}\")\n    return all_df\n\n  \n\n# Usage example:\nresult_dem_csv_path = \"/home/chetana/gridmet_test_run/dem_template.csv\"\nresult_dem_feature_csv_path = \"/home/chetana/gridmet_test_run/dem_all.csv\"\n\ndem_file = \"/home/chetana/gridmet_test_run/dem_file.tif\"\nslope_file = '/home/chetana/gridmet_test_run/dem_file.tif_slope.tif'\naspect_file = '/home/chetana/gridmet_test_run/dem_file.tif_aspect.tif'\ncurvature_file = '/home/chetana/gridmet_test_run/curvature_file.tif'\nnorthness_file = '/home/chetana/gridmet_test_run/northness_file.tif'\neastness_file = '/home/chetana/gridmet_test_run/eastness_file.tif'\n\nslope, aspect = calculate_slope_aspect(dem_file)\n# slope = calculate_slope(dem_file)\n# aspect = calculate_aspect(dem_file)\ncurvature = calculate_curvature(dem_file)\nnorthness, eastness = calculate_gradients(dem_file)\n\n# Save the slope and aspect as new GeoTIFF files\nsave_as_geotiff(slope, slope_file, dem_file)\nsave_as_geotiff(aspect, aspect_file, dem_file)\nsave_as_geotiff(curvature, curvature_file, dem_file)\nsave_as_geotiff(northness, northness_file, dem_file)\nsave_as_geotiff(eastness, eastness_file, dem_file)\n\ngeotiff_to_csv(dem_file, dem_file+\".csv\", \"Elevation\")\ngeotiff_to_csv(slope_file, slope_file+\".csv\", \"Slope\")\ngeotiff_to_csv(aspect_file, aspect_file+\".csv\", \"Aspect\")\ngeotiff_to_csv(curvature_file, curvature_file+\".csv\", \"Curvature\")\ngeotiff_to_csv(northness_file, northness_file+\".csv\", \"Northness\")\ngeotiff_to_csv(eastness_file, eastness_file+\".csv\", \"Eastness\")\n\n# List of file paths for the CSV files\ncsv_files = [dem_file+\".csv\", slope_file+\".csv\", aspect_file+\".csv\", \n             curvature_file+\".csv\", northness_file+\".csv\", eastness_file+\".csv\"]\n\n# Initialize an empty list to store all dataframes\ndfs = []\n\n# Read each CSV file into separate dataframes\nfor file in csv_files:\n    df = pd.read_csv(file, encoding='utf-8')\n    dfs.append(df)\n\n# Merge the dataframes based on the latitude and longitude columns\nmerged_df = dfs[0]  # Start with the first dataframe\nfor i in range(1, len(dfs)):\n    merged_df = pd.merge(merged_df, dfs[i], on=['Latitude', 'Longitude', 'x', 'y'])\n\n# check the statistics of the columns\nfor column in merged_df.columns:\n    merged_df[column] = pd.to_numeric(merged_df[column], errors='coerce')\n    print(merged_df[column].describe())\n    \n# Save the merged dataframe to a new CSV file\nmerged_df.to_csv(result_dem_feature_csv_path, index=False)\nprint(f\"New dem features are updated in {result_dem_feature_csv_path}\")\n",
  "history_output" : "/home/chetana/gw-workspace/etFoOpB4N8wc/western_us_dem.py:205: RuntimeWarning: invalid value encountered in divide\n  northness = np.arctan(dy / np.sqrt(dx**2 + dy**2))\n/home/chetana/gw-workspace/etFoOpB4N8wc/western_us_dem.py:206: RuntimeWarning: invalid value encountered in divide\n  eastness = np.arctan(dx / np.sqrt(dx**2 + dy**2))\ncount    462204.000000\nmean         37.030000\nstd           6.921275\nmin          25.060000\n25%          31.036000\n50%          37.030000\n75%          43.024000\nmax          49.000000\nName: Latitude, dtype: float64\ncount    462204.00000\nmean       -112.52600\nstd           7.21226\nmin        -125.00000\n25%        -118.77200\n50%        -112.52600\n75%        -106.28000\nmax        -100.05200\nName: Longitude, dtype: float64\ncount    462204.000000\nmean        346.500000\nstd         200.340552\nmin           0.000000\n25%         173.000000\n50%         346.500000\n75%         520.000000\nmax         693.000000\nName: x, dtype: float64\ncount    462204.000000\nmean        332.500000\nstd         192.257631\nmin           0.000000\n25%         166.000000\n50%         332.500000\n75%         499.000000\nmax         665.000000\nName: y, dtype: float64\ncount    462204.000000\nmean       1025.629083\nstd         808.945819\nmin         -82.938410\n25%         180.727250\n50%        1018.458080\n75%        1604.870600\nmax        4177.173000\nName: Elevation, dtype: float64\ncount    462204.000000\nmean          1.250591\nstd           0.630813\nmin           0.000000\n25%           1.565756\n50%           1.569817\n75%           1.570469\nmax           1.570769\nName: Slope, dtype: float64\ncount    462204.000000\nmean        150.657475\nstd         119.139631\nmin           0.000000\n25%          22.385444\n50%         147.928925\n75%         258.982280\nmax         359.999600\nName: Aspect, dtype: float64\ncount    462204.000000\nmean        -49.124993\nstd        2819.341836\nmin      -41085.560000\n25%        -482.398620\n50%           0.000000\n75%         840.230590\nmax       21411.324000\nName: Curvature, dtype: float64\ncount    368579.000000\nmean         -0.012698\nstd           0.587101\nmin          -0.785398\n25%          -0.626382\n50%          -0.027939\n75%           0.608819\nmax           0.785398\nName: Northness, dtype: float64\ncount    368579.000000\nmean         -0.040279\nstd           0.583256\nmin          -0.785398\n25%          -0.643895\n50%          -0.087261\n75%           0.573790\nmax           0.785398\nName: Eastness, dtype: float64\nNew dem features are updated in /home/chetana/gridmet_test_run/dem_all.csv\n",
  "history_begin_time" : 1700466374653,
  "history_end_time" : 1700466392316,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "41frAHvBhPau",
  "history_input" : "import numpy as np\nimport pandas as pd\nfrom osgeo import gdal\nimport warnings\nimport rasterio\nimport csv\nfrom rasterio.transform import Affine\nfrom scipy.ndimage import sobel, gaussian_filter\n\nmile_to_meters = 1609.34\nfeet_to_meters = 0.3048\n\n# Set the warning filter globally to ignore the FutureWarning\nwarnings.simplefilter(\"ignore\", FutureWarning)\n\ndef lat_lon_to_pixel(lat, lon, geotransform):\n    \"\"\"\n    Convert latitude and longitude to pixel coordinates using a geotransform.\n\n    Args:\n        lat (float): Latitude.\n        lon (float): Longitude.\n        geotransform (tuple): Geotransform coefficients (e.g., (origin_x, pixel_width, 0, origin_y, 0, pixel_height)).\n\n    Returns:\n        tuple: Pixel coordinates (x, y).\n    \"\"\"\n    x = int((lon - geotransform[0]) / geotransform[1])\n    y = int((lat - geotransform[3]) / geotransform[5])\n    return x, y\n\ndef calculate_slope_aspect_for_single(elevation_data, pixel_size_x, pixel_size_y):\n    \"\"\"\n    Calculate slope and aspect for a single pixel using elevation data.\n\n    Args:\n        elevation_data (array): Elevation data.\n        pixel_size_x (float): Pixel size in the x-direction.\n        pixel_size_y (float): Pixel size in the y-direction.\n\n    Returns:\n        tuple: Slope (in degrees), aspect (in degrees).\n    \"\"\"\n    # Calculate slope using the Sobel operator\n    slope_x = np.gradient(elevation_data, pixel_size_x, axis=1)\n    slope_y = np.gradient(elevation_data, pixel_size_y, axis=0)\n    slope_rad = np.arctan(np.sqrt(slope_x ** 2 + slope_y ** 2))\n    slope_deg = np.degrees(slope_rad)\n\n    # Calculate aspect (direction of the steepest descent)\n    aspect_rad = np.arctan2(slope_y, -slope_x)\n    aspect_deg = (np.degrees(aspect_rad) + 360) % 360\n\n    return slope_deg, aspect_deg\n\ndef save_as_geotiff(data, output_file, src_file):\n    \"\"\"\n    Save data as a GeoTIFF file with metadata from the source file.\n\n    Args:\n        data (array): Data to be saved.\n        output_file (str): Path to the output GeoTIFF file.\n        src_file (str): Path to the source GeoTIFF file to inherit metadata from.\n    \"\"\"\n    with rasterio.open(src_file) as src_dataset:\n        profile = src_dataset.profile\n        transform = src_dataset.transform\n\n        # Update the data type, count, and set the transform for the new dataset\n        profile.update(dtype=rasterio.float32, count=1, transform=transform)\n\n        # Create the new GeoTIFF file\n        with rasterio.open(output_file, 'w', **profile) as dst_dataset:\n            # Write the data to the new GeoTIFF\n            dst_dataset.write(data, 1)\n\ndef print_statistics(data):\n    \"\"\"\n    Print basic statistics of a data array.\n\n    Args:\n        data (array): Data array to calculate statistics for.\n    \"\"\"\n    # Calculate multiple statistics in one line\n    data = data[~np.isnan(data)]\n    mean, median, min_val, max_val, sum_val, std_dev, variance = [np.mean(data), np.median(data), np.min(data), np.max(data), np.sum(data), np.std(data), np.var(data)]\n\n    # Print the calculated statistics\n    print(\"Mean:\", mean)\n    print(\"Median:\", median)\n    print(\"Minimum:\", min_val)\n    print(\"Maximum:\", max_val)\n    print(\"Sum:\", sum_val)\n    print(\"Standard Deviation:\", std_dev)\n    print(\"Variance:\", variance)\n\ndef calculate_slope(dem_file):\n    from osgeo import gdal\n    import numpy as np\n    import rasterio\n    gdal.DEMProcessing(f'{dem_file}_slope.tif', dem_file, 'slope')\n    with rasterio.open(f'{dem_file}_slope.tif') as dataset:\n        slope=dataset.read(1)\n    return slope\n  \ndef calculate_aspect(dem_file):\n    from osgeo import gdal\n    import numpy as np\n    import rasterio\n    gdal.DEMProcessing(f'{dem_file}_aspect.tif', dem_file, 'aspect')\n    with rasterio.open(f'{dem_file}_aspect.tif') as dataset:\n        aspect=dataset.read(1)\n    return aspect\n    \n    \ndef calculate_slope_aspect(dem_file):\n    \"\"\"\n    Calculate slope and aspect from a DEM (Digital Elevation Model) file.\n\n    Args:\n        dem_file (str): Path to the DEM GeoTIFF file.\n\n    Returns:\n        tuple: Slope array (in degrees), aspect array (in degrees).\n    \"\"\"\n    with rasterio.open(dem_file) as dataset:\n        # Read the DEM data as a numpy array\n        dem_data = dataset.read(1)\n\n        # Get the geotransform to convert pixel coordinates to geographic coordinates\n        transform = dataset.transform\n\n        # Calculate the slope and aspect using numpy\n        dx, dy = np.gradient(dem_data, transform[0], transform[4])\n        slope = np.arctan(np.sqrt(dx**2 + dy**2))\n        slope = np.degrees(slope)\n        aspect = np.degrees(np.arctan2(-dy, dx))\n\n        # Adjust aspect values to range from 0 to 360 degrees\n        aspect[aspect < 0] += 360\n\n    return slope, aspect\n\ndef calculate_curvature(elevation_data, pixel_size_x, pixel_size_y):\n    \"\"\"\n    Calculate curvature from elevation data using the Laplacian operator.\n\n    Args:\n        elevation_data (array): Elevation data.\n        pixel_size_x (float): Pixel size in the x-direction.\n        pixel_size_y (float): Pixel size in the y-direction.\n\n    Returns:\n        array: Curvature data.\n    \"\"\"\n    # Calculate curvature using the Laplacian operator\n    curvature_x = np.gradient(np.gradient(elevation_data, pixel_size_x, axis=1), pixel_size_x, axis=1)\n    curvature_y = np.gradient(np.gradient(elevation_data, pixel_size_y, axis=0), pixel_size_y, axis=0)\n    curvature = curvature_x + curvature_y\n\n    return curvature\n  \ndef calculate_curvature(dem_file, sigma=1):\n    with rasterio.open(dem_file) as dataset:\n        # Read the DEM data as a numpy array\n        dem_data = dataset.read(1)\n        \n        # the dem is in meter unit\n        dem_data = dem_data\n\n        # Calculate the gradient using the Sobel filter\n        dx = sobel(dem_data, axis=1, mode='constant')\n        dy = sobel(dem_data, axis=0, mode='constant')\n\n        # Calculate the second derivatives using the Sobel filter\n        dxx = sobel(dx, axis=1, mode='constant')\n        dyy = sobel(dy, axis=0, mode='constant')\n\n        # Calculate the curvature using the second derivatives\n        curvature = dxx + dyy\n\n        # Smooth the curvature using Gaussian filtering (optional)\n        curvature = gaussian_filter(curvature, sigma)\n\n    return curvature\n\ndef calculate_gradients(dem_file):\n    \"\"\"\n    Calculate Northness and Eastness gradients from a DEM (Digital Elevation Model) file.\n\n    Args:\n        dem_file (str): Path to the DEM GeoTIFF file.\n\n    Returns:\n        tuple: Northness array, Eastness array (both in radians).\n    \"\"\"\n    with rasterio.open(dem_file) as dataset:\n        # Read the DEM data as a numpy array\n        dem_data = dataset.read(1)\n\n        # Calculate the gradients along the North and East directions\n        dy, dx = np.gradient(dem_data, dataset.res[0], dataset.res[1])\n\n        # Calculate the Northness and Eastness\n        northness = np.arctan(dy / np.sqrt(dx**2 + dy**2))\n        eastness = np.arctan(dx / np.sqrt(dx**2 + dy**2))\n\n    return northness, eastness\n\ndef geotiff_to_csv(geotiff_file, csv_file, column_name):\n    \"\"\"\n    Convert a GeoTIFF file to a CSV file containing latitude, longitude, and image values.\n\n    Args:\n        geotiff_file (str): Path to the input GeoTIFF file.\n        csv_file (str): Path to the output CSV file.\n        column_name (str): Name for the image value column.\n    \"\"\"\n    # Open the GeoTIFF file\n    with rasterio.open(geotiff_file) as dataset:\n        # Get the pixel values as a 2D array\n        data = dataset.read(1)\n\n        if column_name == \"Elevation\":\n            # default unit is meter\n            data = data\n\n        # Get the geotransform to convert pixel coordinates to geographic coordinates\n        transform = dataset.transform\n\n        # Get the width and height of the GeoTIFF\n        height, width = data.shape\n\n        # Open the CSV file for writing\n        with open(csv_file, 'w', newline='') as csvfile:\n            csvwriter = csv.writer(csvfile)\n\n            # Write the CSV header\n            csvwriter.writerow(['Latitude', 'Longitude', 'x', 'y', column_name])\n\n            # Loop through each pixel and extract latitude, longitude, and image value\n            for y in range(height):\n                for x in range(width):\n                    # Get the pixel value\n                    image_value = data[y, x]\n\n                    # Convert pixel coordinates to geographic coordinates\n                    lon, lat = transform * (x, y)\n\n                    # Write the data to the CSV file\n                    csvwriter.writerow([lat, lon, x, y, image_value])\n\ndef read_elevation_data(file_path, result_dem_csv_path, result_dem_feature_csv_path):\n    \"\"\"\n    Read and process elevation data from a CSV file and save it to another CSV file with additional features.\n\n    Args:\n        file_path (str): Path to the input CSV file containing elevation data.\n        result_dem_csv_path (str): Path to the output CSV file for elevation data.\n        result_dem_feature_csv_path (str): Path to the output CSV file for elevation data with additional features.\n\n    Returns:\n        DataFrame: Merged dataframe with elevation and additional features.\n    \"\"\"\n    neighborhood_size = 4\n    df = pd.read_csv(file_path)\n    \n    dataset = rasterio.open(geotiff_file)\n    data = dataset.read(1)\n\n    # Get the width and height of the GeoTIFF\n    height, width = data.shape\n    \n    # Create an empty DataFrame with column names\n    columns = ['lat', 'lon', 'elevation', 'slope', 'aspect', 'curvature', 'northness', 'eastness']\n    all_df = pd.DataFrame(columns=columns)\n    \n    all_df.to_csv(result_dem_feature_csv_path)\n    print(f\"DEM and other columns are saved to file {result_dem_feature_csv_path}\")\n    return all_df\n\n  \n\n# Usage example:\nresult_dem_csv_path = \"/home/chetana/gridmet_test_run/dem_template.csv\"\nresult_dem_feature_csv_path = \"/home/chetana/gridmet_test_run/dem_all.csv\"\n\ndem_file = \"/home/chetana/gridmet_test_run/dem_file.tif\"\nslope_file = '/home/chetana/gridmet_test_run/dem_file.tif_slope.tif'\naspect_file = '/home/chetana/gridmet_test_run/dem_file.tif_aspect.tif'\ncurvature_file = '/home/chetana/gridmet_test_run/curvature_file.tif'\nnorthness_file = '/home/chetana/gridmet_test_run/northness_file.tif'\neastness_file = '/home/chetana/gridmet_test_run/eastness_file.tif'\n\n#slope, aspect = calculate_slope_aspect(dem_file)\nslope = calculate_slope(dem_file)\naspect = calculate_aspect(dem_file)\ncurvature = calculate_curvature(dem_file)\nnorthness, eastness = calculate_gradients(dem_file)\n\n# Save the slope and aspect as new GeoTIFF files\nsave_as_geotiff(slope, slope_file, dem_file)\nsave_as_geotiff(aspect, aspect_file, dem_file)\nsave_as_geotiff(curvature, curvature_file, dem_file)\nsave_as_geotiff(northness, northness_file, dem_file)\nsave_as_geotiff(eastness, eastness_file, dem_file)\n\ngeotiff_to_csv(dem_file, dem_file+\".csv\", \"Elevation\")\ngeotiff_to_csv(slope_file, slope_file+\".csv\", \"Slope\")\ngeotiff_to_csv(aspect_file, aspect_file+\".csv\", \"Aspect\")\ngeotiff_to_csv(curvature_file, curvature_file+\".csv\", \"Curvature\")\ngeotiff_to_csv(northness_file, northness_file+\".csv\", \"Northness\")\ngeotiff_to_csv(eastness_file, eastness_file+\".csv\", \"Eastness\")\n\n# List of file paths for the CSV files\ncsv_files = [dem_file+\".csv\", slope_file+\".csv\", aspect_file+\".csv\", \n             curvature_file+\".csv\", northness_file+\".csv\", eastness_file+\".csv\"]\n\n# Initialize an empty list to store all dataframes\ndfs = []\n\n# Read each CSV file into separate dataframes\nfor file in csv_files:\n    df = pd.read_csv(file, encoding='utf-8')\n    dfs.append(df)\n\n# Merge the dataframes based on the latitude and longitude columns\nmerged_df = dfs[0]  # Start with the first dataframe\nfor i in range(1, len(dfs)):\n    merged_df = pd.merge(merged_df, dfs[i], on=['Latitude', 'Longitude', 'x', 'y'])\n\n# check the statistics of the columns\nfor column in merged_df.columns:\n    merged_df[column] = pd.to_numeric(merged_df[column], errors='coerce')\n    print(merged_df[column].describe())\n    \n# Save the merged dataframe to a new CSV file\nmerged_df.to_csv(result_dem_feature_csv_path, index=False)\nprint(f\"New dem features are updated in {result_dem_feature_csv_path}\")\n",
  "history_output" : "/home/chetana/gw-workspace/41frAHvBhPau/western_us_dem.py:205: RuntimeWarning: invalid value encountered in divide\n  northness = np.arctan(dy / np.sqrt(dx**2 + dy**2))\n/home/chetana/gw-workspace/41frAHvBhPau/western_us_dem.py:206: RuntimeWarning: invalid value encountered in divide\n  eastness = np.arctan(dx / np.sqrt(dx**2 + dy**2))\ncount    462204.000000\nmean         37.030000\nstd           6.921275\nmin          25.060000\n25%          31.036000\n50%          37.030000\n75%          43.024000\nmax          49.000000\nName: Latitude, dtype: float64\ncount    462204.00000\nmean       -112.52600\nstd           7.21226\nmin        -125.00000\n25%        -118.77200\n50%        -112.52600\n75%        -106.28000\nmax        -100.05200\nName: Longitude, dtype: float64\ncount    462204.000000\nmean        346.500000\nstd         200.340552\nmin           0.000000\n25%         173.000000\n50%         346.500000\n75%         520.000000\nmax         693.000000\nName: x, dtype: float64\ncount    462204.000000\nmean        332.500000\nstd         192.257631\nmin           0.000000\n25%         166.000000\n50%         332.500000\n75%         499.000000\nmax         665.000000\nName: y, dtype: float64\ncount    462204.000000\nmean       1025.629083\nstd         808.945819\nmin         -82.938410\n25%         180.727250\n50%        1018.458080\n75%        1604.870600\nmax        4177.173000\nName: Elevation, dtype: float64\ncount    462204.000000\nmean         12.747597\nstd         770.562792\nmin       -9999.000000\n25%          89.697390\n50%          89.938610\n75%          89.978860\nmax          89.998210\nName: Slope, dtype: float64\ncount    462204.000000\nmean      -1904.824847\nstd        4099.062552\nmin       -9999.000000\n25%          19.073003\n50%         121.330820\n75%         230.338588\nmax         359.998500\nName: Aspect, dtype: float64\ncount    462204.000000\nmean        -49.124993\nstd        2819.341836\nmin      -41085.560000\n25%        -482.398620\n50%           0.000000\n75%         840.230590\nmax       21411.324000\nName: Curvature, dtype: float64\ncount    368579.000000\nmean         -0.012698\nstd           0.587101\nmin          -0.785398\n25%          -0.626382\n50%          -0.027939\n75%           0.608819\nmax           0.785398\nName: Northness, dtype: float64\ncount    368579.000000\nmean         -0.040279\nstd           0.583256\nmin          -0.785398\n25%          -0.643895\n50%          -0.087261\n75%           0.573790\nmax           0.785398\nName: Eastness, dtype: float64\nNew dem features are updated in /home/chetana/gridmet_test_run/dem_all.csv\n",
  "history_begin_time" : 1700466244115,
  "history_end_time" : 1700466261601,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "DqC4dpv1meWS",
  "history_input" : "import numpy as np\nimport pandas as pd\nfrom osgeo import gdal\nimport warnings\nimport rasterio\nimport csv\nfrom rasterio.transform import Affine\nfrom scipy.ndimage import sobel, gaussian_filter\n\nmile_to_meters = 1609.34\nfeet_to_meters = 0.3048\n\n# Set the warning filter globally to ignore the FutureWarning\nwarnings.simplefilter(\"ignore\", FutureWarning)\n\ndef lat_lon_to_pixel(lat, lon, geotransform):\n    \"\"\"\n    Convert latitude and longitude to pixel coordinates using a geotransform.\n\n    Args:\n        lat (float): Latitude.\n        lon (float): Longitude.\n        geotransform (tuple): Geotransform coefficients (e.g., (origin_x, pixel_width, 0, origin_y, 0, pixel_height)).\n\n    Returns:\n        tuple: Pixel coordinates (x, y).\n    \"\"\"\n    x = int((lon - geotransform[0]) / geotransform[1])\n    y = int((lat - geotransform[3]) / geotransform[5])\n    return x, y\n\ndef calculate_slope_aspect_for_single(elevation_data, pixel_size_x, pixel_size_y):\n    \"\"\"\n    Calculate slope and aspect for a single pixel using elevation data.\n\n    Args:\n        elevation_data (array): Elevation data.\n        pixel_size_x (float): Pixel size in the x-direction.\n        pixel_size_y (float): Pixel size in the y-direction.\n\n    Returns:\n        tuple: Slope (in degrees), aspect (in degrees).\n    \"\"\"\n    # Calculate slope using the Sobel operator\n    slope_x = np.gradient(elevation_data, pixel_size_x, axis=1)\n    slope_y = np.gradient(elevation_data, pixel_size_y, axis=0)\n    slope_rad = np.arctan(np.sqrt(slope_x ** 2 + slope_y ** 2))\n    slope_deg = np.degrees(slope_rad)\n\n    # Calculate aspect (direction of the steepest descent)\n    aspect_rad = np.arctan2(slope_y, -slope_x)\n    aspect_deg = (np.degrees(aspect_rad) + 360) % 360\n\n    return slope_deg, aspect_deg\n\ndef save_as_geotiff(data, output_file, src_file):\n    \"\"\"\n    Save data as a GeoTIFF file with metadata from the source file.\n\n    Args:\n        data (array): Data to be saved.\n        output_file (str): Path to the output GeoTIFF file.\n        src_file (str): Path to the source GeoTIFF file to inherit metadata from.\n    \"\"\"\n    with rasterio.open(src_file) as src_dataset:\n        profile = src_dataset.profile\n        transform = src_dataset.transform\n\n        # Update the data type, count, and set the transform for the new dataset\n        profile.update(dtype=rasterio.float32, count=1, transform=transform)\n\n        # Create the new GeoTIFF file\n        with rasterio.open(output_file, 'w', **profile) as dst_dataset:\n            # Write the data to the new GeoTIFF\n            dst_dataset.write(data, 1)\n\ndef print_statistics(data):\n    \"\"\"\n    Print basic statistics of a data array.\n\n    Args:\n        data (array): Data array to calculate statistics for.\n    \"\"\"\n    # Calculate multiple statistics in one line\n    data = data[~np.isnan(data)]\n    mean, median, min_val, max_val, sum_val, std_dev, variance = [np.mean(data), np.median(data), np.min(data), np.max(data), np.sum(data), np.std(data), np.var(data)]\n\n    # Print the calculated statistics\n    print(\"Mean:\", mean)\n    print(\"Median:\", median)\n    print(\"Minimum:\", min_val)\n    print(\"Maximum:\", max_val)\n    print(\"Sum:\", sum_val)\n    print(\"Standard Deviation:\", std_dev)\n    print(\"Variance:\", variance)\n\ndef calculate_slope(dem_file):\n    from osgeo import gdal\n    import numpy as np\n    import rasterio\n    gdal.DEMProcessing(f'{dem_file}_slope.tif', dem_file, 'slope')\n    with rasterio.open(f'{dem_file}_slope.tif') as dataset:\n        slope=dataset.read(1)\n    return slope\n  \ndef calculate_aspect(dem_file):\n    from osgeo import gdal\n    import numpy as np\n    import rasterio\n    gdal.DEMProcessing(f'{dem_file}_aspect.tif', dem_file, 'aspect')\n    with rasterio.open(f'{dem_file}_aspect.tif') as dataset:\n        aspect=dataset.read(1)\n    return aspect\n    \n    \ndef calculate_slope_aspect(dem_file):\n    \"\"\"\n    Calculate slope and aspect from a DEM (Digital Elevation Model) file.\n\n    Args:\n        dem_file (str): Path to the DEM GeoTIFF file.\n\n    Returns:\n        tuple: Slope array (in degrees), aspect array (in degrees).\n    \"\"\"\n    with rasterio.open(dem_file) as dataset:\n        # Read the DEM data as a numpy array\n        dem_data = dataset.read(1)\n\n        # Get the geotransform to convert pixel coordinates to geographic coordinates\n        transform = dataset.transform\n\n        # Calculate the slope and aspect using numpy\n        dx, dy = np.gradient(dem_data, transform[0], transform[4])\n        slope = np.arctan(np.sqrt(dx**2 + dy**2))\n        slope = np.degrees(slope)\n        aspect = np.degrees(np.arctan2(-dy, dx))\n\n        # Adjust aspect values to range from 0 to 360 degrees\n        aspect[aspect < 0] += 360\n\n    return slope, aspect\n\ndef calculate_curvature(elevation_data, pixel_size_x, pixel_size_y):\n    \"\"\"\n    Calculate curvature from elevation data using the Laplacian operator.\n\n    Args:\n        elevation_data (array): Elevation data.\n        pixel_size_x (float): Pixel size in the x-direction.\n        pixel_size_y (float): Pixel size in the y-direction.\n\n    Returns:\n        array: Curvature data.\n    \"\"\"\n    # Calculate curvature using the Laplacian operator\n    curvature_x = np.gradient(np.gradient(elevation_data, pixel_size_x, axis=1), pixel_size_x, axis=1)\n    curvature_y = np.gradient(np.gradient(elevation_data, pixel_size_y, axis=0), pixel_size_y, axis=0)\n    curvature = curvature_x + curvature_y\n\n    return curvature\n  \ndef calculate_curvature(dem_file, sigma=1):\n    with rasterio.open(dem_file) as dataset:\n        # Read the DEM data as a numpy array\n        dem_data = dataset.read(1)\n        \n        # the dem is in meter unit\n        dem_data = dem_data\n\n        # Calculate the gradient using the Sobel filter\n        dx = sobel(dem_data, axis=1, mode='constant')\n        dy = sobel(dem_data, axis=0, mode='constant')\n\n        # Calculate the second derivatives using the Sobel filter\n        dxx = sobel(dx, axis=1, mode='constant')\n        dyy = sobel(dy, axis=0, mode='constant')\n\n        # Calculate the curvature using the second derivatives\n        curvature = dxx + dyy\n\n        # Smooth the curvature using Gaussian filtering (optional)\n        curvature = gaussian_filter(curvature, sigma)\n\n    return curvature\n\ndef calculate_gradients(dem_file):\n    \"\"\"\n    Calculate Northness and Eastness gradients from a DEM (Digital Elevation Model) file.\n\n    Args:\n        dem_file (str): Path to the DEM GeoTIFF file.\n\n    Returns:\n        tuple: Northness array, Eastness array (both in radians).\n    \"\"\"\n    with rasterio.open(dem_file) as dataset:\n        # Read the DEM data as a numpy array\n        dem_data = dataset.read(1)\n\n        # Calculate the gradients along the North and East directions\n        dy, dx = np.gradient(dem_data, dataset.res[0], dataset.res[1])\n\n        # Calculate the Northness and Eastness\n        northness = np.arctan(dy / np.sqrt(dx**2 + dy**2))\n        eastness = np.arctan(dx / np.sqrt(dx**2 + dy**2))\n\n    return northness, eastness\n\ndef geotiff_to_csv(geotiff_file, csv_file, column_name):\n    \"\"\"\n    Convert a GeoTIFF file to a CSV file containing latitude, longitude, and image values.\n\n    Args:\n        geotiff_file (str): Path to the input GeoTIFF file.\n        csv_file (str): Path to the output CSV file.\n        column_name (str): Name for the image value column.\n    \"\"\"\n    # Open the GeoTIFF file\n    with rasterio.open(geotiff_file) as dataset:\n        # Get the pixel values as a 2D array\n        data = dataset.read(1)\n\n        if column_name == \"Elevation\":\n            # default unit is meter\n            data = data\n\n        # Get the geotransform to convert pixel coordinates to geographic coordinates\n        transform = dataset.transform\n\n        # Get the width and height of the GeoTIFF\n        height, width = data.shape\n\n        # Open the CSV file for writing\n        with open(csv_file, 'w', newline='') as csvfile:\n            csvwriter = csv.writer(csvfile)\n\n            # Write the CSV header\n            csvwriter.writerow(['Latitude', 'Longitude', 'x', 'y', column_name])\n\n            # Loop through each pixel and extract latitude, longitude, and image value\n            for y in range(height):\n                for x in range(width):\n                    # Get the pixel value\n                    image_value = data[y, x]\n\n                    # Convert pixel coordinates to geographic coordinates\n                    lon, lat = transform * (x, y)\n\n                    # Write the data to the CSV file\n                    csvwriter.writerow([lat, lon, x, y, image_value])\n\ndef read_elevation_data(file_path, result_dem_csv_path, result_dem_feature_csv_path):\n    \"\"\"\n    Read and process elevation data from a CSV file and save it to another CSV file with additional features.\n\n    Args:\n        file_path (str): Path to the input CSV file containing elevation data.\n        result_dem_csv_path (str): Path to the output CSV file for elevation data.\n        result_dem_feature_csv_path (str): Path to the output CSV file for elevation data with additional features.\n\n    Returns:\n        DataFrame: Merged dataframe with elevation and additional features.\n    \"\"\"\n    neighborhood_size = 4\n    df = pd.read_csv(file_path)\n    \n    dataset = rasterio.open(geotiff_file)\n    data = dataset.read(1)\n\n    # Get the width and height of the GeoTIFF\n    height, width = data.shape\n    \n    # Create an empty DataFrame with column names\n    columns = ['lat', 'lon', 'elevation', 'slope', 'aspect', 'curvature', 'northness', 'eastness']\n    all_df = pd.DataFrame(columns=columns)\n    \n    all_df.to_csv(result_dem_feature_csv_path)\n    print(f\"DEM and other columns are saved to file {result_dem_feature_csv_path}\")\n    return all_df\n\n  \n\n# Usage example:\nresult_dem_csv_path = \"/home/chetana/gridmet_test_run/dem_template.csv\"\nresult_dem_feature_csv_path = \"/home/chetana/gridmet_test_run/dem_all.csv\"\n\ndem_file = \"/home/chetana/gridmet_test_run/dem_file.tif\"\nslope_file = '/home/chetana/gridmet_test_run/slope_file.tif'\naspect_file = '/home/chetana/gridmet_test_run/aspect_file.tif'\ncurvature_file = '/home/chetana/gridmet_test_run/curvature_file.tif'\nnorthness_file = '/home/chetana/gridmet_test_run/northness_file.tif'\neastness_file = '/home/chetana/gridmet_test_run/eastness_file.tif'\n\n#slope, aspect = calculate_slope_aspect(dem_file)\nslope = calculate_slope(dem_file)\naspect = calculate_aspect(dem_file)\ncurvature = calculate_curvature(dem_file)\nnorthness, eastness = calculate_gradients(dem_file)\n\n# Save the slope and aspect as new GeoTIFF files\nsave_as_geotiff(slope, slope_file, dem_file)\nsave_as_geotiff(aspect, aspect_file, dem_file)\nsave_as_geotiff(curvature, curvature_file, dem_file)\nsave_as_geotiff(northness, northness_file, dem_file)\nsave_as_geotiff(eastness, eastness_file, dem_file)\n\ngeotiff_to_csv(dem_file, dem_file+\".csv\", \"Elevation\")\ngeotiff_to_csv(slope_file, slope_file+\".csv\", \"Slope\")\ngeotiff_to_csv(aspect_file, aspect_file+\".csv\", \"Aspect\")\ngeotiff_to_csv(curvature_file, curvature_file+\".csv\", \"Curvature\")\ngeotiff_to_csv(northness_file, northness_file+\".csv\", \"Northness\")\ngeotiff_to_csv(eastness_file, eastness_file+\".csv\", \"Eastness\")\n\n# List of file paths for the CSV files\ncsv_files = [dem_file+\".csv\", slope_file+\".csv\", aspect_file+\".csv\", \n             curvature_file+\".csv\", northness_file+\".csv\", eastness_file+\".csv\"]\n\n# Initialize an empty list to store all dataframes\ndfs = []\n\n# Read each CSV file into separate dataframes\nfor file in csv_files:\n    df = pd.read_csv(file, encoding='utf-8')\n    dfs.append(df)\n\n# Merge the dataframes based on the latitude and longitude columns\nmerged_df = dfs[0]  # Start with the first dataframe\nfor i in range(1, len(dfs)):\n    merged_df = pd.merge(merged_df, dfs[i], on=['Latitude', 'Longitude', 'x', 'y'])\n\n# check the statistics of the columns\nfor column in merged_df.columns:\n    merged_df[column] = pd.to_numeric(merged_df[column], errors='coerce')\n    print(merged_df[column].describe())\n    \n# Save the merged dataframe to a new CSV file\nmerged_df.to_csv(result_dem_feature_csv_path, index=False)\nprint(f\"New dem features are updated in {result_dem_feature_csv_path}\")\n",
  "history_output" : "/home/chetana/gw-workspace/DqC4dpv1meWS/western_us_dem.py:205: RuntimeWarning: invalid value encountered in divide\n  northness = np.arctan(dy / np.sqrt(dx**2 + dy**2))\n/home/chetana/gw-workspace/DqC4dpv1meWS/western_us_dem.py:206: RuntimeWarning: invalid value encountered in divide\n  eastness = np.arctan(dx / np.sqrt(dx**2 + dy**2))\ncount    462204.000000\nmean         37.030000\nstd           6.921275\nmin          25.060000\n25%          31.036000\n50%          37.030000\n75%          43.024000\nmax          49.000000\nName: Latitude, dtype: float64\ncount    462204.00000\nmean       -112.52600\nstd           7.21226\nmin        -125.00000\n25%        -118.77200\n50%        -112.52600\n75%        -106.28000\nmax        -100.05200\nName: Longitude, dtype: float64\ncount    462204.000000\nmean        346.500000\nstd         200.340552\nmin           0.000000\n25%         173.000000\n50%         346.500000\n75%         520.000000\nmax         693.000000\nName: x, dtype: float64\ncount    462204.000000\nmean        332.500000\nstd         192.257631\nmin           0.000000\n25%         166.000000\n50%         332.500000\n75%         499.000000\nmax         665.000000\nName: y, dtype: float64\ncount    462204.000000\nmean       1025.629083\nstd         808.945819\nmin         -82.938410\n25%         180.727250\n50%        1018.458080\n75%        1604.870600\nmax        4177.173000\nName: Elevation, dtype: float64\ncount    462204.000000\nmean         12.747597\nstd         770.562792\nmin       -9999.000000\n25%          89.697390\n50%          89.938610\n75%          89.978860\nmax          89.998210\nName: Slope, dtype: float64\ncount    462204.000000\nmean      -1904.824847\nstd        4099.062552\nmin       -9999.000000\n25%          19.073003\n50%         121.330820\n75%         230.338588\nmax         359.998500\nName: Aspect, dtype: float64\ncount    462204.000000\nmean        -49.124993\nstd        2819.341836\nmin      -41085.560000\n25%        -482.398620\n50%           0.000000\n75%         840.230590\nmax       21411.324000\nName: Curvature, dtype: float64\ncount    368579.000000\nmean         -0.012698\nstd           0.587101\nmin          -0.785398\n25%          -0.626382\n50%          -0.027939\n75%           0.608819\nmax           0.785398\nName: Northness, dtype: float64\ncount    368579.000000\nmean         -0.040279\nstd           0.583256\nmin          -0.785398\n25%          -0.643895\n50%          -0.087261\n75%           0.573790\nmax           0.785398\nName: Eastness, dtype: float64\nNew dem features are updated in /home/chetana/gridmet_test_run/dem_all.csv\n",
  "history_begin_time" : 1700466124784,
  "history_end_time" : 1700466142776,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "LToKZMIFx1T9",
  "history_input" : "import numpy as np\nimport pandas as pd\nfrom osgeo import gdal\nimport warnings\nimport rasterio\nimport csv\nfrom rasterio.transform import Affine\nfrom scipy.ndimage import sobel, gaussian_filter\n\nmile_to_meters = 1609.34\nfeet_to_meters = 0.3048\n\n# Set the warning filter globally to ignore the FutureWarning\nwarnings.simplefilter(\"ignore\", FutureWarning)\n\ndef lat_lon_to_pixel(lat, lon, geotransform):\n    \"\"\"\n    Convert latitude and longitude to pixel coordinates using a geotransform.\n\n    Args:\n        lat (float): Latitude.\n        lon (float): Longitude.\n        geotransform (tuple): Geotransform coefficients (e.g., (origin_x, pixel_width, 0, origin_y, 0, pixel_height)).\n\n    Returns:\n        tuple: Pixel coordinates (x, y).\n    \"\"\"\n    x = int((lon - geotransform[0]) / geotransform[1])\n    y = int((lat - geotransform[3]) / geotransform[5])\n    return x, y\n\ndef calculate_slope_aspect_for_single(elevation_data, pixel_size_x, pixel_size_y):\n    \"\"\"\n    Calculate slope and aspect for a single pixel using elevation data.\n\n    Args:\n        elevation_data (array): Elevation data.\n        pixel_size_x (float): Pixel size in the x-direction.\n        pixel_size_y (float): Pixel size in the y-direction.\n\n    Returns:\n        tuple: Slope (in degrees), aspect (in degrees).\n    \"\"\"\n    # Calculate slope using the Sobel operator\n    slope_x = np.gradient(elevation_data, pixel_size_x, axis=1)\n    slope_y = np.gradient(elevation_data, pixel_size_y, axis=0)\n    slope_rad = np.arctan(np.sqrt(slope_x ** 2 + slope_y ** 2))\n    slope_deg = np.degrees(slope_rad)\n\n    # Calculate aspect (direction of the steepest descent)\n    aspect_rad = np.arctan2(slope_y, -slope_x)\n    aspect_deg = (np.degrees(aspect_rad) + 360) % 360\n\n    return slope_deg, aspect_deg\n\ndef save_as_geotiff(data, output_file, src_file):\n    \"\"\"\n    Save data as a GeoTIFF file with metadata from the source file.\n\n    Args:\n        data (array): Data to be saved.\n        output_file (str): Path to the output GeoTIFF file.\n        src_file (str): Path to the source GeoTIFF file to inherit metadata from.\n    \"\"\"\n    with rasterio.open(src_file) as src_dataset:\n        profile = src_dataset.profile\n        transform = src_dataset.transform\n\n        # Update the data type, count, and set the transform for the new dataset\n        profile.update(dtype=rasterio.float32, count=1, transform=transform)\n\n        # Create the new GeoTIFF file\n        with rasterio.open(output_file, 'w', **profile) as dst_dataset:\n            # Write the data to the new GeoTIFF\n            dst_dataset.write(data, 1)\n\ndef print_statistics(data):\n    \"\"\"\n    Print basic statistics of a data array.\n\n    Args:\n        data (array): Data array to calculate statistics for.\n    \"\"\"\n    # Calculate multiple statistics in one line\n    data = data[~np.isnan(data)]\n    mean, median, min_val, max_val, sum_val, std_dev, variance = [np.mean(data), np.median(data), np.min(data), np.max(data), np.sum(data), np.std(data), np.var(data)]\n\n    # Print the calculated statistics\n    print(\"Mean:\", mean)\n    print(\"Median:\", median)\n    print(\"Minimum:\", min_val)\n    print(\"Maximum:\", max_val)\n    print(\"Sum:\", sum_val)\n    print(\"Standard Deviation:\", std_dev)\n    print(\"Variance:\", variance)\n\ndef calculate_slope(dem_file):\n    from osgeo import gdal\n    import numpy as np\n    import rasterio\n    gdal.DEMProcessing(f'{dem_file}_slope.tif', DEM, 'slope')\n    with rasterio.open(f'{dem_file}_slope.tif') as dataset:\n        slope=dataset.read(1)\n    return slope\n  \ndef calculate_aspect(dem_file):\n    from osgeo import gdal\n    import numpy as np\n    import rasterio\n    gdal.DEMProcessing(f'{dem_file}_aspect.tif', DEM, 'aspect')\n    with rasterio.open(f'{dem_file}_aspect.tif') as dataset:\n        aspect=dataset.read(1)\n    return aspect\n    \n    \ndef calculate_slope_aspect(dem_file):\n    \"\"\"\n    Calculate slope and aspect from a DEM (Digital Elevation Model) file.\n\n    Args:\n        dem_file (str): Path to the DEM GeoTIFF file.\n\n    Returns:\n        tuple: Slope array (in degrees), aspect array (in degrees).\n    \"\"\"\n    with rasterio.open(dem_file) as dataset:\n        # Read the DEM data as a numpy array\n        dem_data = dataset.read(1)\n\n        # Get the geotransform to convert pixel coordinates to geographic coordinates\n        transform = dataset.transform\n\n        # Calculate the slope and aspect using numpy\n        dx, dy = np.gradient(dem_data, transform[0], transform[4])\n        slope = np.arctan(np.sqrt(dx**2 + dy**2))\n        slope = np.degrees(slope)\n        aspect = np.degrees(np.arctan2(-dy, dx))\n\n        # Adjust aspect values to range from 0 to 360 degrees\n        aspect[aspect < 0] += 360\n\n    return slope, aspect\n\ndef calculate_curvature(elevation_data, pixel_size_x, pixel_size_y):\n    \"\"\"\n    Calculate curvature from elevation data using the Laplacian operator.\n\n    Args:\n        elevation_data (array): Elevation data.\n        pixel_size_x (float): Pixel size in the x-direction.\n        pixel_size_y (float): Pixel size in the y-direction.\n\n    Returns:\n        array: Curvature data.\n    \"\"\"\n    # Calculate curvature using the Laplacian operator\n    curvature_x = np.gradient(np.gradient(elevation_data, pixel_size_x, axis=1), pixel_size_x, axis=1)\n    curvature_y = np.gradient(np.gradient(elevation_data, pixel_size_y, axis=0), pixel_size_y, axis=0)\n    curvature = curvature_x + curvature_y\n\n    return curvature\n  \ndef calculate_curvature(dem_file, sigma=1):\n    with rasterio.open(dem_file) as dataset:\n        # Read the DEM data as a numpy array\n        dem_data = dataset.read(1)\n        \n        # the dem is in meter unit\n        dem_data = dem_data\n\n        # Calculate the gradient using the Sobel filter\n        dx = sobel(dem_data, axis=1, mode='constant')\n        dy = sobel(dem_data, axis=0, mode='constant')\n\n        # Calculate the second derivatives using the Sobel filter\n        dxx = sobel(dx, axis=1, mode='constant')\n        dyy = sobel(dy, axis=0, mode='constant')\n\n        # Calculate the curvature using the second derivatives\n        curvature = dxx + dyy\n\n        # Smooth the curvature using Gaussian filtering (optional)\n        curvature = gaussian_filter(curvature, sigma)\n\n    return curvature\n\ndef calculate_gradients(dem_file):\n    \"\"\"\n    Calculate Northness and Eastness gradients from a DEM (Digital Elevation Model) file.\n\n    Args:\n        dem_file (str): Path to the DEM GeoTIFF file.\n\n    Returns:\n        tuple: Northness array, Eastness array (both in radians).\n    \"\"\"\n    with rasterio.open(dem_file) as dataset:\n        # Read the DEM data as a numpy array\n        dem_data = dataset.read(1)\n\n        # Calculate the gradients along the North and East directions\n        dy, dx = np.gradient(dem_data, dataset.res[0], dataset.res[1])\n\n        # Calculate the Northness and Eastness\n        northness = np.arctan(dy / np.sqrt(dx**2 + dy**2))\n        eastness = np.arctan(dx / np.sqrt(dx**2 + dy**2))\n\n    return northness, eastness\n\ndef geotiff_to_csv(geotiff_file, csv_file, column_name):\n    \"\"\"\n    Convert a GeoTIFF file to a CSV file containing latitude, longitude, and image values.\n\n    Args:\n        geotiff_file (str): Path to the input GeoTIFF file.\n        csv_file (str): Path to the output CSV file.\n        column_name (str): Name for the image value column.\n    \"\"\"\n    # Open the GeoTIFF file\n    with rasterio.open(geotiff_file) as dataset:\n        # Get the pixel values as a 2D array\n        data = dataset.read(1)\n\n        if column_name == \"Elevation\":\n            # default unit is meter\n            data = data\n\n        # Get the geotransform to convert pixel coordinates to geographic coordinates\n        transform = dataset.transform\n\n        # Get the width and height of the GeoTIFF\n        height, width = data.shape\n\n        # Open the CSV file for writing\n        with open(csv_file, 'w', newline='') as csvfile:\n            csvwriter = csv.writer(csvfile)\n\n            # Write the CSV header\n            csvwriter.writerow(['Latitude', 'Longitude', 'x', 'y', column_name])\n\n            # Loop through each pixel and extract latitude, longitude, and image value\n            for y in range(height):\n                for x in range(width):\n                    # Get the pixel value\n                    image_value = data[y, x]\n\n                    # Convert pixel coordinates to geographic coordinates\n                    lon, lat = transform * (x, y)\n\n                    # Write the data to the CSV file\n                    csvwriter.writerow([lat, lon, x, y, image_value])\n\ndef read_elevation_data(file_path, result_dem_csv_path, result_dem_feature_csv_path):\n    \"\"\"\n    Read and process elevation data from a CSV file and save it to another CSV file with additional features.\n\n    Args:\n        file_path (str): Path to the input CSV file containing elevation data.\n        result_dem_csv_path (str): Path to the output CSV file for elevation data.\n        result_dem_feature_csv_path (str): Path to the output CSV file for elevation data with additional features.\n\n    Returns:\n        DataFrame: Merged dataframe with elevation and additional features.\n    \"\"\"\n    neighborhood_size = 4\n    df = pd.read_csv(file_path)\n    \n    dataset = rasterio.open(geotiff_file)\n    data = dataset.read(1)\n\n    # Get the width and height of the GeoTIFF\n    height, width = data.shape\n    \n    # Create an empty DataFrame with column names\n    columns = ['lat', 'lon', 'elevation', 'slope', 'aspect', 'curvature', 'northness', 'eastness']\n    all_df = pd.DataFrame(columns=columns)\n    \n    all_df.to_csv(result_dem_feature_csv_path)\n    print(f\"DEM and other columns are saved to file {result_dem_feature_csv_path}\")\n    return all_df\n\n  \n\n# Usage example:\nresult_dem_csv_path = \"/home/chetana/gridmet_test_run/dem_template.csv\"\nresult_dem_feature_csv_path = \"/home/chetana/gridmet_test_run/dem_all.csv\"\n\ndem_file = \"/home/chetana/gridmet_test_run/dem_file.tif\"\nslope_file = '/home/chetana/gridmet_test_run/slope_file.tif'\naspect_file = '/home/chetana/gridmet_test_run/aspect_file.tif'\ncurvature_file = '/home/chetana/gridmet_test_run/curvature_file.tif'\nnorthness_file = '/home/chetana/gridmet_test_run/northness_file.tif'\neastness_file = '/home/chetana/gridmet_test_run/eastness_file.tif'\n\n#slope, aspect = calculate_slope_aspect(dem_file)\nslope = calculate_slope(dem_file)\naspect = calculate_aspect(dem_file)\ncurvature = calculate_curvature(dem_file)\nnorthness, eastness = calculate_gradients(dem_file)\n\n# Save the slope and aspect as new GeoTIFF files\nsave_as_geotiff(slope, slope_file, dem_file)\nsave_as_geotiff(aspect, aspect_file, dem_file)\nsave_as_geotiff(curvature, curvature_file, dem_file)\nsave_as_geotiff(northness, northness_file, dem_file)\nsave_as_geotiff(eastness, eastness_file, dem_file)\n\ngeotiff_to_csv(dem_file, dem_file+\".csv\", \"Elevation\")\ngeotiff_to_csv(slope_file, slope_file+\".csv\", \"Slope\")\ngeotiff_to_csv(aspect_file, aspect_file+\".csv\", \"Aspect\")\ngeotiff_to_csv(curvature_file, curvature_file+\".csv\", \"Curvature\")\ngeotiff_to_csv(northness_file, northness_file+\".csv\", \"Northness\")\ngeotiff_to_csv(eastness_file, eastness_file+\".csv\", \"Eastness\")\n\n# List of file paths for the CSV files\ncsv_files = [dem_file+\".csv\", slope_file+\".csv\", aspect_file+\".csv\", \n             curvature_file+\".csv\", northness_file+\".csv\", eastness_file+\".csv\"]\n\n# Initialize an empty list to store all dataframes\ndfs = []\n\n# Read each CSV file into separate dataframes\nfor file in csv_files:\n    df = pd.read_csv(file, encoding='utf-8')\n    dfs.append(df)\n\n# Merge the dataframes based on the latitude and longitude columns\nmerged_df = dfs[0]  # Start with the first dataframe\nfor i in range(1, len(dfs)):\n    merged_df = pd.merge(merged_df, dfs[i], on=['Latitude', 'Longitude', 'x', 'y'])\n\n# check the statistics of the columns\nfor column in merged_df.columns:\n    merged_df[column] = pd.to_numeric(merged_df[column], errors='coerce')\n    print(merged_df[column].describe())\n    \n# Save the merged dataframe to a new CSV file\nmerged_df.to_csv(result_dem_feature_csv_path, index=False)\nprint(f\"New dem features are updated in {result_dem_feature_csv_path}\")\n",
  "history_output" : "Traceback (most recent call last):\n  File \"/home/chetana/gw-workspace/LToKZMIFx1T9/western_us_dem.py\", line 296, in <module>\n    slope = calculate_slope(dem_file)\n  File \"/home/chetana/gw-workspace/LToKZMIFx1T9/western_us_dem.py\", line 101, in calculate_slope\n    gdal.DEMProcessing(f'{dem_file}_slope.tif', DEM, 'slope')\nNameError: name 'DEM' is not defined\n",
  "history_begin_time" : 1700466083831,
  "history_end_time" : 1700466084603,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : null,
  "indicator" : "Failed"
},{
  "history_id" : "lyk4KqzEdGoO",
  "history_input" : "import numpy as np\nimport pandas as pd\nfrom osgeo import gdal\nimport warnings\nimport rasterio\nimport csv\nfrom rasterio.transform import Affine\nfrom scipy.ndimage import sobel, gaussian_filter\n\nmile_to_meters = 1609.34\nfeet_to_meters = 0.3048\n\n# Set the warning filter globally to ignore the FutureWarning\nwarnings.simplefilter(\"ignore\", FutureWarning)\n\ndef lat_lon_to_pixel(lat, lon, geotransform):\n    \"\"\"\n    Convert latitude and longitude to pixel coordinates using a geotransform.\n\n    Args:\n        lat (float): Latitude.\n        lon (float): Longitude.\n        geotransform (tuple): Geotransform coefficients (e.g., (origin_x, pixel_width, 0, origin_y, 0, pixel_height)).\n\n    Returns:\n        tuple: Pixel coordinates (x, y).\n    \"\"\"\n    x = int((lon - geotransform[0]) / geotransform[1])\n    y = int((lat - geotransform[3]) / geotransform[5])\n    return x, y\n\ndef calculate_slope_aspect_for_single(elevation_data, pixel_size_x, pixel_size_y):\n    \"\"\"\n    Calculate slope and aspect for a single pixel using elevation data.\n\n    Args:\n        elevation_data (array): Elevation data.\n        pixel_size_x (float): Pixel size in the x-direction.\n        pixel_size_y (float): Pixel size in the y-direction.\n\n    Returns:\n        tuple: Slope (in degrees), aspect (in degrees).\n    \"\"\"\n    # Calculate slope using the Sobel operator\n    slope_x = np.gradient(elevation_data, pixel_size_x, axis=1)\n    slope_y = np.gradient(elevation_data, pixel_size_y, axis=0)\n    slope_rad = np.arctan(np.sqrt(slope_x ** 2 + slope_y ** 2))\n    slope_deg = np.degrees(slope_rad)\n\n    # Calculate aspect (direction of the steepest descent)\n    aspect_rad = np.arctan2(slope_y, -slope_x)\n    aspect_deg = (np.degrees(aspect_rad) + 360) % 360\n\n    return slope_deg, aspect_deg\n\ndef save_as_geotiff(data, output_file, src_file):\n    \"\"\"\n    Save data as a GeoTIFF file with metadata from the source file.\n\n    Args:\n        data (array): Data to be saved.\n        output_file (str): Path to the output GeoTIFF file.\n        src_file (str): Path to the source GeoTIFF file to inherit metadata from.\n    \"\"\"\n    with rasterio.open(src_file) as src_dataset:\n        profile = src_dataset.profile\n        transform = src_dataset.transform\n\n        # Update the data type, count, and set the transform for the new dataset\n        profile.update(dtype=rasterio.float32, count=1, transform=transform)\n\n        # Create the new GeoTIFF file\n        with rasterio.open(output_file, 'w', **profile) as dst_dataset:\n            # Write the data to the new GeoTIFF\n            dst_dataset.write(data, 1)\n\ndef print_statistics(data):\n    \"\"\"\n    Print basic statistics of a data array.\n\n    Args:\n        data (array): Data array to calculate statistics for.\n    \"\"\"\n    # Calculate multiple statistics in one line\n    data = data[~np.isnan(data)]\n    mean, median, min_val, max_val, sum_val, std_dev, variance = [np.mean(data), np.median(data), np.min(data), np.max(data), np.sum(data), np.std(data), np.var(data)]\n\n    # Print the calculated statistics\n    print(\"Mean:\", mean)\n    print(\"Median:\", median)\n    print(\"Minimum:\", min_val)\n    print(\"Maximum:\", max_val)\n    print(\"Sum:\", sum_val)\n    print(\"Standard Deviation:\", std_dev)\n    print(\"Variance:\", variance)\n\ndef calculate_slope_aspect(dem_file):\n    \"\"\"\n    Calculate slope and aspect from a DEM (Digital Elevation Model) file.\n\n    Args:\n        dem_file (str): Path to the DEM GeoTIFF file.\n\n    Returns:\n        tuple: Slope array (in degrees), aspect array (in degrees).\n    \"\"\"\n    with rasterio.open(dem_file) as dataset:\n        # Read the DEM data as a numpy array\n        dem_data = dataset.read(1)\n\n        # Get the geotransform to convert pixel coordinates to geographic coordinates\n        transform = dataset.transform\n\n        # Calculate the slope and aspect using numpy\n        dx, dy = np.gradient(dem_data, transform[0], transform[4])\n        slope = np.arctan(np.sqrt(dx**2 + dy**2))\n        slope = np.degrees(slope)\n        aspect = np.degrees(np.arctan2(-dy, dx))\n\n        # Adjust aspect values to range from 0 to 360 degrees\n        aspect[aspect < 0] += 360\n\n    return slope, aspect\n\ndef calculate_curvature(elevation_data, pixel_size_x, pixel_size_y):\n    \"\"\"\n    Calculate curvature from elevation data using the Laplacian operator.\n\n    Args:\n        elevation_data (array): Elevation data.\n        pixel_size_x (float): Pixel size in the x-direction.\n        pixel_size_y (float): Pixel size in the y-direction.\n\n    Returns:\n        array: Curvature data.\n    \"\"\"\n    # Calculate curvature using the Laplacian operator\n    curvature_x = np.gradient(np.gradient(elevation_data, pixel_size_x, axis=1), pixel_size_x, axis=1)\n    curvature_y = np.gradient(np.gradient(elevation_data, pixel_size_y, axis=0), pixel_size_y, axis=0)\n    curvature = curvature_x + curvature_y\n\n    return curvature\n  \ndef calculate_curvature(dem_file, sigma=1):\n    with rasterio.open(dem_file) as dataset:\n        # Read the DEM data as a numpy array\n        dem_data = dataset.read(1)\n        \n        # the dem is in meter unit\n        dem_data = dem_data\n\n        # Calculate the gradient using the Sobel filter\n        dx = sobel(dem_data, axis=1, mode='constant')\n        dy = sobel(dem_data, axis=0, mode='constant')\n\n        # Calculate the second derivatives using the Sobel filter\n        dxx = sobel(dx, axis=1, mode='constant')\n        dyy = sobel(dy, axis=0, mode='constant')\n\n        # Calculate the curvature using the second derivatives\n        curvature = dxx + dyy\n\n        # Smooth the curvature using Gaussian filtering (optional)\n        curvature = gaussian_filter(curvature, sigma)\n\n    return curvature\n\ndef calculate_gradients(dem_file):\n    \"\"\"\n    Calculate Northness and Eastness gradients from a DEM (Digital Elevation Model) file.\n\n    Args:\n        dem_file (str): Path to the DEM GeoTIFF file.\n\n    Returns:\n        tuple: Northness array, Eastness array (both in radians).\n    \"\"\"\n    with rasterio.open(dem_file) as dataset:\n        # Read the DEM data as a numpy array\n        dem_data = dataset.read(1)\n\n        # Calculate the gradients along the North and East directions\n        dy, dx = np.gradient(dem_data, dataset.res[0], dataset.res[1])\n\n        # Calculate the Northness and Eastness\n        northness = np.arctan(dy / np.sqrt(dx**2 + dy**2))\n        eastness = np.arctan(dx / np.sqrt(dx**2 + dy**2))\n\n    return northness, eastness\n\ndef geotiff_to_csv(geotiff_file, csv_file, column_name):\n    \"\"\"\n    Convert a GeoTIFF file to a CSV file containing latitude, longitude, and image values.\n\n    Args:\n        geotiff_file (str): Path to the input GeoTIFF file.\n        csv_file (str): Path to the output CSV file.\n        column_name (str): Name for the image value column.\n    \"\"\"\n    # Open the GeoTIFF file\n    with rasterio.open(geotiff_file) as dataset:\n        # Get the pixel values as a 2D array\n        data = dataset.read(1)\n\n        if column_name == \"Elevation\":\n            # default unit is meter\n            data = data\n\n        # Get the geotransform to convert pixel coordinates to geographic coordinates\n        transform = dataset.transform\n\n        # Get the width and height of the GeoTIFF\n        height, width = data.shape\n\n        # Open the CSV file for writing\n        with open(csv_file, 'w', newline='') as csvfile:\n            csvwriter = csv.writer(csvfile)\n\n            # Write the CSV header\n            csvwriter.writerow(['Latitude', 'Longitude', 'x', 'y', column_name])\n\n            # Loop through each pixel and extract latitude, longitude, and image value\n            for y in range(height):\n                for x in range(width):\n                    # Get the pixel value\n                    image_value = data[y, x]\n\n                    # Convert pixel coordinates to geographic coordinates\n                    lon, lat = transform * (x, y)\n\n                    # Write the data to the CSV file\n                    csvwriter.writerow([lat, lon, x, y, image_value])\n\ndef read_elevation_data(file_path, result_dem_csv_path, result_dem_feature_csv_path):\n    \"\"\"\n    Read and process elevation data from a CSV file and save it to another CSV file with additional features.\n\n    Args:\n        file_path (str): Path to the input CSV file containing elevation data.\n        result_dem_csv_path (str): Path to the output CSV file for elevation data.\n        result_dem_feature_csv_path (str): Path to the output CSV file for elevation data with additional features.\n\n    Returns:\n        DataFrame: Merged dataframe with elevation and additional features.\n    \"\"\"\n    neighborhood_size = 4\n    df = pd.read_csv(file_path)\n    \n    dataset = rasterio.open(geotiff_file)\n    data = dataset.read(1)\n\n    # Get the width and height of the GeoTIFF\n    height, width = data.shape\n    \n    # Create an empty DataFrame with column names\n    columns = ['lat', 'lon', 'elevation', 'slope', 'aspect', 'curvature', 'northness', 'eastness']\n    all_df = pd.DataFrame(columns=columns)\n    \n    all_df.to_csv(result_dem_feature_csv_path)\n    print(f\"DEM and other columns are saved to file {result_dem_feature_csv_path}\")\n    return all_df\n\n  \n\n# Usage example:\nresult_dem_csv_path = \"/home/chetana/gridmet_test_run/dem_template.csv\"\nresult_dem_feature_csv_path = \"/home/chetana/gridmet_test_run/dem_all.csv\"\n\ndem_file = \"/home/chetana/gridmet_test_run/dem_file.tif\"\nslope_file = '/home/chetana/gridmet_test_run/slope_file.tif'\naspect_file = '/home/chetana/gridmet_test_run/aspect_file.tif'\ncurvature_file = '/home/chetana/gridmet_test_run/curvature_file.tif'\nnorthness_file = '/home/chetana/gridmet_test_run/northness_file.tif'\neastness_file = '/home/chetana/gridmet_test_run/eastness_file.tif'\n\nslope, aspect = calculate_slope_aspect(dem_file)\ncurvature = calculate_curvature(dem_file)\nnorthness, eastness = calculate_gradients(dem_file)\n\n# Save the slope and aspect as new GeoTIFF files\nsave_as_geotiff(slope, slope_file, dem_file)\nsave_as_geotiff(aspect, aspect_file, dem_file)\nsave_as_geotiff(curvature, curvature_file, dem_file)\nsave_as_geotiff(northness, northness_file, dem_file)\nsave_as_geotiff(eastness, eastness_file, dem_file)\n\ngeotiff_to_csv(dem_file, dem_file+\".csv\", \"Elevation\")\ngeotiff_to_csv(slope_file, slope_file+\".csv\", \"Slope\")\ngeotiff_to_csv(aspect_file, aspect_file+\".csv\", \"Aspect\")\ngeotiff_to_csv(curvature_file, curvature_file+\".csv\", \"Curvature\")\ngeotiff_to_csv(northness_file, northness_file+\".csv\", \"Northness\")\ngeotiff_to_csv(eastness_file, eastness_file+\".csv\", \"Eastness\")\n\n# List of file paths for the CSV files\ncsv_files = [dem_file+\".csv\", slope_file+\".csv\", aspect_file+\".csv\", \n             curvature_file+\".csv\", northness_file+\".csv\", eastness_file+\".csv\"]\n\n# Initialize an empty list to store all dataframes\ndfs = []\n\n# Read each CSV file into separate dataframes\nfor file in csv_files:\n    df = pd.read_csv(file, encoding='utf-8')\n    dfs.append(df)\n\n# Merge the dataframes based on the latitude and longitude columns\nmerged_df = dfs[0]  # Start with the first dataframe\nfor i in range(1, len(dfs)):\n    merged_df = pd.merge(merged_df, dfs[i], on=['Latitude', 'Longitude', 'x', 'y'])\n\n# check the statistics of the columns\nfor column in merged_df.columns:\n    merged_df[column] = pd.to_numeric(merged_df[column], errors='coerce')\n    print(merged_df[column].describe())\n    \n# Save the merged dataframe to a new CSV file\nmerged_df.to_csv(result_dem_feature_csv_path, index=False)\nprint(f\"New dem features are updated in {result_dem_feature_csv_path}\")\n",
  "history_output" : "/home/chetana/gw-workspace/lyk4KqzEdGoO/western_us_dem.py:186: RuntimeWarning: invalid value encountered in divide\n  northness = np.arctan(dy / np.sqrt(dx**2 + dy**2))\n/home/chetana/gw-workspace/lyk4KqzEdGoO/western_us_dem.py:187: RuntimeWarning: invalid value encountered in divide\n  eastness = np.arctan(dx / np.sqrt(dx**2 + dy**2))\ncount    462204.000000\nmean         37.030000\nstd           6.921275\nmin          25.060000\n25%          31.036000\n50%          37.030000\n75%          43.024000\nmax          49.000000\nName: Latitude, dtype: float64\ncount    462204.00000\nmean       -112.52600\nstd           7.21226\nmin        -125.00000\n25%        -118.77200\n50%        -112.52600\n75%        -106.28000\nmax        -100.05200\nName: Longitude, dtype: float64\ncount    462204.000000\nmean        346.500000\nstd         200.340552\nmin           0.000000\n25%         173.000000\n50%         346.500000\n75%         520.000000\nmax         693.000000\nName: x, dtype: float64\ncount    462204.000000\nmean        332.500000\nstd         192.257631\nmin           0.000000\n25%         166.000000\n50%         332.500000\n75%         499.000000\nmax         665.000000\nName: y, dtype: float64\ncount    462204.000000\nmean       1025.629083\nstd         808.945819\nmin         -82.938410\n25%         180.727250\n50%        1018.458080\n75%        1604.870600\nmax        4177.173000\nName: Elevation, dtype: float64\ncount    462204.000000\nmean         71.653609\nstd          36.142936\nmin           0.000000\n25%          89.711186\n50%          89.943880\n75%          89.981230\nmax          89.998410\nName: Slope, dtype: float64\ncount    462204.000000\nmean        150.657475\nstd         119.139631\nmin           0.000000\n25%          22.385444\n50%         147.928925\n75%         258.982280\nmax         359.999600\nName: Aspect, dtype: float64\ncount    462204.000000\nmean        -49.124993\nstd        2819.341836\nmin      -41085.560000\n25%        -482.398620\n50%           0.000000\n75%         840.230590\nmax       21411.324000\nName: Curvature, dtype: float64\ncount    368579.000000\nmean         -0.012698\nstd           0.587101\nmin          -0.785398\n25%          -0.626382\n50%          -0.027939\n75%           0.608819\nmax           0.785398\nName: Northness, dtype: float64\ncount    368579.000000\nmean         -0.040279\nstd           0.583256\nmin          -0.785398\n25%          -0.643895\n50%          -0.087261\n75%           0.573790\nmax           0.785398\nName: Eastness, dtype: float64\nNew dem features are updated in /home/chetana/gridmet_test_run/dem_all.csv\n",
  "history_begin_time" : 1700464947302,
  "history_end_time" : 1700464968183,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "dutes6r1syh",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1700461922991,
  "history_end_time" : 1700462913677,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Stopped"
},{
  "history_id" : "l98td6lg68g",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1700448500136,
  "history_end_time" : 1700448500136,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "qpxkmf01kyv",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1700447319844,
  "history_end_time" : 1700447319844,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "SeNuUSwj4aVm",
  "history_input" : "import numpy as np\nimport pandas as pd\nfrom osgeo import gdal\nimport warnings\nimport rasterio\nimport csv\nfrom rasterio.transform import Affine\nfrom scipy.ndimage import sobel, gaussian_filter\n\nmile_to_meters = 1609.34\nfeet_to_meters = 0.3048\n\n# Set the warning filter globally to ignore the FutureWarning\nwarnings.simplefilter(\"ignore\", FutureWarning)\n\ndef lat_lon_to_pixel(lat, lon, geotransform):\n    \"\"\"\n    Convert latitude and longitude to pixel coordinates using a geotransform.\n\n    Args:\n        lat (float): Latitude.\n        lon (float): Longitude.\n        geotransform (tuple): Geotransform coefficients (e.g., (origin_x, pixel_width, 0, origin_y, 0, pixel_height)).\n\n    Returns:\n        tuple: Pixel coordinates (x, y).\n    \"\"\"\n    x = int((lon - geotransform[0]) / geotransform[1])\n    y = int((lat - geotransform[3]) / geotransform[5])\n    return x, y\n\ndef calculate_slope_aspect_for_single(elevation_data, pixel_size_x, pixel_size_y):\n    \"\"\"\n    Calculate slope and aspect for a single pixel using elevation data.\n\n    Args:\n        elevation_data (array): Elevation data.\n        pixel_size_x (float): Pixel size in the x-direction.\n        pixel_size_y (float): Pixel size in the y-direction.\n\n    Returns:\n        tuple: Slope (in degrees), aspect (in degrees).\n    \"\"\"\n    # Calculate slope using the Sobel operator\n    slope_x = np.gradient(elevation_data, pixel_size_x, axis=1)\n    slope_y = np.gradient(elevation_data, pixel_size_y, axis=0)\n    slope_rad = np.arctan(np.sqrt(slope_x ** 2 + slope_y ** 2))\n    slope_deg = np.degrees(slope_rad)\n\n    # Calculate aspect (direction of the steepest descent)\n    aspect_rad = np.arctan2(slope_y, -slope_x)\n    aspect_deg = (np.degrees(aspect_rad) + 360) % 360\n\n    return slope_deg, aspect_deg\n\ndef save_as_geotiff(data, output_file, src_file):\n    \"\"\"\n    Save data as a GeoTIFF file with metadata from the source file.\n\n    Args:\n        data (array): Data to be saved.\n        output_file (str): Path to the output GeoTIFF file.\n        src_file (str): Path to the source GeoTIFF file to inherit metadata from.\n    \"\"\"\n    with rasterio.open(src_file) as src_dataset:\n        profile = src_dataset.profile\n        transform = src_dataset.transform\n\n        # Update the data type, count, and set the transform for the new dataset\n        profile.update(dtype=rasterio.float32, count=1, transform=transform)\n\n        # Create the new GeoTIFF file\n        with rasterio.open(output_file, 'w', **profile) as dst_dataset:\n            # Write the data to the new GeoTIFF\n            dst_dataset.write(data, 1)\n\ndef print_statistics(data):\n    \"\"\"\n    Print basic statistics of a data array.\n\n    Args:\n        data (array): Data array to calculate statistics for.\n    \"\"\"\n    # Calculate multiple statistics in one line\n    data = data[~np.isnan(data)]\n    mean, median, min_val, max_val, sum_val, std_dev, variance = [np.mean(data), np.median(data), np.min(data), np.max(data), np.sum(data), np.std(data), np.var(data)]\n\n    # Print the calculated statistics\n    print(\"Mean:\", mean)\n    print(\"Median:\", median)\n    print(\"Minimum:\", min_val)\n    print(\"Maximum:\", max_val)\n    print(\"Sum:\", sum_val)\n    print(\"Standard Deviation:\", std_dev)\n    print(\"Variance:\", variance)\n\ndef calculate_slope_aspect(dem_file):\n    \"\"\"\n    Calculate slope and aspect from a DEM (Digital Elevation Model) file.\n\n    Args:\n        dem_file (str): Path to the DEM GeoTIFF file.\n\n    Returns:\n        tuple: Slope array (in degrees), aspect array (in degrees).\n    \"\"\"\n    with rasterio.open(dem_file) as dataset:\n        # Read the DEM data as a numpy array\n        dem_data = dataset.read(1)\n\n        # Get the geotransform to convert pixel coordinates to geographic coordinates\n        transform = dataset.transform\n\n        # Calculate the slope and aspect using numpy\n        dx, dy = np.gradient(dem_data, transform[0], transform[4])\n        slope = np.degrees(np.arctan(np.sqrt(dx**2 + dy**2)))\n        aspect = np.degrees(np.arctan2(-dy, dx))\n\n        # Adjust aspect values to range from 0 to 360 degrees\n        aspect[aspect < 0] += 360\n\n    return slope, aspect\n\ndef calculate_curvature(elevation_data, pixel_size_x, pixel_size_y):\n    \"\"\"\n    Calculate curvature from elevation data using the Laplacian operator.\n\n    Args:\n        elevation_data (array): Elevation data.\n        pixel_size_x (float): Pixel size in the x-direction.\n        pixel_size_y (float): Pixel size in the y-direction.\n\n    Returns:\n        array: Curvature data.\n    \"\"\"\n    # Calculate curvature using the Laplacian operator\n    curvature_x = np.gradient(np.gradient(elevation_data, pixel_size_x, axis=1), pixel_size_x, axis=1)\n    curvature_y = np.gradient(np.gradient(elevation_data, pixel_size_y, axis=0), pixel_size_y, axis=0)\n    curvature = curvature_x + curvature_y\n\n    return curvature\n  \ndef calculate_curvature(dem_file, sigma=1):\n    with rasterio.open(dem_file) as dataset:\n        # Read the DEM data as a numpy array\n        dem_data = dataset.read(1)\n        \n        # the dem is in meter unit\n        dem_data = dem_data\n\n        # Calculate the gradient using the Sobel filter\n        dx = sobel(dem_data, axis=1, mode='constant')\n        dy = sobel(dem_data, axis=0, mode='constant')\n\n        # Calculate the second derivatives using the Sobel filter\n        dxx = sobel(dx, axis=1, mode='constant')\n        dyy = sobel(dy, axis=0, mode='constant')\n\n        # Calculate the curvature using the second derivatives\n        curvature = dxx + dyy\n\n        # Smooth the curvature using Gaussian filtering (optional)\n        curvature = gaussian_filter(curvature, sigma)\n\n    return curvature\n\ndef calculate_gradients(dem_file):\n    \"\"\"\n    Calculate Northness and Eastness gradients from a DEM (Digital Elevation Model) file.\n\n    Args:\n        dem_file (str): Path to the DEM GeoTIFF file.\n\n    Returns:\n        tuple: Northness array, Eastness array (both in radians).\n    \"\"\"\n    with rasterio.open(dem_file) as dataset:\n        # Read the DEM data as a numpy array\n        dem_data = dataset.read(1)\n\n        # Calculate the gradients along the North and East directions\n        dy, dx = np.gradient(dem_data, dataset.res[0], dataset.res[1])\n\n        # Calculate the Northness and Eastness\n        northness = np.arctan(dy / np.sqrt(dx**2 + dy**2))\n        eastness = np.arctan(dx / np.sqrt(dx**2 + dy**2))\n\n    return northness, eastness\n\ndef geotiff_to_csv(geotiff_file, csv_file, column_name):\n    \"\"\"\n    Convert a GeoTIFF file to a CSV file containing latitude, longitude, and image values.\n\n    Args:\n        geotiff_file (str): Path to the input GeoTIFF file.\n        csv_file (str): Path to the output CSV file.\n        column_name (str): Name for the image value column.\n    \"\"\"\n    # Open the GeoTIFF file\n    with rasterio.open(geotiff_file) as dataset:\n        # Get the pixel values as a 2D array\n        data = dataset.read(1)\n\n        if column_name == \"Elevation\":\n            # default unit is meter\n            data = data\n\n        # Get the geotransform to convert pixel coordinates to geographic coordinates\n        transform = dataset.transform\n\n        # Get the width and height of the GeoTIFF\n        height, width = data.shape\n\n        # Open the CSV file for writing\n        with open(csv_file, 'w', newline='') as csvfile:\n            csvwriter = csv.writer(csvfile)\n\n            # Write the CSV header\n            csvwriter.writerow(['Latitude', 'Longitude', 'x', 'y', column_name])\n\n            # Loop through each pixel and extract latitude, longitude, and image value\n            for y in range(height):\n                for x in range(width):\n                    # Get the pixel value\n                    image_value = data[y, x]\n\n                    # Convert pixel coordinates to geographic coordinates\n                    lon, lat = transform * (x, y)\n\n                    # Write the data to the CSV file\n                    csvwriter.writerow([lat, lon, x, y, image_value])\n\ndef read_elevation_data(file_path, result_dem_csv_path, result_dem_feature_csv_path):\n    \"\"\"\n    Read and process elevation data from a CSV file and save it to another CSV file with additional features.\n\n    Args:\n        file_path (str): Path to the input CSV file containing elevation data.\n        result_dem_csv_path (str): Path to the output CSV file for elevation data.\n        result_dem_feature_csv_path (str): Path to the output CSV file for elevation data with additional features.\n\n    Returns:\n        DataFrame: Merged dataframe with elevation and additional features.\n    \"\"\"\n    neighborhood_size = 4\n    df = pd.read_csv(file_path)\n    \n    dataset = rasterio.open(geotiff_file)\n    data = dataset.read(1)\n\n    # Get the width and height of the GeoTIFF\n    height, width = data.shape\n    \n    # Create an empty DataFrame with column names\n    columns = ['lat', 'lon', 'elevation', 'slope', 'aspect', 'curvature', 'northness', 'eastness']\n    all_df = pd.DataFrame(columns=columns)\n    \n    all_df.to_csv(result_dem_feature_csv_path)\n    print(f\"DEM and other columns are saved to file {result_dem_feature_csv_path}\")\n    return all_df\n\n  \n\n# Usage example:\nresult_dem_csv_path = \"/home/chetana/gridmet_test_run/dem_template.csv\"\nresult_dem_feature_csv_path = \"/home/chetana/gridmet_test_run/dem_all.csv\"\n\ndem_file = \"/home/chetana/gridmet_test_run/dem_file.tif\"\nslope_file = '/home/chetana/gridmet_test_run/slope_file.tif'\naspect_file = '/home/chetana/gridmet_test_run/aspect_file.tif'\ncurvature_file = '/home/chetana/gridmet_test_run/curvature_file.tif'\nnorthness_file = '/home/chetana/gridmet_test_run/northness_file.tif'\neastness_file = '/home/chetana/gridmet_test_run/eastness_file.tif'\n\nslope, aspect = calculate_slope_aspect(dem_file)\ncurvature = calculate_curvature(dem_file)\nnorthness, eastness = calculate_gradients(dem_file)\n\n# Save the slope and aspect as new GeoTIFF files\nsave_as_geotiff(slope, slope_file, dem_file)\nsave_as_geotiff(aspect, aspect_file, dem_file)\nsave_as_geotiff(curvature, curvature_file, dem_file)\nsave_as_geotiff(northness, northness_file, dem_file)\nsave_as_geotiff(eastness, eastness_file, dem_file)\n\ngeotiff_to_csv(dem_file, dem_file+\".csv\", \"Elevation\")\ngeotiff_to_csv(slope_file, slope_file+\".csv\", \"Slope\")\ngeotiff_to_csv(aspect_file, aspect_file+\".csv\", \"Aspect\")\ngeotiff_to_csv(curvature_file, curvature_file+\".csv\", \"Curvature\")\ngeotiff_to_csv(northness_file, northness_file+\".csv\", \"Northness\")\ngeotiff_to_csv(eastness_file, eastness_file+\".csv\", \"Eastness\")\n\n# List of file paths for the CSV files\ncsv_files = [dem_file+\".csv\", slope_file+\".csv\", aspect_file+\".csv\", \n             curvature_file+\".csv\", northness_file+\".csv\", eastness_file+\".csv\"]\n\n# Initialize an empty list to store all dataframes\ndfs = []\n\n# Read each CSV file into separate dataframes\nfor file in csv_files:\n    df = pd.read_csv(file, encoding='utf-8')\n    dfs.append(df)\n\n# Merge the dataframes based on the latitude and longitude columns\nmerged_df = dfs[0]  # Start with the first dataframe\nfor i in range(1, len(dfs)):\n    merged_df = pd.merge(merged_df, dfs[i], on=['Latitude', 'Longitude', 'x', 'y'])\n\n# check the statistics of the columns\nfor column in merged_df.columns:\n    merged_df[column] = pd.to_numeric(merged_df[column], errors='coerce')\n    print(merged_df[column].describe())\n    \n# Save the merged dataframe to a new CSV file\nmerged_df.to_csv(result_dem_feature_csv_path, index=False)\nprint(f\"New dem features are updated in {result_dem_feature_csv_path}\")\n",
  "history_output" : "/home/chetana/gw-workspace/SeNuUSwj4aVm/western_us_dem.py:185: RuntimeWarning: invalid value encountered in divide\n  northness = np.arctan(dy / np.sqrt(dx**2 + dy**2))\n/home/chetana/gw-workspace/SeNuUSwj4aVm/western_us_dem.py:186: RuntimeWarning: invalid value encountered in divide\n  eastness = np.arctan(dx / np.sqrt(dx**2 + dy**2))\ncount    462204.000000\nmean         37.030000\nstd           6.921275\nmin          25.060000\n25%          31.036000\n50%          37.030000\n75%          43.024000\nmax          49.000000\nName: Latitude, dtype: float64\ncount    462204.00000\nmean       -112.52600\nstd           7.21226\nmin        -125.00000\n25%        -118.77200\n50%        -112.52600\n75%        -106.28000\nmax        -100.05200\nName: Longitude, dtype: float64\ncount    462204.000000\nmean        346.500000\nstd         200.340552\nmin           0.000000\n25%         173.000000\n50%         346.500000\n75%         520.000000\nmax         693.000000\nName: x, dtype: float64\ncount    462204.000000\nmean        332.500000\nstd         192.257631\nmin           0.000000\n25%         166.000000\n50%         332.500000\n75%         499.000000\nmax         665.000000\nName: y, dtype: float64\ncount    462204.000000\nmean       1025.629083\nstd         808.945819\nmin         -82.938410\n25%         180.727250\n50%        1018.458080\n75%        1604.870600\nmax        4177.173000\nName: Elevation, dtype: float64\ncount    462204.000000\nmean         71.653609\nstd          36.142936\nmin           0.000000\n25%          89.711186\n50%          89.943880\n75%          89.981230\nmax          89.998410\nName: Slope, dtype: float64\ncount    462204.000000\nmean        150.657475\nstd         119.139631\nmin           0.000000\n25%          22.385444\n50%         147.928925\n75%         258.982280\nmax         359.999600\nName: Aspect, dtype: float64\ncount    462204.000000\nmean        -49.124993\nstd        2819.341836\nmin      -41085.560000\n25%        -482.398620\n50%           0.000000\n75%         840.230590\nmax       21411.324000\nName: Curvature, dtype: float64\ncount    368579.000000\nmean         -0.012698\nstd           0.587101\nmin          -0.785398\n25%          -0.626382\n50%          -0.027939\n75%           0.608819\nmax           0.785398\nName: Northness, dtype: float64\ncount    368579.000000\nmean         -0.040279\nstd           0.583256\nmin          -0.785398\n25%          -0.643895\n50%          -0.087261\n75%           0.573790\nmax           0.785398\nName: Eastness, dtype: float64\nNew dem features are updated in /home/chetana/gridmet_test_run/dem_all.csv\n",
  "history_begin_time" : 1700446003398,
  "history_end_time" : 1700446019870,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "1f1oOBOgOU6C",
  "history_input" : "import numpy as np\nimport pandas as pd\nfrom osgeo import gdal\nimport warnings\nimport rasterio\nimport csv\nfrom rasterio.transform import Affine\nfrom scipy.ndimage import sobel, gaussian_filter\n\nmile_to_meters = 1609.34\nfeet_to_meters = 0.3048\n\n# Set the warning filter globally to ignore the FutureWarning\nwarnings.simplefilter(\"ignore\", FutureWarning)\n\ndef lat_lon_to_pixel(lat, lon, geotransform):\n    \"\"\"\n    Convert latitude and longitude to pixel coordinates using a geotransform.\n\n    Args:\n        lat (float): Latitude.\n        lon (float): Longitude.\n        geotransform (tuple): Geotransform coefficients (e.g., (origin_x, pixel_width, 0, origin_y, 0, pixel_height)).\n\n    Returns:\n        tuple: Pixel coordinates (x, y).\n    \"\"\"\n    x = int((lon - geotransform[0]) / geotransform[1])\n    y = int((lat - geotransform[3]) / geotransform[5])\n    return x, y\n\ndef calculate_slope_aspect_for_single(elevation_data, pixel_size_x, pixel_size_y):\n    \"\"\"\n    Calculate slope and aspect for a single pixel using elevation data.\n\n    Args:\n        elevation_data (array): Elevation data.\n        pixel_size_x (float): Pixel size in the x-direction.\n        pixel_size_y (float): Pixel size in the y-direction.\n\n    Returns:\n        tuple: Slope (in degrees), aspect (in degrees).\n    \"\"\"\n    # Calculate slope using the Sobel operator\n    slope_x = np.gradient(elevation_data, pixel_size_x, axis=1)\n    slope_y = np.gradient(elevation_data, pixel_size_y, axis=0)\n    slope_rad = np.arctan(np.sqrt(slope_x ** 2 + slope_y ** 2))\n    slope_deg = np.degrees(slope_rad)\n\n    # Calculate aspect (direction of the steepest descent)\n    aspect_rad = np.arctan2(slope_y, -slope_x)\n    aspect_deg = (np.degrees(aspect_rad) + 360) % 360\n\n    return slope_deg, aspect_deg\n\ndef save_as_geotiff(data, output_file, src_file):\n    \"\"\"\n    Save data as a GeoTIFF file with metadata from the source file.\n\n    Args:\n        data (array): Data to be saved.\n        output_file (str): Path to the output GeoTIFF file.\n        src_file (str): Path to the source GeoTIFF file to inherit metadata from.\n    \"\"\"\n    with rasterio.open(src_file) as src_dataset:\n        profile = src_dataset.profile\n        transform = src_dataset.transform\n\n        # Update the data type, count, and set the transform for the new dataset\n        profile.update(dtype=rasterio.float32, count=1, transform=transform)\n\n        # Create the new GeoTIFF file\n        with rasterio.open(output_file, 'w', **profile) as dst_dataset:\n            # Write the data to the new GeoTIFF\n            dst_dataset.write(data, 1)\n\ndef print_statistics(data):\n    \"\"\"\n    Print basic statistics of a data array.\n\n    Args:\n        data (array): Data array to calculate statistics for.\n    \"\"\"\n    # Calculate multiple statistics in one line\n    data = data[~np.isnan(data)]\n    mean, median, min_val, max_val, sum_val, std_dev, variance = [np.mean(data), np.median(data), np.min(data), np.max(data), np.sum(data), np.std(data), np.var(data)]\n\n    # Print the calculated statistics\n    print(\"Mean:\", mean)\n    print(\"Median:\", median)\n    print(\"Minimum:\", min_val)\n    print(\"Maximum:\", max_val)\n    print(\"Sum:\", sum_val)\n    print(\"Standard Deviation:\", std_dev)\n    print(\"Variance:\", variance)\n\ndef calculate_slope_aspect(dem_file):\n    \"\"\"\n    Calculate slope and aspect from a DEM (Digital Elevation Model) file.\n\n    Args:\n        dem_file (str): Path to the DEM GeoTIFF file.\n\n    Returns:\n        tuple: Slope array (in degrees), aspect array (in degrees).\n    \"\"\"\n    with rasterio.open(dem_file) as dataset:\n        # Read the DEM data as a numpy array\n        dem_data = dataset.read(1)\n\n        # Get the geotransform to convert pixel coordinates to geographic coordinates\n        transform = dataset.transform\n\n        # Calculate the slope and aspect using numpy\n        dx, dy = np.gradient(dem_data, transform[0], transform[4])\n        slope = np.degrees(np.arctan(np.sqrt(dx**2 + dy**2)))\n        aspect = np.degrees(np.arctan2(-dy, dx))\n\n        # Adjust aspect values to range from 0 to 360 degrees\n        aspect[aspect < 0] += 360\n\n    return slope, aspect\n\ndef calculate_curvature(elevation_data, pixel_size_x, pixel_size_y):\n    \"\"\"\n    Calculate curvature from elevation data using the Laplacian operator.\n\n    Args:\n        elevation_data (array): Elevation data.\n        pixel_size_x (float): Pixel size in the x-direction.\n        pixel_size_y (float): Pixel size in the y-direction.\n\n    Returns:\n        array: Curvature data.\n    \"\"\"\n    # Calculate curvature using the Laplacian operator\n    curvature_x = np.gradient(np.gradient(elevation_data, pixel_size_x, axis=1), pixel_size_x, axis=1)\n    curvature_y = np.gradient(np.gradient(elevation_data, pixel_size_y, axis=0), pixel_size_y, axis=0)\n    curvature = curvature_x + curvature_y\n\n    return curvature\n  \ndef calculate_curvature(dem_file, sigma=1):\n    with rasterio.open(dem_file) as dataset:\n        # Read the DEM data as a numpy array\n        dem_data = dataset.read(1)\n        \n        # convert feet to meters\n        dem_data = dem_data*feet_to_meters\n\n        # Calculate the gradient using the Sobel filter\n        dx = sobel(dem_data, axis=1, mode='constant')\n        dy = sobel(dem_data, axis=0, mode='constant')\n\n        # Calculate the second derivatives using the Sobel filter\n        dxx = sobel(dx, axis=1, mode='constant')\n        dyy = sobel(dy, axis=0, mode='constant')\n\n        # Calculate the curvature using the second derivatives\n        curvature = dxx + dyy\n\n        # Smooth the curvature using Gaussian filtering (optional)\n        curvature = gaussian_filter(curvature, sigma)\n\n    return curvature\n\ndef calculate_gradients(dem_file):\n    \"\"\"\n    Calculate Northness and Eastness gradients from a DEM (Digital Elevation Model) file.\n\n    Args:\n        dem_file (str): Path to the DEM GeoTIFF file.\n\n    Returns:\n        tuple: Northness array, Eastness array (both in radians).\n    \"\"\"\n    with rasterio.open(dem_file) as dataset:\n        # Read the DEM data as a numpy array\n        dem_data = dataset.read(1)\n\n        # Calculate the gradients along the North and East directions\n        dy, dx = np.gradient(dem_data, dataset.res[0], dataset.res[1])\n\n        # Calculate the Northness and Eastness\n        northness = np.arctan(dy / np.sqrt(dx**2 + dy**2))\n        eastness = np.arctan(dx / np.sqrt(dx**2 + dy**2))\n\n    return northness, eastness\n\ndef geotiff_to_csv(geotiff_file, csv_file, column_name):\n    \"\"\"\n    Convert a GeoTIFF file to a CSV file containing latitude, longitude, and image values.\n\n    Args:\n        geotiff_file (str): Path to the input GeoTIFF file.\n        csv_file (str): Path to the output CSV file.\n        column_name (str): Name for the image value column.\n    \"\"\"\n    # Open the GeoTIFF file\n    with rasterio.open(geotiff_file) as dataset:\n        # Get the pixel values as a 2D array\n        data = dataset.read(1)\n\n        if column_name == \"Elevation\":\n            # Convert miles to meters (if applicable)\n            data = data * feet_to_meters\n\n        # Get the geotransform to convert pixel coordinates to geographic coordinates\n        transform = dataset.transform\n\n        # Get the width and height of the GeoTIFF\n        height, width = data.shape\n\n        # Open the CSV file for writing\n        with open(csv_file, 'w', newline='') as csvfile:\n            csvwriter = csv.writer(csvfile)\n\n            # Write the CSV header\n            csvwriter.writerow(['Latitude', 'Longitude', 'x', 'y', column_name])\n\n            # Loop through each pixel and extract latitude, longitude, and image value\n            for y in range(height):\n                for x in range(width):\n                    # Get the pixel value\n                    image_value = data[y, x]\n\n                    # Convert pixel coordinates to geographic coordinates\n                    lon, lat = transform * (x, y)\n\n                    # Write the data to the CSV file\n                    csvwriter.writerow([lat, lon, x, y, image_value])\n\ndef read_elevation_data(file_path, result_dem_csv_path, result_dem_feature_csv_path):\n    \"\"\"\n    Read and process elevation data from a CSV file and save it to another CSV file with additional features.\n\n    Args:\n        file_path (str): Path to the input CSV file containing elevation data.\n        result_dem_csv_path (str): Path to the output CSV file for elevation data.\n        result_dem_feature_csv_path (str): Path to the output CSV file for elevation data with additional features.\n\n    Returns:\n        DataFrame: Merged dataframe with elevation and additional features.\n    \"\"\"\n    neighborhood_size = 4\n    df = pd.read_csv(file_path)\n    \n    dataset = rasterio.open(geotiff_file)\n    data = dataset.read(1)\n\n    # Get the width and height of the GeoTIFF\n    height, width = data.shape\n    \n    # Create an empty DataFrame with column names\n    columns = ['lat', 'lon', 'elevation', 'slope', 'aspect', 'curvature', 'northness', 'eastness']\n    all_df = pd.DataFrame(columns=columns)\n    \n    all_df.to_csv(result_dem_feature_csv_path)\n    print(f\"DEM and other columns are saved to file {result_dem_feature_csv_path}\")\n    return all_df\n\n  \n\n# Usage example:\nresult_dem_csv_path = \"/home/chetana/gridmet_test_run/dem_template.csv\"\nresult_dem_feature_csv_path = \"/home/chetana/gridmet_test_run/dem_all.csv\"\n\ndem_file = \"/home/chetana/gridmet_test_run/dem_file.tif\"\nslope_file = '/home/chetana/gridmet_test_run/slope_file.tif'\naspect_file = '/home/chetana/gridmet_test_run/aspect_file.tif'\ncurvature_file = '/home/chetana/gridmet_test_run/curvature_file.tif'\nnorthness_file = '/home/chetana/gridmet_test_run/northness_file.tif'\neastness_file = '/home/chetana/gridmet_test_run/eastness_file.tif'\n\nslope, aspect = calculate_slope_aspect(dem_file)\ncurvature = calculate_curvature(dem_file)\nnorthness, eastness = calculate_gradients(dem_file)\n\n# Save the slope and aspect as new GeoTIFF files\nsave_as_geotiff(slope, slope_file, dem_file)\nsave_as_geotiff(aspect, aspect_file, dem_file)\nsave_as_geotiff(curvature, curvature_file, dem_file)\nsave_as_geotiff(northness, northness_file, dem_file)\nsave_as_geotiff(eastness, eastness_file, dem_file)\n\ngeotiff_to_csv(dem_file, dem_file+\".csv\", \"Elevation\")\ngeotiff_to_csv(slope_file, slope_file+\".csv\", \"Slope\")\ngeotiff_to_csv(aspect_file, aspect_file+\".csv\", \"Aspect\")\ngeotiff_to_csv(curvature_file, curvature_file+\".csv\", \"Curvature\")\ngeotiff_to_csv(northness_file, northness_file+\".csv\", \"Northness\")\ngeotiff_to_csv(eastness_file, eastness_file+\".csv\", \"Eastness\")\n\n# List of file paths for the CSV files\ncsv_files = [dem_file+\".csv\", slope_file+\".csv\", aspect_file+\".csv\", \n             curvature_file+\".csv\", northness_file+\".csv\", eastness_file+\".csv\"]\n\n# Initialize an empty list to store all dataframes\ndfs = []\n\n# Read each CSV file into separate dataframes\nfor file in csv_files:\n    df = pd.read_csv(file, encoding='utf-8')\n    dfs.append(df)\n\n# Merge the dataframes based on the latitude and longitude columns\nmerged_df = dfs[0]  # Start with the first dataframe\nfor i in range(1, len(dfs)):\n    merged_df = pd.merge(merged_df, dfs[i], on=['Latitude', 'Longitude', 'x', 'y'])\n\n# check the statistics of the columns\nfor column in merged_df.columns:\n    merged_df[column] = pd.to_numeric(merged_df[column], errors='coerce')\n    print(merged_df[column].describe())\n    \n# Save the merged dataframe to a new CSV file\nmerged_df.to_csv(result_dem_feature_csv_path, index=False)\nprint(f\"New dem features are updated in {result_dem_feature_csv_path}\")\n",
  "history_output" : "/home/chetana/gw-workspace/1f1oOBOgOU6C/western_us_dem.py:185: RuntimeWarning: invalid value encountered in divide\n  northness = np.arctan(dy / np.sqrt(dx**2 + dy**2))\n/home/chetana/gw-workspace/1f1oOBOgOU6C/western_us_dem.py:186: RuntimeWarning: invalid value encountered in divide\n  eastness = np.arctan(dx / np.sqrt(dx**2 + dy**2))\ncount    462204.000000\nmean         37.030000\nstd           6.921275\nmin          25.060000\n25%          31.036000\n50%          37.030000\n75%          43.024000\nmax          49.000000\nName: Latitude, dtype: float64\ncount    462204.00000\nmean       -112.52600\nstd           7.21226\nmin        -125.00000\n25%        -118.77200\n50%        -112.52600\n75%        -106.28000\nmax        -100.05200\nName: Longitude, dtype: float64\ncount    462204.000000\nmean        346.500000\nstd         200.340552\nmin           0.000000\n25%         173.000000\n50%         346.500000\n75%         520.000000\nmax         693.000000\nName: x, dtype: float64\ncount    462204.000000\nmean        332.500000\nstd         192.257631\nmin           0.000000\n25%         166.000000\n50%         332.500000\n75%         499.000000\nmax         665.000000\nName: y, dtype: float64\ncount    462204.000000\nmean        312.611748\nstd         246.566689\nmin         -25.279627\n25%          55.085665\n50%         310.426025\n75%         489.164555\nmax        1273.202300\nName: Elevation, dtype: float64\ncount    462204.000000\nmean         71.653609\nstd          36.142936\nmin           0.000000\n25%          89.711186\n50%          89.943880\n75%          89.981230\nmax          89.998410\nName: Slope, dtype: float64\ncount    462204.000000\nmean        150.657475\nstd         119.139631\nmin           0.000000\n25%          22.385444\n50%         147.928925\n75%         258.982280\nmax         359.999600\nName: Aspect, dtype: float64\ncount    462204.000000\nmean        -14.973298\nstd         859.335403\nmin      -12522.879000\n25%        -147.035178\n50%           0.000000\n75%         256.102103\nmax        6526.172000\nName: Curvature, dtype: float64\ncount    368579.000000\nmean         -0.012698\nstd           0.587101\nmin          -0.785398\n25%          -0.626382\n50%          -0.027939\n75%           0.608819\nmax           0.785398\nName: Northness, dtype: float64\ncount    368579.000000\nmean         -0.040279\nstd           0.583256\nmin          -0.785398\n25%          -0.643895\n50%          -0.087261\n75%           0.573790\nmax           0.785398\nName: Eastness, dtype: float64\nNew dem features are updated in /home/chetana/gridmet_test_run/dem_all.csv\n",
  "history_begin_time" : 1700445824107,
  "history_end_time" : 1700445839134,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "sJ62BhyB14WI",
  "history_input" : "import numpy as np\nimport pandas as pd\nfrom osgeo import gdal\nimport warnings\nimport rasterio\nimport csv\nfrom rasterio.transform import Affine\nfrom scipy.ndimage import sobel, gaussian_filter\n\nmile_to_meters = 1609.34\nfeet_to_meters = 0.3048\n\n# Set the warning filter globally to ignore the FutureWarning\nwarnings.simplefilter(\"ignore\", FutureWarning)\n\ndef lat_lon_to_pixel(lat, lon, geotransform):\n    \"\"\"\n    Convert latitude and longitude to pixel coordinates using a geotransform.\n\n    Args:\n        lat (float): Latitude.\n        lon (float): Longitude.\n        geotransform (tuple): Geotransform coefficients (e.g., (origin_x, pixel_width, 0, origin_y, 0, pixel_height)).\n\n    Returns:\n        tuple: Pixel coordinates (x, y).\n    \"\"\"\n    x = int((lon - geotransform[0]) / geotransform[1])\n    y = int((lat - geotransform[3]) / geotransform[5])\n    return x, y\n\ndef calculate_slope_aspect_for_single(elevation_data, pixel_size_x, pixel_size_y):\n    \"\"\"\n    Calculate slope and aspect for a single pixel using elevation data.\n\n    Args:\n        elevation_data (array): Elevation data.\n        pixel_size_x (float): Pixel size in the x-direction.\n        pixel_size_y (float): Pixel size in the y-direction.\n\n    Returns:\n        tuple: Slope (in degrees), aspect (in degrees).\n    \"\"\"\n    # Calculate slope using the Sobel operator\n    slope_x = np.gradient(elevation_data, pixel_size_x, axis=1)\n    slope_y = np.gradient(elevation_data, pixel_size_y, axis=0)\n    slope_rad = np.arctan(np.sqrt(slope_x ** 2 + slope_y ** 2))\n    slope_deg = np.degrees(slope_rad)\n\n    # Calculate aspect (direction of the steepest descent)\n    aspect_rad = np.arctan2(slope_y, -slope_x)\n    aspect_deg = (np.degrees(aspect_rad) + 360) % 360\n\n    return slope_deg, aspect_deg\n\ndef save_as_geotiff(data, output_file, src_file):\n    \"\"\"\n    Save data as a GeoTIFF file with metadata from the source file.\n\n    Args:\n        data (array): Data to be saved.\n        output_file (str): Path to the output GeoTIFF file.\n        src_file (str): Path to the source GeoTIFF file to inherit metadata from.\n    \"\"\"\n    with rasterio.open(src_file) as src_dataset:\n        profile = src_dataset.profile\n        transform = src_dataset.transform\n\n        # Update the data type, count, and set the transform for the new dataset\n        profile.update(dtype=rasterio.float32, count=1, transform=transform)\n\n        # Create the new GeoTIFF file\n        with rasterio.open(output_file, 'w', **profile) as dst_dataset:\n            # Write the data to the new GeoTIFF\n            dst_dataset.write(data, 1)\n\ndef print_statistics(data):\n    \"\"\"\n    Print basic statistics of a data array.\n\n    Args:\n        data (array): Data array to calculate statistics for.\n    \"\"\"\n    # Calculate multiple statistics in one line\n    data = data[~np.isnan(data)]\n    mean, median, min_val, max_val, sum_val, std_dev, variance = [np.mean(data), np.median(data), np.min(data), np.max(data), np.sum(data), np.std(data), np.var(data)]\n\n    # Print the calculated statistics\n    print(\"Mean:\", mean)\n    print(\"Median:\", median)\n    print(\"Minimum:\", min_val)\n    print(\"Maximum:\", max_val)\n    print(\"Sum:\", sum_val)\n    print(\"Standard Deviation:\", std_dev)\n    print(\"Variance:\", variance)\n\ndef calculate_slope_aspect(dem_file):\n    \"\"\"\n    Calculate slope and aspect from a DEM (Digital Elevation Model) file.\n\n    Args:\n        dem_file (str): Path to the DEM GeoTIFF file.\n\n    Returns:\n        tuple: Slope array (in degrees), aspect array (in degrees).\n    \"\"\"\n    with rasterio.open(dem_file) as dataset:\n        # Read the DEM data as a numpy array\n        dem_data = dataset.read(1)\n\n        # Get the geotransform to convert pixel coordinates to geographic coordinates\n        transform = dataset.transform\n\n        # Calculate the slope and aspect using numpy\n        dx, dy = np.gradient(dem_data, transform[0], transform[4])\n        slope = np.degrees(np.arctan(np.sqrt(dx**2 + dy**2)))\n        aspect = np.degrees(np.arctan2(-dy, dx))\n\n        # Adjust aspect values to range from 0 to 360 degrees\n        aspect[aspect < 0] += 360\n\n    return slope, aspect\n\ndef calculate_curvature(elevation_data, pixel_size_x, pixel_size_y):\n    \"\"\"\n    Calculate curvature from elevation data using the Laplacian operator.\n\n    Args:\n        elevation_data (array): Elevation data.\n        pixel_size_x (float): Pixel size in the x-direction.\n        pixel_size_y (float): Pixel size in the y-direction.\n\n    Returns:\n        array: Curvature data.\n    \"\"\"\n    # Calculate curvature using the Laplacian operator\n    curvature_x = np.gradient(np.gradient(elevation_data, pixel_size_x, axis=1), pixel_size_x, axis=1)\n    curvature_y = np.gradient(np.gradient(elevation_data, pixel_size_y, axis=0), pixel_size_y, axis=0)\n    curvature = curvature_x + curvature_y\n\n    return curvature\n  \ndef calculate_curvature(dem_file, sigma=1):\n    with rasterio.open(dem_file) as dataset:\n        # Read the DEM data as a numpy array\n        dem_data = dataset.read(1)\n        \n        # convert feet to meters\n        dem_data = dem_data*feet_to_meters\n\n        # Calculate the gradient using the Sobel filter\n        dx = sobel(dem_data, axis=1, mode='constant')\n        dy = sobel(dem_data, axis=0, mode='constant')\n\n        # Calculate the second derivatives using the Sobel filter\n        dxx = sobel(dx, axis=1, mode='constant')\n        dyy = sobel(dy, axis=0, mode='constant')\n\n        # Calculate the curvature using the second derivatives\n        curvature = dxx + dyy\n\n        # Smooth the curvature using Gaussian filtering (optional)\n        curvature = gaussian_filter(curvature, sigma)\n\n    return curvature\n\ndef calculate_gradients(dem_file):\n    \"\"\"\n    Calculate Northness and Eastness gradients from a DEM (Digital Elevation Model) file.\n\n    Args:\n        dem_file (str): Path to the DEM GeoTIFF file.\n\n    Returns:\n        tuple: Northness array, Eastness array (both in radians).\n    \"\"\"\n    with rasterio.open(dem_file) as dataset:\n        # Read the DEM data as a numpy array\n        dem_data = dataset.read(1)\n\n        # Calculate the gradients along the North and East directions\n        dy, dx = np.gradient(dem_data, dataset.res[0], dataset.res[1])\n\n        # Calculate the Northness and Eastness\n        northness = np.arctan(dy / np.sqrt(dx**2 + dy**2))\n        eastness = np.arctan(dx / np.sqrt(dx**2 + dy**2))\n\n    return northness, eastness\n\ndef geotiff_to_csv(geotiff_file, csv_file, column_name):\n    \"\"\"\n    Convert a GeoTIFF file to a CSV file containing latitude, longitude, and image values.\n\n    Args:\n        geotiff_file (str): Path to the input GeoTIFF file.\n        csv_file (str): Path to the output CSV file.\n        column_name (str): Name for the image value column.\n    \"\"\"\n    # Open the GeoTIFF file\n    with rasterio.open(geotiff_file) as dataset:\n        # Get the pixel values as a 2D array\n        data = dataset.read(1)\n\n        if column_name == \"Elevation\":\n            # Convert miles to meters (if applicable)\n            data = data * mile_to_meters\n\n        # Get the geotransform to convert pixel coordinates to geographic coordinates\n        transform = dataset.transform\n\n        # Get the width and height of the GeoTIFF\n        height, width = data.shape\n\n        # Open the CSV file for writing\n        with open(csv_file, 'w', newline='') as csvfile:\n            csvwriter = csv.writer(csvfile)\n\n            # Write the CSV header\n            csvwriter.writerow(['Latitude', 'Longitude', 'x', 'y', column_name])\n\n            # Loop through each pixel and extract latitude, longitude, and image value\n            for y in range(height):\n                for x in range(width):\n                    # Get the pixel value\n                    image_value = data[y, x]\n\n                    # Convert pixel coordinates to geographic coordinates\n                    lon, lat = transform * (x, y)\n\n                    # Write the data to the CSV file\n                    csvwriter.writerow([lat, lon, x, y, image_value])\n\ndef read_elevation_data(file_path, result_dem_csv_path, result_dem_feature_csv_path):\n    \"\"\"\n    Read and process elevation data from a CSV file and save it to another CSV file with additional features.\n\n    Args:\n        file_path (str): Path to the input CSV file containing elevation data.\n        result_dem_csv_path (str): Path to the output CSV file for elevation data.\n        result_dem_feature_csv_path (str): Path to the output CSV file for elevation data with additional features.\n\n    Returns:\n        DataFrame: Merged dataframe with elevation and additional features.\n    \"\"\"\n    neighborhood_size = 4\n    df = pd.read_csv(file_path)\n    \n    dataset = rasterio.open(geotiff_file)\n    data = dataset.read(1)\n\n    # Get the width and height of the GeoTIFF\n    height, width = data.shape\n    \n    # Create an empty DataFrame with column names\n    columns = ['lat', 'lon', 'elevation', 'slope', 'aspect', 'curvature', 'northness', 'eastness']\n    all_df = pd.DataFrame(columns=columns)\n    \n    all_df.to_csv(result_dem_feature_csv_path)\n    print(f\"DEM and other columns are saved to file {result_dem_feature_csv_path}\")\n    return all_df\n\n  \n\n# Usage example:\nresult_dem_csv_path = \"/home/chetana/gridmet_test_run/dem_template.csv\"\nresult_dem_feature_csv_path = \"/home/chetana/gridmet_test_run/dem_all.csv\"\n\ndem_file = \"/home/chetana/gridmet_test_run/dem_file.tif\"\nslope_file = '/home/chetana/gridmet_test_run/slope_file.tif'\naspect_file = '/home/chetana/gridmet_test_run/aspect_file.tif'\ncurvature_file = '/home/chetana/gridmet_test_run/curvature_file.tif'\nnorthness_file = '/home/chetana/gridmet_test_run/northness_file.tif'\neastness_file = '/home/chetana/gridmet_test_run/eastness_file.tif'\n\nslope, aspect = calculate_slope_aspect(dem_file)\ncurvature = calculate_curvature(dem_file)\nnorthness, eastness = calculate_gradients(dem_file)\n\n# Save the slope and aspect as new GeoTIFF files\nsave_as_geotiff(slope, slope_file, dem_file)\nsave_as_geotiff(aspect, aspect_file, dem_file)\nsave_as_geotiff(curvature, curvature_file, dem_file)\nsave_as_geotiff(northness, northness_file, dem_file)\nsave_as_geotiff(eastness, eastness_file, dem_file)\n\ngeotiff_to_csv(dem_file, dem_file+\".csv\", \"Elevation\")\ngeotiff_to_csv(slope_file, slope_file+\".csv\", \"Slope\")\ngeotiff_to_csv(aspect_file, aspect_file+\".csv\", \"Aspect\")\ngeotiff_to_csv(curvature_file, curvature_file+\".csv\", \"Curvature\")\ngeotiff_to_csv(northness_file, northness_file+\".csv\", \"Northness\")\ngeotiff_to_csv(eastness_file, eastness_file+\".csv\", \"Eastness\")\n\n# List of file paths for the CSV files\ncsv_files = [dem_file+\".csv\", slope_file+\".csv\", aspect_file+\".csv\", \n             curvature_file+\".csv\", northness_file+\".csv\", eastness_file+\".csv\"]\n\n# Initialize an empty list to store all dataframes\ndfs = []\n\n# Read each CSV file into separate dataframes\nfor file in csv_files:\n    df = pd.read_csv(file, encoding='utf-8')\n    dfs.append(df)\n\n# Merge the dataframes based on the latitude and longitude columns\nmerged_df = dfs[0]  # Start with the first dataframe\nfor i in range(1, len(dfs)):\n    merged_df = pd.merge(merged_df, dfs[i], on=['Latitude', 'Longitude', 'x', 'y'])\n\n# check the statistics of the columns\nfor column in merged_df.columns:\n    merged_df[column] = pd.to_numeric(merged_df[column], errors='coerce')\n    print(merged_df[column].describe())\n    \n# Save the merged dataframe to a new CSV file\nmerged_df.to_csv(result_dem_feature_csv_path, index=False)\nprint(f\"New dem features are updated in {result_dem_feature_csv_path}\")\n",
  "history_output" : "/home/chetana/gw-workspace/sJ62BhyB14WI/western_us_dem.py:185: RuntimeWarning: invalid value encountered in divide\n  northness = np.arctan(dy / np.sqrt(dx**2 + dy**2))\n/home/chetana/gw-workspace/sJ62BhyB14WI/western_us_dem.py:186: RuntimeWarning: invalid value encountered in divide\n  eastness = np.arctan(dx / np.sqrt(dx**2 + dy**2))\ncount    462204.000000\nmean         37.030000\nstd           6.921275\nmin          25.060000\n25%          31.036000\n50%          37.030000\n75%          43.024000\nmax          49.000000\nName: Latitude, dtype: float64\ncount    462204.00000\nmean       -112.52600\nstd           7.21226\nmin        -125.00000\n25%        -118.77200\n50%        -112.52600\n75%        -106.28000\nmax        -100.05200\nName: Longitude, dtype: float64\ncount    462204.000000\nmean        346.500000\nstd         200.340552\nmin           0.000000\n25%         173.000000\n50%         346.500000\n75%         520.000000\nmax         693.000000\nName: x, dtype: float64\ncount    462204.000000\nmean        332.500000\nstd         192.257631\nmin           0.000000\n25%         166.000000\n50%         332.500000\n75%         499.000000\nmax         665.000000\nName: y, dtype: float64\ncount    4.622040e+05\nmean     1.650586e+06\nstd      1.301869e+06\nmin     -1.334761e+05\n25%      2.908516e+05\n50%      1.639045e+06\n75%      2.582782e+06\nmax      6.722491e+06\nName: Elevation, dtype: float64\ncount    462204.000000\nmean         71.653609\nstd          36.142936\nmin           0.000000\n25%          89.711186\n50%          89.943880\n75%          89.981230\nmax          89.998410\nName: Slope, dtype: float64\ncount    462204.000000\nmean        150.657475\nstd         119.139631\nmin           0.000000\n25%          22.385444\n50%         147.928925\n75%         258.982280\nmax         359.999600\nName: Aspect, dtype: float64\ncount    462204.000000\nmean        -14.973298\nstd         859.335403\nmin      -12522.879000\n25%        -147.035178\n50%           0.000000\n75%         256.102103\nmax        6526.172000\nName: Curvature, dtype: float64\ncount    368579.000000\nmean         -0.012698\nstd           0.587101\nmin          -0.785398\n25%          -0.626382\n50%          -0.027939\n75%           0.608819\nmax           0.785398\nName: Northness, dtype: float64\ncount    368579.000000\nmean         -0.040279\nstd           0.583256\nmin          -0.785398\n25%          -0.643895\n50%          -0.087261\n75%           0.573790\nmax           0.785398\nName: Eastness, dtype: float64\nNew dem features are updated in /home/chetana/gridmet_test_run/dem_all.csv\n",
  "history_begin_time" : 1700445703308,
  "history_end_time" : 1700445719557,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "weSaiTDc61c0",
  "history_input" : "import numpy as np\nimport pandas as pd\nfrom osgeo import gdal\nimport warnings\nimport rasterio\nimport csv\nfrom rasterio.transform import Affine\nfrom scipy.ndimage import sobel, gaussian_filter\n\nmile_to_meters = 1609.34\n\n# Set the warning filter globally to ignore the FutureWarning\nwarnings.simplefilter(\"ignore\", FutureWarning)\n\ndef lat_lon_to_pixel(lat, lon, geotransform):\n    \"\"\"\n    Convert latitude and longitude to pixel coordinates using a geotransform.\n\n    Args:\n        lat (float): Latitude.\n        lon (float): Longitude.\n        geotransform (tuple): Geotransform coefficients (e.g., (origin_x, pixel_width, 0, origin_y, 0, pixel_height)).\n\n    Returns:\n        tuple: Pixel coordinates (x, y).\n    \"\"\"\n    x = int((lon - geotransform[0]) / geotransform[1])\n    y = int((lat - geotransform[3]) / geotransform[5])\n    return x, y\n\ndef calculate_slope_aspect_for_single(elevation_data, pixel_size_x, pixel_size_y):\n    \"\"\"\n    Calculate slope and aspect for a single pixel using elevation data.\n\n    Args:\n        elevation_data (array): Elevation data.\n        pixel_size_x (float): Pixel size in the x-direction.\n        pixel_size_y (float): Pixel size in the y-direction.\n\n    Returns:\n        tuple: Slope (in degrees), aspect (in degrees).\n    \"\"\"\n    # Calculate slope using the Sobel operator\n    slope_x = np.gradient(elevation_data, pixel_size_x, axis=1)\n    slope_y = np.gradient(elevation_data, pixel_size_y, axis=0)\n    slope_rad = np.arctan(np.sqrt(slope_x ** 2 + slope_y ** 2))\n    slope_deg = np.degrees(slope_rad)\n\n    # Calculate aspect (direction of the steepest descent)\n    aspect_rad = np.arctan2(slope_y, -slope_x)\n    aspect_deg = (np.degrees(aspect_rad) + 360) % 360\n\n    return slope_deg, aspect_deg\n\ndef save_as_geotiff(data, output_file, src_file):\n    \"\"\"\n    Save data as a GeoTIFF file with metadata from the source file.\n\n    Args:\n        data (array): Data to be saved.\n        output_file (str): Path to the output GeoTIFF file.\n        src_file (str): Path to the source GeoTIFF file to inherit metadata from.\n    \"\"\"\n    with rasterio.open(src_file) as src_dataset:\n        profile = src_dataset.profile\n        transform = src_dataset.transform\n\n        # Update the data type, count, and set the transform for the new dataset\n        profile.update(dtype=rasterio.float32, count=1, transform=transform)\n\n        # Create the new GeoTIFF file\n        with rasterio.open(output_file, 'w', **profile) as dst_dataset:\n            # Write the data to the new GeoTIFF\n            dst_dataset.write(data, 1)\n\ndef print_statistics(data):\n    \"\"\"\n    Print basic statistics of a data array.\n\n    Args:\n        data (array): Data array to calculate statistics for.\n    \"\"\"\n    # Calculate multiple statistics in one line\n    data = data[~np.isnan(data)]\n    mean, median, min_val, max_val, sum_val, std_dev, variance = [np.mean(data), np.median(data), np.min(data), np.max(data), np.sum(data), np.std(data), np.var(data)]\n\n    # Print the calculated statistics\n    print(\"Mean:\", mean)\n    print(\"Median:\", median)\n    print(\"Minimum:\", min_val)\n    print(\"Maximum:\", max_val)\n    print(\"Sum:\", sum_val)\n    print(\"Standard Deviation:\", std_dev)\n    print(\"Variance:\", variance)\n\ndef calculate_slope_aspect(dem_file):\n    \"\"\"\n    Calculate slope and aspect from a DEM (Digital Elevation Model) file.\n\n    Args:\n        dem_file (str): Path to the DEM GeoTIFF file.\n\n    Returns:\n        tuple: Slope array (in degrees), aspect array (in degrees).\n    \"\"\"\n    with rasterio.open(dem_file) as dataset:\n        # Read the DEM data as a numpy array\n        dem_data = dataset.read(1)\n\n        # Get the geotransform to convert pixel coordinates to geographic coordinates\n        transform = dataset.transform\n\n        # Calculate the slope and aspect using numpy\n        dx, dy = np.gradient(dem_data, transform[0], transform[4])\n        slope = np.degrees(np.arctan(np.sqrt(dx**2 + dy**2)))\n        aspect = np.degrees(np.arctan2(-dy, dx))\n\n        # Adjust aspect values to range from 0 to 360 degrees\n        aspect[aspect < 0] += 360\n\n    return slope, aspect\n\ndef calculate_curvature(elevation_data, pixel_size_x, pixel_size_y):\n    \"\"\"\n    Calculate curvature from elevation data using the Laplacian operator.\n\n    Args:\n        elevation_data (array): Elevation data.\n        pixel_size_x (float): Pixel size in the x-direction.\n        pixel_size_y (float): Pixel size in the y-direction.\n\n    Returns:\n        array: Curvature data.\n    \"\"\"\n    # Calculate curvature using the Laplacian operator\n    curvature_x = np.gradient(np.gradient(elevation_data, pixel_size_x, axis=1), pixel_size_x, axis=1)\n    curvature_y = np.gradient(np.gradient(elevation_data, pixel_size_y, axis=0), pixel_size_y, axis=0)\n    curvature = curvature_x + curvature_y\n\n    return curvature\n  \ndef calculate_curvature(dem_file, sigma=1):\n    with rasterio.open(dem_file) as dataset:\n        # Read the DEM data as a numpy array\n        dem_data = dataset.read(1)\n        \n        # convert miles to meters\n        dem_data = dem_data*mile_to_meters\n\n        # Calculate the gradient using the Sobel filter\n        dx = sobel(dem_data, axis=1, mode='constant')\n        dy = sobel(dem_data, axis=0, mode='constant')\n\n        # Calculate the second derivatives using the Sobel filter\n        dxx = sobel(dx, axis=1, mode='constant')\n        dyy = sobel(dy, axis=0, mode='constant')\n\n        # Calculate the curvature using the second derivatives\n        curvature = dxx + dyy\n\n        # Smooth the curvature using Gaussian filtering (optional)\n        curvature = gaussian_filter(curvature, sigma)\n\n    return curvature\n\ndef calculate_gradients(dem_file):\n    \"\"\"\n    Calculate Northness and Eastness gradients from a DEM (Digital Elevation Model) file.\n\n    Args:\n        dem_file (str): Path to the DEM GeoTIFF file.\n\n    Returns:\n        tuple: Northness array, Eastness array (both in radians).\n    \"\"\"\n    with rasterio.open(dem_file) as dataset:\n        # Read the DEM data as a numpy array\n        dem_data = dataset.read(1)\n\n        # Calculate the gradients along the North and East directions\n        dy, dx = np.gradient(dem_data, dataset.res[0], dataset.res[1])\n\n        # Calculate the Northness and Eastness\n        northness = np.arctan(dy / np.sqrt(dx**2 + dy**2))\n        eastness = np.arctan(dx / np.sqrt(dx**2 + dy**2))\n\n    return northness, eastness\n\ndef geotiff_to_csv(geotiff_file, csv_file, column_name):\n    \"\"\"\n    Convert a GeoTIFF file to a CSV file containing latitude, longitude, and image values.\n\n    Args:\n        geotiff_file (str): Path to the input GeoTIFF file.\n        csv_file (str): Path to the output CSV file.\n        column_name (str): Name for the image value column.\n    \"\"\"\n    # Open the GeoTIFF file\n    with rasterio.open(geotiff_file) as dataset:\n        # Get the pixel values as a 2D array\n        data = dataset.read(1)\n\n        if column_name == \"Elevation\":\n            # Convert miles to meters (if applicable)\n            data = data * mile_to_meters\n\n        # Get the geotransform to convert pixel coordinates to geographic coordinates\n        transform = dataset.transform\n\n        # Get the width and height of the GeoTIFF\n        height, width = data.shape\n\n        # Open the CSV file for writing\n        with open(csv_file, 'w', newline='') as csvfile:\n            csvwriter = csv.writer(csvfile)\n\n            # Write the CSV header\n            csvwriter.writerow(['Latitude', 'Longitude', 'x', 'y', column_name])\n\n            # Loop through each pixel and extract latitude, longitude, and image value\n            for y in range(height):\n                for x in range(width):\n                    # Get the pixel value\n                    image_value = data[y, x]\n\n                    # Convert pixel coordinates to geographic coordinates\n                    lon, lat = transform * (x, y)\n\n                    # Write the data to the CSV file\n                    csvwriter.writerow([lat, lon, x, y, image_value])\n\ndef read_elevation_data(file_path, result_dem_csv_path, result_dem_feature_csv_path):\n    \"\"\"\n    Read and process elevation data from a CSV file and save it to another CSV file with additional features.\n\n    Args:\n        file_path (str): Path to the input CSV file containing elevation data.\n        result_dem_csv_path (str): Path to the output CSV file for elevation data.\n        result_dem_feature_csv_path (str): Path to the output CSV file for elevation data with additional features.\n\n    Returns:\n        DataFrame: Merged dataframe with elevation and additional features.\n    \"\"\"\n    neighborhood_size = 4\n    df = pd.read_csv(file_path)\n    \n    dataset = rasterio.open(geotiff_file)\n    data = dataset.read(1)\n\n    # Get the width and height of the GeoTIFF\n    height, width = data.shape\n    \n    # Create an empty DataFrame with column names\n    columns = ['lat', 'lon', 'elevation', 'slope', 'aspect', 'curvature', 'northness', 'eastness']\n    all_df = pd.DataFrame(columns=columns)\n    \n    all_df.to_csv(result_dem_feature_csv_path)\n    print(f\"DEM and other columns are saved to file {result_dem_feature_csv_path}\")\n    return all_df\n\n  \n\n# Usage example:\nresult_dem_csv_path = \"/home/chetana/gridmet_test_run/dem_template.csv\"\nresult_dem_feature_csv_path = \"/home/chetana/gridmet_test_run/dem_all.csv\"\n\ndem_file = \"/home/chetana/gridmet_test_run/dem_file.tif\"\nslope_file = '/home/chetana/gridmet_test_run/slope_file.tif'\naspect_file = '/home/chetana/gridmet_test_run/aspect_file.tif'\ncurvature_file = '/home/chetana/gridmet_test_run/curvature_file.tif'\nnorthness_file = '/home/chetana/gridmet_test_run/northness_file.tif'\neastness_file = '/home/chetana/gridmet_test_run/eastness_file.tif'\n\nslope, aspect = calculate_slope_aspect(dem_file)\ncurvature = calculate_curvature(dem_file)\nnorthness, eastness = calculate_gradients(dem_file)\n\n# Save the slope and aspect as new GeoTIFF files\nsave_as_geotiff(slope, slope_file, dem_file)\nsave_as_geotiff(aspect, aspect_file, dem_file)\nsave_as_geotiff(curvature, curvature_file, dem_file)\nsave_as_geotiff(northness, northness_file, dem_file)\nsave_as_geotiff(eastness, eastness_file, dem_file)\n\ngeotiff_to_csv(dem_file, dem_file+\".csv\", \"Elevation\")\ngeotiff_to_csv(slope_file, slope_file+\".csv\", \"Slope\")\ngeotiff_to_csv(aspect_file, aspect_file+\".csv\", \"Aspect\")\ngeotiff_to_csv(curvature_file, curvature_file+\".csv\", \"Curvature\")\ngeotiff_to_csv(northness_file, northness_file+\".csv\", \"Northness\")\ngeotiff_to_csv(eastness_file, eastness_file+\".csv\", \"Eastness\")\n\n# List of file paths for the CSV files\ncsv_files = [dem_file+\".csv\", slope_file+\".csv\", aspect_file+\".csv\", \n             curvature_file+\".csv\", northness_file+\".csv\", eastness_file+\".csv\"]\n\n# Initialize an empty list to store all dataframes\ndfs = []\n\n# Read each CSV file into separate dataframes\nfor file in csv_files:\n    df = pd.read_csv(file, encoding='utf-8')\n    dfs.append(df)\n\n# Merge the dataframes based on the latitude and longitude columns\nmerged_df = dfs[0]  # Start with the first dataframe\nfor i in range(1, len(dfs)):\n    merged_df = pd.merge(merged_df, dfs[i], on=['Latitude', 'Longitude', 'x', 'y'])\n\n# check the statistics of the columns\nfor column in merged_df.columns:\n    merged_df[column] = pd.to_numeric(merged_df[column], errors='coerce')\n    print(merged_df[column].describe())\n    \n# Save the merged dataframe to a new CSV file\nmerged_df.to_csv(result_dem_feature_csv_path, index=False)\nprint(f\"New dem features are updated in {result_dem_feature_csv_path}\")\n",
  "history_output" : "/home/chetana/gw-workspace/weSaiTDc61c0/western_us_dem.py:184: RuntimeWarning: invalid value encountered in divide\n  northness = np.arctan(dy / np.sqrt(dx**2 + dy**2))\n/home/chetana/gw-workspace/weSaiTDc61c0/western_us_dem.py:185: RuntimeWarning: invalid value encountered in divide\n  eastness = np.arctan(dx / np.sqrt(dx**2 + dy**2))\ncount    462204.000000\nmean         37.030000\nstd           6.921275\nmin          25.060000\n25%          31.036000\n50%          37.030000\n75%          43.024000\nmax          49.000000\nName: Latitude, dtype: float64\ncount    462204.00000\nmean       -112.52600\nstd           7.21226\nmin        -125.00000\n25%        -118.77200\n50%        -112.52600\n75%        -106.28000\nmax        -100.05200\nName: Longitude, dtype: float64\ncount    462204.000000\nmean        346.500000\nstd         200.340552\nmin           0.000000\n25%         173.000000\n50%         346.500000\n75%         520.000000\nmax         693.000000\nName: x, dtype: float64\ncount    462204.000000\nmean        332.500000\nstd         192.257631\nmin           0.000000\n25%         166.000000\n50%         332.500000\n75%         499.000000\nmax         665.000000\nName: y, dtype: float64\ncount    4.622040e+05\nmean     1.650586e+06\nstd      1.301869e+06\nmin     -1.334761e+05\n25%      2.908516e+05\n50%      1.639045e+06\n75%      2.582782e+06\nmax      6.722491e+06\nName: Elevation, dtype: float64\ncount    462204.000000\nmean         71.653609\nstd          36.142936\nmin           0.000000\n25%          89.711186\n50%          89.943880\n75%          89.981230\nmax          89.998410\nName: Slope, dtype: float64\ncount    462204.000000\nmean        150.657475\nstd         119.139631\nmin           0.000000\n25%          22.385444\n50%         147.928925\n75%         258.982280\nmax         359.999600\nName: Aspect, dtype: float64\ncount    4.622040e+05\nmean    -7.905881e+04\nstd      4.537279e+06\nmin     -6.612064e+07\n25%     -7.763437e+05\n50%      0.000000e+00\n75%      1.352217e+06\nmax      3.445810e+07\nName: Curvature, dtype: float64\ncount    368579.000000\nmean         -0.012698\nstd           0.587101\nmin          -0.785398\n25%          -0.626382\n50%          -0.027939\n75%           0.608819\nmax           0.785398\nName: Northness, dtype: float64\ncount    368579.000000\nmean         -0.040279\nstd           0.583256\nmin          -0.785398\n25%          -0.643895\n50%          -0.087261\n75%           0.573790\nmax           0.785398\nName: Eastness, dtype: float64\nNew dem features are updated in /home/chetana/gridmet_test_run/dem_all.csv\n",
  "history_begin_time" : 1700445266058,
  "history_end_time" : 1700445282420,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "qpxPFtlGQQyD",
  "history_input" : "import numpy as np\nimport pandas as pd\nfrom osgeo import gdal\nimport warnings\nimport rasterio\nimport csv\nfrom rasterio.transform import Affine\nfrom scipy.ndimage import sobel, gaussian_filter\n\nmile_to_meters = 1609.34\n\n# Set the warning filter globally to ignore the FutureWarning\nwarnings.simplefilter(\"ignore\", FutureWarning)\n\ndef lat_lon_to_pixel(lat, lon, geotransform):\n    \"\"\"\n    Convert latitude and longitude to pixel coordinates using a geotransform.\n\n    Args:\n        lat (float): Latitude.\n        lon (float): Longitude.\n        geotransform (tuple): Geotransform coefficients (e.g., (origin_x, pixel_width, 0, origin_y, 0, pixel_height)).\n\n    Returns:\n        tuple: Pixel coordinates (x, y).\n    \"\"\"\n    x = int((lon - geotransform[0]) / geotransform[1])\n    y = int((lat - geotransform[3]) / geotransform[5])\n    return x, y\n\ndef calculate_slope_aspect_for_single(elevation_data, pixel_size_x, pixel_size_y):\n    \"\"\"\n    Calculate slope and aspect for a single pixel using elevation data.\n\n    Args:\n        elevation_data (array): Elevation data.\n        pixel_size_x (float): Pixel size in the x-direction.\n        pixel_size_y (float): Pixel size in the y-direction.\n\n    Returns:\n        tuple: Slope (in degrees), aspect (in degrees).\n    \"\"\"\n    # Calculate slope using the Sobel operator\n    slope_x = np.gradient(elevation_data, pixel_size_x, axis=1)\n    slope_y = np.gradient(elevation_data, pixel_size_y, axis=0)\n    slope_rad = np.arctan(np.sqrt(slope_x ** 2 + slope_y ** 2))\n    slope_deg = np.degrees(slope_rad)\n\n    # Calculate aspect (direction of the steepest descent)\n    aspect_rad = np.arctan2(slope_y, -slope_x)\n    aspect_deg = (np.degrees(aspect_rad) + 360) % 360\n\n    return slope_deg, aspect_deg\n\ndef save_as_geotiff(data, output_file, src_file):\n    \"\"\"\n    Save data as a GeoTIFF file with metadata from the source file.\n\n    Args:\n        data (array): Data to be saved.\n        output_file (str): Path to the output GeoTIFF file.\n        src_file (str): Path to the source GeoTIFF file to inherit metadata from.\n    \"\"\"\n    with rasterio.open(src_file) as src_dataset:\n        profile = src_dataset.profile\n        transform = src_dataset.transform\n\n        # Update the data type, count, and set the transform for the new dataset\n        profile.update(dtype=rasterio.float32, count=1, transform=transform)\n\n        # Create the new GeoTIFF file\n        with rasterio.open(output_file, 'w', **profile) as dst_dataset:\n            # Write the data to the new GeoTIFF\n            dst_dataset.write(data, 1)\n\ndef print_statistics(data):\n    \"\"\"\n    Print basic statistics of a data array.\n\n    Args:\n        data (array): Data array to calculate statistics for.\n    \"\"\"\n    # Calculate multiple statistics in one line\n    data = data[~np.isnan(data)]\n    mean, median, min_val, max_val, sum_val, std_dev, variance = [np.mean(data), np.median(data), np.min(data), np.max(data), np.sum(data), np.std(data), np.var(data)]\n\n    # Print the calculated statistics\n    print(\"Mean:\", mean)\n    print(\"Median:\", median)\n    print(\"Minimum:\", min_val)\n    print(\"Maximum:\", max_val)\n    print(\"Sum:\", sum_val)\n    print(\"Standard Deviation:\", std_dev)\n    print(\"Variance:\", variance)\n\ndef calculate_slope_aspect(dem_file):\n    \"\"\"\n    Calculate slope and aspect from a DEM (Digital Elevation Model) file.\n\n    Args:\n        dem_file (str): Path to the DEM GeoTIFF file.\n\n    Returns:\n        tuple: Slope array (in degrees), aspect array (in degrees).\n    \"\"\"\n    with rasterio.open(dem_file) as dataset:\n        # Read the DEM data as a numpy array\n        dem_data = dataset.read(1)\n\n        # Get the geotransform to convert pixel coordinates to geographic coordinates\n        transform = dataset.transform\n\n        # Calculate the slope and aspect using numpy\n        dx, dy = np.gradient(dem_data, transform[0], transform[4])\n        slope = np.degrees(np.arctan(np.sqrt(dx**2 + dy**2)))\n        aspect = np.degrees(np.arctan2(-dy, dx))\n\n        # Adjust aspect values to range from 0 to 360 degrees\n        aspect[aspect < 0] += 360\n\n    return slope, aspect\n\ndef calculate_curvature(elevation_data, pixel_size_x, pixel_size_y):\n    \"\"\"\n    Calculate curvature from elevation data using the Laplacian operator.\n\n    Args:\n        elevation_data (array): Elevation data.\n        pixel_size_x (float): Pixel size in the x-direction.\n        pixel_size_y (float): Pixel size in the y-direction.\n\n    Returns:\n        array: Curvature data.\n    \"\"\"\n    # Calculate curvature using the Laplacian operator\n    curvature_x = np.gradient(np.gradient(elevation_data, pixel_size_x, axis=1), pixel_size_x, axis=1)\n    curvature_y = np.gradient(np.gradient(elevation_data, pixel_size_y, axis=0), pixel_size_y, axis=0)\n    curvature = curvature_x + curvature_y\n\n    return curvature\n\ndef calculate_gradients(dem_file):\n    \"\"\"\n    Calculate Northness and Eastness gradients from a DEM (Digital Elevation Model) file.\n\n    Args:\n        dem_file (str): Path to the DEM GeoTIFF file.\n\n    Returns:\n        tuple: Northness array, Eastness array (both in radians).\n    \"\"\"\n    with rasterio.open(dem_file) as dataset:\n        # Read the DEM data as a numpy array\n        dem_data = dataset.read(1)\n\n        # Calculate the gradients along the North and East directions\n        dy, dx = np.gradient(dem_data, dataset.res[0], dataset.res[1])\n\n        # Calculate the Northness and Eastness\n        northness = np.arctan(dy / np.sqrt(dx**2 + dy**2))\n        eastness = np.arctan(dx / np.sqrt(dx**2 + dy**2))\n\n    return northness, eastness\n\ndef geotiff_to_csv(geotiff_file, csv_file, column_name):\n    \"\"\"\n    Convert a GeoTIFF file to a CSV file containing latitude, longitude, and image values.\n\n    Args:\n        geotiff_file (str): Path to the input GeoTIFF file.\n        csv_file (str): Path to the output CSV file.\n        column_name (str): Name for the image value column.\n    \"\"\"\n    # Open the GeoTIFF file\n    with rasterio.open(geotiff_file) as dataset:\n        # Get the pixel values as a 2D array\n        data = dataset.read(1)\n\n        if column_name == \"Elevation\":\n            # Convert miles to meters (if applicable)\n            data = data * mile_to_meters\n\n        # Get the geotransform to convert pixel coordinates to geographic coordinates\n        transform = dataset.transform\n\n        # Get the width and height of the GeoTIFF\n        height, width = data.shape\n\n        # Open the CSV file for writing\n        with open(csv_file, 'w', newline='') as csvfile:\n            csvwriter = csv.writer(csvfile)\n\n            # Write the CSV header\n            csvwriter.writerow(['Latitude', 'Longitude', 'x', 'y', column_name])\n\n            # Loop through each pixel and extract latitude, longitude, and image value\n            for y in range(height):\n                for x in range(width):\n                    # Get the pixel value\n                    image_value = data[y, x]\n\n                    # Convert pixel coordinates to geographic coordinates\n                    lon, lat = transform * (x, y)\n\n                    # Write the data to the CSV file\n                    csvwriter.writerow([lat, lon, x, y, image_value])\n\ndef read_elevation_data(file_path, result_dem_csv_path, result_dem_feature_csv_path):\n    \"\"\"\n    Read and process elevation data from a CSV file and save it to another CSV file with additional features.\n\n    Args:\n        file_path (str): Path to the input CSV file containing elevation data.\n        result_dem_csv_path (str): Path to the output CSV file for elevation data.\n        result_dem_feature_csv_path (str): Path to the output CSV file for elevation data with additional features.\n\n    Returns:\n        DataFrame: Merged dataframe with elevation and additional features.\n    \"\"\"\n    neighborhood_size = 4\n    df = pd.read_csv(file_path)\n    \n    dataset = rasterio.open(geotiff_file)\n    data = dataset.read(1)\n\n    # Get the width and height of the GeoTIFF\n    height, width = data.shape\n    \n    # Create an empty DataFrame with column names\n    columns = ['lat', 'lon', 'elevation', 'slope', 'aspect', 'curvature', 'northness', 'eastness']\n    all_df = pd.DataFrame(columns=columns)\n    \n    all_df.to_csv(result_dem_feature_csv_path)\n    print(f\"DEM and other columns are saved to file {result_dem_feature_csv_path}\")\n    return all_df\n\n  \n\n# Usage example:\nresult_dem_csv_path = \"/home/chetana/gridmet_test_run/dem_template.csv\"\nresult_dem_feature_csv_path = \"/home/chetana/gridmet_test_run/dem_all.csv\"\n\ndem_file = \"/home/chetana/gridmet_test_run/dem_file.tif\"\nslope_file = '/home/chetana/gridmet_test_run/slope_file.tif'\naspect_file = '/home/chetana/gridmet_test_run/aspect_file.tif'\ncurvature_file = '/home/chetana/gridmet_test_run/curvature_file.tif'\nnorthness_file = '/home/chetana/gridmet_test_run/northness_file.tif'\neastness_file = '/home/chetana/gridmet_test_run/eastness_file.tif'\n\nslope, aspect = calculate_slope_aspect(dem_file)\ncurvature = calculate_curvature(dem_file)\nnorthness, eastness = calculate_gradients(dem_file)\n\n# Save the slope and aspect as new GeoTIFF files\nsave_as_geotiff(slope, slope_file, dem_file)\nsave_as_geotiff(aspect, aspect_file, dem_file)\nsave_as_geotiff(curvature, curvature_file, dem_file)\nsave_as_geotiff(northness, northness_file, dem_file)\nsave_as_geotiff(eastness, eastness_file, dem_file)\n\ngeotiff_to_csv(dem_file, dem_file+\".csv\", \"Elevation\")\ngeotiff_to_csv(slope_file, slope_file+\".csv\", \"Slope\")\ngeotiff_to_csv(aspect_file, aspect_file+\".csv\", \"Aspect\")\ngeotiff_to_csv(curvature_file, curvature_file+\".csv\", \"Curvature\")\ngeotiff_to_csv(northness_file, northness_file+\".csv\", \"Northness\")\ngeotiff_to_csv(eastness_file, eastness_file+\".csv\", \"Eastness\")\n\n# List of file paths for the CSV files\ncsv_files = [dem_file+\".csv\", slope_file+\".csv\", aspect_file+\".csv\", \n             curvature_file+\".csv\", northness_file+\".csv\", eastness_file+\".csv\"]\n\n# Initialize an empty list to store all dataframes\ndfs = []\n\n# Read each CSV file into separate dataframes\nfor file in csv_files:\n    df = pd.read_csv(file, encoding='utf-8')\n    dfs.append(df)\n\n# Merge the dataframes based on the latitude and longitude columns\nmerged_df = dfs[0]  # Start with the first dataframe\nfor i in range(1, len(dfs)):\n    merged_df = pd.merge(merged_df, dfs[i], on=['Latitude', 'Longitude', 'x', 'y'])\n\n# check the statistics of the columns\nfor column in merged_df.columns:\n    merged_df[column] = pd.to_numeric(merged_df[column], errors='coerce')\n    print(merged_df[column].describe())\n    \n# Save the merged dataframe to a new CSV file\nmerged_df.to_csv(result_dem_feature_csv_path, index=False)\nprint(f\"New dem features are updated in {result_dem_feature_csv_path}\")\n",
  "history_output" : "Traceback (most recent call last):\n  File \"/home/chetana/gw-workspace/qpxPFtlGQQyD/western_us_dem.py\", line 251, in <module>\n    curvature = calculate_curvature(dem_file)\nTypeError: calculate_curvature() missing 2 required positional arguments: 'pixel_size_x' and 'pixel_size_y'\n",
  "history_begin_time" : 1700445148592,
  "history_end_time" : 1700445152991,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : null,
  "indicator" : "Failed"
},{
  "history_id" : "yngawx3tcp4",
  "history_input" : null,
  "history_output" : "Authentication Failed. Wrong Password.",
  "history_begin_time" : 1700230067673,
  "history_end_time" : 1700230069118,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Failed"
},{
  "history_id" : "e6w5v67pyhl",
  "history_input" : null,
  "history_output" : "Authentication Failed. Wrong Password.",
  "history_begin_time" : 1700229012765,
  "history_end_time" : 1700229014225,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Failed"
},{
  "history_id" : "nykj7lo5cld",
  "history_input" : null,
  "history_output" : "Authentication Failed. Wrong Password.",
  "history_begin_time" : 1700210214005,
  "history_end_time" : 1700210215497,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Failed"
},{
  "history_id" : "7s4t765gep8",
  "history_input" : null,
  "history_output" : "Authentication Failed. Wrong Password.",
  "history_begin_time" : 1700209781144,
  "history_end_time" : 1700209782598,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Failed"
},{
  "history_id" : "gvr55jqnf96",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1700209729246,
  "history_end_time" : 1700209729246,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "0th3g8olf4k",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1700203478647,
  "history_end_time" : 1700204245682,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Stopped"
},{
  "history_id" : "nkf2uqtbdq1",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1700201828263,
  "history_end_time" : 1700201828263,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "ip2rgr2ga9i",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1700200332855,
  "history_end_time" : 1700200332855,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "rcygf3e7b9p",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1700145667869,
  "history_end_time" : 1700145667869,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "sfvuv0mzgrj",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1700143295305,
  "history_end_time" : 1700143295305,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "5q0ccrovebt",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1700141615812,
  "history_end_time" : 1700141615812,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "nc20zvw36hs",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1700134126837,
  "history_end_time" : 1700134126837,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "k2qynxf6cqw",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1700133783705,
  "history_end_time" : 1700133783705,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "vusph17ueil",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1699992839758,
  "history_end_time" : 1699992839758,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "ar5ko6nu16r",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1699982145434,
  "history_end_time" : 1699982145434,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "l5gc1s3aj3l",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1699941614800,
  "history_end_time" : 1699941614800,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "r5c89mr1gw3",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1699939440553,
  "history_end_time" : 1699939440553,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "fdth9z585ln",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1699937910465,
  "history_end_time" : 1699937910465,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "2al9v5r3wb8",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1699805634648,
  "history_end_time" : 1699806085193,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Stopped"
},{
  "history_id" : "l3xolsrz1hc",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1699684154062,
  "history_end_time" : 1705789690232,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Stopped"
},{
  "history_id" : "73tas6z8ak1",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1699681071343,
  "history_end_time" : 1699681071343,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "zje5nptj0ez",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1698762678694,
  "history_end_time" : 1698762678694,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "ey9gtgi4wx7",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1698762637971,
  "history_end_time" : 1698762637971,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "ur1otmb8ybl",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1698276496957,
  "history_end_time" : 1698276496957,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "ftvl8aww39a",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1698252277360,
  "history_end_time" : 1698252277360,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "ny9l7jtvvdk",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1698251392463,
  "history_end_time" : 1698251392463,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "0chmmpw6ox2",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1698228210954,
  "history_end_time" : 1698228210954,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "1mzb0xri3ff",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1698227897136,
  "history_end_time" : 1698227897136,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "m12h4hpns4r",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1698163737289,
  "history_end_time" : 1698163737289,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "e0v20hmmk8r",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1698163445823,
  "history_end_time" : 1698163445823,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "5noo8b551g5",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1698163121536,
  "history_end_time" : 1698163121536,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "chle4pco6px",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1698160809372,
  "history_end_time" : 1698160809372,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "dj34a6pfdf8",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1698157805174,
  "history_end_time" : 1698157805174,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "98i1ess8xb5",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1698152099739,
  "history_end_time" : 1698152099739,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "8vdmg8tclsd",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1698095495741,
  "history_end_time" : 1698095495741,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "34ivapx3l7x",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1698075453580,
  "history_end_time" : 1698075453580,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "u93zleiilmy",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1697349529998,
  "history_end_time" : 1697349529998,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "ovjbftgt5j0",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1697348852273,
  "history_end_time" : 1697348852273,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "50jcbsgb8hm",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1697189923556,
  "history_end_time" : 1697189923556,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "oiygtm3hqnv",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1697188523294,
  "history_end_time" : 1697188523294,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "sw8hamrxs6x",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1697187892261,
  "history_end_time" : 1697187892261,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "nraadi0ulv4",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1697187367967,
  "history_end_time" : 1697187367967,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "p27hd56zfj8",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1696863953273,
  "history_end_time" : 1696863953273,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "0dw7ov4zyww",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1696862402949,
  "history_end_time" : 1696862402949,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "fdjhrjcb75k",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1696832263668,
  "history_end_time" : 1696832263668,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "u6q2uonm2nx",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1696831867372,
  "history_end_time" : 1696831867372,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "ql3up9h98tf",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1696830174366,
  "history_end_time" : 1696830174366,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "lkgt2e4cff8",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1696787541910,
  "history_end_time" : 1696787541910,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "0w7lw4lbl6w",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1696786838193,
  "history_end_time" : 1696786838193,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "7f3cjaex5mi",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1696771780903,
  "history_end_time" : 1696771780903,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "hpadiajx429",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1696602943941,
  "history_end_time" : 1696602943941,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "s0mkun67bcn",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1696432484318,
  "history_end_time" : 1696432484318,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "xmjneng49m5",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1696432299759,
  "history_end_time" : 1696432482234,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Stopped"
},{
  "history_id" : "dhcotamin2v",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1695827991090,
  "history_end_time" : 1695827991090,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "3fxsbvguisd",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1695827889174,
  "history_end_time" : 1695827964215,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Stopped"
},{
  "history_id" : "6ftkrokysl2",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1695827855642,
  "history_end_time" : 1695827867008,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Stopped"
},{
  "history_id" : "pzu795ct0rt",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1695696616114,
  "history_end_time" : 1695696616114,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "t9gkh7yam2n",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1695694257325,
  "history_end_time" : 1695694257325,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "5u6l2i46scy",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1695693585744,
  "history_end_time" : 1695693585744,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "f3n08jxjal5",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1695693149368,
  "history_end_time" : 1695693149368,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "5404cafv5bk",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1695580915844,
  "history_end_time" : 1695580915844,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "ymm77100vcj",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1695576291654,
  "history_end_time" : 1695576291654,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "aq2al6wd71f",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1695575931016,
  "history_end_time" : 1695575931016,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "0uult9qlbco",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1695535769211,
  "history_end_time" : 1695535769211,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "enpif6ik7mx",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1695535478699,
  "history_end_time" : 1695535478699,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "usrah3pmfn8",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1695535214021,
  "history_end_time" : 1695535214021,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "viv5mnvmowi",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1695534943585,
  "history_end_time" : 1695534943585,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "8re3qr8rqte",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1695534671825,
  "history_end_time" : 1695534671825,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "izdvzolvkjq",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1695533024127,
  "history_end_time" : 1695533024127,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "djxoSgs5JGwT",
  "history_input" : "import numpy as np\nimport pandas as pd\nfrom osgeo import gdal\nimport warnings\nimport rasterio\nimport csv\nfrom rasterio.transform import Affine\nfrom scipy.ndimage import sobel, gaussian_filter\n\nmile_to_meters = 1609.34\n\n# Set the warning filter globally to ignore the FutureWarning\nwarnings.simplefilter(\"ignore\", FutureWarning)\n\ndef lat_lon_to_pixel(lat, lon, geotransform):\n    x = int((lon - geotransform[0]) / geotransform[1])\n    y = int((lat - geotransform[3]) / geotransform[5])\n    return x, y\n\n\ndef calculate_slope_aspect_for_single(elevation_data, pixel_size_x, pixel_size_y):\n    # Calculate slope using the Sobel operator\n    slope_x = np.gradient(elevation_data, pixel_size_x, axis=1)\n    slope_y = np.gradient(elevation_data, pixel_size_y, axis=0)\n    slope_rad = np.arctan(np.sqrt(slope_x ** 2 + slope_y ** 2))\n    slope_deg = np.degrees(slope_rad)\n\n    # Calculate aspect (direction of the steepest descent)\n    aspect_rad = np.arctan2(slope_y, -slope_x)\n    aspect_deg = (np.degrees(aspect_rad) + 360) % 360\n\n    return slope_deg, aspect_deg\n\n\ndef save_as_geotiff(data, output_file, src_file):\n    with rasterio.open(src_file) as src_dataset:\n        profile = src_dataset.profile\n        transform = src_dataset.transform\n\n        # Update the data type, count, and set the transform for the new dataset\n        profile.update(dtype=rasterio.float32, count=1, transform=transform)\n\n        # Create the new GeoTIFF file\n        with rasterio.open(output_file, 'w', **profile) as dst_dataset:\n            # Write the data to the new GeoTIFF\n            dst_dataset.write(data, 1)\n  \ndef print_statistics(data):\n    # Calculate multiple statistics in one line\n    # clean data n/a\n    data = data[~np.isnan(data)]\n    print(data.shape)\n    mean, median, min_val, max_val, sum_val, std_dev, variance = [np.mean(data), np.median(data), np.min(data), np.max(data), np.sum(data), np.std(data), np.var(data)]\n\n    # Print the calculated statistics\n    print(\"Mean:\", mean)\n    print(\"Median:\", median)\n    print(\"Minimum:\", min_val)\n    print(\"Maximum:\", max_val)\n    print(\"Sum:\", sum_val)\n    print(\"Standard Deviation:\", std_dev)\n    print(\"Variance:\", variance)\n\ndef calculate_slope_aspect(dem_file):\n    with rasterio.open(dem_file) as dataset:\n        # Read the DEM data as a numpy array\n        dem_data = dataset.read(1)\n        \n        # convert miles to meters\n        #dem_data = dem_data * mile_to_meters\n\n        # Get the geotransform to convert pixel coordinates to geographic coordinates\n        transform = dataset.transform\n\n        # Calculate the slope and aspect using numpy\n        dx, dy = np.gradient(dem_data, transform[0], transform[4])\n        #slope = np.arctan(np.sqrt(dx ** 2 + dy ** 2)) * (180.0 / np.pi)\n        # Convert the slope to degrees\n        slope = np.degrees(np.arctan(np.sqrt(dx**2 + dy**2)))\n        #print_statistics(slope.ravel())\n        aspect = np.degrees(np.arctan2(-dy, dx))\n        #print_statistics(aspect.ravel())\n\n        # Adjust aspect values to range from 0 to 360 degrees\n        aspect[aspect < 0] += 360\n        print(f\"slope shape: {slope.shape}\")\n        print(f\"aspect shape: {aspect.shape}\")\n        \n        \n    return slope, aspect\n  \ndef calculate_curvature(elevation_data, pixel_size_x, pixel_size_y):\n    # Calculate curvature using the Laplacian operator\n    curvature_x = np.gradient(np.gradient(elevation_data, pixel_size_x, axis=1), pixel_size_x, axis=1)\n    curvature_y = np.gradient(np.gradient(elevation_data, pixel_size_y, axis=0), pixel_size_y, axis=0)\n    curvature = curvature_x + curvature_y\n\n    return curvature\n\n  \ndef calculate_curvature(dem_file, sigma=1):\n    with rasterio.open(dem_file) as dataset:\n        # Read the DEM data as a numpy array\n        dem_data = dataset.read(1)\n        \n        # convert miles to meters\n        dem_data = dem_data*mile_to_meters\n\n        # Calculate the gradient using the Sobel filter\n        dx = sobel(dem_data, axis=1, mode='constant')\n        dy = sobel(dem_data, axis=0, mode='constant')\n\n        # Calculate the second derivatives using the Sobel filter\n        dxx = sobel(dx, axis=1, mode='constant')\n        dyy = sobel(dy, axis=0, mode='constant')\n\n        # Calculate the curvature using the second derivatives\n        curvature = dxx + dyy\n\n        # Smooth the curvature using Gaussian filtering (optional)\n        curvature = gaussian_filter(curvature, sigma)\n\n    return curvature\n  \ndef calculate_gradients(dem_file):\n    with rasterio.open(dem_file) as dataset:\n        # Read the DEM data as a numpy array\n        dem_data = dataset.read(1)\n\n        # Calculate the gradients along the North and East directions\n        dy, dx = np.gradient(dem_data, dataset.res[0], dataset.res[1])\n\n        # Calculate the Northness and Eastness\n        northness = np.arctan(dy / np.sqrt(dx**2 + dy**2))\n        eastness = np.arctan(dx / np.sqrt(dx**2 + dy**2))\n\n    return northness, eastness\n  \n  \ndef geotiff_to_csv(geotiff_file, csv_file, column_name):\n    # Open the GeoTIFF file\n    with rasterio.open(geotiff_file) as dataset:\n        # Get the pixel values as a 2D array\n        data = dataset.read(1)\n        \n        if column_name == \"Elevation\":\n          # convert miles to meters\n          data = data*mile_to_meters\n\n        # Get the geotransform to convert pixel coordinates to geographic coordinates\n        transform = dataset.transform\n\n        # Get the width and height of the GeoTIFF\n        height, width = data.shape\n\n        # Open the CSV file for writing\n        with open(csv_file, 'w', newline='') as csvfile:\n            csvwriter = csv.writer(csvfile)\n\n            # Write the CSV header\n            csvwriter.writerow(['Latitude', 'Longitude', 'x', 'y', column_name])\n\n            # Loop through each pixel and extract latitude, longitude, and image value\n            for y in range(height):\n                for x in range(width):\n                    # Get the pixel value\n                    image_value = data[y, x]\n\n                    # Convert pixel coordinates to geographic coordinates\n                    lon, lat = transform * (x, y)\n\n                    # Write the data to the CSV file\n                    csvwriter.writerow([lat, lon, x, y, image_value])\n\n  \ndef read_elevation_data(file_path, result_dem_csv_path, result_dem_feature_csv_path):\n    neighborhood_size=4\n    df = pd.read_csv(file_path)\n    \n    dataset = rasterio.open(geotiff_file)\n    data = dataset.read(1)\n\n    # Get the width and height of the GeoTIFF\n    height, width = data.shape\n    \n    # Create an empty DataFrame with column names\n    columns = ['lat', 'lon', 'elevation', 'slope', 'aspect', 'curvature', 'northness', 'eastness']\n    all_df = pd.DataFrame(columns=columns)\n    \n    all_df.to_csv(result_dem_feature_csv_path)\n    print(f\"DEM and other columns are saved to file {result_dem_feature_csv_path}\")\n    return all_df\n\n\n  \n# Usage example:\nresult_dem_csv_path = \"/home/chetana/gridmet_test_run/dem_template.csv\"\nresult_dem_feature_csv_path = \"/home/chetana/gridmet_test_run/dem_all.csv\"\n\n\ndem_file = \"/home/chetana/gridmet_test_run/dem_file.tif\"\nslope_file = '/home/chetana/gridmet_test_run/slope_file.tif'\naspect_file = '/home/chetana/gridmet_test_run/aspect_file.tif'\ncurvature_file = '/home/chetana/gridmet_test_run/curvature_file.tif'\nnorthness_file = '/home/chetana/gridmet_test_run/northness_file.tif'\neastness_file = '/home/chetana/gridmet_test_run/eastness_file.tif'\n\n\nslope, aspect = calculate_slope_aspect(dem_file)\ncurvature = calculate_curvature(dem_file)\nnorthness, eastness = calculate_gradients(dem_file)\n\n# Save the slope and aspect as new GeoTIFF files\nsave_as_geotiff(slope, slope_file, dem_file)\nsave_as_geotiff(aspect, aspect_file, dem_file)\nsave_as_geotiff(curvature, curvature_file, dem_file)\nsave_as_geotiff(northness, northness_file, dem_file)\nsave_as_geotiff(eastness, eastness_file, dem_file)\n\ngeotiff_to_csv(dem_file, dem_file+\".csv\", \"Elevation\")\ngeotiff_to_csv(slope_file, slope_file+\".csv\", \"Slope\")\ngeotiff_to_csv(aspect_file, aspect_file+\".csv\", \"Aspect\")\ngeotiff_to_csv(curvature_file, curvature_file+\".csv\", \"Curvature\")\ngeotiff_to_csv(northness_file, northness_file+\".csv\", \"Northness\")\ngeotiff_to_csv(eastness_file, eastness_file+\".csv\", \"Eastness\")\n\n# List of file paths for the CSV files\ncsv_files = [dem_file+\".csv\", slope_file+\".csv\", aspect_file+\".csv\", \n             curvature_file+\".csv\", northness_file+\".csv\", eastness_file+\".csv\"]\n\n# Initialize an empty list to store all dataframes\ndfs = []\n\n# Read each CSV file into separate dataframes\nfor file in csv_files:\n    df = pd.read_csv(file, encoding='utf-8')\n    dfs.append(df)\n\n# Merge the dataframes based on the latitude and longitude columns\nmerged_df = dfs[0]  # Start with the first dataframe\nfor i in range(1, len(dfs)):\n    merged_df = pd.merge(merged_df, dfs[i], on=['Latitude', 'Longitude', 'x', 'y'])\n\n# check the statistics of the columns\nfor column in merged_df.columns:\n    merged_df[column] = pd.to_numeric(merged_df[column], errors='coerce')\n    print(merged_df[column].describe())\n    \n# Save the merged dataframe to a new CSV file\nmerged_df.to_csv(result_dem_feature_csv_path, index=False)\nprint(f\"New dem features are updated in {result_dem_feature_csv_path}\")\n\n",
  "history_output" : "/home/chetana/gw-workspace/djxoSgs5JGwT/western_us_dem.py:134: RuntimeWarning: invalid value encountered in divide\n  northness = np.arctan(dy / np.sqrt(dx**2 + dy**2))\n/home/chetana/gw-workspace/djxoSgs5JGwT/western_us_dem.py:135: RuntimeWarning: invalid value encountered in divide\n  eastness = np.arctan(dx / np.sqrt(dx**2 + dy**2))\nslope shape: (666, 694)\naspect shape: (666, 694)\ncount    462204.000000\nmean         37.030000\nstd           6.921275\nmin          25.060000\n25%          31.036000\n50%          37.030000\n75%          43.024000\nmax          49.000000\nName: Latitude, dtype: float64\ncount    462204.00000\nmean       -112.52600\nstd           7.21226\nmin        -125.00000\n25%        -118.77200\n50%        -112.52600\n75%        -106.28000\nmax        -100.05200\nName: Longitude, dtype: float64\ncount    462204.000000\nmean        346.500000\nstd         200.340552\nmin           0.000000\n25%         173.000000\n50%         346.500000\n75%         520.000000\nmax         693.000000\nName: x, dtype: float64\ncount    462204.000000\nmean        332.500000\nstd         192.257631\nmin           0.000000\n25%         166.000000\n50%         332.500000\n75%         499.000000\nmax         665.000000\nName: y, dtype: float64\ncount    309830.000000\nmean       2561.017903\nstd         376.542591\nmin        1691.416300\n25%        2286.872000\n50%        2471.946300\n75%        2776.111600\nmax        4115.082000\nName: Elevation, dtype: float64\ncount    308251.000000\nmean         54.006650\nstd          20.681525\nmin           0.000000\n25%          44.149170\n50%          58.931244\n75%          69.586060\nmax          86.687220\nName: Slope, dtype: float64\ncount    308251.000000\nmean        170.498344\nstd         106.428245\nmin           0.000000\n25%          83.157240\n50%         176.729480\n75%         266.423680\nmax         359.906980\nName: Aspect, dtype: float64\ncount    295965.000000\nmean       -186.538634\nstd        3215.498709\nmin      -40479.438000\n25%       -1488.354700\n50%          29.660137\n75%        1457.598300\nmax       18450.988000\nName: Curvature, dtype: float64\ncount    300725.000000\nmean         -0.007756\nstd           0.590930\nmin          -0.785398\n25%          -0.620971\n50%           0.000000\n75%           0.615480\nmax           0.785398\nName: Northness, dtype: float64\ncount    300725.000000\nmean         -0.002146\nstd           0.577707\nmin          -0.785398\n25%          -0.615480\n50%           0.000000\n75%           0.612676\nmax           0.785398\nName: Eastness, dtype: float64\nNew dem features are updated in /home/chetana/gridmet_test_run/dem_all.csv\n",
  "history_begin_time" : 1695532964134,
  "history_end_time" : 1695532978272,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "gEpgBtBjlqRh",
  "history_input" : "import numpy as np\nimport pandas as pd\nfrom osgeo import gdal\nimport warnings\nimport rasterio\nimport csv\nfrom rasterio.transform import Affine\nfrom scipy.ndimage import sobel, gaussian_filter\n\nmile_to_meters = 1609.34\n\n# Set the warning filter globally to ignore the FutureWarning\nwarnings.simplefilter(\"ignore\", FutureWarning)\n\ndef lat_lon_to_pixel(lat, lon, geotransform):\n    x = int((lon - geotransform[0]) / geotransform[1])\n    y = int((lat - geotransform[3]) / geotransform[5])\n    return x, y\n\n\ndef calculate_slope_aspect_for_single(elevation_data, pixel_size_x, pixel_size_y):\n    # Calculate slope using the Sobel operator\n    slope_x = np.gradient(elevation_data, pixel_size_x, axis=1)\n    slope_y = np.gradient(elevation_data, pixel_size_y, axis=0)\n    slope_rad = np.arctan(np.sqrt(slope_x ** 2 + slope_y ** 2))\n    slope_deg = np.degrees(slope_rad)\n\n    # Calculate aspect (direction of the steepest descent)\n    aspect_rad = np.arctan2(slope_y, -slope_x)\n    aspect_deg = (np.degrees(aspect_rad) + 360) % 360\n\n    return slope_deg, aspect_deg\n\n\ndef save_as_geotiff(data, output_file, src_file):\n    with rasterio.open(src_file) as src_dataset:\n        profile = src_dataset.profile\n        transform = src_dataset.transform\n\n        # Update the data type, count, and set the transform for the new dataset\n        profile.update(dtype=rasterio.float32, count=1, transform=transform)\n\n        # Create the new GeoTIFF file\n        with rasterio.open(output_file, 'w', **profile) as dst_dataset:\n            # Write the data to the new GeoTIFF\n            dst_dataset.write(data, 1)\n  \ndef print_statistics(data):\n    # Calculate multiple statistics in one line\n    # clean data n/a\n    data = data[~np.isnan(data)]\n    print(data.shape)\n    mean, median, min_val, max_val, sum_val, std_dev, variance = [np.mean(data), np.median(data), np.min(data), np.max(data), np.sum(data), np.std(data), np.var(data)]\n\n    # Print the calculated statistics\n    print(\"Mean:\", mean)\n    print(\"Median:\", median)\n    print(\"Minimum:\", min_val)\n    print(\"Maximum:\", max_val)\n    print(\"Sum:\", sum_val)\n    print(\"Standard Deviation:\", std_dev)\n    print(\"Variance:\", variance)\n\ndef calculate_slope_aspect(dem_file):\n    with rasterio.open(dem_file) as dataset:\n        # Read the DEM data as a numpy array\n        dem_data = dataset.read(1)\n        \n        # convert miles to meters\n        #dem_data = dem_data * mile_to_meters\n\n        # Get the geotransform to convert pixel coordinates to geographic coordinates\n        transform = dataset.transform\n\n        # Calculate the slope and aspect using numpy\n        dx, dy = np.gradient(dem_data, transform[0], transform[4])\n        #slope = np.arctan(np.sqrt(dx ** 2 + dy ** 2)) * (180.0 / np.pi)\n        slope_rad = np.arctan(np.sqrt(dx**2 + dy**2))\n\n        # Convert the slope to degrees\n        slope = np.degrees(slope_rad)\n        #print_statistics(slope.ravel())\n        aspect = np.degrees(np.arctan2(-dy, dx))\n        #print_statistics(aspect.ravel())\n\n        # Adjust aspect values to range from 0 to 360 degrees\n        aspect[aspect < 0] += 360\n        print(f\"slope shape: {slope.shape}\")\n        print(f\"aspect shape: {aspect.shape}\")\n        \n        \n    return slope, aspect\n  \ndef calculate_curvature(elevation_data, pixel_size_x, pixel_size_y):\n    # Calculate curvature using the Laplacian operator\n    curvature_x = np.gradient(np.gradient(elevation_data, pixel_size_x, axis=1), pixel_size_x, axis=1)\n    curvature_y = np.gradient(np.gradient(elevation_data, pixel_size_y, axis=0), pixel_size_y, axis=0)\n    curvature = curvature_x + curvature_y\n\n    return curvature\n\n  \ndef calculate_curvature(dem_file, sigma=1):\n    with rasterio.open(dem_file) as dataset:\n        # Read the DEM data as a numpy array\n        dem_data = dataset.read(1)\n        \n        # convert miles to meters\n        dem_data = dem_data*mile_to_meters\n\n        # Calculate the gradient using the Sobel filter\n        dx = sobel(dem_data, axis=1, mode='constant')\n        dy = sobel(dem_data, axis=0, mode='constant')\n\n        # Calculate the second derivatives using the Sobel filter\n        dxx = sobel(dx, axis=1, mode='constant')\n        dyy = sobel(dy, axis=0, mode='constant')\n\n        # Calculate the curvature using the second derivatives\n        curvature = dxx + dyy\n\n        # Smooth the curvature using Gaussian filtering (optional)\n        curvature = gaussian_filter(curvature, sigma)\n\n    return curvature\n  \ndef calculate_gradients(dem_file):\n    with rasterio.open(dem_file) as dataset:\n        # Read the DEM data as a numpy array\n        dem_data = dataset.read(1)\n\n        # Calculate the gradients along the North and East directions\n        dy, dx = np.gradient(dem_data, dataset.res[0], dataset.res[1])\n\n        # Calculate the Northness and Eastness\n        northness = np.arctan(dy / np.sqrt(dx**2 + dy**2))\n        eastness = np.arctan(dx / np.sqrt(dx**2 + dy**2))\n\n    return northness, eastness\n  \n  \ndef geotiff_to_csv(geotiff_file, csv_file, column_name):\n    # Open the GeoTIFF file\n    with rasterio.open(geotiff_file) as dataset:\n        # Get the pixel values as a 2D array\n        data = dataset.read(1)\n        \n        if column_name == \"Elevation\":\n          # convert miles to meters\n          data = data*mile_to_meters\n\n        # Get the geotransform to convert pixel coordinates to geographic coordinates\n        transform = dataset.transform\n\n        # Get the width and height of the GeoTIFF\n        height, width = data.shape\n\n        # Open the CSV file for writing\n        with open(csv_file, 'w', newline='') as csvfile:\n            csvwriter = csv.writer(csvfile)\n\n            # Write the CSV header\n            csvwriter.writerow(['Latitude', 'Longitude', 'x', 'y', column_name])\n\n            # Loop through each pixel and extract latitude, longitude, and image value\n            for y in range(height):\n                for x in range(width):\n                    # Get the pixel value\n                    image_value = data[y, x]\n\n                    # Convert pixel coordinates to geographic coordinates\n                    lon, lat = transform * (x, y)\n\n                    # Write the data to the CSV file\n                    csvwriter.writerow([lat, lon, x, y, image_value])\n\n  \ndef read_elevation_data(file_path, result_dem_csv_path, result_dem_feature_csv_path):\n    neighborhood_size=4\n    df = pd.read_csv(file_path)\n    \n    dataset = rasterio.open(geotiff_file)\n    data = dataset.read(1)\n\n    # Get the width and height of the GeoTIFF\n    height, width = data.shape\n    \n    # Create an empty DataFrame with column names\n    columns = ['lat', 'lon', 'elevation', 'slope', 'aspect', 'curvature', 'northness', 'eastness']\n    all_df = pd.DataFrame(columns=columns)\n    \n    all_df.to_csv(result_dem_feature_csv_path)\n    print(f\"DEM and other columns are saved to file {result_dem_feature_csv_path}\")\n    return all_df\n\n\n  \n# Usage example:\nresult_dem_csv_path = \"/home/chetana/gridmet_test_run/dem_template.csv\"\nresult_dem_feature_csv_path = \"/home/chetana/gridmet_test_run/dem_all.csv\"\n\n\ndem_file = \"/home/chetana/gridmet_test_run/dem_file.tif\"\nslope_file = '/home/chetana/gridmet_test_run/slope_file.tif'\naspect_file = '/home/chetana/gridmet_test_run/aspect_file.tif'\ncurvature_file = '/home/chetana/gridmet_test_run/curvature_file.tif'\nnorthness_file = '/home/chetana/gridmet_test_run/northness_file.tif'\neastness_file = '/home/chetana/gridmet_test_run/eastness_file.tif'\n\n\nslope, aspect = calculate_slope_aspect(dem_file)\ncurvature = calculate_curvature(dem_file)\nnorthness, eastness = calculate_gradients(dem_file)\n\n# Save the slope and aspect as new GeoTIFF files\nsave_as_geotiff(slope, slope_file, dem_file)\nsave_as_geotiff(aspect, aspect_file, dem_file)\nsave_as_geotiff(curvature, curvature_file, dem_file)\nsave_as_geotiff(northness, northness_file, dem_file)\nsave_as_geotiff(eastness, eastness_file, dem_file)\n\ngeotiff_to_csv(dem_file, dem_file+\".csv\", \"Elevation\")\ngeotiff_to_csv(slope_file, slope_file+\".csv\", \"Slope\")\ngeotiff_to_csv(aspect_file, aspect_file+\".csv\", \"Aspect\")\ngeotiff_to_csv(curvature_file, curvature_file+\".csv\", \"Curvature\")\ngeotiff_to_csv(northness_file, northness_file+\".csv\", \"Northness\")\ngeotiff_to_csv(eastness_file, eastness_file+\".csv\", \"Eastness\")\n\n# List of file paths for the CSV files\ncsv_files = [dem_file+\".csv\", slope_file+\".csv\", aspect_file+\".csv\", \n             curvature_file+\".csv\", northness_file+\".csv\", eastness_file+\".csv\"]\n\n# Initialize an empty list to store all dataframes\ndfs = []\n\n# Read each CSV file into separate dataframes\nfor file in csv_files:\n    df = pd.read_csv(file, encoding='utf-8')\n    dfs.append(df)\n\n# Merge the dataframes based on the latitude and longitude columns\nmerged_df = dfs[0]  # Start with the first dataframe\nfor i in range(1, len(dfs)):\n    merged_df = pd.merge(merged_df, dfs[i], on=['Latitude', 'Longitude', 'x', 'y'])\n\n# check the statistics of the columns\nfor column in merged_df.columns:\n    merged_df[column] = pd.to_numeric(merged_df[column], errors='coerce')\n    print(merged_df[column].describe())\n    \n# Save the merged dataframe to a new CSV file\nmerged_df.to_csv(result_dem_feature_csv_path, index=False)\nprint(f\"New dem features are updated in {result_dem_feature_csv_path}\")\n\n",
  "history_output" : "/home/chetana/gw-workspace/gEpgBtBjlqRh/western_us_dem.py:136: RuntimeWarning: invalid value encountered in divide\n  northness = np.arctan(dy / np.sqrt(dx**2 + dy**2))\n/home/chetana/gw-workspace/gEpgBtBjlqRh/western_us_dem.py:137: RuntimeWarning: invalid value encountered in divide\n  eastness = np.arctan(dx / np.sqrt(dx**2 + dy**2))\nslope shape: (666, 694)\naspect shape: (666, 694)\ncount    462204.000000\nmean         37.030000\nstd           6.921275\nmin          25.060000\n25%          31.036000\n50%          37.030000\n75%          43.024000\nmax          49.000000\nName: Latitude, dtype: float64\ncount    462204.00000\nmean       -112.52600\nstd           7.21226\nmin        -125.00000\n25%        -118.77200\n50%        -112.52600\n75%        -106.28000\nmax        -100.05200\nName: Longitude, dtype: float64\ncount    462204.000000\nmean        346.500000\nstd         200.340552\nmin           0.000000\n25%         173.000000\n50%         346.500000\n75%         520.000000\nmax         693.000000\nName: x, dtype: float64\ncount    462204.000000\nmean        332.500000\nstd         192.257631\nmin           0.000000\n25%         166.000000\n50%         332.500000\n75%         499.000000\nmax         665.000000\nName: y, dtype: float64\ncount    309830.000000\nmean       2561.017903\nstd         376.542591\nmin        1691.416300\n25%        2286.872000\n50%        2471.946300\n75%        2776.111600\nmax        4115.082000\nName: Elevation, dtype: float64\ncount    308251.000000\nmean         54.006650\nstd          20.681525\nmin           0.000000\n25%          44.149170\n50%          58.931244\n75%          69.586060\nmax          86.687220\nName: Slope, dtype: float64\ncount    308251.000000\nmean        170.498344\nstd         106.428245\nmin           0.000000\n25%          83.157240\n50%         176.729480\n75%         266.423680\nmax         359.906980\nName: Aspect, dtype: float64\ncount    295965.000000\nmean       -186.538634\nstd        3215.498709\nmin      -40479.438000\n25%       -1488.354700\n50%          29.660137\n75%        1457.598300\nmax       18450.988000\nName: Curvature, dtype: float64\ncount    300725.000000\nmean         -0.007756\nstd           0.590930\nmin          -0.785398\n25%          -0.620971\n50%           0.000000\n75%           0.615480\nmax           0.785398\nName: Northness, dtype: float64\ncount    300725.000000\nmean         -0.002146\nstd           0.577707\nmin          -0.785398\n25%          -0.615480\n50%           0.000000\n75%           0.612676\nmax           0.785398\nName: Eastness, dtype: float64\nNew dem features are updated in /home/chetana/gridmet_test_run/dem_all.csv\n",
  "history_begin_time" : 1695532887119,
  "history_end_time" : 1695532901425,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "TDn6nZOWlrN5",
  "history_input" : "import numpy as np\nimport pandas as pd\nfrom osgeo import gdal\nimport warnings\nimport rasterio\nimport csv\nfrom rasterio.transform import Affine\nfrom scipy.ndimage import sobel, gaussian_filter\n\nmile_to_meters = 1609.34\n\n# Set the warning filter globally to ignore the FutureWarning\nwarnings.simplefilter(\"ignore\", FutureWarning)\n\ndef lat_lon_to_pixel(lat, lon, geotransform):\n    x = int((lon - geotransform[0]) / geotransform[1])\n    y = int((lat - geotransform[3]) / geotransform[5])\n    return x, y\n\n\ndef calculate_slope_aspect_for_single(elevation_data, pixel_size_x, pixel_size_y):\n    # Calculate slope using the Sobel operator\n    slope_x = np.gradient(elevation_data, pixel_size_x, axis=1)\n    slope_y = np.gradient(elevation_data, pixel_size_y, axis=0)\n    slope_rad = np.arctan(np.sqrt(slope_x ** 2 + slope_y ** 2))\n    slope_deg = np.degrees(slope_rad)\n\n    # Calculate aspect (direction of the steepest descent)\n    aspect_rad = np.arctan2(slope_y, -slope_x)\n    aspect_deg = (np.degrees(aspect_rad) + 360) % 360\n\n    return slope_deg, aspect_deg\n\n\ndef save_as_geotiff(data, output_file, src_file):\n    with rasterio.open(src_file) as src_dataset:\n        profile = src_dataset.profile\n        transform = src_dataset.transform\n\n        # Update the data type, count, and set the transform for the new dataset\n        profile.update(dtype=rasterio.float32, count=1, transform=transform)\n\n        # Create the new GeoTIFF file\n        with rasterio.open(output_file, 'w', **profile) as dst_dataset:\n            # Write the data to the new GeoTIFF\n            dst_dataset.write(data, 1)\n  \ndef print_statistics(data):\n    # Calculate multiple statistics in one line\n    # clean data n/a\n    data = data[~np.isnan(data)]\n    print(data.shape)\n    mean, median, min_val, max_val, sum_val, std_dev, variance = [np.mean(data), np.median(data), np.min(data), np.max(data), np.sum(data), np.std(data), np.var(data)]\n\n    # Print the calculated statistics\n    print(\"Mean:\", mean)\n    print(\"Median:\", median)\n    print(\"Minimum:\", min_val)\n    print(\"Maximum:\", max_val)\n    print(\"Sum:\", sum_val)\n    print(\"Standard Deviation:\", std_dev)\n    print(\"Variance:\", variance)\n\ndef calculate_slope_aspect(dem_file):\n    with rasterio.open(dem_file) as dataset:\n        # Read the DEM data as a numpy array\n        dem_data = dataset.read(1)\n        \n        # convert miles to meters\n        #dem_data = dem_data * mile_to_meters\n\n        # Get the geotransform to convert pixel coordinates to geographic coordinates\n        transform = dataset.transform\n\n        # Calculate the slope and aspect using numpy\n        dx, dy = np.gradient(dem_data, transform[0], transform[4])\n        #slope = np.arctan(np.sqrt(dx ** 2 + dy ** 2)) * (180.0 / np.pi)\n        slope_rad = np.arctan(np.sqrt(dx**2 + dy**2))\n\n        # Convert the slope to degrees\n        slope = np.degrees(slope_rad)\n        print(\"Slop: \", print_statistics(slope.ravel()))\n        aspect = np.degrees(np.arctan2(-dy, dx))\n        print(\"Aspect: \", print_statistics(aspect.ravel()))\n\n        # Adjust aspect values to range from 0 to 360 degrees\n        aspect[aspect < 0] += 360\n        print(f\"slope shape: {slope.shape}\")\n        print(f\"aspect shape: {aspect.shape}\")\n        \n        \n    return slope, aspect\n  \ndef calculate_curvature(elevation_data, pixel_size_x, pixel_size_y):\n    # Calculate curvature using the Laplacian operator\n    curvature_x = np.gradient(np.gradient(elevation_data, pixel_size_x, axis=1), pixel_size_x, axis=1)\n    curvature_y = np.gradient(np.gradient(elevation_data, pixel_size_y, axis=0), pixel_size_y, axis=0)\n    curvature = curvature_x + curvature_y\n\n    return curvature\n\n  \ndef calculate_curvature(dem_file, sigma=1):\n    with rasterio.open(dem_file) as dataset:\n        # Read the DEM data as a numpy array\n        dem_data = dataset.read(1)\n        \n        # convert miles to meters\n        dem_data = dem_data*mile_to_meters\n\n        # Calculate the gradient using the Sobel filter\n        dx = sobel(dem_data, axis=1, mode='constant')\n        dy = sobel(dem_data, axis=0, mode='constant')\n\n        # Calculate the second derivatives using the Sobel filter\n        dxx = sobel(dx, axis=1, mode='constant')\n        dyy = sobel(dy, axis=0, mode='constant')\n\n        # Calculate the curvature using the second derivatives\n        curvature = dxx + dyy\n\n        # Smooth the curvature using Gaussian filtering (optional)\n        curvature = gaussian_filter(curvature, sigma)\n\n    return curvature\n  \ndef calculate_gradients(dem_file):\n    with rasterio.open(dem_file) as dataset:\n        # Read the DEM data as a numpy array\n        dem_data = dataset.read(1)\n\n        # Calculate the gradients along the North and East directions\n        dy, dx = np.gradient(dem_data, dataset.res[0], dataset.res[1])\n\n        # Calculate the Northness and Eastness\n        northness = np.arctan(dy / np.sqrt(dx**2 + dy**2))\n        eastness = np.arctan(dx / np.sqrt(dx**2 + dy**2))\n\n    return northness, eastness\n  \n  \ndef geotiff_to_csv(geotiff_file, csv_file, column_name):\n    # Open the GeoTIFF file\n    with rasterio.open(geotiff_file) as dataset:\n        # Get the pixel values as a 2D array\n        data = dataset.read(1)\n        \n        if column_name == \"Elevation\":\n          # convert miles to meters\n          data = data*mile_to_meters\n\n        # Get the geotransform to convert pixel coordinates to geographic coordinates\n        transform = dataset.transform\n\n        # Get the width and height of the GeoTIFF\n        height, width = data.shape\n\n        # Open the CSV file for writing\n        with open(csv_file, 'w', newline='') as csvfile:\n            csvwriter = csv.writer(csvfile)\n\n            # Write the CSV header\n            csvwriter.writerow(['Latitude', 'Longitude', 'x', 'y', column_name])\n\n            # Loop through each pixel and extract latitude, longitude, and image value\n            for y in range(height):\n                for x in range(width):\n                    # Get the pixel value\n                    image_value = data[y, x]\n\n                    # Convert pixel coordinates to geographic coordinates\n                    lon, lat = transform * (x, y)\n\n                    # Write the data to the CSV file\n                    csvwriter.writerow([lat, lon, x, y, image_value])\n\n  \ndef read_elevation_data(file_path, result_dem_csv_path, result_dem_feature_csv_path):\n    neighborhood_size=4\n    df = pd.read_csv(file_path)\n    \n    dataset = rasterio.open(geotiff_file)\n    data = dataset.read(1)\n\n    # Get the width and height of the GeoTIFF\n    height, width = data.shape\n    \n    # Create an empty DataFrame with column names\n    columns = ['lat', 'lon', 'elevation', 'slope', 'aspect', 'curvature', 'northness', 'eastness']\n    all_df = pd.DataFrame(columns=columns)\n    \n    all_df.to_csv(result_dem_feature_csv_path)\n    print(f\"DEM and other columns are saved to file {result_dem_feature_csv_path}\")\n    return all_df\n\n\n  \n# Usage example:\nresult_dem_csv_path = \"/home/chetana/gridmet_test_run/dem_template.csv\"\nresult_dem_feature_csv_path = \"/home/chetana/gridmet_test_run/dem_all.csv\"\n\n\ndem_file = \"/home/chetana/gridmet_test_run/dem_file.tif\"\nslope_file = '/home/chetana/gridmet_test_run/slope_file.tif'\naspect_file = '/home/chetana/gridmet_test_run/aspect_file.tif'\ncurvature_file = '/home/chetana/gridmet_test_run/curvature_file.tif'\nnorthness_file = '/home/chetana/gridmet_test_run/northness_file.tif'\neastness_file = '/home/chetana/gridmet_test_run/eastness_file.tif'\n\n\nslope, aspect = calculate_slope_aspect(dem_file)\ncurvature = calculate_curvature(dem_file)\nnorthness, eastness = calculate_gradients(dem_file)\n\n# Save the slope and aspect as new GeoTIFF files\nsave_as_geotiff(slope, slope_file, dem_file)\nsave_as_geotiff(aspect, aspect_file, dem_file)\nsave_as_geotiff(curvature, curvature_file, dem_file)\nsave_as_geotiff(northness, northness_file, dem_file)\nsave_as_geotiff(eastness, eastness_file, dem_file)\n\ngeotiff_to_csv(dem_file, dem_file+\".csv\", \"Elevation\")\ngeotiff_to_csv(slope_file, slope_file+\".csv\", \"Slope\")\ngeotiff_to_csv(aspect_file, aspect_file+\".csv\", \"Aspect\")\ngeotiff_to_csv(curvature_file, curvature_file+\".csv\", \"Curvature\")\ngeotiff_to_csv(northness_file, northness_file+\".csv\", \"Northness\")\ngeotiff_to_csv(eastness_file, eastness_file+\".csv\", \"Eastness\")\n\n# List of file paths for the CSV files\ncsv_files = [dem_file+\".csv\", slope_file+\".csv\", aspect_file+\".csv\", \n             curvature_file+\".csv\", northness_file+\".csv\", eastness_file+\".csv\"]\n\n# Initialize an empty list to store all dataframes\ndfs = []\n\n# Read each CSV file into separate dataframes\nfor file in csv_files:\n    df = pd.read_csv(file, encoding='utf-8')\n    dfs.append(df)\n\n# Merge the dataframes based on the latitude and longitude columns\nmerged_df = dfs[0]  # Start with the first dataframe\nfor i in range(1, len(dfs)):\n    merged_df = pd.merge(merged_df, dfs[i], on=['Latitude', 'Longitude', 'x', 'y'])\n\n# check the statistics of the columns\nfor column in merged_df.columns:\n    merged_df[column] = pd.to_numeric(merged_df[column], errors='coerce')\n    print(merged_df[column].describe())\n    \n# Save the merged dataframe to a new CSV file\nmerged_df.to_csv(result_dem_feature_csv_path, index=False)\nprint(f\"New dem features are updated in {result_dem_feature_csv_path}\")\n\n",
  "history_output" : "/home/chetana/gw-workspace/TDn6nZOWlrN5/western_us_dem.py:136: RuntimeWarning: invalid value encountered in divide\n  northness = np.arctan(dy / np.sqrt(dx**2 + dy**2))\n/home/chetana/gw-workspace/TDn6nZOWlrN5/western_us_dem.py:137: RuntimeWarning: invalid value encountered in divide\n  eastness = np.arctan(dx / np.sqrt(dx**2 + dy**2))\n(308251,)\nMean: 54.006653\nMedian: 58.931244\nMinimum: 0.0\nMaximum: 86.68722\nSum: 16647605.0\nStandard Deviation: 20.681492\nVariance: 427.7241\nSlop:  None\n(308251,)\nMean: 4.950267\nMedian: 0.0\nMinimum: -179.89488\nMaximum: 180.0\nSum: 1525924.8\nStandard Deviation: 104.200294\nVariance: 10857.701\nAspect:  None\nslope shape: (666, 694)\naspect shape: (666, 694)\ncount    462204.000000\nmean         37.030000\nstd           6.921275\nmin          25.060000\n25%          31.036000\n50%          37.030000\n75%          43.024000\nmax          49.000000\nName: Latitude, dtype: float64\ncount    462204.00000\nmean       -112.52600\nstd           7.21226\nmin        -125.00000\n25%        -118.77200\n50%        -112.52600\n75%        -106.28000\nmax        -100.05200\nName: Longitude, dtype: float64\ncount    462204.000000\nmean        346.500000\nstd         200.340552\nmin           0.000000\n25%         173.000000\n50%         346.500000\n75%         520.000000\nmax         693.000000\nName: x, dtype: float64\ncount    462204.000000\nmean        332.500000\nstd         192.257631\nmin           0.000000\n25%         166.000000\n50%         332.500000\n75%         499.000000\nmax         665.000000\nName: y, dtype: float64\ncount    309830.000000\nmean       2561.017903\nstd         376.542591\nmin        1691.416300\n25%        2286.872000\n50%        2471.946300\n75%        2776.111600\nmax        4115.082000\nName: Elevation, dtype: float64\ncount    308251.000000\nmean         54.006650\nstd          20.681525\nmin           0.000000\n25%          44.149170\n50%          58.931244\n75%          69.586060\nmax          86.687220\nName: Slope, dtype: float64\ncount    308251.000000\nmean        170.498344\nstd         106.428245\nmin           0.000000\n25%          83.157240\n50%         176.729480\n75%         266.423680\nmax         359.906980\nName: Aspect, dtype: float64\ncount    295965.000000\nmean       -186.538634\nstd        3215.498709\nmin      -40479.438000\n25%       -1488.354700\n50%          29.660137\n75%        1457.598300\nmax       18450.988000\nName: Curvature, dtype: float64\ncount    300725.000000\nmean         -0.007756\nstd           0.590930\nmin          -0.785398\n25%          -0.620971\n50%           0.000000\n75%           0.615480\nmax           0.785398\nName: Northness, dtype: float64\ncount    300725.000000\nmean         -0.002146\nstd           0.577707\nmin          -0.785398\n25%          -0.615480\n50%           0.000000\n75%           0.612676\nmax           0.785398\nName: Eastness, dtype: float64\nNew dem features are updated in /home/chetana/gridmet_test_run/dem_all.csv\n",
  "history_begin_time" : 1695532788138,
  "history_end_time" : 1695532802193,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "958hZSPX8iDB",
  "history_input" : "import numpy as np\nimport pandas as pd\nfrom osgeo import gdal\nimport warnings\nimport rasterio\nimport csv\nfrom rasterio.transform import Affine\nfrom scipy.ndimage import sobel, gaussian_filter\n\nmile_to_meters = 1609.34\n\n# Set the warning filter globally to ignore the FutureWarning\nwarnings.simplefilter(\"ignore\", FutureWarning)\n\ndef lat_lon_to_pixel(lat, lon, geotransform):\n    x = int((lon - geotransform[0]) / geotransform[1])\n    y = int((lat - geotransform[3]) / geotransform[5])\n    return x, y\n\n\ndef calculate_slope_aspect_for_single(elevation_data, pixel_size_x, pixel_size_y):\n    # Calculate slope using the Sobel operator\n    slope_x = np.gradient(elevation_data, pixel_size_x, axis=1)\n    slope_y = np.gradient(elevation_data, pixel_size_y, axis=0)\n    slope_rad = np.arctan(np.sqrt(slope_x ** 2 + slope_y ** 2))\n    slope_deg = np.degrees(slope_rad)\n\n    # Calculate aspect (direction of the steepest descent)\n    aspect_rad = np.arctan2(slope_y, -slope_x)\n    aspect_deg = (np.degrees(aspect_rad) + 360) % 360\n\n    return slope_deg, aspect_deg\n\n\ndef save_as_geotiff(data, output_file, src_file):\n    with rasterio.open(src_file) as src_dataset:\n        profile = src_dataset.profile\n        transform = src_dataset.transform\n\n        # Update the data type, count, and set the transform for the new dataset\n        profile.update(dtype=rasterio.float32, count=1, transform=transform)\n\n        # Create the new GeoTIFF file\n        with rasterio.open(output_file, 'w', **profile) as dst_dataset:\n            # Write the data to the new GeoTIFF\n            dst_dataset.write(data, 1)\n  \ndef print_statistics(data):\n    # Calculate multiple statistics in one line\n    # clean data n/a\n    data = data[~np.isnan(data)]\n    print(data.shape)\n    mean, median, min_val, max_val, sum_val, std_dev, variance = [np.mean(data), np.median(data), np.min(data), np.max(data), np.sum(data), np.std(data), np.var(data)]\n\n    # Print the calculated statistics\n    print(\"Mean:\", mean)\n    print(\"Median:\", median)\n    print(\"Minimum:\", min_val)\n    print(\"Maximum:\", max_val)\n    print(\"Sum:\", sum_val)\n    print(\"Standard Deviation:\", std_dev)\n    print(\"Variance:\", variance)\n\ndef calculate_slope_aspect(dem_file):\n    with rasterio.open(dem_file) as dataset:\n        # Read the DEM data as a numpy array\n        dem_data = dataset.read(1)\n        \n        # convert miles to meters\n        dem_data = dem_data * mile_to_meters\n\n        # Get the geotransform to convert pixel coordinates to geographic coordinates\n        transform = dataset.transform\n\n        # Calculate the slope and aspect using numpy\n        dx, dy = np.gradient(dem_data, transform[0], transform[4])\n        #slope = np.arctan(np.sqrt(dx ** 2 + dy ** 2)) * (180.0 / np.pi)\n        slope_rad = np.arctan(np.sqrt(dx**2 + dy**2))\n\n        # Convert the slope to degrees\n        slope = np.degrees(slope_rad)\n        print(\"Slop: \", print_statistics(slope.ravel()))\n        aspect = np.degrees(np.arctan2(-dy, dx))\n        print(\"Aspect: \", print_statistics(aspect.ravel()))\n\n        # Adjust aspect values to range from 0 to 360 degrees\n        aspect[aspect < 0] += 360\n        print(f\"slope shape: {slope.shape}\")\n        print(f\"aspect shape: {aspect.shape}\")\n        \n        \n    return slope, aspect\n  \ndef calculate_curvature(elevation_data, pixel_size_x, pixel_size_y):\n    # Calculate curvature using the Laplacian operator\n    curvature_x = np.gradient(np.gradient(elevation_data, pixel_size_x, axis=1), pixel_size_x, axis=1)\n    curvature_y = np.gradient(np.gradient(elevation_data, pixel_size_y, axis=0), pixel_size_y, axis=0)\n    curvature = curvature_x + curvature_y\n\n    return curvature\n\n  \ndef calculate_curvature(dem_file, sigma=1):\n    with rasterio.open(dem_file) as dataset:\n        # Read the DEM data as a numpy array\n        dem_data = dataset.read(1)\n        \n        # convert miles to meters\n        dem_data = dem_data*mile_to_meters\n\n        # Calculate the gradient using the Sobel filter\n        dx = sobel(dem_data, axis=1, mode='constant')\n        dy = sobel(dem_data, axis=0, mode='constant')\n\n        # Calculate the second derivatives using the Sobel filter\n        dxx = sobel(dx, axis=1, mode='constant')\n        dyy = sobel(dy, axis=0, mode='constant')\n\n        # Calculate the curvature using the second derivatives\n        curvature = dxx + dyy\n\n        # Smooth the curvature using Gaussian filtering (optional)\n        curvature = gaussian_filter(curvature, sigma)\n\n    return curvature\n  \ndef calculate_gradients(dem_file):\n    with rasterio.open(dem_file) as dataset:\n        # Read the DEM data as a numpy array\n        dem_data = dataset.read(1)\n\n        # Calculate the gradients along the North and East directions\n        dy, dx = np.gradient(dem_data, dataset.res[0], dataset.res[1])\n\n        # Calculate the Northness and Eastness\n        northness = np.arctan(dy / np.sqrt(dx**2 + dy**2))\n        eastness = np.arctan(dx / np.sqrt(dx**2 + dy**2))\n\n    return northness, eastness\n  \n  \ndef geotiff_to_csv(geotiff_file, csv_file, column_name):\n    # Open the GeoTIFF file\n    with rasterio.open(geotiff_file) as dataset:\n        # Get the pixel values as a 2D array\n        data = dataset.read(1)\n        \n        if column_name == \"Elevation\":\n          # convert miles to meters\n          data = data*mile_to_meters\n\n        # Get the geotransform to convert pixel coordinates to geographic coordinates\n        transform = dataset.transform\n\n        # Get the width and height of the GeoTIFF\n        height, width = data.shape\n\n        # Open the CSV file for writing\n        with open(csv_file, 'w', newline='') as csvfile:\n            csvwriter = csv.writer(csvfile)\n\n            # Write the CSV header\n            csvwriter.writerow(['Latitude', 'Longitude', 'x', 'y', column_name])\n\n            # Loop through each pixel and extract latitude, longitude, and image value\n            for y in range(height):\n                for x in range(width):\n                    # Get the pixel value\n                    image_value = data[y, x]\n\n                    # Convert pixel coordinates to geographic coordinates\n                    lon, lat = transform * (x, y)\n\n                    # Write the data to the CSV file\n                    csvwriter.writerow([lat, lon, x, y, image_value])\n\n  \ndef read_elevation_data(file_path, result_dem_csv_path, result_dem_feature_csv_path):\n    neighborhood_size=4\n    df = pd.read_csv(file_path)\n    \n    dataset = rasterio.open(geotiff_file)\n    data = dataset.read(1)\n\n    # Get the width and height of the GeoTIFF\n    height, width = data.shape\n    \n    # Create an empty DataFrame with column names\n    columns = ['lat', 'lon', 'elevation', 'slope', 'aspect', 'curvature', 'northness', 'eastness']\n    all_df = pd.DataFrame(columns=columns)\n    \n    all_df.to_csv(result_dem_feature_csv_path)\n    print(f\"DEM and other columns are saved to file {result_dem_feature_csv_path}\")\n    return all_df\n\n\n  \n# Usage example:\nresult_dem_csv_path = \"/home/chetana/gridmet_test_run/dem_template.csv\"\nresult_dem_feature_csv_path = \"/home/chetana/gridmet_test_run/dem_all.csv\"\n\n\ndem_file = \"/home/chetana/gridmet_test_run/dem_file.tif\"\nslope_file = '/home/chetana/gridmet_test_run/slope_file.tif'\naspect_file = '/home/chetana/gridmet_test_run/aspect_file.tif'\ncurvature_file = '/home/chetana/gridmet_test_run/curvature_file.tif'\nnorthness_file = '/home/chetana/gridmet_test_run/northness_file.tif'\neastness_file = '/home/chetana/gridmet_test_run/eastness_file.tif'\n\n\nslope, aspect = calculate_slope_aspect(dem_file)\ncurvature = calculate_curvature(dem_file)\nnorthness, eastness = calculate_gradients(dem_file)\n\n# Save the slope and aspect as new GeoTIFF files\nsave_as_geotiff(slope, slope_file, dem_file)\nsave_as_geotiff(aspect, aspect_file, dem_file)\nsave_as_geotiff(curvature, curvature_file, dem_file)\nsave_as_geotiff(northness, northness_file, dem_file)\nsave_as_geotiff(eastness, eastness_file, dem_file)\n\ngeotiff_to_csv(dem_file, dem_file+\".csv\", \"Elevation\")\ngeotiff_to_csv(slope_file, slope_file+\".csv\", \"Slope\")\ngeotiff_to_csv(aspect_file, aspect_file+\".csv\", \"Aspect\")\ngeotiff_to_csv(curvature_file, curvature_file+\".csv\", \"Curvature\")\ngeotiff_to_csv(northness_file, northness_file+\".csv\", \"Northness\")\ngeotiff_to_csv(eastness_file, eastness_file+\".csv\", \"Eastness\")\n\n# List of file paths for the CSV files\ncsv_files = [dem_file+\".csv\", slope_file+\".csv\", aspect_file+\".csv\", \n             curvature_file+\".csv\", northness_file+\".csv\", eastness_file+\".csv\"]\n\n# Initialize an empty list to store all dataframes\ndfs = []\n\n# Read each CSV file into separate dataframes\nfor file in csv_files:\n    df = pd.read_csv(file, encoding='utf-8')\n    dfs.append(df)\n\n# Merge the dataframes based on the latitude and longitude columns\nmerged_df = dfs[0]  # Start with the first dataframe\nfor i in range(1, len(dfs)):\n    merged_df = pd.merge(merged_df, dfs[i], on=['Latitude', 'Longitude', 'x', 'y'])\n\n# check the statistics of the columns\nfor column in merged_df.columns:\n    merged_df[column] = pd.to_numeric(merged_df[column], errors='coerce')\n    print(merged_df[column].describe())\n    \n# Save the merged dataframe to a new CSV file\nmerged_df.to_csv(result_dem_feature_csv_path, index=False)\nprint(f\"New dem features are updated in {result_dem_feature_csv_path}\")\n\n",
  "history_output" : "/home/chetana/gw-workspace/958hZSPX8iDB/western_us_dem.py:136: RuntimeWarning: invalid value encountered in divide\n  northness = np.arctan(dy / np.sqrt(dx**2 + dy**2))\n/home/chetana/gw-workspace/958hZSPX8iDB/western_us_dem.py:137: RuntimeWarning: invalid value encountered in divide\n  eastness = np.arctan(dx / np.sqrt(dx**2 + dy**2))\n(308251,)\nMean: 87.74606\nMedian: 89.97855\nMinimum: 0.0\nMaximum: 89.99793\nSum: 27047812.0\nStandard Deviation: 13.882807\nVariance: 192.73232\nSlop:  None\n(308251,)\nMean: 4.950267\nMedian: 0.0\nMinimum: -179.89487\nMaximum: 180.0\nSum: 1525924.8\nStandard Deviation: 104.200294\nVariance: 10857.701\nAspect:  None\nslope shape: (666, 694)\naspect shape: (666, 694)\ncount    462204.000000\nmean         37.030000\nstd           6.921275\nmin          25.060000\n25%          31.036000\n50%          37.030000\n75%          43.024000\nmax          49.000000\nName: Latitude, dtype: float64\ncount    462204.00000\nmean       -112.52600\nstd           7.21226\nmin        -125.00000\n25%        -118.77200\n50%        -112.52600\n75%        -106.28000\nmax        -100.05200\nName: Longitude, dtype: float64\ncount    462204.000000\nmean        346.500000\nstd         200.340552\nmin           0.000000\n25%         173.000000\n50%         346.500000\n75%         520.000000\nmax         693.000000\nName: x, dtype: float64\ncount    462204.000000\nmean        332.500000\nstd         192.257631\nmin           0.000000\n25%         166.000000\n50%         332.500000\n75%         499.000000\nmax         665.000000\nName: y, dtype: float64\ncount    309830.000000\nmean       2561.017903\nstd         376.542591\nmin        1691.416300\n25%        2286.872000\n50%        2471.946300\n75%        2776.111600\nmax        4115.082000\nName: Elevation, dtype: float64\ncount    308251.000000\nmean         87.746066\nstd          13.882829\nmin           0.000000\n25%          89.963320\n50%          89.978550\n75%          89.986750\nmax          89.997930\nName: Slope, dtype: float64\ncount    308251.000000\nmean        170.498343\nstd         106.428245\nmin           0.000000\n25%          83.157240\n50%         176.729450\n75%         266.423700\nmax         359.907000\nName: Aspect, dtype: float64\ncount    295965.000000\nmean       -186.538634\nstd        3215.498709\nmin      -40479.438000\n25%       -1488.354700\n50%          29.660137\n75%        1457.598300\nmax       18450.988000\nName: Curvature, dtype: float64\ncount    300725.000000\nmean         -0.007756\nstd           0.590930\nmin          -0.785398\n25%          -0.620971\n50%           0.000000\n75%           0.615480\nmax           0.785398\nName: Northness, dtype: float64\ncount    300725.000000\nmean         -0.002146\nstd           0.577707\nmin          -0.785398\n25%          -0.615480\n50%           0.000000\n75%           0.612676\nmax           0.785398\nName: Eastness, dtype: float64\nNew dem features are updated in /home/chetana/gridmet_test_run/dem_all.csv\n",
  "history_begin_time" : 1695532720325,
  "history_end_time" : 1695532733927,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "AklhZMKNNsPF",
  "history_input" : "import numpy as np\nimport pandas as pd\nfrom osgeo import gdal\nimport warnings\nimport rasterio\nimport csv\nfrom rasterio.transform import Affine\nfrom scipy.ndimage import sobel, gaussian_filter\n\nmile_to_meters = 1609.34\n\n# Set the warning filter globally to ignore the FutureWarning\nwarnings.simplefilter(\"ignore\", FutureWarning)\n\ndef lat_lon_to_pixel(lat, lon, geotransform):\n    x = int((lon - geotransform[0]) / geotransform[1])\n    y = int((lat - geotransform[3]) / geotransform[5])\n    return x, y\n\n\ndef calculate_slope_aspect_for_single(elevation_data, pixel_size_x, pixel_size_y):\n    # Calculate slope using the Sobel operator\n    slope_x = np.gradient(elevation_data, pixel_size_x, axis=1)\n    slope_y = np.gradient(elevation_data, pixel_size_y, axis=0)\n    slope_rad = np.arctan(np.sqrt(slope_x ** 2 + slope_y ** 2))\n    slope_deg = np.degrees(slope_rad)\n\n    # Calculate aspect (direction of the steepest descent)\n    aspect_rad = np.arctan2(slope_y, -slope_x)\n    aspect_deg = (np.degrees(aspect_rad) + 360) % 360\n\n    return slope_deg, aspect_deg\n\n\ndef save_as_geotiff(data, output_file, src_file):\n    with rasterio.open(src_file) as src_dataset:\n        profile = src_dataset.profile\n        transform = src_dataset.transform\n\n        # Update the data type, count, and set the transform for the new dataset\n        profile.update(dtype=rasterio.float32, count=1, transform=transform)\n\n        # Create the new GeoTIFF file\n        with rasterio.open(output_file, 'w', **profile) as dst_dataset:\n            # Write the data to the new GeoTIFF\n            dst_dataset.write(data, 1)\n  \ndef print_statistics(data):\n    # Calculate multiple statistics in one line\n    print(data)\n    print(data.shape)\n    mean, median, min_val, max_val, sum_val, std_dev, variance = [np.mean(data), np.median(data), np.min(data), np.max(data), np.sum(data), np.std(data), np.var(data)]\n\n    # Print the calculated statistics\n    print(\"Mean:\", mean)\n    print(\"Median:\", median)\n    print(\"Minimum:\", min_val)\n    print(\"Maximum:\", max_val)\n    print(\"Sum:\", sum_val)\n    print(\"Standard Deviation:\", std_dev)\n    print(\"Variance:\", variance)\n\ndef calculate_slope_aspect(dem_file):\n    with rasterio.open(dem_file) as dataset:\n        # Read the DEM data as a numpy array\n        dem_data = dataset.read(1)\n        \n        # convert miles to meters\n        dem_data = dem_data * mile_to_meters\n\n        # Get the geotransform to convert pixel coordinates to geographic coordinates\n        transform = dataset.transform\n\n        # Calculate the slope and aspect using numpy\n        dx, dy = np.gradient(dem_data, transform[0], transform[4])\n        #slope = np.arctan(np.sqrt(dx ** 2 + dy ** 2)) * (180.0 / np.pi)\n        slope_rad = np.arctan(np.sqrt(dx**2 + dy**2))\n\n        # Convert the slope to degrees\n        slope = np.degrees(slope_rad)\n        print(\"Slop: \", print_statistics(slope.ravel()))\n        aspect = np.degrees(np.arctan2(-dy, dx))\n        print(\"Aspect: \", print_statistics(aspect.ravel()))\n\n        # Adjust aspect values to range from 0 to 360 degrees\n        aspect[aspect < 0] += 360\n        print(f\"slope shape: {slope.shape}\")\n        print(f\"aspect shape: {aspect.shape}\")\n        \n        \n    return slope, aspect\n  \ndef calculate_curvature(elevation_data, pixel_size_x, pixel_size_y):\n    # Calculate curvature using the Laplacian operator\n    curvature_x = np.gradient(np.gradient(elevation_data, pixel_size_x, axis=1), pixel_size_x, axis=1)\n    curvature_y = np.gradient(np.gradient(elevation_data, pixel_size_y, axis=0), pixel_size_y, axis=0)\n    curvature = curvature_x + curvature_y\n\n    return curvature\n\n  \ndef calculate_curvature(dem_file, sigma=1):\n    with rasterio.open(dem_file) as dataset:\n        # Read the DEM data as a numpy array\n        dem_data = dataset.read(1)\n        \n        # convert miles to meters\n        dem_data = dem_data*mile_to_meters\n\n        # Calculate the gradient using the Sobel filter\n        dx = sobel(dem_data, axis=1, mode='constant')\n        dy = sobel(dem_data, axis=0, mode='constant')\n\n        # Calculate the second derivatives using the Sobel filter\n        dxx = sobel(dx, axis=1, mode='constant')\n        dyy = sobel(dy, axis=0, mode='constant')\n\n        # Calculate the curvature using the second derivatives\n        curvature = dxx + dyy\n\n        # Smooth the curvature using Gaussian filtering (optional)\n        curvature = gaussian_filter(curvature, sigma)\n\n    return curvature\n  \ndef calculate_gradients(dem_file):\n    with rasterio.open(dem_file) as dataset:\n        # Read the DEM data as a numpy array\n        dem_data = dataset.read(1)\n\n        # Calculate the gradients along the North and East directions\n        dy, dx = np.gradient(dem_data, dataset.res[0], dataset.res[1])\n\n        # Calculate the Northness and Eastness\n        northness = np.arctan(dy / np.sqrt(dx**2 + dy**2))\n        eastness = np.arctan(dx / np.sqrt(dx**2 + dy**2))\n\n    return northness, eastness\n  \n  \ndef geotiff_to_csv(geotiff_file, csv_file, column_name):\n    # Open the GeoTIFF file\n    with rasterio.open(geotiff_file) as dataset:\n        # Get the pixel values as a 2D array\n        data = dataset.read(1)\n        \n        if column_name == \"Elevation\":\n          # convert miles to meters\n          data = data*mile_to_meters\n\n        # Get the geotransform to convert pixel coordinates to geographic coordinates\n        transform = dataset.transform\n\n        # Get the width and height of the GeoTIFF\n        height, width = data.shape\n\n        # Open the CSV file for writing\n        with open(csv_file, 'w', newline='') as csvfile:\n            csvwriter = csv.writer(csvfile)\n\n            # Write the CSV header\n            csvwriter.writerow(['Latitude', 'Longitude', 'x', 'y', column_name])\n\n            # Loop through each pixel and extract latitude, longitude, and image value\n            for y in range(height):\n                for x in range(width):\n                    # Get the pixel value\n                    image_value = data[y, x]\n\n                    # Convert pixel coordinates to geographic coordinates\n                    lon, lat = transform * (x, y)\n\n                    # Write the data to the CSV file\n                    csvwriter.writerow([lat, lon, x, y, image_value])\n\n  \ndef read_elevation_data(file_path, result_dem_csv_path, result_dem_feature_csv_path):\n    neighborhood_size=4\n    df = pd.read_csv(file_path)\n    \n    dataset = rasterio.open(geotiff_file)\n    data = dataset.read(1)\n\n    # Get the width and height of the GeoTIFF\n    height, width = data.shape\n    \n    # Create an empty DataFrame with column names\n    columns = ['lat', 'lon', 'elevation', 'slope', 'aspect', 'curvature', 'northness', 'eastness']\n    all_df = pd.DataFrame(columns=columns)\n    \n    all_df.to_csv(result_dem_feature_csv_path)\n    print(f\"DEM and other columns are saved to file {result_dem_feature_csv_path}\")\n    return all_df\n\n\n  \n# Usage example:\nresult_dem_csv_path = \"/home/chetana/gridmet_test_run/dem_template.csv\"\nresult_dem_feature_csv_path = \"/home/chetana/gridmet_test_run/dem_all.csv\"\n\n\ndem_file = \"/home/chetana/gridmet_test_run/dem_file.tif\"\nslope_file = '/home/chetana/gridmet_test_run/slope_file.tif'\naspect_file = '/home/chetana/gridmet_test_run/aspect_file.tif'\ncurvature_file = '/home/chetana/gridmet_test_run/curvature_file.tif'\nnorthness_file = '/home/chetana/gridmet_test_run/northness_file.tif'\neastness_file = '/home/chetana/gridmet_test_run/eastness_file.tif'\n\n\nslope, aspect = calculate_slope_aspect(dem_file)\ncurvature = calculate_curvature(dem_file)\nnorthness, eastness = calculate_gradients(dem_file)\n\n# Save the slope and aspect as new GeoTIFF files\nsave_as_geotiff(slope, slope_file, dem_file)\nsave_as_geotiff(aspect, aspect_file, dem_file)\nsave_as_geotiff(curvature, curvature_file, dem_file)\nsave_as_geotiff(northness, northness_file, dem_file)\nsave_as_geotiff(eastness, eastness_file, dem_file)\n\ngeotiff_to_csv(dem_file, dem_file+\".csv\", \"Elevation\")\ngeotiff_to_csv(slope_file, slope_file+\".csv\", \"Slope\")\ngeotiff_to_csv(aspect_file, aspect_file+\".csv\", \"Aspect\")\ngeotiff_to_csv(curvature_file, curvature_file+\".csv\", \"Curvature\")\ngeotiff_to_csv(northness_file, northness_file+\".csv\", \"Northness\")\ngeotiff_to_csv(eastness_file, eastness_file+\".csv\", \"Eastness\")\n\n# List of file paths for the CSV files\ncsv_files = [dem_file+\".csv\", slope_file+\".csv\", aspect_file+\".csv\", \n             curvature_file+\".csv\", northness_file+\".csv\", eastness_file+\".csv\"]\n\n# Initialize an empty list to store all dataframes\ndfs = []\n\n# Read each CSV file into separate dataframes\nfor file in csv_files:\n    df = pd.read_csv(file, encoding='utf-8')\n    dfs.append(df)\n\n# Merge the dataframes based on the latitude and longitude columns\nmerged_df = dfs[0]  # Start with the first dataframe\nfor i in range(1, len(dfs)):\n    merged_df = pd.merge(merged_df, dfs[i], on=['Latitude', 'Longitude', 'x', 'y'])\n\n# check the statistics of the columns\nfor column in merged_df.columns:\n    merged_df[column] = pd.to_numeric(merged_df[column], errors='coerce')\n    print(merged_df[column].describe())\n    \n# Save the merged dataframe to a new CSV file\nmerged_df.to_csv(result_dem_feature_csv_path, index=False)\nprint(f\"New dem features are updated in {result_dem_feature_csv_path}\")\n\n",
  "history_output" : "/home/chetana/gw-workspace/AklhZMKNNsPF/western_us_dem.py:135: RuntimeWarning: invalid value encountered in divide\n  northness = np.arctan(dy / np.sqrt(dx**2 + dy**2))\n/home/chetana/gw-workspace/AklhZMKNNsPF/western_us_dem.py:136: RuntimeWarning: invalid value encountered in divide\n  eastness = np.arctan(dx / np.sqrt(dx**2 + dy**2))\n[nan nan nan ... nan nan nan]\n(462204,)\nMean: nan\nMedian: nan\nMinimum: nan\nMaximum: nan\nSum: nan\nStandard Deviation: nan\nVariance: nan\nSlop:  None\n[nan nan nan ... nan nan nan]\n(462204,)\nMean: nan\nMedian: nan\nMinimum: nan\nMaximum: nan\nSum: nan\nStandard Deviation: nan\nVariance: nan\nAspect:  None\nslope shape: (666, 694)\naspect shape: (666, 694)\ncount    462204.000000\nmean         37.030000\nstd           6.921275\nmin          25.060000\n25%          31.036000\n50%          37.030000\n75%          43.024000\nmax          49.000000\nName: Latitude, dtype: float64\ncount    462204.00000\nmean       -112.52600\nstd           7.21226\nmin        -125.00000\n25%        -118.77200\n50%        -112.52600\n75%        -106.28000\nmax        -100.05200\nName: Longitude, dtype: float64\ncount    462204.000000\nmean        346.500000\nstd         200.340552\nmin           0.000000\n25%         173.000000\n50%         346.500000\n75%         520.000000\nmax         693.000000\nName: x, dtype: float64\ncount    462204.000000\nmean        332.500000\nstd         192.257631\nmin           0.000000\n25%         166.000000\n50%         332.500000\n75%         499.000000\nmax         665.000000\nName: y, dtype: float64\ncount    309830.000000\nmean       2561.017903\nstd         376.542591\nmin        1691.416300\n25%        2286.872000\n50%        2471.946300\n75%        2776.111600\nmax        4115.082000\nName: Elevation, dtype: float64\ncount    308251.000000\nmean         87.746066\nstd          13.882829\nmin           0.000000\n25%          89.963320\n50%          89.978550\n75%          89.986750\nmax          89.997930\nName: Slope, dtype: float64\ncount    308251.000000\nmean        170.498343\nstd         106.428245\nmin           0.000000\n25%          83.157240\n50%         176.729450\n75%         266.423700\nmax         359.907000\nName: Aspect, dtype: float64\ncount    295965.000000\nmean       -186.538634\nstd        3215.498709\nmin      -40479.438000\n25%       -1488.354700\n50%          29.660137\n75%        1457.598300\nmax       18450.988000\nName: Curvature, dtype: float64\ncount    300725.000000\nmean         -0.007756\nstd           0.590930\nmin          -0.785398\n25%          -0.620971\n50%           0.000000\n75%           0.615480\nmax           0.785398\nName: Northness, dtype: float64\ncount    300725.000000\nmean         -0.002146\nstd           0.577707\nmin          -0.785398\n25%          -0.615480\n50%           0.000000\n75%           0.612676\nmax           0.785398\nName: Eastness, dtype: float64\nNew dem features are updated in /home/chetana/gridmet_test_run/dem_all.csv\n",
  "history_begin_time" : 1695532559004,
  "history_end_time" : 1695532572955,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "keu50vkM50zg",
  "history_input" : "import numpy as np\nimport pandas as pd\nfrom osgeo import gdal\nimport warnings\nimport rasterio\nimport csv\nfrom rasterio.transform import Affine\nfrom scipy.ndimage import sobel, gaussian_filter\n\nmile_to_meters = 1609.34\n\n# Set the warning filter globally to ignore the FutureWarning\nwarnings.simplefilter(\"ignore\", FutureWarning)\n\ndef lat_lon_to_pixel(lat, lon, geotransform):\n    x = int((lon - geotransform[0]) / geotransform[1])\n    y = int((lat - geotransform[3]) / geotransform[5])\n    return x, y\n\n\ndef calculate_slope_aspect_for_single(elevation_data, pixel_size_x, pixel_size_y):\n    # Calculate slope using the Sobel operator\n    slope_x = np.gradient(elevation_data, pixel_size_x, axis=1)\n    slope_y = np.gradient(elevation_data, pixel_size_y, axis=0)\n    slope_rad = np.arctan(np.sqrt(slope_x ** 2 + slope_y ** 2))\n    slope_deg = np.degrees(slope_rad)\n\n    # Calculate aspect (direction of the steepest descent)\n    aspect_rad = np.arctan2(slope_y, -slope_x)\n    aspect_deg = (np.degrees(aspect_rad) + 360) % 360\n\n    return slope_deg, aspect_deg\n\n\ndef save_as_geotiff(data, output_file, src_file):\n    with rasterio.open(src_file) as src_dataset:\n        profile = src_dataset.profile\n        transform = src_dataset.transform\n\n        # Update the data type, count, and set the transform for the new dataset\n        profile.update(dtype=rasterio.float32, count=1, transform=transform)\n\n        # Create the new GeoTIFF file\n        with rasterio.open(output_file, 'w', **profile) as dst_dataset:\n            # Write the data to the new GeoTIFF\n            dst_dataset.write(data, 1)\n  \ndef print_statistics(data):\n    # Calculate multiple statistics in one line\n    mean, median, min_val, max_val, sum_val, std_dev, variance = [np.mean(data), np.median(data), np.min(data), np.max(data), np.sum(data), np.std(data), np.var(data)]\n\n    # Print the calculated statistics\n    print(\"Mean:\", mean)\n    print(\"Median:\", median)\n    print(\"Minimum:\", min_val)\n    print(\"Maximum:\", max_val)\n    print(\"Sum:\", sum_val)\n    print(\"Standard Deviation:\", std_dev)\n    print(\"Variance:\", variance)\n\ndef calculate_slope_aspect(dem_file):\n    with rasterio.open(dem_file) as dataset:\n        # Read the DEM data as a numpy array\n        dem_data = dataset.read(1)\n        \n        # convert miles to meters\n        dem_data = dem_data * mile_to_meters\n\n        # Get the geotransform to convert pixel coordinates to geographic coordinates\n        transform = dataset.transform\n\n        # Calculate the slope and aspect using numpy\n        dx, dy = np.gradient(dem_data, transform[0], transform[4])\n        #slope = np.arctan(np.sqrt(dx ** 2 + dy ** 2)) * (180.0 / np.pi)\n        slope_rad = np.arctan(np.sqrt(dx**2 + dy**2))\n\n        # Convert the slope to degrees\n        slope = np.degrees(slope_rad)\n        print(\"Slop: \", print_statistics(slope.ravel()))\n        aspect = np.degrees(np.arctan2(-dy, dx))\n        print(\"Aspect: \", print_statistics(aspect.ravel()))\n\n        # Adjust aspect values to range from 0 to 360 degrees\n        aspect[aspect < 0] += 360\n        print(f\"slope shape: {slope.shape}\")\n        print(f\"aspect shape: {aspect.shape}\")\n        \n        \n    return slope, aspect\n  \ndef calculate_curvature(elevation_data, pixel_size_x, pixel_size_y):\n    # Calculate curvature using the Laplacian operator\n    curvature_x = np.gradient(np.gradient(elevation_data, pixel_size_x, axis=1), pixel_size_x, axis=1)\n    curvature_y = np.gradient(np.gradient(elevation_data, pixel_size_y, axis=0), pixel_size_y, axis=0)\n    curvature = curvature_x + curvature_y\n\n    return curvature\n\n  \ndef calculate_curvature(dem_file, sigma=1):\n    with rasterio.open(dem_file) as dataset:\n        # Read the DEM data as a numpy array\n        dem_data = dataset.read(1)\n        \n        # convert miles to meters\n        dem_data = dem_data*mile_to_meters\n\n        # Calculate the gradient using the Sobel filter\n        dx = sobel(dem_data, axis=1, mode='constant')\n        dy = sobel(dem_data, axis=0, mode='constant')\n\n        # Calculate the second derivatives using the Sobel filter\n        dxx = sobel(dx, axis=1, mode='constant')\n        dyy = sobel(dy, axis=0, mode='constant')\n\n        # Calculate the curvature using the second derivatives\n        curvature = dxx + dyy\n\n        # Smooth the curvature using Gaussian filtering (optional)\n        curvature = gaussian_filter(curvature, sigma)\n\n    return curvature\n  \ndef calculate_gradients(dem_file):\n    with rasterio.open(dem_file) as dataset:\n        # Read the DEM data as a numpy array\n        dem_data = dataset.read(1)\n\n        # Calculate the gradients along the North and East directions\n        dy, dx = np.gradient(dem_data, dataset.res[0], dataset.res[1])\n\n        # Calculate the Northness and Eastness\n        northness = np.arctan(dy / np.sqrt(dx**2 + dy**2))\n        eastness = np.arctan(dx / np.sqrt(dx**2 + dy**2))\n\n    return northness, eastness\n  \n  \ndef geotiff_to_csv(geotiff_file, csv_file, column_name):\n    # Open the GeoTIFF file\n    with rasterio.open(geotiff_file) as dataset:\n        # Get the pixel values as a 2D array\n        data = dataset.read(1)\n        \n        if column_name == \"Elevation\":\n          # convert miles to meters\n          data = data*mile_to_meters\n\n        # Get the geotransform to convert pixel coordinates to geographic coordinates\n        transform = dataset.transform\n\n        # Get the width and height of the GeoTIFF\n        height, width = data.shape\n\n        # Open the CSV file for writing\n        with open(csv_file, 'w', newline='') as csvfile:\n            csvwriter = csv.writer(csvfile)\n\n            # Write the CSV header\n            csvwriter.writerow(['Latitude', 'Longitude', 'x', 'y', column_name])\n\n            # Loop through each pixel and extract latitude, longitude, and image value\n            for y in range(height):\n                for x in range(width):\n                    # Get the pixel value\n                    image_value = data[y, x]\n\n                    # Convert pixel coordinates to geographic coordinates\n                    lon, lat = transform * (x, y)\n\n                    # Write the data to the CSV file\n                    csvwriter.writerow([lat, lon, x, y, image_value])\n\n  \ndef read_elevation_data(file_path, result_dem_csv_path, result_dem_feature_csv_path):\n    neighborhood_size=4\n    df = pd.read_csv(file_path)\n    \n    dataset = rasterio.open(geotiff_file)\n    data = dataset.read(1)\n\n    # Get the width and height of the GeoTIFF\n    height, width = data.shape\n    \n    # Create an empty DataFrame with column names\n    columns = ['lat', 'lon', 'elevation', 'slope', 'aspect', 'curvature', 'northness', 'eastness']\n    all_df = pd.DataFrame(columns=columns)\n    \n    all_df.to_csv(result_dem_feature_csv_path)\n    print(f\"DEM and other columns are saved to file {result_dem_feature_csv_path}\")\n    return all_df\n\n\n  \n# Usage example:\nresult_dem_csv_path = \"/home/chetana/gridmet_test_run/dem_template.csv\"\nresult_dem_feature_csv_path = \"/home/chetana/gridmet_test_run/dem_all.csv\"\n\n\ndem_file = \"/home/chetana/gridmet_test_run/dem_file.tif\"\nslope_file = '/home/chetana/gridmet_test_run/slope_file.tif'\naspect_file = '/home/chetana/gridmet_test_run/aspect_file.tif'\ncurvature_file = '/home/chetana/gridmet_test_run/curvature_file.tif'\nnorthness_file = '/home/chetana/gridmet_test_run/northness_file.tif'\neastness_file = '/home/chetana/gridmet_test_run/eastness_file.tif'\n\n\nslope, aspect = calculate_slope_aspect(dem_file)\ncurvature = calculate_curvature(dem_file)\nnorthness, eastness = calculate_gradients(dem_file)\n\n# Save the slope and aspect as new GeoTIFF files\nsave_as_geotiff(slope, slope_file, dem_file)\nsave_as_geotiff(aspect, aspect_file, dem_file)\nsave_as_geotiff(curvature, curvature_file, dem_file)\nsave_as_geotiff(northness, northness_file, dem_file)\nsave_as_geotiff(eastness, eastness_file, dem_file)\n\ngeotiff_to_csv(dem_file, dem_file+\".csv\", \"Elevation\")\ngeotiff_to_csv(slope_file, slope_file+\".csv\", \"Slope\")\ngeotiff_to_csv(aspect_file, aspect_file+\".csv\", \"Aspect\")\ngeotiff_to_csv(curvature_file, curvature_file+\".csv\", \"Curvature\")\ngeotiff_to_csv(northness_file, northness_file+\".csv\", \"Northness\")\ngeotiff_to_csv(eastness_file, eastness_file+\".csv\", \"Eastness\")\n\n# List of file paths for the CSV files\ncsv_files = [dem_file+\".csv\", slope_file+\".csv\", aspect_file+\".csv\", \n             curvature_file+\".csv\", northness_file+\".csv\", eastness_file+\".csv\"]\n\n# Initialize an empty list to store all dataframes\ndfs = []\n\n# Read each CSV file into separate dataframes\nfor file in csv_files:\n    df = pd.read_csv(file, encoding='utf-8')\n    dfs.append(df)\n\n# Merge the dataframes based on the latitude and longitude columns\nmerged_df = dfs[0]  # Start with the first dataframe\nfor i in range(1, len(dfs)):\n    merged_df = pd.merge(merged_df, dfs[i], on=['Latitude', 'Longitude', 'x', 'y'])\n\n# check the statistics of the columns\nfor column in merged_df.columns:\n    merged_df[column] = pd.to_numeric(merged_df[column], errors='coerce')\n    print(merged_df[column].describe())\n    \n# Save the merged dataframe to a new CSV file\nmerged_df.to_csv(result_dem_feature_csv_path, index=False)\nprint(f\"New dem features are updated in {result_dem_feature_csv_path}\")\n\n",
  "history_output" : "/home/chetana/gw-workspace/keu50vkM50zg/western_us_dem.py:133: RuntimeWarning: invalid value encountered in divide\n  northness = np.arctan(dy / np.sqrt(dx**2 + dy**2))\n/home/chetana/gw-workspace/keu50vkM50zg/western_us_dem.py:134: RuntimeWarning: invalid value encountered in divide\n  eastness = np.arctan(dx / np.sqrt(dx**2 + dy**2))\nMean: nan\nMedian: nan\nMinimum: nan\nMaximum: nan\nSum: nan\nStandard Deviation: nan\nVariance: nan\nSlop:  None\nMean: nan\nMedian: nan\nMinimum: nan\nMaximum: nan\nSum: nan\nStandard Deviation: nan\nVariance: nan\nAspect:  None\nslope shape: (666, 694)\naspect shape: (666, 694)\ncount    462204.000000\nmean         37.030000\nstd           6.921275\nmin          25.060000\n25%          31.036000\n50%          37.030000\n75%          43.024000\nmax          49.000000\nName: Latitude, dtype: float64\ncount    462204.00000\nmean       -112.52600\nstd           7.21226\nmin        -125.00000\n25%        -118.77200\n50%        -112.52600\n75%        -106.28000\nmax        -100.05200\nName: Longitude, dtype: float64\ncount    462204.000000\nmean        346.500000\nstd         200.340552\nmin           0.000000\n25%         173.000000\n50%         346.500000\n75%         520.000000\nmax         693.000000\nName: x, dtype: float64\ncount    462204.000000\nmean        332.500000\nstd         192.257631\nmin           0.000000\n25%         166.000000\n50%         332.500000\n75%         499.000000\nmax         665.000000\nName: y, dtype: float64\ncount    309830.000000\nmean       2561.017903\nstd         376.542591\nmin        1691.416300\n25%        2286.872000\n50%        2471.946300\n75%        2776.111600\nmax        4115.082000\nName: Elevation, dtype: float64\ncount    308251.000000\nmean         87.746066\nstd          13.882829\nmin           0.000000\n25%          89.963320\n50%          89.978550\n75%          89.986750\nmax          89.997930\nName: Slope, dtype: float64\ncount    308251.000000\nmean        170.498343\nstd         106.428245\nmin           0.000000\n25%          83.157240\n50%         176.729450\n75%         266.423700\nmax         359.907000\nName: Aspect, dtype: float64\ncount    295965.000000\nmean       -186.538634\nstd        3215.498709\nmin      -40479.438000\n25%       -1488.354700\n50%          29.660137\n75%        1457.598300\nmax       18450.988000\nName: Curvature, dtype: float64\ncount    300725.000000\nmean         -0.007756\nstd           0.590930\nmin          -0.785398\n25%          -0.620971\n50%           0.000000\n75%           0.615480\nmax           0.785398\nName: Northness, dtype: float64\ncount    300725.000000\nmean         -0.002146\nstd           0.577707\nmin          -0.785398\n25%          -0.615480\n50%           0.000000\n75%           0.612676\nmax           0.785398\nName: Eastness, dtype: float64\nNew dem features are updated in /home/chetana/gridmet_test_run/dem_all.csv\n",
  "history_begin_time" : 1695532480002,
  "history_end_time" : 1695532493964,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "chIMrNOT9TGh",
  "history_input" : "import numpy as np\nimport pandas as pd\nfrom osgeo import gdal\nimport warnings\nimport rasterio\nimport csv\nfrom rasterio.transform import Affine\nfrom scipy.ndimage import sobel, gaussian_filter\n\nmile_to_meters = 1609.34\n\n# Set the warning filter globally to ignore the FutureWarning\nwarnings.simplefilter(\"ignore\", FutureWarning)\n\ndef lat_lon_to_pixel(lat, lon, geotransform):\n    x = int((lon - geotransform[0]) / geotransform[1])\n    y = int((lat - geotransform[3]) / geotransform[5])\n    return x, y\n\n\ndef calculate_slope_aspect_for_single(elevation_data, pixel_size_x, pixel_size_y):\n    # Calculate slope using the Sobel operator\n    slope_x = np.gradient(elevation_data, pixel_size_x, axis=1)\n    slope_y = np.gradient(elevation_data, pixel_size_y, axis=0)\n    slope_rad = np.arctan(np.sqrt(slope_x ** 2 + slope_y ** 2))\n    slope_deg = np.degrees(slope_rad)\n\n    # Calculate aspect (direction of the steepest descent)\n    aspect_rad = np.arctan2(slope_y, -slope_x)\n    aspect_deg = (np.degrees(aspect_rad) + 360) % 360\n\n    return slope_deg, aspect_deg\n\n\ndef save_as_geotiff(data, output_file, src_file):\n    with rasterio.open(src_file) as src_dataset:\n        profile = src_dataset.profile\n        transform = src_dataset.transform\n\n        # Update the data type, count, and set the transform for the new dataset\n        profile.update(dtype=rasterio.float32, count=1, transform=transform)\n\n        # Create the new GeoTIFF file\n        with rasterio.open(output_file, 'w', **profile) as dst_dataset:\n            # Write the data to the new GeoTIFF\n            dst_dataset.write(data, 1)\n  \ndef print_statistics(data):\n    # Calculate multiple statistics in one line\n    mean, median, min_val, max_val, sum_val, std_dev, variance = [np.mean(data), np.median(data), np.min(data), np.max(data), np.sum(data), np.std(data), np.var(data)]\n\n    # Print the calculated statistics\n    print(\"Mean:\", mean)\n    print(\"Median:\", median)\n    print(\"Minimum:\", min_val)\n    print(\"Maximum:\", max_val)\n    print(\"Sum:\", sum_val)\n    print(\"Standard Deviation:\", std_dev)\n    print(\"Variance:\", variance)\n\ndef calculate_slope_aspect(dem_file):\n    with rasterio.open(dem_file) as dataset:\n        # Read the DEM data as a numpy array\n        dem_data = dataset.read(1)\n        \n        # convert miles to meters\n        dem_data = dem_data * mile_to_meters\n\n        # Get the geotransform to convert pixel coordinates to geographic coordinates\n        transform = dataset.transform\n\n        # Calculate the slope and aspect using numpy\n        dx, dy = np.gradient(dem_data, transform[0], transform[4])\n        #slope = np.arctan(np.sqrt(dx ** 2 + dy ** 2)) * (180.0 / np.pi)\n        slope_rad = np.arctan(np.sqrt(dx**2 + dy**2))\n\n        # Convert the slope to degrees\n        slope = np.degrees(slope_rad)\n        print(\"Slop: \", print_statistics(slope))\n        aspect = np.degrees(np.arctan2(-dy, dx))\n        print(\"Aspect: \", print_statistics(aspect))\n\n        # Adjust aspect values to range from 0 to 360 degrees\n        aspect[aspect < 0] += 360\n        print(f\"slope shape: {slope.shape}\")\n        print(f\"aspect shape: {aspect.shape}\")\n        \n        \n    return slope, aspect\n  \ndef calculate_curvature(elevation_data, pixel_size_x, pixel_size_y):\n    # Calculate curvature using the Laplacian operator\n    curvature_x = np.gradient(np.gradient(elevation_data, pixel_size_x, axis=1), pixel_size_x, axis=1)\n    curvature_y = np.gradient(np.gradient(elevation_data, pixel_size_y, axis=0), pixel_size_y, axis=0)\n    curvature = curvature_x + curvature_y\n\n    return curvature\n\n  \ndef calculate_curvature(dem_file, sigma=1):\n    with rasterio.open(dem_file) as dataset:\n        # Read the DEM data as a numpy array\n        dem_data = dataset.read(1)\n        \n        # convert miles to meters\n        dem_data = dem_data*mile_to_meters\n\n        # Calculate the gradient using the Sobel filter\n        dx = sobel(dem_data, axis=1, mode='constant')\n        dy = sobel(dem_data, axis=0, mode='constant')\n\n        # Calculate the second derivatives using the Sobel filter\n        dxx = sobel(dx, axis=1, mode='constant')\n        dyy = sobel(dy, axis=0, mode='constant')\n\n        # Calculate the curvature using the second derivatives\n        curvature = dxx + dyy\n\n        # Smooth the curvature using Gaussian filtering (optional)\n        curvature = gaussian_filter(curvature, sigma)\n\n    return curvature\n  \ndef calculate_gradients(dem_file):\n    with rasterio.open(dem_file) as dataset:\n        # Read the DEM data as a numpy array\n        dem_data = dataset.read(1)\n\n        # Calculate the gradients along the North and East directions\n        dy, dx = np.gradient(dem_data, dataset.res[0], dataset.res[1])\n\n        # Calculate the Northness and Eastness\n        northness = np.arctan(dy / np.sqrt(dx**2 + dy**2))\n        eastness = np.arctan(dx / np.sqrt(dx**2 + dy**2))\n\n    return northness, eastness\n  \n  \ndef geotiff_to_csv(geotiff_file, csv_file, column_name):\n    # Open the GeoTIFF file\n    with rasterio.open(geotiff_file) as dataset:\n        # Get the pixel values as a 2D array\n        data = dataset.read(1)\n        \n        if column_name == \"Elevation\":\n          # convert miles to meters\n          data = data*mile_to_meters\n\n        # Get the geotransform to convert pixel coordinates to geographic coordinates\n        transform = dataset.transform\n\n        # Get the width and height of the GeoTIFF\n        height, width = data.shape\n\n        # Open the CSV file for writing\n        with open(csv_file, 'w', newline='') as csvfile:\n            csvwriter = csv.writer(csvfile)\n\n            # Write the CSV header\n            csvwriter.writerow(['Latitude', 'Longitude', 'x', 'y', column_name])\n\n            # Loop through each pixel and extract latitude, longitude, and image value\n            for y in range(height):\n                for x in range(width):\n                    # Get the pixel value\n                    image_value = data[y, x]\n\n                    # Convert pixel coordinates to geographic coordinates\n                    lon, lat = transform * (x, y)\n\n                    # Write the data to the CSV file\n                    csvwriter.writerow([lat, lon, x, y, image_value])\n\n  \ndef read_elevation_data(file_path, result_dem_csv_path, result_dem_feature_csv_path):\n    neighborhood_size=4\n    df = pd.read_csv(file_path)\n    \n    dataset = rasterio.open(geotiff_file)\n    data = dataset.read(1)\n\n    # Get the width and height of the GeoTIFF\n    height, width = data.shape\n    \n    # Create an empty DataFrame with column names\n    columns = ['lat', 'lon', 'elevation', 'slope', 'aspect', 'curvature', 'northness', 'eastness']\n    all_df = pd.DataFrame(columns=columns)\n    \n    all_df.to_csv(result_dem_feature_csv_path)\n    print(f\"DEM and other columns are saved to file {result_dem_feature_csv_path}\")\n    return all_df\n\n\n  \n# Usage example:\nresult_dem_csv_path = \"/home/chetana/gridmet_test_run/dem_template.csv\"\nresult_dem_feature_csv_path = \"/home/chetana/gridmet_test_run/dem_all.csv\"\n\n\ndem_file = \"/home/chetana/gridmet_test_run/dem_file.tif\"\nslope_file = '/home/chetana/gridmet_test_run/slope_file.tif'\naspect_file = '/home/chetana/gridmet_test_run/aspect_file.tif'\ncurvature_file = '/home/chetana/gridmet_test_run/curvature_file.tif'\nnorthness_file = '/home/chetana/gridmet_test_run/northness_file.tif'\neastness_file = '/home/chetana/gridmet_test_run/eastness_file.tif'\n\n\nslope, aspect = calculate_slope_aspect(dem_file)\ncurvature = calculate_curvature(dem_file)\nnorthness, eastness = calculate_gradients(dem_file)\n\n# Save the slope and aspect as new GeoTIFF files\nsave_as_geotiff(slope, slope_file, dem_file)\nsave_as_geotiff(aspect, aspect_file, dem_file)\nsave_as_geotiff(curvature, curvature_file, dem_file)\nsave_as_geotiff(northness, northness_file, dem_file)\nsave_as_geotiff(eastness, eastness_file, dem_file)\n\ngeotiff_to_csv(dem_file, dem_file+\".csv\", \"Elevation\")\ngeotiff_to_csv(slope_file, slope_file+\".csv\", \"Slope\")\ngeotiff_to_csv(aspect_file, aspect_file+\".csv\", \"Aspect\")\ngeotiff_to_csv(curvature_file, curvature_file+\".csv\", \"Curvature\")\ngeotiff_to_csv(northness_file, northness_file+\".csv\", \"Northness\")\ngeotiff_to_csv(eastness_file, eastness_file+\".csv\", \"Eastness\")\n\n# List of file paths for the CSV files\ncsv_files = [dem_file+\".csv\", slope_file+\".csv\", aspect_file+\".csv\", \n             curvature_file+\".csv\", northness_file+\".csv\", eastness_file+\".csv\"]\n\n# Initialize an empty list to store all dataframes\ndfs = []\n\n# Read each CSV file into separate dataframes\nfor file in csv_files:\n    df = pd.read_csv(file, encoding='utf-8')\n    dfs.append(df)\n\n# Merge the dataframes based on the latitude and longitude columns\nmerged_df = dfs[0]  # Start with the first dataframe\nfor i in range(1, len(dfs)):\n    merged_df = pd.merge(merged_df, dfs[i], on=['Latitude', 'Longitude', 'x', 'y'])\n\n# check the statistics of the columns\nfor column in merged_df.columns:\n    merged_df[column] = pd.to_numeric(merged_df[column], errors='coerce')\n    print(merged_df[column].describe())\n    \n# Save the merged dataframe to a new CSV file\nmerged_df.to_csv(result_dem_feature_csv_path, index=False)\nprint(f\"New dem features are updated in {result_dem_feature_csv_path}\")\n\n",
  "history_output" : "/home/chetana/gw-workspace/chIMrNOT9TGh/western_us_dem.py:133: RuntimeWarning: invalid value encountered in divide\n  northness = np.arctan(dy / np.sqrt(dx**2 + dy**2))\n/home/chetana/gw-workspace/chIMrNOT9TGh/western_us_dem.py:134: RuntimeWarning: invalid value encountered in divide\n  eastness = np.arctan(dx / np.sqrt(dx**2 + dy**2))\nMean: nan\nMedian: nan\nMinimum: nan\nMaximum: nan\nSum: nan\nStandard Deviation: nan\nVariance: nan\nSlop:  None\nMean: nan\nMedian: nan\nMinimum: nan\nMaximum: nan\nSum: nan\nStandard Deviation: nan\nVariance: nan\nAspect:  None\nslope shape: (666, 694)\naspect shape: (666, 694)\ncount    462204.000000\nmean         37.030000\nstd           6.921275\nmin          25.060000\n25%          31.036000\n50%          37.030000\n75%          43.024000\nmax          49.000000\nName: Latitude, dtype: float64\ncount    462204.00000\nmean       -112.52600\nstd           7.21226\nmin        -125.00000\n25%        -118.77200\n50%        -112.52600\n75%        -106.28000\nmax        -100.05200\nName: Longitude, dtype: float64\ncount    462204.000000\nmean        346.500000\nstd         200.340552\nmin           0.000000\n25%         173.000000\n50%         346.500000\n75%         520.000000\nmax         693.000000\nName: x, dtype: float64\ncount    462204.000000\nmean        332.500000\nstd         192.257631\nmin           0.000000\n25%         166.000000\n50%         332.500000\n75%         499.000000\nmax         665.000000\nName: y, dtype: float64\ncount    309830.000000\nmean       2561.017903\nstd         376.542591\nmin        1691.416300\n25%        2286.872000\n50%        2471.946300\n75%        2776.111600\nmax        4115.082000\nName: Elevation, dtype: float64\ncount    308251.000000\nmean         87.746066\nstd          13.882829\nmin           0.000000\n25%          89.963320\n50%          89.978550\n75%          89.986750\nmax          89.997930\nName: Slope, dtype: float64\ncount    308251.000000\nmean        170.498343\nstd         106.428245\nmin           0.000000\n25%          83.157240\n50%         176.729450\n75%         266.423700\nmax         359.907000\nName: Aspect, dtype: float64\ncount    295965.000000\nmean       -186.538634\nstd        3215.498709\nmin      -40479.438000\n25%       -1488.354700\n50%          29.660137\n75%        1457.598300\nmax       18450.988000\nName: Curvature, dtype: float64\ncount    300725.000000\nmean         -0.007756\nstd           0.590930\nmin          -0.785398\n25%          -0.620971\n50%           0.000000\n75%           0.615480\nmax           0.785398\nName: Northness, dtype: float64\ncount    300725.000000\nmean         -0.002146\nstd           0.577707\nmin          -0.785398\n25%          -0.615480\n50%           0.000000\n75%           0.612676\nmax           0.785398\nName: Eastness, dtype: float64\nNew dem features are updated in /home/chetana/gridmet_test_run/dem_all.csv\n",
  "history_begin_time" : 1695532209664,
  "history_end_time" : 1695532226412,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "euc1cm2bdy4",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1695529187863,
  "history_end_time" : 1695529187863,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "fws306dt273",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1695528505186,
  "history_end_time" : 1695528505186,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "15yl89ebkhp",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1695515862427,
  "history_end_time" : 1695515862427,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "d2QcSiU4M4V5",
  "history_input" : "import numpy as np\nimport pandas as pd\nfrom osgeo import gdal\nimport warnings\nimport rasterio\nimport csv\nfrom rasterio.transform import Affine\nfrom scipy.ndimage import sobel, gaussian_filter\n\nmile_to_meters = 1609.34\n\n# Set the warning filter globally to ignore the FutureWarning\nwarnings.simplefilter(\"ignore\", FutureWarning)\n\ndef lat_lon_to_pixel(lat, lon, geotransform):\n    x = int((lon - geotransform[0]) / geotransform[1])\n    y = int((lat - geotransform[3]) / geotransform[5])\n    return x, y\n\n\ndef calculate_slope_aspect_for_single(elevation_data, pixel_size_x, pixel_size_y):\n    # Calculate slope using the Sobel operator\n    slope_x = np.gradient(elevation_data, pixel_size_x, axis=1)\n    slope_y = np.gradient(elevation_data, pixel_size_y, axis=0)\n    slope_rad = np.arctan(np.sqrt(slope_x ** 2 + slope_y ** 2))\n    slope_deg = np.degrees(slope_rad)\n\n    # Calculate aspect (direction of the steepest descent)\n    aspect_rad = np.arctan2(slope_y, -slope_x)\n    aspect_deg = (np.degrees(aspect_rad) + 360) % 360\n\n    return slope_deg, aspect_deg\n\n\ndef save_as_geotiff(data, output_file, src_file):\n    with rasterio.open(src_file) as src_dataset:\n        profile = src_dataset.profile\n        transform = src_dataset.transform\n\n        # Update the data type, count, and set the transform for the new dataset\n        profile.update(dtype=rasterio.float32, count=1, transform=transform)\n\n        # Create the new GeoTIFF file\n        with rasterio.open(output_file, 'w', **profile) as dst_dataset:\n            # Write the data to the new GeoTIFF\n            dst_dataset.write(data, 1)\n  \n\ndef calculate_slope_aspect(dem_file):\n    with rasterio.open(dem_file) as dataset:\n        # Read the DEM data as a numpy array\n        dem_data = dataset.read(1)\n        \n        # convert miles to meters\n        dem_data = dem_data * mile_to_meters\n\n        # Get the geotransform to convert pixel coordinates to geographic coordinates\n        transform = dataset.transform\n\n        # Calculate the slope and aspect using numpy\n        dx, dy = np.gradient(dem_data, transform[0], transform[4])\n        slope = np.arctan(np.sqrt(dx ** 2 + dy ** 2)) * (180.0 / np.pi)\n        aspect = np.arctan2(-dy, dx) * (180.0 / np.pi)\n\n        # Adjust aspect values to range from 0 to 360 degrees\n        aspect[aspect < 0] += 360\n        print(f\"slope shape: {slope.shape}\")\n        print(f\"aspect shape: {aspect.shape}\")\n        \n        \n    return slope, aspect\n  \ndef calculate_curvature(elevation_data, pixel_size_x, pixel_size_y):\n    # Calculate curvature using the Laplacian operator\n    curvature_x = np.gradient(np.gradient(elevation_data, pixel_size_x, axis=1), pixel_size_x, axis=1)\n    curvature_y = np.gradient(np.gradient(elevation_data, pixel_size_y, axis=0), pixel_size_y, axis=0)\n    curvature = curvature_x + curvature_y\n\n    return curvature\n\n  \ndef calculate_curvature(dem_file, sigma=1):\n    with rasterio.open(dem_file) as dataset:\n        # Read the DEM data as a numpy array\n        dem_data = dataset.read(1)\n        \n        # convert miles to meters\n        dem_data = dem_data*mile_to_meters\n\n        # Calculate the gradient using the Sobel filter\n        dx = sobel(dem_data, axis=1, mode='constant')\n        dy = sobel(dem_data, axis=0, mode='constant')\n\n        # Calculate the second derivatives using the Sobel filter\n        dxx = sobel(dx, axis=1, mode='constant')\n        dyy = sobel(dy, axis=0, mode='constant')\n\n        # Calculate the curvature using the second derivatives\n        curvature = dxx + dyy\n\n        # Smooth the curvature using Gaussian filtering (optional)\n        curvature = gaussian_filter(curvature, sigma)\n\n    return curvature\n  \ndef calculate_gradients(dem_file):\n    with rasterio.open(dem_file) as dataset:\n        # Read the DEM data as a numpy array\n        dem_data = dataset.read(1)\n\n        # Calculate the gradients along the North and East directions\n        dy, dx = np.gradient(dem_data, dataset.res[0], dataset.res[1])\n\n        # Calculate the Northness and Eastness\n        northness = np.arctan(dy / np.sqrt(dx**2 + dy**2))\n        eastness = np.arctan(dx / np.sqrt(dx**2 + dy**2))\n\n    return northness, eastness\n  \n  \ndef geotiff_to_csv(geotiff_file, csv_file, column_name):\n    # Open the GeoTIFF file\n    with rasterio.open(geotiff_file) as dataset:\n        # Get the pixel values as a 2D array\n        data = dataset.read(1)\n        \n        if column_name == \"Elevation\":\n          # convert miles to meters\n          data = data*mile_to_meters\n\n        # Get the geotransform to convert pixel coordinates to geographic coordinates\n        transform = dataset.transform\n\n        # Get the width and height of the GeoTIFF\n        height, width = data.shape\n\n        # Open the CSV file for writing\n        with open(csv_file, 'w', newline='') as csvfile:\n            csvwriter = csv.writer(csvfile)\n\n            # Write the CSV header\n            csvwriter.writerow(['Latitude', 'Longitude', 'x', 'y', column_name])\n\n            # Loop through each pixel and extract latitude, longitude, and image value\n            for y in range(height):\n                for x in range(width):\n                    # Get the pixel value\n                    image_value = data[y, x]\n\n                    # Convert pixel coordinates to geographic coordinates\n                    lon, lat = transform * (x, y)\n\n                    # Write the data to the CSV file\n                    csvwriter.writerow([lat, lon, x, y, image_value])\n\n  \ndef read_elevation_data(file_path, result_dem_csv_path, result_dem_feature_csv_path):\n    neighborhood_size=4\n    df = pd.read_csv(file_path)\n    \n    dataset = rasterio.open(geotiff_file)\n    data = dataset.read(1)\n\n    # Get the width and height of the GeoTIFF\n    height, width = data.shape\n    \n    # Create an empty DataFrame with column names\n    columns = ['lat', 'lon', 'elevation', 'slope', 'aspect', 'curvature', 'northness', 'eastness']\n    all_df = pd.DataFrame(columns=columns)\n    \n    all_df.to_csv(result_dem_feature_csv_path)\n    print(f\"DEM and other columns are saved to file {result_dem_feature_csv_path}\")\n    return all_df\n\n\n  \n# Usage example:\nresult_dem_csv_path = \"/home/chetana/gridmet_test_run/dem_template.csv\"\nresult_dem_feature_csv_path = \"/home/chetana/gridmet_test_run/dem_all.csv\"\n\n\ndem_file = \"/home/chetana/gridmet_test_run/dem_file.tif\"\nslope_file = '/home/chetana/gridmet_test_run/slope_file.tif'\naspect_file = '/home/chetana/gridmet_test_run/aspect_file.tif'\ncurvature_file = '/home/chetana/gridmet_test_run/curvature_file.tif'\nnorthness_file = '/home/chetana/gridmet_test_run/northness_file.tif'\neastness_file = '/home/chetana/gridmet_test_run/eastness_file.tif'\n\n\nslope, aspect = calculate_slope_aspect(dem_file)\ncurvature = calculate_curvature(dem_file)\nnorthness, eastness = calculate_gradients(dem_file)\n\n# Save the slope and aspect as new GeoTIFF files\nsave_as_geotiff(slope, slope_file, dem_file)\nsave_as_geotiff(aspect, aspect_file, dem_file)\nsave_as_geotiff(curvature, curvature_file, dem_file)\nsave_as_geotiff(northness, northness_file, dem_file)\nsave_as_geotiff(eastness, eastness_file, dem_file)\n\ngeotiff_to_csv(dem_file, dem_file+\".csv\", \"Elevation\")\ngeotiff_to_csv(slope_file, slope_file+\".csv\", \"Slope\")\ngeotiff_to_csv(aspect_file, aspect_file+\".csv\", \"Aspect\")\ngeotiff_to_csv(curvature_file, curvature_file+\".csv\", \"Curvature\")\ngeotiff_to_csv(northness_file, northness_file+\".csv\", \"Northness\")\ngeotiff_to_csv(eastness_file, eastness_file+\".csv\", \"Eastness\")\n\n# List of file paths for the CSV files\ncsv_files = [dem_file+\".csv\", slope_file+\".csv\", aspect_file+\".csv\", \n             curvature_file+\".csv\", northness_file+\".csv\", eastness_file+\".csv\"]\n\n# Initialize an empty list to store all dataframes\ndfs = []\n\n# Read each CSV file into separate dataframes\nfor file in csv_files:\n    df = pd.read_csv(file, encoding='utf-8')\n    dfs.append(df)\n\n# Merge the dataframes based on the latitude and longitude columns\nmerged_df = dfs[0]  # Start with the first dataframe\nfor i in range(1, len(dfs)):\n    merged_df = pd.merge(merged_df, dfs[i], on=['Latitude', 'Longitude', 'x', 'y'])\n\n# check the statistics of the columns\nfor column in merged_df.columns:\n    merged_df[column] = pd.to_numeric(merged_df[column], errors='coerce')\n    print(merged_df[column].describe())\n    \n# Save the merged dataframe to a new CSV file\nmerged_df.to_csv(result_dem_feature_csv_path, index=False)\nprint(f\"New dem features are updated in {result_dem_feature_csv_path}\")\n\n",
  "history_output" : "/home/chetana/gw-workspace/d2QcSiU4M4V5/western_us_dem.py:115: RuntimeWarning: invalid value encountered in divide\n  northness = np.arctan(dy / np.sqrt(dx**2 + dy**2))\n/home/chetana/gw-workspace/d2QcSiU4M4V5/western_us_dem.py:116: RuntimeWarning: invalid value encountered in divide\n  eastness = np.arctan(dx / np.sqrt(dx**2 + dy**2))\nslope shape: (666, 694)\naspect shape: (666, 694)\ncount    462204.000000\nmean         37.030000\nstd           6.921275\nmin          25.060000\n25%          31.036000\n50%          37.030000\n75%          43.024000\nmax          49.000000\nName: Latitude, dtype: float64\ncount    462204.00000\nmean       -112.52600\nstd           7.21226\nmin        -125.00000\n25%        -118.77200\n50%        -112.52600\n75%        -106.28000\nmax        -100.05200\nName: Longitude, dtype: float64\ncount    462204.000000\nmean        346.500000\nstd         200.340552\nmin           0.000000\n25%         173.000000\n50%         346.500000\n75%         520.000000\nmax         693.000000\nName: x, dtype: float64\ncount    462204.000000\nmean        332.500000\nstd         192.257631\nmin           0.000000\n25%         166.000000\n50%         332.500000\n75%         499.000000\nmax         665.000000\nName: y, dtype: float64\ncount    309830.000000\nmean       2561.017903\nstd         376.542591\nmin        1691.416300\n25%        2286.872000\n50%        2471.946300\n75%        2776.111600\nmax        4115.082000\nName: Elevation, dtype: float64\ncount    308251.000000\nmean         87.746072\nstd          13.882830\nmin           0.000000\n25%          89.963326\n50%          89.978550\n75%          89.986755\nmax          89.997940\nName: Slope, dtype: float64\ncount    308251.000000\nmean        170.498343\nstd         106.428242\nmin           0.000000\n25%          83.157250\n50%         176.729450\n75%         266.423700\nmax         359.907000\nName: Aspect, dtype: float64\ncount    295965.000000\nmean       -186.538634\nstd        3215.498709\nmin      -40479.438000\n25%       -1488.354700\n50%          29.660137\n75%        1457.598300\nmax       18450.988000\nName: Curvature, dtype: float64\ncount    300725.000000\nmean         -0.007756\nstd           0.590930\nmin          -0.785398\n25%          -0.620971\n50%           0.000000\n75%           0.615480\nmax           0.785398\nName: Northness, dtype: float64\ncount    300725.000000\nmean         -0.002146\nstd           0.577707\nmin          -0.785398\n25%          -0.615480\n50%           0.000000\n75%           0.612676\nmax           0.785398\nName: Eastness, dtype: float64\nNew dem features are updated in /home/chetana/gridmet_test_run/dem_all.csv\n",
  "history_begin_time" : 1695515746336,
  "history_end_time" : 1695515761006,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "9jcJbN2ASspU",
  "history_input" : "import numpy as np\nimport pandas as pd\nfrom osgeo import gdal\nimport warnings\nimport rasterio\nimport csv\nfrom rasterio.transform import Affine\nfrom scipy.ndimage import sobel, gaussian_filter\n\nmile_to_meters = 1609.34\n\n# Set the warning filter globally to ignore the FutureWarning\nwarnings.simplefilter(\"ignore\", FutureWarning)\n\ndef lat_lon_to_pixel(lat, lon, geotransform):\n    x = int((lon - geotransform[0]) / geotransform[1])\n    y = int((lat - geotransform[3]) / geotransform[5])\n    return x, y\n\n\ndef calculate_slope_aspect_for_single(elevation_data, pixel_size_x, pixel_size_y):\n    # Calculate slope using the Sobel operator\n    slope_x = np.gradient(elevation_data, pixel_size_x, axis=1)\n    slope_y = np.gradient(elevation_data, pixel_size_y, axis=0)\n    slope_rad = np.arctan(np.sqrt(slope_x ** 2 + slope_y ** 2))\n    slope_deg = np.degrees(slope_rad)\n\n    # Calculate aspect (direction of the steepest descent)\n    aspect_rad = np.arctan2(slope_y, -slope_x)\n    aspect_deg = (np.degrees(aspect_rad) + 360) % 360\n\n    return slope_deg, aspect_deg\n\n\ndef save_as_geotiff(data, output_file, src_file):\n    with rasterio.open(src_file) as src_dataset:\n        profile = src_dataset.profile\n        transform = src_dataset.transform\n\n        # Update the data type, count, and set the transform for the new dataset\n        profile.update(dtype=rasterio.float32, count=1, transform=transform)\n\n        # Create the new GeoTIFF file\n        with rasterio.open(output_file, 'w', **profile) as dst_dataset:\n            # Write the data to the new GeoTIFF\n            dst_dataset.write(data, 1)\n  \n\ndef calculate_slope_aspect(dem_file):\n    with rasterio.open(dem_file) as dataset:\n        # Read the DEM data as a numpy array\n        dem_data = dataset.read(1)\n        \n        # convert miles to meters\n        dem_data = dem_data * mile_to_meters\n\n        # Get the geotransform to convert pixel coordinates to geographic coordinates\n        transform = dataset.transform\n\n        # Calculate the slope and aspect using numpy\n        dx, dy = np.gradient(dem_data, transform[0], transform[4])\n        slope = np.arctan(np.sqrt(dx ** 2 + dy ** 2)) * (180.0 / np.pi)\n        aspect = np.arctan2(-dy, dx) * (180.0 / np.pi)\n\n        # Adjust aspect values to range from 0 to 360 degrees\n        aspect[aspect < 0] += 360\n        print(f\"slope shape: {slope.shape}\")\n        print(f\"aspect shape: {aspect.shape}\")\n        \n        \n    return slope, aspect\n  \ndef calculate_curvature(elevation_data, pixel_size_x, pixel_size_y):\n    # Calculate curvature using the Laplacian operator\n    curvature_x = np.gradient(np.gradient(elevation_data, pixel_size_x, axis=1), pixel_size_x, axis=1)\n    curvature_y = np.gradient(np.gradient(elevation_data, pixel_size_y, axis=0), pixel_size_y, axis=0)\n    curvature = curvature_x + curvature_y\n\n    return curvature\n\n  \ndef calculate_curvature(dem_file, sigma=1):\n    with rasterio.open(dem_file) as dataset:\n        # Read the DEM data as a numpy array\n        dem_data = dataset.read(1)\n        \n        # convert miles to meters\n        dem_data = dem_data*mile_to_meters\n\n        # Calculate the gradient using the Sobel filter\n        dx = sobel(dem_data, axis=1, mode='constant')\n        dy = sobel(dem_data, axis=0, mode='constant')\n\n        # Calculate the second derivatives using the Sobel filter\n        dxx = sobel(dx, axis=1, mode='constant')\n        dyy = sobel(dy, axis=0, mode='constant')\n\n        # Calculate the curvature using the second derivatives\n        curvature = dxx + dyy\n\n        # Smooth the curvature using Gaussian filtering (optional)\n        curvature = gaussian_filter(curvature, sigma)\n\n    return curvature\n  \ndef calculate_gradients(dem_file):\n    with rasterio.open(dem_file) as dataset:\n        # Read the DEM data as a numpy array\n        dem_data = dataset.read(1)\n\n        # Calculate the gradients along the North and East directions\n        dy, dx = np.gradient(dem_data, dataset.res[0], dataset.res[1])\n\n        # Calculate the Northness and Eastness\n        northness = np.arctan(dy / np.sqrt(dx**2 + dy**2))\n        eastness = np.arctan(dx / np.sqrt(dx**2 + dy**2))\n\n    return northness, eastness\n  \n  \ndef geotiff_to_csv(geotiff_file, csv_file, column_name):\n    # Open the GeoTIFF file\n    with rasterio.open(geotiff_file) as dataset:\n        # Get the pixel values as a 2D array\n        data = dataset.read(1)\n        \n        if column_name == \"Elevation\":\n          # convert miles to meters\n          data = data*mile_to_meters\n\n        # Get the geotransform to convert pixel coordinates to geographic coordinates\n        transform = dataset.transform\n\n        # Get the width and height of the GeoTIFF\n        height, width = data.shape\n\n        # Open the CSV file for writing\n        with open(csv_file, 'w', newline='') as csvfile:\n            csvwriter = csv.writer(csvfile)\n\n            # Write the CSV header\n            csvwriter.writerow(['Latitude', 'Longitude', 'x', 'y', column_name])\n\n            # Loop through each pixel and extract latitude, longitude, and image value\n            for y in range(height):\n                for x in range(width):\n                    # Get the pixel value\n                    image_value = data[y, x]\n\n                    # Convert pixel coordinates to geographic coordinates\n                    lon, lat = transform * (x, y)\n\n                    # Write the data to the CSV file\n                    csvwriter.writerow([lat, lon, x, y, image_value])\n\n  \ndef read_elevation_data(file_path, result_dem_csv_path, result_dem_feature_csv_path):\n    neighborhood_size=4\n    df = pd.read_csv(file_path)\n    \n    dataset = rasterio.open(geotiff_file)\n    data = dataset.read(1)\n\n    # Get the width and height of the GeoTIFF\n    height, width = data.shape\n    \n    # Create an empty DataFrame with column names\n    columns = ['lat', 'lon', 'elevation', 'slope', 'aspect', 'curvature', 'northness', 'eastness']\n    all_df = pd.DataFrame(columns=columns)\n    \n    all_df.to_csv(result_dem_feature_csv_path)\n    print(f\"DEM and other columns are saved to file {result_dem_feature_csv_path}\")\n    return all_df\n\n\n  \n# Usage example:\nresult_dem_csv_path = \"/home/chetana/gridmet_test_run/dem_template.csv\"\nresult_dem_feature_csv_path = \"/home/chetana/gridmet_test_run/dem_all.csv\"\n\n\ndem_file = \"/home/chetana/gridmet_test_run/dem_file.tif\"\nslope_file = '/home/chetana/gridmet_test_run/slope_file.tif'\naspect_file = '/home/chetana/gridmet_test_run/aspect_file.tif'\ncurvature_file = '/home/chetana/gridmet_test_run/curvature_file.tif'\nnorthness_file = '/home/chetana/gridmet_test_run/northness_file.tif'\neastness_file = '/home/chetana/gridmet_test_run/eastness_file.tif'\n\n\nslope, aspect = calculate_slope_aspect(dem_file)\ncurvature = calculate_curvature(dem_file)\nnorthness, eastness = calculate_gradients(dem_file)\n\n# Save the slope and aspect as new GeoTIFF files\nsave_as_geotiff(slope, slope_file, dem_file)\nsave_as_geotiff(aspect, aspect_file, dem_file)\nsave_as_geotiff(curvature, curvature_file, dem_file)\nsave_as_geotiff(northness, northness_file, dem_file)\nsave_as_geotiff(eastness, eastness_file, dem_file)\n\ngeotiff_to_csv(dem_file, dem_file+\".csv\", \"Elevation\")\ngeotiff_to_csv(slope_file, slope_file+\".csv\", \"Slope\")\ngeotiff_to_csv(aspect_file, aspect_file+\".csv\", \"Aspect\")\ngeotiff_to_csv(curvature_file, curvature_file+\".csv\", \"Curvature\")\ngeotiff_to_csv(northness_file, northness_file+\".csv\", \"Northness\")\ngeotiff_to_csv(eastness_file, eastness_file+\".csv\", \"Eastness\")\n\n# List of file paths for the CSV files\ncsv_files = [dem_file+\".csv\", slope_file+\".csv\", aspect_file+\".csv\", \n             curvature_file+\".csv\", northness_file+\".csv\", eastness_file+\".csv\"]\n\n# Initialize an empty list to store all dataframes\ndfs = []\n\n# Read each CSV file into separate dataframes\nfor file in csv_files:\n    df = pd.read_csv(file, encoding='utf-8')\n    dfs.append(df)\n\n# Merge the dataframes based on the latitude and longitude columns\nmerged_df = dfs[0]  # Start with the first dataframe\nfor i in range(1, len(dfs)):\n    merged_df = pd.merge(merged_df, dfs[i], on=['Latitude', 'Longitude', 'x', 'y'])\n\n# Save the merged dataframe to a new CSV file\nmerged_df.to_csv(result_dem_feature_csv_path, index=False)\nprint(f\"New dem features are updated in {result_dem_feature_csv_path}\")\n",
  "history_output" : "/home/chetana/gw-workspace/9jcJbN2ASspU/western_us_dem.py:115: RuntimeWarning: invalid value encountered in divide\n  northness = np.arctan(dy / np.sqrt(dx**2 + dy**2))\n/home/chetana/gw-workspace/9jcJbN2ASspU/western_us_dem.py:116: RuntimeWarning: invalid value encountered in divide\n  eastness = np.arctan(dx / np.sqrt(dx**2 + dy**2))\nslope shape: (666, 694)\naspect shape: (666, 694)\nNew dem features are updated in /home/chetana/gridmet_test_run/dem_all.csv\n",
  "history_begin_time" : 1695515589561,
  "history_end_time" : 1695515603256,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "MeyMuROD1yRh",
  "history_input" : "import numpy as np\nimport pandas as pd\nfrom osgeo import gdal\nimport warnings\nimport rasterio\nimport csv\nfrom rasterio.transform import Affine\nfrom scipy.ndimage import sobel, gaussian_filter\n\nmile_to_meters = 1609.34\n\n# Set the warning filter globally to ignore the FutureWarning\nwarnings.simplefilter(\"ignore\", FutureWarning)\n\ndef lat_lon_to_pixel(lat, lon, geotransform):\n    x = int((lon - geotransform[0]) / geotransform[1])\n    y = int((lat - geotransform[3]) / geotransform[5])\n    return x, y\n\n\ndef calculate_slope_aspect_for_single(elevation_data, pixel_size_x, pixel_size_y):\n    # Calculate slope using the Sobel operator\n    slope_x = np.gradient(elevation_data, pixel_size_x, axis=1)\n    slope_y = np.gradient(elevation_data, pixel_size_y, axis=0)\n    slope_rad = np.arctan(np.sqrt(slope_x ** 2 + slope_y ** 2))\n    slope_deg = np.degrees(slope_rad)\n\n    # Calculate aspect (direction of the steepest descent)\n    aspect_rad = np.arctan2(slope_y, -slope_x)\n    aspect_deg = (np.degrees(aspect_rad) + 360) % 360\n\n    return slope_deg, aspect_deg\n\n\ndef save_as_geotiff(data, output_file, src_file):\n    with rasterio.open(src_file) as src_dataset:\n        profile = src_dataset.profile\n        transform = src_dataset.transform\n\n        # Update the data type, count, and set the transform for the new dataset\n        profile.update(dtype=rasterio.float32, count=1, transform=transform)\n\n        # Create the new GeoTIFF file\n        with rasterio.open(output_file, 'w', **profile) as dst_dataset:\n            # Write the data to the new GeoTIFF\n            dst_dataset.write(data, 1)\n  \n\ndef calculate_slope_aspect(dem_file):\n    with rasterio.open(dem_file) as dataset:\n        # Read the DEM data as a numpy array\n        dem_data = dataset.read(1)\n        \n        # convert miles to meters\n        dem_data = dem_data * mile_to_meters\n\n        # Get the geotransform to convert pixel coordinates to geographic coordinates\n        transform = dataset.transform\n\n        # Calculate the slope and aspect using numpy\n        dx, dy = np.gradient(dem_data, transform[0], transform[4])\n        slope = np.arctan(np.sqrt(dx ** 2 + dy ** 2)) * (180.0 / np.pi)\n        aspect = np.arctan2(-dy, dx) * (180.0 / np.pi)\n\n        # Adjust aspect values to range from 0 to 360 degrees\n        aspect[aspect < 0] += 360\n        print(f\"slope shape: {slope.shape}\")\n        print(f\"aspect shape: {aspect.shape}\")\n        \n        \n    return slope, aspect\n  \ndef calculate_curvature(elevation_data, pixel_size_x, pixel_size_y):\n    # Calculate curvature using the Laplacian operator\n    curvature_x = np.gradient(np.gradient(elevation_data, pixel_size_x, axis=1), pixel_size_x, axis=1)\n    curvature_y = np.gradient(np.gradient(elevation_data, pixel_size_y, axis=0), pixel_size_y, axis=0)\n    curvature = curvature_x + curvature_y\n\n    return curvature\n\n  \ndef calculate_curvature(dem_file, sigma=1):\n    with rasterio.open(dem_file) as dataset:\n        # Read the DEM data as a numpy array\n        dem_data = dataset.read(1)\n        \n        # convert miles to meters\n        dem_data = dem_data*mile_to_meters\n\n        # Calculate the gradient using the Sobel filter\n        dx = sobel(dem_data, axis=1, mode='constant')\n        dy = sobel(dem_data, axis=0, mode='constant')\n\n        # Calculate the second derivatives using the Sobel filter\n        dxx = sobel(dx, axis=1, mode='constant')\n        dyy = sobel(dy, axis=0, mode='constant')\n\n        # Calculate the curvature using the second derivatives\n        curvature = dxx + dyy\n\n        # Smooth the curvature using Gaussian filtering (optional)\n        curvature = gaussian_filter(curvature, sigma)\n\n    return curvature\n  \ndef calculate_gradients(dem_file):\n    with rasterio.open(dem_file) as dataset:\n        # Read the DEM data as a numpy array\n        dem_data = dataset.read(1)\n\n        # Calculate the gradients along the North and East directions\n        dy, dx = np.gradient(dem_data, dataset.res[0], dataset.res[1])\n\n        # Calculate the Northness and Eastness\n        northness = np.arctan(dy / np.sqrt(dx**2 + dy**2))\n        eastness = np.arctan(dx / np.sqrt(dx**2 + dy**2))\n\n    return northness, eastness\n  \n  \ndef geotiff_to_csv(geotiff_file, csv_file, column_name):\n    # Open the GeoTIFF file\n    with rasterio.open(geotiff_file) as dataset:\n        # Get the pixel values as a 2D array\n        data = dataset.read(1)\n        \n        if column_name == \"Elevation\":\n          # convert miles to meters\n          data = data*mile_to_meters\n\n        # Get the geotransform to convert pixel coordinates to geographic coordinates\n        transform = dataset.transform\n\n        # Get the width and height of the GeoTIFF\n        height, width = data.shape\n\n        # Open the CSV file for writing\n        with open(csv_file, 'w', newline='') as csvfile:\n            csvwriter = csv.writer(csvfile)\n\n            # Write the CSV header\n            csvwriter.writerow(['Latitude', 'Longitude', 'x', 'y', column_name])\n\n            # Loop through each pixel and extract latitude, longitude, and image value\n            for y in range(height):\n                for x in range(width):\n                    # Get the pixel value\n                    image_value = data[y, x]\n\n                    # Convert pixel coordinates to geographic coordinates\n                    lon, lat = transform * (x, y)\n\n                    # Write the data to the CSV file\n                    csvwriter.writerow([lat, lon, x, y, image_value])\n\n  \ndef read_elevation_data(file_path, result_dem_csv_path, result_dem_feature_csv_path):\n    neighborhood_size=4\n    df = pd.read_csv(file_path)\n    \n    dataset = rasterio.open(geotiff_file)\n    data = dataset.read(1)\n\n    # Get the width and height of the GeoTIFF\n    height, width = data.shape\n    \n    # Create an empty DataFrame with column names\n    columns = ['lat', 'lon', 'elevation', 'slope', 'aspect', 'curvature', 'northness', 'eastness']\n    all_df = pd.DataFrame(columns=columns)\n    \n    all_df.to_csv(result_dem_feature_csv_path)\n    print(f\"DEM and other columns are saved to file {result_dem_feature_csv_path}\")\n    return all_df\n\n\n  \n# Usage example:\nresult_dem_csv_path = \"/home/chetana/gridmet_test_run/dem_template.csv\"\nresult_dem_feature_csv_path = \"/home/chetana/gridmet_test_run/dem_all.csv\"\n\n\ndem_file = \"/home/chetana/gridmet_test_run/dem_file.tif\"\nslope_file = '/home/chetana/gridmet_test_run/slope_file.tif'\naspect_file = '/home/chetana/gridmet_test_run/aspect_file.tif'\ncurvature_file = '/home/chetana/gridmet_test_run/curvature_file.tif'\nnorthness_file = '/home/chetana/gridmet_test_run/northness_file.tif'\neastness_file = '/home/chetana/gridmet_test_run/eastness_file.tif'\n\n\nslope, aspect = calculate_slope_aspect(dem_file)\ncurvature = calculate_curvature(dem_file)\nnorthness, eastness = calculate_gradients(dem_file)\n\n# Save the slope and aspect as new GeoTIFF files\nsave_as_geotiff(slope, slope_file, dem_file)\nsave_as_geotiff(aspect, aspect_file, dem_file)\nsave_as_geotiff(curvature, curvature_file, dem_file)\nsave_as_geotiff(northness, northness_file, dem_file)\nsave_as_geotiff(eastness, eastness_file, dem_file)\n\ngeotiff_to_csv(dem_file, dem_file+\".csv\", \"Elevation\")\ngeotiff_to_csv(slope_file, slope_file+\".csv\", \"Slope\")\ngeotiff_to_csv(aspect_file, aspect_file+\".csv\", \"Aspect\")\ngeotiff_to_csv(curvature_file, curvature_file+\".csv\", \"Curvature\")\ngeotiff_to_csv(northness_file, northness_file+\".csv\", \"Northness\")\ngeotiff_to_csv(eastness_file, eastness_file+\".csv\", \"Eastness\")\n\n# List of file paths for the CSV files\ncsv_files = [dem_file+\".csv\", slope_file+\".csv\", aspect_file+\".csv\", \n             curvature_file+\".csv\", northness_file+\".csv\", eastness_file+\".csv\"]\n\n# Initialize an empty list to store all dataframes\ndfs = []\n\n# Read each CSV file into separate dataframes\nfor file in csv_files:\n    df = pd.read_csv(file, encoding='utf-8')\n    dfs.append(df)\n\n# Merge the dataframes based on the latitude and longitude columns\nmerged_df = dfs[0]  # Start with the first dataframe\nfor i in range(1, len(dfs)):\n    merged_df = pd.merge(merged_df, dfs[i], on=['Latitude', 'Longitude', 'x', 'y'])\n\n# Save the merged dataframe to a new CSV file\nmerged_df.to_csv(result_dem_feature_csv_path, index=False)\n",
  "history_output" : "/home/chetana/gw-workspace/MeyMuROD1yRh/western_us_dem.py:115: RuntimeWarning: invalid value encountered in divide\n  northness = np.arctan(dy / np.sqrt(dx**2 + dy**2))\n/home/chetana/gw-workspace/MeyMuROD1yRh/western_us_dem.py:116: RuntimeWarning: invalid value encountered in divide\n  eastness = np.arctan(dx / np.sqrt(dx**2 + dy**2))\nslope shape: (666, 694)\naspect shape: (666, 694)\n",
  "history_begin_time" : 1695515543037,
  "history_end_time" : 1695515558211,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "JINOaZmsp5W7",
  "history_input" : "import numpy as np\nimport pandas as pd\nfrom osgeo import gdal\nimport warnings\nimport rasterio\nimport csv\nfrom rasterio.transform import Affine\nfrom scipy.ndimage import sobel, gaussian_filter\n\nmile_to_meters = 1609.34\n\n# Set the warning filter globally to ignore the FutureWarning\nwarnings.simplefilter(\"ignore\", FutureWarning)\n\ndef lat_lon_to_pixel(lat, lon, geotransform):\n    x = int((lon - geotransform[0]) / geotransform[1])\n    y = int((lat - geotransform[3]) / geotransform[5])\n    return x, y\n\n\ndef calculate_slope_aspect_for_single(elevation_data, pixel_size_x, pixel_size_y):\n    # Calculate slope using the Sobel operator\n    slope_x = np.gradient(elevation_data, pixel_size_x, axis=1)\n    slope_y = np.gradient(elevation_data, pixel_size_y, axis=0)\n    slope_rad = np.arctan(np.sqrt(slope_x ** 2 + slope_y ** 2))\n    slope_deg = np.degrees(slope_rad)\n\n    # Calculate aspect (direction of the steepest descent)\n    aspect_rad = np.arctan2(slope_y, -slope_x)\n    aspect_deg = (np.degrees(aspect_rad) + 360) % 360\n\n    return slope_deg, aspect_deg\n\n\ndef save_as_geotiff(data, output_file, src_file):\n    with rasterio.open(src_file) as src_dataset:\n        profile = src_dataset.profile\n        transform = src_dataset.transform\n\n        # Update the data type, count, and set the transform for the new dataset\n        profile.update(dtype=rasterio.float32, count=1, transform=transform)\n\n        # Create the new GeoTIFF file\n        with rasterio.open(output_file, 'w', **profile) as dst_dataset:\n            # Write the data to the new GeoTIFF\n            dst_dataset.write(data, 1)\n  \n\ndef calculate_slope_aspect(dem_file):\n    with rasterio.open(dem_file) as dataset:\n        # Read the DEM data as a numpy array\n        dem_data = dataset.read(1)\n        \n        # convert miles to meters\n        print(dem_data)\n        dem_data = dem_data * mile_to_meters\n\n        # Get the geotransform to convert pixel coordinates to geographic coordinates\n        transform = dataset.transform\n\n        # Calculate the slope and aspect using numpy\n        dx, dy = np.gradient(dem_data, transform[0], transform[4])\n        slope = np.arctan(np.sqrt(dx ** 2 + dy ** 2)) * (180.0 / np.pi)\n        aspect = np.arctan2(-dy, dx) * (180.0 / np.pi)\n\n        # Adjust aspect values to range from 0 to 360 degrees\n        aspect[aspect < 0] += 360\n        print(f\"slope shape: {slope.shape}\")\n        print(f\"aspect shape: {aspect.shape}\")\n        \n        \n    return slope, aspect\n  \ndef calculate_curvature(elevation_data, pixel_size_x, pixel_size_y):\n    # Calculate curvature using the Laplacian operator\n    curvature_x = np.gradient(np.gradient(elevation_data, pixel_size_x, axis=1), pixel_size_x, axis=1)\n    curvature_y = np.gradient(np.gradient(elevation_data, pixel_size_y, axis=0), pixel_size_y, axis=0)\n    curvature = curvature_x + curvature_y\n\n    return curvature\n\n  \ndef calculate_curvature(dem_file, sigma=1):\n    with rasterio.open(dem_file) as dataset:\n        # Read the DEM data as a numpy array\n        dem_data = dataset.read(1)\n        \n        # convert miles to meters\n        dem_data = dem_data*mile_to_meters\n\n        # Calculate the gradient using the Sobel filter\n        dx = sobel(dem_data, axis=1, mode='constant')\n        dy = sobel(dem_data, axis=0, mode='constant')\n\n        # Calculate the second derivatives using the Sobel filter\n        dxx = sobel(dx, axis=1, mode='constant')\n        dyy = sobel(dy, axis=0, mode='constant')\n\n        # Calculate the curvature using the second derivatives\n        curvature = dxx + dyy\n\n        # Smooth the curvature using Gaussian filtering (optional)\n        curvature = gaussian_filter(curvature, sigma)\n\n    return curvature\n  \ndef calculate_gradients(dem_file):\n    with rasterio.open(dem_file) as dataset:\n        # Read the DEM data as a numpy array\n        dem_data = dataset.read(1)\n\n        # Calculate the gradients along the North and East directions\n        dy, dx = np.gradient(dem_data, dataset.res[0], dataset.res[1])\n\n        # Calculate the Northness and Eastness\n        northness = np.arctan(dy / np.sqrt(dx**2 + dy**2))\n        eastness = np.arctan(dx / np.sqrt(dx**2 + dy**2))\n\n    return northness, eastness\n  \n  \ndef geotiff_to_csv(geotiff_file, csv_file, column_name):\n    # Open the GeoTIFF file\n    with rasterio.open(geotiff_file) as dataset:\n        # Get the pixel values as a 2D array\n        data = dataset.read(1)\n        \n        if column_name == \"Elevation\":\n          # convert miles to meters\n          dem_data = dem_data*mile_to_meters\n\n        # Get the geotransform to convert pixel coordinates to geographic coordinates\n        transform = dataset.transform\n\n        # Get the width and height of the GeoTIFF\n        height, width = data.shape\n\n        # Open the CSV file for writing\n        with open(csv_file, 'w', newline='') as csvfile:\n            csvwriter = csv.writer(csvfile)\n\n            # Write the CSV header\n            csvwriter.writerow(['Latitude', 'Longitude', 'x', 'y', column_name])\n\n            # Loop through each pixel and extract latitude, longitude, and image value\n            for y in range(height):\n                for x in range(width):\n                    # Get the pixel value\n                    image_value = data[y, x]\n\n                    # Convert pixel coordinates to geographic coordinates\n                    lon, lat = transform * (x, y)\n\n                    # Write the data to the CSV file\n                    csvwriter.writerow([lat, lon, x, y, image_value])\n\n  \ndef read_elevation_data(file_path, result_dem_csv_path, result_dem_feature_csv_path):\n    neighborhood_size=4\n    df = pd.read_csv(file_path)\n    \n    dataset = rasterio.open(geotiff_file)\n    data = dataset.read(1)\n\n    # Get the width and height of the GeoTIFF\n    height, width = data.shape\n    \n    # Create an empty DataFrame with column names\n    columns = ['lat', 'lon', 'elevation', 'slope', 'aspect', 'curvature', 'northness', 'eastness']\n    all_df = pd.DataFrame(columns=columns)\n    \n    all_df.to_csv(result_dem_feature_csv_path)\n    print(f\"DEM and other columns are saved to file {result_dem_feature_csv_path}\")\n    return all_df\n\n\n  \n# Usage example:\nresult_dem_csv_path = \"/home/chetana/gridmet_test_run/dem_template.csv\"\nresult_dem_feature_csv_path = \"/home/chetana/gridmet_test_run/dem_all.csv\"\n\n\ndem_file = \"/home/chetana/gridmet_test_run/dem_file.tif\"\nslope_file = '/home/chetana/gridmet_test_run/slope_file.tif'\naspect_file = '/home/chetana/gridmet_test_run/aspect_file.tif'\ncurvature_file = '/home/chetana/gridmet_test_run/curvature_file.tif'\nnorthness_file = '/home/chetana/gridmet_test_run/northness_file.tif'\neastness_file = '/home/chetana/gridmet_test_run/eastness_file.tif'\n\n\nslope, aspect = calculate_slope_aspect(dem_file)\ncurvature = calculate_curvature(dem_file)\nnorthness, eastness = calculate_gradients(dem_file)\n\n# Save the slope and aspect as new GeoTIFF files\nsave_as_geotiff(slope, slope_file, dem_file)\nsave_as_geotiff(aspect, aspect_file, dem_file)\nsave_as_geotiff(curvature, curvature_file, dem_file)\nsave_as_geotiff(northness, northness_file, dem_file)\nsave_as_geotiff(eastness, eastness_file, dem_file)\n\ngeotiff_to_csv(dem_file, dem_file+\".csv\", \"Elevation\")\ngeotiff_to_csv(slope_file, slope_file+\".csv\", \"Slope\")\ngeotiff_to_csv(aspect_file, aspect_file+\".csv\", \"Aspect\")\ngeotiff_to_csv(curvature_file, curvature_file+\".csv\", \"Curvature\")\ngeotiff_to_csv(northness_file, northness_file+\".csv\", \"Northness\")\ngeotiff_to_csv(eastness_file, eastness_file+\".csv\", \"Eastness\")\n\n# List of file paths for the CSV files\ncsv_files = [dem_file+\".csv\", slope_file+\".csv\", aspect_file+\".csv\", \n             curvature_file+\".csv\", northness_file+\".csv\", eastness_file+\".csv\"]\n\n# Initialize an empty list to store all dataframes\ndfs = []\n\n# Read each CSV file into separate dataframes\nfor file in csv_files:\n    df = pd.read_csv(file, encoding='utf-8')\n    dfs.append(df)\n\n# Merge the dataframes based on the latitude and longitude columns\nmerged_df = dfs[0]  # Start with the first dataframe\nfor i in range(1, len(dfs)):\n    merged_df = pd.merge(merged_df, dfs[i], on=['Latitude', 'Longitude', 'x', 'y'])\n\n# Save the merged dataframe to a new CSV file\nmerged_df.to_csv(result_dem_feature_csv_path, index=False)\n",
  "history_output" : "/home/chetana/gw-workspace/JINOaZmsp5W7/western_us_dem.py:116: RuntimeWarning: invalid value encountered in divide\n  northness = np.arctan(dy / np.sqrt(dx**2 + dy**2))\n/home/chetana/gw-workspace/JINOaZmsp5W7/western_us_dem.py:117: RuntimeWarning: invalid value encountered in divide\n  eastness = np.arctan(dx / np.sqrt(dx**2 + dy**2))\n[[  nan   nan   nan ... 2.373 2.366 2.366]\n [  nan   nan   nan ... 2.309 2.344 2.344]\n [  nan   nan   nan ... 2.288 2.309 2.309]\n ...\n [  nan   nan   nan ...   nan   nan   nan]\n [  nan   nan   nan ...   nan   nan   nan]\n [  nan   nan   nan ...   nan   nan   nan]]\nslope shape: (666, 694)\naspect shape: (666, 694)\nTraceback (most recent call last):\n  File \"/home/chetana/gw-workspace/JINOaZmsp5W7/western_us_dem.py\", line 202, in <module>\n    geotiff_to_csv(dem_file, dem_file+\".csv\", \"Elevation\")\n  File \"/home/chetana/gw-workspace/JINOaZmsp5W7/western_us_dem.py\", line 130, in geotiff_to_csv\n    dem_data = dem_data*mile_to_meters\nUnboundLocalError: local variable 'dem_data' referenced before assignment\n",
  "history_begin_time" : 1695515508761,
  "history_end_time" : 1695515510241,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : null,
  "indicator" : "Failed"
},{
  "history_id" : "Y4T7Z9RIdrC0",
  "history_input" : "import numpy as np\nimport pandas as pd\nfrom osgeo import gdal\nimport warnings\nimport rasterio\nimport csv\nfrom rasterio.transform import Affine\nfrom scipy.ndimage import sobel, gaussian_filter\n\nmile_to_meters = 1,609.34\n\n# Set the warning filter globally to ignore the FutureWarning\nwarnings.simplefilter(\"ignore\", FutureWarning)\n\ndef lat_lon_to_pixel(lat, lon, geotransform):\n    x = int((lon - geotransform[0]) / geotransform[1])\n    y = int((lat - geotransform[3]) / geotransform[5])\n    return x, y\n\n\ndef calculate_slope_aspect_for_single(elevation_data, pixel_size_x, pixel_size_y):\n    # Calculate slope using the Sobel operator\n    slope_x = np.gradient(elevation_data, pixel_size_x, axis=1)\n    slope_y = np.gradient(elevation_data, pixel_size_y, axis=0)\n    slope_rad = np.arctan(np.sqrt(slope_x ** 2 + slope_y ** 2))\n    slope_deg = np.degrees(slope_rad)\n\n    # Calculate aspect (direction of the steepest descent)\n    aspect_rad = np.arctan2(slope_y, -slope_x)\n    aspect_deg = (np.degrees(aspect_rad) + 360) % 360\n\n    return slope_deg, aspect_deg\n\n\ndef save_as_geotiff(data, output_file, src_file):\n    with rasterio.open(src_file) as src_dataset:\n        profile = src_dataset.profile\n        transform = src_dataset.transform\n\n        # Update the data type, count, and set the transform for the new dataset\n        profile.update(dtype=rasterio.float32, count=1, transform=transform)\n\n        # Create the new GeoTIFF file\n        with rasterio.open(output_file, 'w', **profile) as dst_dataset:\n            # Write the data to the new GeoTIFF\n            dst_dataset.write(data, 1)\n  \n\ndef calculate_slope_aspect(dem_file):\n    with rasterio.open(dem_file) as dataset:\n        # Read the DEM data as a numpy array\n        dem_data = dataset.read(1)\n        \n        # convert miles to meters\n        print(dem_data)\n        dem_data = dem_data * mile_to_meters\n\n        # Get the geotransform to convert pixel coordinates to geographic coordinates\n        transform = dataset.transform\n\n        # Calculate the slope and aspect using numpy\n        dx, dy = np.gradient(dem_data, transform[0], transform[4])\n        slope = np.arctan(np.sqrt(dx ** 2 + dy ** 2)) * (180.0 / np.pi)\n        aspect = np.arctan2(-dy, dx) * (180.0 / np.pi)\n\n        # Adjust aspect values to range from 0 to 360 degrees\n        aspect[aspect < 0] += 360\n        print(f\"slope shape: {slope.shape}\")\n        print(f\"aspect shape: {aspect.shape}\")\n        \n        \n    return slope, aspect\n  \ndef calculate_curvature(elevation_data, pixel_size_x, pixel_size_y):\n    # Calculate curvature using the Laplacian operator\n    curvature_x = np.gradient(np.gradient(elevation_data, pixel_size_x, axis=1), pixel_size_x, axis=1)\n    curvature_y = np.gradient(np.gradient(elevation_data, pixel_size_y, axis=0), pixel_size_y, axis=0)\n    curvature = curvature_x + curvature_y\n\n    return curvature\n\n  \ndef calculate_curvature(dem_file, sigma=1):\n    with rasterio.open(dem_file) as dataset:\n        # Read the DEM data as a numpy array\n        dem_data = dataset.read(1)\n        \n        # convert miles to meters\n        dem_data = dem_data*mile_to_meters\n\n        # Calculate the gradient using the Sobel filter\n        dx = sobel(dem_data, axis=1, mode='constant')\n        dy = sobel(dem_data, axis=0, mode='constant')\n\n        # Calculate the second derivatives using the Sobel filter\n        dxx = sobel(dx, axis=1, mode='constant')\n        dyy = sobel(dy, axis=0, mode='constant')\n\n        # Calculate the curvature using the second derivatives\n        curvature = dxx + dyy\n\n        # Smooth the curvature using Gaussian filtering (optional)\n        curvature = gaussian_filter(curvature, sigma)\n\n    return curvature\n  \ndef calculate_gradients(dem_file):\n    with rasterio.open(dem_file) as dataset:\n        # Read the DEM data as a numpy array\n        dem_data = dataset.read(1)\n\n        # Calculate the gradients along the North and East directions\n        dy, dx = np.gradient(dem_data, dataset.res[0], dataset.res[1])\n\n        # Calculate the Northness and Eastness\n        northness = np.arctan(dy / np.sqrt(dx**2 + dy**2))\n        eastness = np.arctan(dx / np.sqrt(dx**2 + dy**2))\n\n    return northness, eastness\n  \n  \ndef geotiff_to_csv(geotiff_file, csv_file, column_name):\n    # Open the GeoTIFF file\n    with rasterio.open(geotiff_file) as dataset:\n        # Get the pixel values as a 2D array\n        data = dataset.read(1)\n        \n        if column_name == \"Elevation\":\n          # convert miles to meters\n          dem_data = dem_data*mile_to_meters\n\n        # Get the geotransform to convert pixel coordinates to geographic coordinates\n        transform = dataset.transform\n\n        # Get the width and height of the GeoTIFF\n        height, width = data.shape\n\n        # Open the CSV file for writing\n        with open(csv_file, 'w', newline='') as csvfile:\n            csvwriter = csv.writer(csvfile)\n\n            # Write the CSV header\n            csvwriter.writerow(['Latitude', 'Longitude', 'x', 'y', column_name])\n\n            # Loop through each pixel and extract latitude, longitude, and image value\n            for y in range(height):\n                for x in range(width):\n                    # Get the pixel value\n                    image_value = data[y, x]\n\n                    # Convert pixel coordinates to geographic coordinates\n                    lon, lat = transform * (x, y)\n\n                    # Write the data to the CSV file\n                    csvwriter.writerow([lat, lon, x, y, image_value])\n\n  \ndef read_elevation_data(file_path, result_dem_csv_path, result_dem_feature_csv_path):\n    neighborhood_size=4\n    df = pd.read_csv(file_path)\n    \n    dataset = rasterio.open(geotiff_file)\n    data = dataset.read(1)\n\n    # Get the width and height of the GeoTIFF\n    height, width = data.shape\n    \n    # Create an empty DataFrame with column names\n    columns = ['lat', 'lon', 'elevation', 'slope', 'aspect', 'curvature', 'northness', 'eastness']\n    all_df = pd.DataFrame(columns=columns)\n    \n    all_df.to_csv(result_dem_feature_csv_path)\n    print(f\"DEM and other columns are saved to file {result_dem_feature_csv_path}\")\n    return all_df\n\n\n  \n# Usage example:\nresult_dem_csv_path = \"/home/chetana/gridmet_test_run/dem_template.csv\"\nresult_dem_feature_csv_path = \"/home/chetana/gridmet_test_run/dem_all.csv\"\n\n\ndem_file = \"/home/chetana/gridmet_test_run/dem_file.tif\"\nslope_file = '/home/chetana/gridmet_test_run/slope_file.tif'\naspect_file = '/home/chetana/gridmet_test_run/aspect_file.tif'\ncurvature_file = '/home/chetana/gridmet_test_run/curvature_file.tif'\nnorthness_file = '/home/chetana/gridmet_test_run/northness_file.tif'\neastness_file = '/home/chetana/gridmet_test_run/eastness_file.tif'\n\n\nslope, aspect = calculate_slope_aspect(dem_file)\ncurvature = calculate_curvature(dem_file)\nnorthness, eastness = calculate_gradients(dem_file)\n\n# Save the slope and aspect as new GeoTIFF files\nsave_as_geotiff(slope, slope_file, dem_file)\nsave_as_geotiff(aspect, aspect_file, dem_file)\nsave_as_geotiff(curvature, curvature_file, dem_file)\nsave_as_geotiff(northness, northness_file, dem_file)\nsave_as_geotiff(eastness, eastness_file, dem_file)\n\ngeotiff_to_csv(dem_file, dem_file+\".csv\", \"Elevation\")\ngeotiff_to_csv(slope_file, slope_file+\".csv\", \"Slope\")\ngeotiff_to_csv(aspect_file, aspect_file+\".csv\", \"Aspect\")\ngeotiff_to_csv(curvature_file, curvature_file+\".csv\", \"Curvature\")\ngeotiff_to_csv(northness_file, northness_file+\".csv\", \"Northness\")\ngeotiff_to_csv(eastness_file, eastness_file+\".csv\", \"Eastness\")\n\n# List of file paths for the CSV files\ncsv_files = [dem_file+\".csv\", slope_file+\".csv\", aspect_file+\".csv\", \n             curvature_file+\".csv\", northness_file+\".csv\", eastness_file+\".csv\"]\n\n# Initialize an empty list to store all dataframes\ndfs = []\n\n# Read each CSV file into separate dataframes\nfor file in csv_files:\n    df = pd.read_csv(file, encoding='utf-8')\n    dfs.append(df)\n\n# Merge the dataframes based on the latitude and longitude columns\nmerged_df = dfs[0]  # Start with the first dataframe\nfor i in range(1, len(dfs)):\n    merged_df = pd.merge(merged_df, dfs[i], on=['Latitude', 'Longitude', 'x', 'y'])\n\n# Save the merged dataframe to a new CSV file\nmerged_df.to_csv(result_dem_feature_csv_path, index=False)\n",
  "history_output" : "[[  nan   nan   nan ... 2.373 2.366 2.366]\n [  nan   nan   nan ... 2.309 2.344 2.344]\n [  nan   nan   nan ... 2.288 2.309 2.309]\n ...\n [  nan   nan   nan ...   nan   nan   nan]\n [  nan   nan   nan ...   nan   nan   nan]\n [  nan   nan   nan ...   nan   nan   nan]]\nTraceback (most recent call last):\n  File \"/home/chetana/gw-workspace/Y4T7Z9RIdrC0/western_us_dem.py\", line 191, in <module>\n    slope, aspect = calculate_slope_aspect(dem_file)\n  File \"/home/chetana/gw-workspace/Y4T7Z9RIdrC0/western_us_dem.py\", line 56, in calculate_slope_aspect\n    dem_data = dem_data * mile_to_meters\nValueError: operands could not be broadcast together with shapes (666,694) (2,) \n",
  "history_begin_time" : 1695515465406,
  "history_end_time" : 1695515466493,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : null,
  "indicator" : "Failed"
},{
  "history_id" : "azsM0kZBEUIA",
  "history_input" : "import numpy as np\nimport pandas as pd\nfrom osgeo import gdal\nimport warnings\nimport rasterio\nimport csv\nfrom rasterio.transform import Affine\nfrom scipy.ndimage import sobel, gaussian_filter\n\nmile_to_meters = 1,609.34\n\n# Set the warning filter globally to ignore the FutureWarning\nwarnings.simplefilter(\"ignore\", FutureWarning)\n\ndef lat_lon_to_pixel(lat, lon, geotransform):\n    x = int((lon - geotransform[0]) / geotransform[1])\n    y = int((lat - geotransform[3]) / geotransform[5])\n    return x, y\n\n\ndef calculate_slope_aspect_for_single(elevation_data, pixel_size_x, pixel_size_y):\n    # Calculate slope using the Sobel operator\n    slope_x = np.gradient(elevation_data, pixel_size_x, axis=1)\n    slope_y = np.gradient(elevation_data, pixel_size_y, axis=0)\n    slope_rad = np.arctan(np.sqrt(slope_x ** 2 + slope_y ** 2))\n    slope_deg = np.degrees(slope_rad)\n\n    # Calculate aspect (direction of the steepest descent)\n    aspect_rad = np.arctan2(slope_y, -slope_x)\n    aspect_deg = (np.degrees(aspect_rad) + 360) % 360\n\n    return slope_deg, aspect_deg\n\n\ndef save_as_geotiff(data, output_file, src_file):\n    with rasterio.open(src_file) as src_dataset:\n        profile = src_dataset.profile\n        transform = src_dataset.transform\n\n        # Update the data type, count, and set the transform for the new dataset\n        profile.update(dtype=rasterio.float32, count=1, transform=transform)\n\n        # Create the new GeoTIFF file\n        with rasterio.open(output_file, 'w', **profile) as dst_dataset:\n            # Write the data to the new GeoTIFF\n            dst_dataset.write(data, 1)\n  \n\ndef calculate_slope_aspect(dem_file):\n    with rasterio.open(dem_file) as dataset:\n        # Read the DEM data as a numpy array\n        dem_data = dataset.read(1)\n        \n        # convert miles to meters\n        dem_data = dem_data*mile_to_meters\n\n        # Get the geotransform to convert pixel coordinates to geographic coordinates\n        transform = dataset.transform\n\n        # Calculate the slope and aspect using numpy\n        dx, dy = np.gradient(dem_data, transform[0], transform[4])\n        slope = np.arctan(np.sqrt(dx ** 2 + dy ** 2)) * (180.0 / np.pi)\n        aspect = np.arctan2(-dy, dx) * (180.0 / np.pi)\n\n        # Adjust aspect values to range from 0 to 360 degrees\n        aspect[aspect < 0] += 360\n        print(f\"slope shape: {slope.shape}\")\n        print(f\"aspect shape: {aspect.shape}\")\n        \n        \n    return slope, aspect\n  \ndef calculate_curvature(elevation_data, pixel_size_x, pixel_size_y):\n    # Calculate curvature using the Laplacian operator\n    curvature_x = np.gradient(np.gradient(elevation_data, pixel_size_x, axis=1), pixel_size_x, axis=1)\n    curvature_y = np.gradient(np.gradient(elevation_data, pixel_size_y, axis=0), pixel_size_y, axis=0)\n    curvature = curvature_x + curvature_y\n\n    return curvature\n\n  \ndef calculate_curvature(dem_file, sigma=1):\n    with rasterio.open(dem_file) as dataset:\n        # Read the DEM data as a numpy array\n        dem_data = dataset.read(1)\n        \n        # convert miles to meters\n        dem_data = dem_data*mile_to_meters\n\n        # Calculate the gradient using the Sobel filter\n        dx = sobel(dem_data, axis=1, mode='constant')\n        dy = sobel(dem_data, axis=0, mode='constant')\n\n        # Calculate the second derivatives using the Sobel filter\n        dxx = sobel(dx, axis=1, mode='constant')\n        dyy = sobel(dy, axis=0, mode='constant')\n\n        # Calculate the curvature using the second derivatives\n        curvature = dxx + dyy\n\n        # Smooth the curvature using Gaussian filtering (optional)\n        curvature = gaussian_filter(curvature, sigma)\n\n    return curvature\n  \ndef calculate_gradients(dem_file):\n    with rasterio.open(dem_file) as dataset:\n        # Read the DEM data as a numpy array\n        dem_data = dataset.read(1)\n\n        # Calculate the gradients along the North and East directions\n        dy, dx = np.gradient(dem_data, dataset.res[0], dataset.res[1])\n\n        # Calculate the Northness and Eastness\n        northness = np.arctan(dy / np.sqrt(dx**2 + dy**2))\n        eastness = np.arctan(dx / np.sqrt(dx**2 + dy**2))\n\n    return northness, eastness\n  \n  \ndef geotiff_to_csv(geotiff_file, csv_file, column_name):\n    # Open the GeoTIFF file\n    with rasterio.open(geotiff_file) as dataset:\n        # Get the pixel values as a 2D array\n        data = dataset.read(1)\n        \n        if column_name == \"Elevation\":\n          # convert miles to meters\n          dem_data = dem_data*mile_to_meters\n\n        # Get the geotransform to convert pixel coordinates to geographic coordinates\n        transform = dataset.transform\n\n        # Get the width and height of the GeoTIFF\n        height, width = data.shape\n\n        # Open the CSV file for writing\n        with open(csv_file, 'w', newline='') as csvfile:\n            csvwriter = csv.writer(csvfile)\n\n            # Write the CSV header\n            csvwriter.writerow(['Latitude', 'Longitude', 'x', 'y', column_name])\n\n            # Loop through each pixel and extract latitude, longitude, and image value\n            for y in range(height):\n                for x in range(width):\n                    # Get the pixel value\n                    image_value = data[y, x]\n\n                    # Convert pixel coordinates to geographic coordinates\n                    lon, lat = transform * (x, y)\n\n                    # Write the data to the CSV file\n                    csvwriter.writerow([lat, lon, x, y, image_value])\n\n  \ndef read_elevation_data(file_path, result_dem_csv_path, result_dem_feature_csv_path):\n    neighborhood_size=4\n    df = pd.read_csv(file_path)\n    \n    dataset = rasterio.open(geotiff_file)\n    data = dataset.read(1)\n\n    # Get the width and height of the GeoTIFF\n    height, width = data.shape\n    \n    # Create an empty DataFrame with column names\n    columns = ['lat', 'lon', 'elevation', 'slope', 'aspect', 'curvature', 'northness', 'eastness']\n    all_df = pd.DataFrame(columns=columns)\n    \n    all_df.to_csv(result_dem_feature_csv_path)\n    print(f\"DEM and other columns are saved to file {result_dem_feature_csv_path}\")\n    return all_df\n\n\n  \n# Usage example:\nresult_dem_csv_path = \"/home/chetana/gridmet_test_run/dem_template.csv\"\nresult_dem_feature_csv_path = \"/home/chetana/gridmet_test_run/dem_all.csv\"\n\n\ndem_file = \"/home/chetana/gridmet_test_run/dem_file.tif\"\nslope_file = '/home/chetana/gridmet_test_run/slope_file.tif'\naspect_file = '/home/chetana/gridmet_test_run/aspect_file.tif'\ncurvature_file = '/home/chetana/gridmet_test_run/curvature_file.tif'\nnorthness_file = '/home/chetana/gridmet_test_run/northness_file.tif'\neastness_file = '/home/chetana/gridmet_test_run/eastness_file.tif'\n\n\nslope, aspect = calculate_slope_aspect(dem_file)\ncurvature = calculate_curvature(dem_file)\nnorthness, eastness = calculate_gradients(dem_file)\n\n# Save the slope and aspect as new GeoTIFF files\nsave_as_geotiff(slope, slope_file, dem_file)\nsave_as_geotiff(aspect, aspect_file, dem_file)\nsave_as_geotiff(curvature, curvature_file, dem_file)\nsave_as_geotiff(northness, northness_file, dem_file)\nsave_as_geotiff(eastness, eastness_file, dem_file)\n\ngeotiff_to_csv(dem_file, dem_file+\".csv\", \"Elevation\")\ngeotiff_to_csv(slope_file, slope_file+\".csv\", \"Slope\")\ngeotiff_to_csv(aspect_file, aspect_file+\".csv\", \"Aspect\")\ngeotiff_to_csv(curvature_file, curvature_file+\".csv\", \"Curvature\")\ngeotiff_to_csv(northness_file, northness_file+\".csv\", \"Northness\")\ngeotiff_to_csv(eastness_file, eastness_file+\".csv\", \"Eastness\")\n\n# List of file paths for the CSV files\ncsv_files = [dem_file+\".csv\", slope_file+\".csv\", aspect_file+\".csv\", \n             curvature_file+\".csv\", northness_file+\".csv\", eastness_file+\".csv\"]\n\n# Initialize an empty list to store all dataframes\ndfs = []\n\n# Read each CSV file into separate dataframes\nfor file in csv_files:\n    df = pd.read_csv(file, encoding='utf-8')\n    dfs.append(df)\n\n# Merge the dataframes based on the latitude and longitude columns\nmerged_df = dfs[0]  # Start with the first dataframe\nfor i in range(1, len(dfs)):\n    merged_df = pd.merge(merged_df, dfs[i], on=['Latitude', 'Longitude', 'x', 'y'])\n\n# Save the merged dataframe to a new CSV file\nmerged_df.to_csv(result_dem_feature_csv_path, index=False)\n",
  "history_output" : "Traceback (most recent call last):\n  File \"/home/chetana/gw-workspace/azsM0kZBEUIA/western_us_dem.py\", line 190, in <module>\n    slope, aspect = calculate_slope_aspect(dem_file)\n  File \"/home/chetana/gw-workspace/azsM0kZBEUIA/western_us_dem.py\", line 55, in calculate_slope_aspect\n    dem_data = dem_data*mile_to_meters\nValueError: operands could not be broadcast together with shapes (666,694) (2,) \n",
  "history_begin_time" : 1695515350419,
  "history_end_time" : 1695515358590,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : null,
  "indicator" : "Failed"
},{
  "history_id" : "225but3zpty",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1695506423847,
  "history_end_time" : 1695506423847,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "jfkmvzd578l",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1695418741338,
  "history_end_time" : 1695418741338,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "q8fo60qatko",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1695417619675,
  "history_end_time" : 1695417619675,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "vpx7lbd9y9e",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1695417171277,
  "history_end_time" : 1695417171277,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "lpwbwxcvg3f",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1695417052729,
  "history_end_time" : 1695417052729,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "3zmhxxwra4v",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1695416916046,
  "history_end_time" : 1695416916046,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "deuri77j4o5",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1695106488976,
  "history_end_time" : 1695106488976,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "h4kyw7947gn",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1695106316210,
  "history_end_time" : 1695106316210,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "uirxbsrz1wv",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1695054045025,
  "history_end_time" : 1695054045025,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "wanom0tnpo4",
  "history_input" : "import numpy as np\nimport pandas as pd\nfrom osgeo import gdal\nimport warnings\nimport rasterio\nimport csv\nfrom rasterio.transform import Affine\nfrom scipy.ndimage import sobel, gaussian_filter\n\n# Set the warning filter globally to ignore the FutureWarning\nwarnings.simplefilter(\"ignore\", FutureWarning)\n\ndef lat_lon_to_pixel(lat, lon, geotransform):\n    x = int((lon - geotransform[0]) / geotransform[1])\n    y = int((lat - geotransform[3]) / geotransform[5])\n    return x, y\n\n\ndef calculate_slope_aspect_for_single(elevation_data, pixel_size_x, pixel_size_y):\n    # Calculate slope using the Sobel operator\n    slope_x = np.gradient(elevation_data, pixel_size_x, axis=1)\n    slope_y = np.gradient(elevation_data, pixel_size_y, axis=0)\n    slope_rad = np.arctan(np.sqrt(slope_x ** 2 + slope_y ** 2))\n    slope_deg = np.degrees(slope_rad)\n\n    # Calculate aspect (direction of the steepest descent)\n    aspect_rad = np.arctan2(slope_y, -slope_x)\n    aspect_deg = (np.degrees(aspect_rad) + 360) % 360\n\n    return slope_deg, aspect_deg\n\n\ndef save_as_geotiff(data, output_file, src_file):\n    with rasterio.open(src_file) as src_dataset:\n        profile = src_dataset.profile\n        transform = src_dataset.transform\n\n        # Update the data type, count, and set the transform for the new dataset\n        profile.update(dtype=rasterio.float32, count=1, transform=transform)\n\n        # Create the new GeoTIFF file\n        with rasterio.open(output_file, 'w', **profile) as dst_dataset:\n            # Write the data to the new GeoTIFF\n            dst_dataset.write(data, 1)\n  \n\ndef calculate_slope_aspect(dem_file):\n    with rasterio.open(dem_file) as dataset:\n        # Read the DEM data as a numpy array\n        dem_data = dataset.read(1)\n\n        # Get the geotransform to convert pixel coordinates to geographic coordinates\n        transform = dataset.transform\n\n        # Calculate the slope and aspect using numpy\n        dx, dy = np.gradient(dem_data, transform[0], transform[4])\n        slope = np.arctan(np.sqrt(dx ** 2 + dy ** 2)) * (180.0 / np.pi)\n        aspect = np.arctan2(-dy, dx) * (180.0 / np.pi)\n\n        # Adjust aspect values to range from 0 to 360 degrees\n        aspect[aspect < 0] += 360\n        print(f\"slope shape: {slope.shape}\")\n        print(f\"aspect shape: {aspect.shape}\")\n        \n        \n    return slope, aspect\n  \ndef calculate_curvature(elevation_data, pixel_size_x, pixel_size_y):\n    # Calculate curvature using the Laplacian operator\n    curvature_x = np.gradient(np.gradient(elevation_data, pixel_size_x, axis=1), pixel_size_x, axis=1)\n    curvature_y = np.gradient(np.gradient(elevation_data, pixel_size_y, axis=0), pixel_size_y, axis=0)\n    curvature = curvature_x + curvature_y\n\n    return curvature\n\n  \ndef calculate_curvature(dem_file, sigma=1):\n    with rasterio.open(dem_file) as dataset:\n        # Read the DEM data as a numpy array\n        dem_data = dataset.read(1)\n\n        # Calculate the gradient using the Sobel filter\n        dx = sobel(dem_data, axis=1, mode='constant')\n        dy = sobel(dem_data, axis=0, mode='constant')\n\n        # Calculate the second derivatives using the Sobel filter\n        dxx = sobel(dx, axis=1, mode='constant')\n        dyy = sobel(dy, axis=0, mode='constant')\n\n        # Calculate the curvature using the second derivatives\n        curvature = dxx + dyy\n\n        # Smooth the curvature using Gaussian filtering (optional)\n        curvature = gaussian_filter(curvature, sigma)\n\n    return curvature\n  \ndef calculate_gradients(dem_file):\n    with rasterio.open(dem_file) as dataset:\n        # Read the DEM data as a numpy array\n        dem_data = dataset.read(1)\n\n        # Calculate the gradients along the North and East directions\n        dy, dx = np.gradient(dem_data, dataset.res[0], dataset.res[1])\n\n        # Calculate the Northness and Eastness\n        northness = np.arctan(dy / np.sqrt(dx**2 + dy**2))\n        eastness = np.arctan(dx / np.sqrt(dx**2 + dy**2))\n\n    return northness, eastness\n  \n  \ndef geotiff_to_csv(geotiff_file, csv_file, column_name):\n    # Open the GeoTIFF file\n    with rasterio.open(geotiff_file) as dataset:\n        # Get the pixel values as a 2D array\n        data = dataset.read(1)\n\n        # Get the geotransform to convert pixel coordinates to geographic coordinates\n        transform = dataset.transform\n\n        # Get the width and height of the GeoTIFF\n        height, width = data.shape\n\n        # Open the CSV file for writing\n        with open(csv_file, 'w', newline='') as csvfile:\n            csvwriter = csv.writer(csvfile)\n\n            # Write the CSV header\n            csvwriter.writerow(['Latitude', 'Longitude', 'x', 'y', column_name])\n\n            # Loop through each pixel and extract latitude, longitude, and image value\n            for y in range(height):\n                for x in range(width):\n                    # Get the pixel value\n                    image_value = data[y, x]\n\n                    # Convert pixel coordinates to geographic coordinates\n                    lon, lat = transform * (x, y)\n\n                    # Write the data to the CSV file\n                    csvwriter.writerow([lat, lon, x, y, image_value])\n\n  \ndef read_elevation_data(file_path, result_dem_csv_path, result_dem_feature_csv_path):\n    neighborhood_size=4\n    df = pd.read_csv(file_path)\n    \n    dataset = rasterio.open(geotiff_file)\n    data = dataset.read(1)\n\n    # Get the width and height of the GeoTIFF\n    height, width = data.shape\n    \n    # Create an empty DataFrame with column names\n    columns = ['lat', 'lon', 'elevation', 'slope', 'aspect', 'curvature', 'northness', 'eastness']\n    all_df = pd.DataFrame(columns=columns)\n    \n    all_df.to_csv(result_dem_feature_csv_path)\n    print(f\"DEM and other columns are saved to file {result_dem_feature_csv_path}\")\n    return all_df\n\n\n  \n# Usage example:\nresult_dem_csv_path = \"/home/chetana/gridmet_test_run/dem_template.csv\"\nresult_dem_feature_csv_path = \"/home/chetana/gridmet_test_run/dem_all.csv\"\n\n\ndem_file = \"/home/chetana/gridmet_test_run/dem_file.tif\"\nslope_file = '/home/chetana/gridmet_test_run/slope_file.tif'\naspect_file = '/home/chetana/gridmet_test_run/aspect_file.tif'\ncurvature_file = '/home/chetana/gridmet_test_run/curvature_file.tif'\nnorthness_file = '/home/chetana/gridmet_test_run/northness_file.tif'\neastness_file = '/home/chetana/gridmet_test_run/eastness_file.tif'\n\n\nslope, aspect = calculate_slope_aspect(dem_file)\ncurvature = calculate_curvature(dem_file)\nnorthness, eastness = calculate_gradients(dem_file)\n\n# Save the slope and aspect as new GeoTIFF files\nsave_as_geotiff(slope, slope_file, dem_file)\nsave_as_geotiff(aspect, aspect_file, dem_file)\nsave_as_geotiff(curvature, curvature_file, dem_file)\nsave_as_geotiff(northness, northness_file, dem_file)\nsave_as_geotiff(eastness, eastness_file, dem_file)\n\ngeotiff_to_csv(dem_file, dem_file+\".csv\", \"Elevation\")\ngeotiff_to_csv(slope_file, slope_file+\".csv\", \"Slope\")\ngeotiff_to_csv(aspect_file, aspect_file+\".csv\", \"Aspect\")\ngeotiff_to_csv(curvature_file, curvature_file+\".csv\", \"Curvature\")\ngeotiff_to_csv(northness_file, northness_file+\".csv\", \"Northness\")\ngeotiff_to_csv(eastness_file, eastness_file+\".csv\", \"Eastness\")\n\n# List of file paths for the CSV files\ncsv_files = [dem_file+\".csv\", slope_file+\".csv\", aspect_file+\".csv\", \n             curvature_file+\".csv\", northness_file+\".csv\", eastness_file+\".csv\"]\n\n# Initialize an empty list to store all dataframes\ndfs = []\n\n# Read each CSV file into separate dataframes\nfor file in csv_files:\n    df = pd.read_csv(file, encoding='utf-8')\n    dfs.append(df)\n\n# Merge the dataframes based on the latitude and longitude columns\nmerged_df = dfs[0]  # Start with the first dataframe\nfor i in range(1, len(dfs)):\n    merged_df = pd.merge(merged_df, dfs[i], on=['Latitude', 'Longitude', 'x', 'y'])\n\n# Save the merged dataframe to a new CSV file\nmerged_df.to_csv(result_dem_feature_csv_path, index=False)\n",
  "history_output" : "Running",
  "history_begin_time" : 1695054020287,
  "history_end_time" : 1695054032350,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Done"
},{
  "history_id" : "cvyzgtqz292",
  "history_input" : "import numpy as np\nimport pandas as pd\nfrom osgeo import gdal\nimport warnings\nimport rasterio\nimport csv\nfrom rasterio.transform import Affine\nfrom scipy.ndimage import sobel, gaussian_filter\n\n# Set the warning filter globally to ignore the FutureWarning\nwarnings.simplefilter(\"ignore\", FutureWarning)\n\ndef lat_lon_to_pixel(lat, lon, geotransform):\n    x = int((lon - geotransform[0]) / geotransform[1])\n    y = int((lat - geotransform[3]) / geotransform[5])\n    return x, y\n\n\ndef calculate_slope_aspect_for_single(elevation_data, pixel_size_x, pixel_size_y):\n    # Calculate slope using the Sobel operator\n    slope_x = np.gradient(elevation_data, pixel_size_x, axis=1)\n    slope_y = np.gradient(elevation_data, pixel_size_y, axis=0)\n    slope_rad = np.arctan(np.sqrt(slope_x ** 2 + slope_y ** 2))\n    slope_deg = np.degrees(slope_rad)\n\n    # Calculate aspect (direction of the steepest descent)\n    aspect_rad = np.arctan2(slope_y, -slope_x)\n    aspect_deg = (np.degrees(aspect_rad) + 360) % 360\n\n    return slope_deg, aspect_deg\n\n\ndef save_as_geotiff(data, output_file, src_file):\n    with rasterio.open(src_file) as src_dataset:\n        profile = src_dataset.profile\n        transform = src_dataset.transform\n\n        # Update the data type, count, and set the transform for the new dataset\n        profile.update(dtype=rasterio.float32, count=1, transform=transform)\n\n        # Create the new GeoTIFF file\n        with rasterio.open(output_file, 'w', **profile) as dst_dataset:\n            # Write the data to the new GeoTIFF\n            dst_dataset.write(data, 1)\n  \n\ndef calculate_slope_aspect(dem_file):\n    with rasterio.open(dem_file) as dataset:\n        # Read the DEM data as a numpy array\n        dem_data = dataset.read(1)\n\n        # Get the geotransform to convert pixel coordinates to geographic coordinates\n        transform = dataset.transform\n\n        # Calculate the slope and aspect using numpy\n        dx, dy = np.gradient(dem_data, transform[0], transform[4])\n        slope = np.arctan(np.sqrt(dx ** 2 + dy ** 2)) * (180.0 / np.pi)\n        aspect = np.arctan2(-dy, dx) * (180.0 / np.pi)\n\n        # Adjust aspect values to range from 0 to 360 degrees\n        aspect[aspect < 0] += 360\n        print(f\"slope shape: {slope.shape}\")\n        print(f\"aspect shape: {aspect.shape}\")\n        \n        \n    return slope, aspect\n  \ndef calculate_curvature(elevation_data, pixel_size_x, pixel_size_y):\n    # Calculate curvature using the Laplacian operator\n    curvature_x = np.gradient(np.gradient(elevation_data, pixel_size_x, axis=1), pixel_size_x, axis=1)\n    curvature_y = np.gradient(np.gradient(elevation_data, pixel_size_y, axis=0), pixel_size_y, axis=0)\n    curvature = curvature_x + curvature_y\n\n    return curvature\n\n  \ndef calculate_curvature(dem_file, sigma=1):\n    with rasterio.open(dem_file) as dataset:\n        # Read the DEM data as a numpy array\n        dem_data = dataset.read(1)\n\n        # Calculate the gradient using the Sobel filter\n        dx = sobel(dem_data, axis=1, mode='constant')\n        dy = sobel(dem_data, axis=0, mode='constant')\n\n        # Calculate the second derivatives using the Sobel filter\n        dxx = sobel(dx, axis=1, mode='constant')\n        dyy = sobel(dy, axis=0, mode='constant')\n\n        # Calculate the curvature using the second derivatives\n        curvature = dxx + dyy\n\n        # Smooth the curvature using Gaussian filtering (optional)\n        curvature = gaussian_filter(curvature, sigma)\n\n    return curvature\n  \ndef calculate_gradients(dem_file):\n    with rasterio.open(dem_file) as dataset:\n        # Read the DEM data as a numpy array\n        dem_data = dataset.read(1)\n\n        # Calculate the gradients along the North and East directions\n        dy, dx = np.gradient(dem_data, dataset.res[0], dataset.res[1])\n\n        # Calculate the Northness and Eastness\n        northness = np.arctan(dy / np.sqrt(dx**2 + dy**2))\n        eastness = np.arctan(dx / np.sqrt(dx**2 + dy**2))\n\n    return northness, eastness\n  \n  \ndef geotiff_to_csv(geotiff_file, csv_file, column_name):\n    # Open the GeoTIFF file\n    with rasterio.open(geotiff_file) as dataset:\n        # Get the pixel values as a 2D array\n        data = dataset.read(1)\n\n        # Get the geotransform to convert pixel coordinates to geographic coordinates\n        transform = dataset.transform\n\n        # Get the width and height of the GeoTIFF\n        height, width = data.shape\n\n        # Open the CSV file for writing\n        with open(csv_file, 'w', newline='') as csvfile:\n            csvwriter = csv.writer(csvfile)\n\n            # Write the CSV header\n            csvwriter.writerow(['Latitude', 'Longitude', 'x', 'y', column_name])\n\n            # Loop through each pixel and extract latitude, longitude, and image value\n            for y in range(height):\n                for x in range(width):\n                    # Get the pixel value\n                    image_value = data[y, x]\n\n                    # Convert pixel coordinates to geographic coordinates\n                    lon, lat = transform * (x, y)\n\n                    # Write the data to the CSV file\n                    csvwriter.writerow([lat, lon, x, y, image_value])\n\n  \ndef read_elevation_data(file_path, result_dem_csv_path, result_dem_feature_csv_path):\n    neighborhood_size=4\n    df = pd.read_csv(file_path)\n    \n    dataset = rasterio.open(geotiff_file)\n    data = dataset.read(1)\n\n    # Get the width and height of the GeoTIFF\n    height, width = data.shape\n    \n    # Create an empty DataFrame with column names\n    columns = ['lat', 'lon', 'elevation', 'slope', 'aspect', 'curvature', 'northness', 'eastness']\n    all_df = pd.DataFrame(columns=columns)\n    \n    all_df.to_csv(result_dem_feature_csv_path)\n    print(f\"DEM and other columns are saved to file {result_dem_feature_csv_path}\")\n    return all_df\n\n\n  \n# Usage example:\nresult_dem_csv_path = \"/home/chetana/gridmet_test_run/dem_template.csv\"\nresult_dem_feature_csv_path = \"/home/chetana/gridmet_test_run/dem_all.csv\"\n\n\ndem_file = \"/home/chetana/gridmet_test_run/dem_file.tif\"\nslope_file = '/home/chetana/gridmet_test_run/slope_file.tif'\naspect_file = '/home/chetana/gridmet_test_run/aspect_file.tif'\ncurvature_file = '/home/chetana/gridmet_test_run/curvature_file.tif'\nnorthness_file = '/home/chetana/gridmet_test_run/northness_file.tif'\neastness_file = '/home/chetana/gridmet_test_run/eastness_file.tif'\n\n\nslope, aspect = calculate_slope_aspect(dem_file)\ncurvature = calculate_curvature(dem_file)\nnorthness, eastness = calculate_gradients(dem_file)\n\n# Save the slope and aspect as new GeoTIFF files\nsave_as_geotiff(slope, slope_file, dem_file)\nsave_as_geotiff(aspect, aspect_file, dem_file)\nsave_as_geotiff(curvature, curvature_file, dem_file)\nsave_as_geotiff(northness, northness_file, dem_file)\nsave_as_geotiff(eastness, eastness_file, dem_file)\n\ngeotiff_to_csv(dem_file, dem_file+\".csv\", \"Elevation\")\ngeotiff_to_csv(slope_file, slope_file+\".csv\", \"Slope\")\ngeotiff_to_csv(aspect_file, aspect_file+\".csv\", \"Aspect\")\ngeotiff_to_csv(curvature_file, curvature_file+\".csv\", \"Curvature\")\ngeotiff_to_csv(northness_file, northness_file+\".csv\", \"Northness\")\ngeotiff_to_csv(eastness_file, eastness_file+\".csv\", \"Eastness\")\n\n# List of file paths for the CSV files\ncsv_files = [dem_file+\".csv\", slope_file+\".csv\", aspect_file+\".csv\", \n             curvature_file+\".csv\", northness_file+\".csv\", eastness_file+\".csv\"]\n\n# Initialize an empty list to store all dataframes\ndfs = []\n\n# Read each CSV file into separate dataframes\nfor file in csv_files:\n    df = pd.read_csv(file, encoding='utf-8')\n    dfs.append(df)\n\n# Merge the dataframes based on the latitude and longitude columns\nmerged_df = dfs[0]  # Start with the first dataframe\nfor i in range(1, len(dfs)):\n    merged_df = pd.merge(merged_df, dfs[i], on=['Latitude', 'Longitude', 'x', 'y'])\n\n# Save the merged dataframe to a new CSV file\nmerged_df.to_csv(result_dem_feature_csv_path, index=False)\n",
  "history_output" : "/home/chetana/gw-workspace/cvyzgtqz292/western_us_dem.py:107: RuntimeWarning: invalid value encountered in divide\n  northness = np.arctan(dy / np.sqrt(dx**2 + dy**2))\n/home/chetana/gw-workspace/cvyzgtqz292/western_us_dem.py:108: RuntimeWarning: invalid value encountered in divide\n  eastness = np.arctan(dx / np.sqrt(dx**2 + dy**2))\nslope shape: (666, 694)\naspect shape: (666, 694)\n",
  "history_begin_time" : 1695053980593,
  "history_end_time" : 1695054019273,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Stopped"
},{
  "history_id" : "s6ba0g90rym",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1695053793416,
  "history_end_time" : 1695053793416,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "cxya967ot61",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1695053733433,
  "history_end_time" : 1695053733433,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "shyyi1ewdcr",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1694971144823,
  "history_end_time" : 1694972839687,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Stopped"
},{
  "history_id" : "hw8nu6ke6oa",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1694970707922,
  "history_end_time" : 1694970707922,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "9wobw7m87a8",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1694970594759,
  "history_end_time" : 1694970594759,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "ibwz2tkunf0",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1694970131593,
  "history_end_time" : 1694970131593,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Skipped"
},{
  "history_id" : "RyREWqRLgg5i",
  "history_input" : "import numpy as np\nimport pandas as pd\nfrom osgeo import gdal\nimport warnings\nimport rasterio\nimport csv\nfrom rasterio.transform import Affine\nfrom scipy.ndimage import sobel, gaussian_filter\n\n# Set the warning filter globally to ignore the FutureWarning\nwarnings.simplefilter(\"ignore\", FutureWarning)\n\ndef lat_lon_to_pixel(lat, lon, geotransform):\n    x = int((lon - geotransform[0]) / geotransform[1])\n    y = int((lat - geotransform[3]) / geotransform[5])\n    return x, y\n\n\ndef calculate_slope_aspect_for_single(elevation_data, pixel_size_x, pixel_size_y):\n    # Calculate slope using the Sobel operator\n    slope_x = np.gradient(elevation_data, pixel_size_x, axis=1)\n    slope_y = np.gradient(elevation_data, pixel_size_y, axis=0)\n    slope_rad = np.arctan(np.sqrt(slope_x ** 2 + slope_y ** 2))\n    slope_deg = np.degrees(slope_rad)\n\n    # Calculate aspect (direction of the steepest descent)\n    aspect_rad = np.arctan2(slope_y, -slope_x)\n    aspect_deg = (np.degrees(aspect_rad) + 360) % 360\n\n    return slope_deg, aspect_deg\n\n\ndef save_as_geotiff(data, output_file, src_file):\n    with rasterio.open(src_file) as src_dataset:\n        profile = src_dataset.profile\n        transform = src_dataset.transform\n\n        # Update the data type, count, and set the transform for the new dataset\n        profile.update(dtype=rasterio.float32, count=1, transform=transform)\n\n        # Create the new GeoTIFF file\n        with rasterio.open(output_file, 'w', **profile) as dst_dataset:\n            # Write the data to the new GeoTIFF\n            dst_dataset.write(data, 1)\n  \n\ndef calculate_slope_aspect(dem_file):\n    with rasterio.open(dem_file) as dataset:\n        # Read the DEM data as a numpy array\n        dem_data = dataset.read(1)\n\n        # Get the geotransform to convert pixel coordinates to geographic coordinates\n        transform = dataset.transform\n\n        # Calculate the slope and aspect using numpy\n        dx, dy = np.gradient(dem_data, transform[0], transform[4])\n        slope = np.arctan(np.sqrt(dx ** 2 + dy ** 2)) * (180.0 / np.pi)\n        aspect = np.arctan2(-dy, dx) * (180.0 / np.pi)\n\n        # Adjust aspect values to range from 0 to 360 degrees\n        aspect[aspect < 0] += 360\n        print(f\"slope shape: {slope.shape}\")\n        print(f\"aspect shape: {aspect.shape}\")\n        \n        \n    return slope, aspect\n  \ndef calculate_curvature(elevation_data, pixel_size_x, pixel_size_y):\n    # Calculate curvature using the Laplacian operator\n    curvature_x = np.gradient(np.gradient(elevation_data, pixel_size_x, axis=1), pixel_size_x, axis=1)\n    curvature_y = np.gradient(np.gradient(elevation_data, pixel_size_y, axis=0), pixel_size_y, axis=0)\n    curvature = curvature_x + curvature_y\n\n    return curvature\n\n  \ndef calculate_curvature(dem_file, sigma=1):\n    with rasterio.open(dem_file) as dataset:\n        # Read the DEM data as a numpy array\n        dem_data = dataset.read(1)\n\n        # Calculate the gradient using the Sobel filter\n        dx = sobel(dem_data, axis=1, mode='constant')\n        dy = sobel(dem_data, axis=0, mode='constant')\n\n        # Calculate the second derivatives using the Sobel filter\n        dxx = sobel(dx, axis=1, mode='constant')\n        dyy = sobel(dy, axis=0, mode='constant')\n\n        # Calculate the curvature using the second derivatives\n        curvature = dxx + dyy\n\n        # Smooth the curvature using Gaussian filtering (optional)\n        curvature = gaussian_filter(curvature, sigma)\n\n    return curvature\n  \ndef calculate_gradients(dem_file):\n    with rasterio.open(dem_file) as dataset:\n        # Read the DEM data as a numpy array\n        dem_data = dataset.read(1)\n\n        # Calculate the gradients along the North and East directions\n        dy, dx = np.gradient(dem_data, dataset.res[0], dataset.res[1])\n\n        # Calculate the Northness and Eastness\n        northness = np.arctan(dy / np.sqrt(dx**2 + dy**2))\n        eastness = np.arctan(dx / np.sqrt(dx**2 + dy**2))\n\n    return northness, eastness\n  \n  \ndef geotiff_to_csv(geotiff_file, csv_file, column_name):\n    # Open the GeoTIFF file\n    with rasterio.open(geotiff_file) as dataset:\n        # Get the pixel values as a 2D array\n        data = dataset.read(1)\n\n        # Get the geotransform to convert pixel coordinates to geographic coordinates\n        transform = dataset.transform\n\n        # Get the width and height of the GeoTIFF\n        height, width = data.shape\n\n        # Open the CSV file for writing\n        with open(csv_file, 'w', newline='') as csvfile:\n            csvwriter = csv.writer(csvfile)\n\n            # Write the CSV header\n            csvwriter.writerow(['Latitude', 'Longitude', 'x', 'y', column_name])\n\n            # Loop through each pixel and extract latitude, longitude, and image value\n            for y in range(height):\n                for x in range(width):\n                    # Get the pixel value\n                    image_value = data[y, x]\n\n                    # Convert pixel coordinates to geographic coordinates\n                    lon, lat = transform * (x, y)\n\n                    # Write the data to the CSV file\n                    csvwriter.writerow([lat, lon, x, y, image_value])\n\n  \ndef read_elevation_data(file_path, result_dem_csv_path, result_dem_feature_csv_path):\n    neighborhood_size=4\n    df = pd.read_csv(file_path)\n    \n    dataset = rasterio.open(geotiff_file)\n    data = dataset.read(1)\n\n    # Get the width and height of the GeoTIFF\n    height, width = data.shape\n    \n    # Create an empty DataFrame with column names\n    columns = ['lat', 'lon', 'elevation', 'slope', 'aspect', 'curvature', 'northness', 'eastness']\n    all_df = pd.DataFrame(columns=columns)\n    \n    all_df.to_csv(result_dem_feature_csv_path)\n    print(f\"DEM and other columns are saved to file {result_dem_feature_csv_path}\")\n    return all_df\n\n\n  \n# Usage example:\nresult_dem_csv_path = \"/home/chetana/gridmet_test_run/dem_template.csv\"\nresult_dem_feature_csv_path = \"/home/chetana/gridmet_test_run/dem_all.csv\"\n\n\ndem_file = \"/home/chetana/gridmet_test_run/dem_file.tif\"\nslope_file = '/home/chetana/gridmet_test_run/slope_file.tif'\naspect_file = '/home/chetana/gridmet_test_run/aspect_file.tif'\ncurvature_file = '/home/chetana/gridmet_test_run/curvature_file.tif'\nnorthness_file = '/home/chetana/gridmet_test_run/northness_file.tif'\neastness_file = '/home/chetana/gridmet_test_run/eastness_file.tif'\n\n\nslope, aspect = calculate_slope_aspect(dem_file)\ncurvature = calculate_curvature(dem_file)\nnorthness, eastness = calculate_gradients(dem_file)\n\n# Save the slope and aspect as new GeoTIFF files\nsave_as_geotiff(slope, slope_file, dem_file)\nsave_as_geotiff(aspect, aspect_file, dem_file)\nsave_as_geotiff(curvature, curvature_file, dem_file)\nsave_as_geotiff(northness, northness_file, dem_file)\nsave_as_geotiff(eastness, eastness_file, dem_file)\n\ngeotiff_to_csv(dem_file, dem_file+\".csv\", \"Elevation\")\ngeotiff_to_csv(slope_file, slope_file+\".csv\", \"Slope\")\ngeotiff_to_csv(aspect_file, aspect_file+\".csv\", \"Aspect\")\ngeotiff_to_csv(curvature_file, curvature_file+\".csv\", \"Curvature\")\ngeotiff_to_csv(northness_file, northness_file+\".csv\", \"Northness\")\ngeotiff_to_csv(eastness_file, eastness_file+\".csv\", \"Eastness\")\n\n# List of file paths for the CSV files\ncsv_files = [dem_file+\".csv\", slope_file+\".csv\", aspect_file+\".csv\", \n             curvature_file+\".csv\", northness_file+\".csv\", eastness_file+\".csv\"]\n\n# Initialize an empty list to store all dataframes\ndfs = []\n\n# Read each CSV file into separate dataframes\nfor file in csv_files:\n    df = pd.read_csv(file, encoding='utf-8')\n    dfs.append(df)\n\n# Merge the dataframes based on the latitude and longitude columns\nmerged_df = dfs[0]  # Start with the first dataframe\nfor i in range(1, len(dfs)):\n    merged_df = pd.merge(merged_df, dfs[i], on=['Latitude', 'Longitude', 'x', 'y'])\n\n# Save the merged dataframe to a new CSV file\nmerged_df.to_csv(result_dem_feature_csv_path, index=False)\n",
  "history_output" : "/home/chetana/gw-workspace/RyREWqRLgg5i/western_us_dem.py:107: RuntimeWarning: invalid value encountered in divide\n  northness = np.arctan(dy / np.sqrt(dx**2 + dy**2))\n/home/chetana/gw-workspace/RyREWqRLgg5i/western_us_dem.py:108: RuntimeWarning: invalid value encountered in divide\n  eastness = np.arctan(dx / np.sqrt(dx**2 + dy**2))\nslope shape: (666, 694)\naspect shape: (666, 694)\n",
  "history_begin_time" : 1694970076791,
  "history_end_time" : 1694970091738,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "soxrpq036pg",
  "history_input" : "import numpy as np\nimport pandas as pd\nfrom osgeo import gdal\nimport warnings\nimport rasterio\nimport csv\nfrom rasterio.transform import Affine\nfrom scipy.ndimage import sobel, gaussian_filter\n\n# Set the warning filter globally to ignore the FutureWarning\nwarnings.simplefilter(\"ignore\", FutureWarning)\n\ndef lat_lon_to_pixel(lat, lon, geotransform):\n    x = int((lon - geotransform[0]) / geotransform[1])\n    y = int((lat - geotransform[3]) / geotransform[5])\n    return x, y\n\n\ndef calculate_slope_aspect_for_single(elevation_data, pixel_size_x, pixel_size_y):\n    # Calculate slope using the Sobel operator\n    slope_x = np.gradient(elevation_data, pixel_size_x, axis=1)\n    slope_y = np.gradient(elevation_data, pixel_size_y, axis=0)\n    slope_rad = np.arctan(np.sqrt(slope_x ** 2 + slope_y ** 2))\n    slope_deg = np.degrees(slope_rad)\n\n    # Calculate aspect (direction of the steepest descent)\n    aspect_rad = np.arctan2(slope_y, -slope_x)\n    aspect_deg = (np.degrees(aspect_rad) + 360) % 360\n\n    return slope_deg, aspect_deg\n\n\ndef save_as_geotiff(data, output_file, src_file):\n    with rasterio.open(src_file) as src_dataset:\n        profile = src_dataset.profile\n        transform = src_dataset.transform\n\n        # Update the data type, count, and set the transform for the new dataset\n        profile.update(dtype=rasterio.float32, count=1, transform=transform)\n\n        # Create the new GeoTIFF file\n        with rasterio.open(output_file, 'w', **profile) as dst_dataset:\n            # Write the data to the new GeoTIFF\n            dst_dataset.write(data, 1)\n  \n\ndef calculate_slope_aspect(dem_file):\n    with rasterio.open(dem_file) as dataset:\n        # Read the DEM data as a numpy array\n        dem_data = dataset.read(1)\n\n        # Get the geotransform to convert pixel coordinates to geographic coordinates\n        transform = dataset.transform\n\n        # Calculate the slope and aspect using numpy\n        dx, dy = np.gradient(dem_data, transform[0], transform[4])\n        slope = np.arctan(np.sqrt(dx ** 2 + dy ** 2)) * (180.0 / np.pi)\n        aspect = np.arctan2(-dy, dx) * (180.0 / np.pi)\n\n        # Adjust aspect values to range from 0 to 360 degrees\n        aspect[aspect < 0] += 360\n        print(f\"slope shape: {slope.shape}\")\n        print(f\"aspect shape: {aspect.shape}\")\n        \n        \n    return slope, aspect\n  \ndef calculate_curvature(elevation_data, pixel_size_x, pixel_size_y):\n    # Calculate curvature using the Laplacian operator\n    curvature_x = np.gradient(np.gradient(elevation_data, pixel_size_x, axis=1), pixel_size_x, axis=1)\n    curvature_y = np.gradient(np.gradient(elevation_data, pixel_size_y, axis=0), pixel_size_y, axis=0)\n    curvature = curvature_x + curvature_y\n\n    return curvature\n\n  \ndef calculate_curvature(dem_file, sigma=1):\n    with rasterio.open(dem_file) as dataset:\n        # Read the DEM data as a numpy array\n        dem_data = dataset.read(1)\n\n        # Calculate the gradient using the Sobel filter\n        dx = sobel(dem_data, axis=1, mode='constant')\n        dy = sobel(dem_data, axis=0, mode='constant')\n\n        # Calculate the second derivatives using the Sobel filter\n        dxx = sobel(dx, axis=1, mode='constant')\n        dyy = sobel(dy, axis=0, mode='constant')\n\n        # Calculate the curvature using the second derivatives\n        curvature = dxx + dyy\n\n        # Smooth the curvature using Gaussian filtering (optional)\n        curvature = gaussian_filter(curvature, sigma)\n\n    return curvature\n  \ndef calculate_gradients(dem_file):\n    with rasterio.open(dem_file) as dataset:\n        # Read the DEM data as a numpy array\n        dem_data = dataset.read(1)\n\n        # Calculate the gradients along the North and East directions\n        dy, dx = np.gradient(dem_data, dataset.res[0], dataset.res[1])\n\n        # Calculate the Northness and Eastness\n        northness = np.arctan(dy / np.sqrt(dx**2 + dy**2))\n        eastness = np.arctan(dx / np.sqrt(dx**2 + dy**2))\n\n    return northness, eastness\n  \n  \ndef geotiff_to_csv(geotiff_file, csv_file, column_name):\n    # Open the GeoTIFF file\n    with rasterio.open(geotiff_file) as dataset:\n        # Get the pixel values as a 2D array\n        data = dataset.read(1)\n\n        # Get the geotransform to convert pixel coordinates to geographic coordinates\n        transform = dataset.transform\n\n        # Get the width and height of the GeoTIFF\n        height, width = data.shape\n\n        # Open the CSV file for writing\n        with open(csv_file, 'w', newline='') as csvfile:\n            csvwriter = csv.writer(csvfile)\n\n            # Write the CSV header\n            csvwriter.writerow(['Latitude', 'Longitude', 'x', 'y', column_name])\n\n            # Loop through each pixel and extract latitude, longitude, and image value\n            for y in range(height):\n                for x in range(width):\n                    # Get the pixel value\n                    image_value = data[y, x]\n\n                    # Convert pixel coordinates to geographic coordinates\n                    lon, lat = transform * (x, y)\n\n                    # Write the data to the CSV file\n                    csvwriter.writerow([lat, lon, x, y, image_value])\n\n  \ndef read_elevation_data(file_path, result_dem_csv_path, result_dem_feature_csv_path):\n    neighborhood_size=4\n    df = pd.read_csv(file_path)\n    \n    dataset = rasterio.open(geotiff_file)\n    data = dataset.read(1)\n\n    # Get the width and height of the GeoTIFF\n    height, width = data.shape\n    \n    # Create an empty DataFrame with column names\n    columns = ['lat', 'lon', 'elevation', 'slope', 'aspect', 'curvature', 'northness', 'eastness']\n    all_df = pd.DataFrame(columns=columns)\n    \n    all_df.to_csv(result_dem_feature_csv_path)\n    print(f\"DEM and other columns are saved to file {result_dem_feature_csv_path}\")\n    return all_df\n\n\n  \n# Usage example:\nresult_dem_csv_path = \"/home/chetana/gridmet_test_run/dem_template.csv\"\nresult_dem_feature_csv_path = \"/home/chetana/gridmet_test_run/dem_all.csv\"\n\n\ndem_file = \"/home/chetana/gridmet_test_run/dem_file.tif\"\nslope_file = '/home/chetana/gridmet_test_run/slope_file.tif'\naspect_file = '/home/chetana/gridmet_test_run/aspect_file.tif'\ncurvature_file = '/home/chetana/gridmet_test_run/curvature_file.tif'\nnorthness_file = '/home/chetana/gridmet_test_run/northness_file.tif'\neastness_file = '/home/chetana/gridmet_test_run/eastness_file.tif'\n\n\nslope, aspect = calculate_slope_aspect(dem_file)\ncurvature = calculate_curvature(dem_file)\nnorthness, eastness = calculate_gradients(dem_file)\n\n# Save the slope and aspect as new GeoTIFF files\nsave_as_geotiff(slope, slope_file, dem_file)\nsave_as_geotiff(aspect, aspect_file, dem_file)\nsave_as_geotiff(curvature, curvature_file, dem_file)\nsave_as_geotiff(northness, northness_file, dem_file)\nsave_as_geotiff(eastness, eastness_file, dem_file)\n\ngeotiff_to_csv(dem_file, dem_file+\".csv\", \"Elevation\")\ngeotiff_to_csv(slope_file, slope_file+\".csv\", \"Slope\")\ngeotiff_to_csv(aspect_file, aspect_file+\".csv\", \"Aspect\")\ngeotiff_to_csv(curvature_file, curvature_file+\".csv\", \"Curvature\")\ngeotiff_to_csv(northness_file, northness_file+\".csv\", \"Northness\")\ngeotiff_to_csv(eastness_file, eastness_file+\".csv\", \"Eastness\")\n\n# List of file paths for the CSV files\ncsv_files = [dem_file+\".csv\", slope_file+\".csv\", aspect_file+\".csv\", \n             curvature_file+\".csv\", northness_file+\".csv\", eastness_file+\".csv\"]\n\n# Initialize an empty list to store all dataframes\ndfs = []\n\n# Read each CSV file into separate dataframes\nfor file in csv_files:\n    df = pd.read_csv(file, encoding='utf-8')\n    dfs.append(df)\n\n# Merge the dataframes based on the latitude and longitude columns\nmerged_df = dfs[0]  # Start with the first dataframe\nfor i in range(1, len(dfs)):\n    merged_df = pd.merge(merged_df, dfs[i], on=['Latitude', 'Longitude', 'x', 'y'])\n\n# Save the merged dataframe to a new CSV file\nmerged_df.to_csv(result_dem_feature_csv_path, index=False)\n",
  "history_output" : "",
  "history_begin_time" : 1694969350763,
  "history_end_time" : 1694969353415,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Failed"
},{
  "history_id" : "mutode0w3ga",
  "history_input" : "import numpy as np\nimport pandas as pd\nfrom osgeo import gdal\nimport warnings\nimport rasterio\nimport csv\nfrom rasterio.transform import Affine\nfrom scipy.ndimage import sobel, gaussian_filter\n\n# Set the warning filter globally to ignore the FutureWarning\nwarnings.simplefilter(\"ignore\", FutureWarning)\n\ndef lat_lon_to_pixel(lat, lon, geotransform):\n    x = int((lon - geotransform[0]) / geotransform[1])\n    y = int((lat - geotransform[3]) / geotransform[5])\n    return x, y\n\n\ndef calculate_slope_aspect_for_single(elevation_data, pixel_size_x, pixel_size_y):\n    # Calculate slope using the Sobel operator\n    slope_x = np.gradient(elevation_data, pixel_size_x, axis=1)\n    slope_y = np.gradient(elevation_data, pixel_size_y, axis=0)\n    slope_rad = np.arctan(np.sqrt(slope_x ** 2 + slope_y ** 2))\n    slope_deg = np.degrees(slope_rad)\n\n    # Calculate aspect (direction of the steepest descent)\n    aspect_rad = np.arctan2(slope_y, -slope_x)\n    aspect_deg = (np.degrees(aspect_rad) + 360) % 360\n\n    return slope_deg, aspect_deg\n\n\ndef save_as_geotiff(data, output_file, src_file):\n    with rasterio.open(src_file) as src_dataset:\n        profile = src_dataset.profile\n        transform = src_dataset.transform\n\n        # Update the data type, count, and set the transform for the new dataset\n        profile.update(dtype=rasterio.float32, count=1, transform=transform)\n\n        # Create the new GeoTIFF file\n        with rasterio.open(output_file, 'w', **profile) as dst_dataset:\n            # Write the data to the new GeoTIFF\n            dst_dataset.write(data, 1)\n  \n\ndef calculate_slope_aspect(dem_file):\n    with rasterio.open(dem_file) as dataset:\n        # Read the DEM data as a numpy array\n        dem_data = dataset.read(1)\n\n        # Get the geotransform to convert pixel coordinates to geographic coordinates\n        transform = dataset.transform\n\n        # Calculate the slope and aspect using numpy\n        dx, dy = np.gradient(dem_data, transform[0], transform[4])\n        slope = np.arctan(np.sqrt(dx ** 2 + dy ** 2)) * (180.0 / np.pi)\n        aspect = np.arctan2(-dy, dx) * (180.0 / np.pi)\n\n        # Adjust aspect values to range from 0 to 360 degrees\n        aspect[aspect < 0] += 360\n        print(f\"slope shape: {slope.shape}\")\n        print(f\"aspect shape: {aspect.shape}\")\n        \n        \n    return slope, aspect\n  \ndef calculate_curvature(elevation_data, pixel_size_x, pixel_size_y):\n    # Calculate curvature using the Laplacian operator\n    curvature_x = np.gradient(np.gradient(elevation_data, pixel_size_x, axis=1), pixel_size_x, axis=1)\n    curvature_y = np.gradient(np.gradient(elevation_data, pixel_size_y, axis=0), pixel_size_y, axis=0)\n    curvature = curvature_x + curvature_y\n\n    return curvature\n\n  \ndef calculate_curvature(dem_file, sigma=1):\n    with rasterio.open(dem_file) as dataset:\n        # Read the DEM data as a numpy array\n        dem_data = dataset.read(1)\n\n        # Calculate the gradient using the Sobel filter\n        dx = sobel(dem_data, axis=1, mode='constant')\n        dy = sobel(dem_data, axis=0, mode='constant')\n\n        # Calculate the second derivatives using the Sobel filter\n        dxx = sobel(dx, axis=1, mode='constant')\n        dyy = sobel(dy, axis=0, mode='constant')\n\n        # Calculate the curvature using the second derivatives\n        curvature = dxx + dyy\n\n        # Smooth the curvature using Gaussian filtering (optional)\n        curvature = gaussian_filter(curvature, sigma)\n\n    return curvature\n  \ndef calculate_gradients(dem_file):\n    with rasterio.open(dem_file) as dataset:\n        # Read the DEM data as a numpy array\n        dem_data = dataset.read(1)\n\n        # Calculate the gradients along the North and East directions\n        dy, dx = np.gradient(dem_data, dataset.res[0], dataset.res[1])\n\n        # Calculate the Northness and Eastness\n        northness = np.arctan(dy / np.sqrt(dx**2 + dy**2))\n        eastness = np.arctan(dx / np.sqrt(dx**2 + dy**2))\n\n    return northness, eastness\n  \n  \ndef geotiff_to_csv(geotiff_file, csv_file, column_name):\n    # Open the GeoTIFF file\n    with rasterio.open(geotiff_file) as dataset:\n        # Get the pixel values as a 2D array\n        data = dataset.read(1)\n\n        # Get the geotransform to convert pixel coordinates to geographic coordinates\n        transform = dataset.transform\n\n        # Get the width and height of the GeoTIFF\n        height, width = data.shape\n\n        # Open the CSV file for writing\n        with open(csv_file, 'w', newline='') as csvfile:\n            csvwriter = csv.writer(csvfile)\n\n            # Write the CSV header\n            csvwriter.writerow(['Latitude', 'Longitude', 'x', 'y', column_name])\n\n            # Loop through each pixel and extract latitude, longitude, and image value\n            for y in range(height):\n                for x in range(width):\n                    # Get the pixel value\n                    image_value = data[y, x]\n\n                    # Convert pixel coordinates to geographic coordinates\n                    lon, lat = transform * (x, y)\n\n                    # Write the data to the CSV file\n                    csvwriter.writerow([lat, lon, x, y, image_value])\n\n  \ndef read_elevation_data(file_path, result_dem_csv_path, result_dem_feature_csv_path):\n    neighborhood_size=4\n    df = pd.read_csv(file_path)\n    \n    dataset = rasterio.open(geotiff_file)\n    data = dataset.read(1)\n\n    # Get the width and height of the GeoTIFF\n    height, width = data.shape\n    \n    # Create an empty DataFrame with column names\n    columns = ['lat', 'lon', 'elevation', 'slope', 'aspect', 'curvature', 'northness', 'eastness']\n    all_df = pd.DataFrame(columns=columns)\n    \n    all_df.to_csv(result_dem_feature_csv_path)\n    print(f\"DEM and other columns are saved to file {result_dem_feature_csv_path}\")\n    return all_df\n\n\n  \n# Usage example:\nresult_dem_csv_path = \"/home/chetana/gridmet_test_run/dem_template.csv\"\nresult_dem_feature_csv_path = \"/home/chetana/gridmet_test_run/dem_all.csv\"\n\n\ndem_file = \"/home/chetana/gridmet_test_run/dem_file.tif\"\nslope_file = '/home/chetana/gridmet_test_run/slope_file.tif'\naspect_file = '/home/chetana/gridmet_test_run/aspect_file.tif'\ncurvature_file = '/home/chetana/gridmet_test_run/curvature_file.tif'\nnorthness_file = '/home/chetana/gridmet_test_run/northness_file.tif'\neastness_file = '/home/chetana/gridmet_test_run/eastness_file.tif'\n\n\nslope, aspect = calculate_slope_aspect(dem_file)\ncurvature = calculate_curvature(dem_file)\nnorthness, eastness = calculate_gradients(dem_file)\n\n# Save the slope and aspect as new GeoTIFF files\nsave_as_geotiff(slope, slope_file, dem_file)\nsave_as_geotiff(aspect, aspect_file, dem_file)\nsave_as_geotiff(curvature, curvature_file, dem_file)\nsave_as_geotiff(northness, northness_file, dem_file)\nsave_as_geotiff(eastness, eastness_file, dem_file)\n\ngeotiff_to_csv(dem_file, dem_file+\".csv\", \"Elevation\")\ngeotiff_to_csv(slope_file, slope_file+\".csv\", \"Slope\")\ngeotiff_to_csv(aspect_file, aspect_file+\".csv\", \"Aspect\")\ngeotiff_to_csv(curvature_file, curvature_file+\".csv\", \"Curvature\")\ngeotiff_to_csv(northness_file, northness_file+\".csv\", \"Northness\")\ngeotiff_to_csv(eastness_file, eastness_file+\".csv\", \"Eastness\")\n\n# List of file paths for the CSV files\ncsv_files = [dem_file+\".csv\", slope_file+\".csv\", aspect_file+\".csv\", \n             curvature_file+\".csv\", northness_file+\".csv\", eastness_file+\".csv\"]\n\n# Initialize an empty list to store all dataframes\ndfs = []\n\n# Read each CSV file into separate dataframes\nfor file in csv_files:\n    df = pd.read_csv(file, encoding='utf-8')\n    dfs.append(df)\n\n# Merge the dataframes based on the latitude and longitude columns\nmerged_df = dfs[0]  # Start with the first dataframe\nfor i in range(1, len(dfs)):\n    merged_df = pd.merge(merged_df, dfs[i], on=['Latitude', 'Longitude', 'x', 'y'])\n\n# Save the merged dataframe to a new CSV file\nmerged_df.to_csv(result_dem_feature_csv_path, index=False)\n",
  "history_output" : "/home/chetana/gw-workspace/mutode0w3ga/western_us_dem.py:107: RuntimeWarning: invalid value encountered in true_divide\n  northness = np.arctan(dy / np.sqrt(dx**2 + dy**2))\n/home/chetana/gw-workspace/mutode0w3ga/western_us_dem.py:108: RuntimeWarning: invalid value encountered in true_divide\n  eastness = np.arctan(dx / np.sqrt(dx**2 + dy**2))\nslope shape: (666, 694)\naspect shape: (666, 694)\n",
  "history_begin_time" : 1694905308580,
  "history_end_time" : 1694905325440,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Done"
},{
  "history_id" : "dzkk0pd1vvy",
  "history_input" : "import numpy as np\nimport pandas as pd\nfrom osgeo import gdal\nimport warnings\nimport rasterio\nimport csv\nfrom rasterio.transform import Affine\nfrom scipy.ndimage import sobel, gaussian_filter\n\n# Set the warning filter globally to ignore the FutureWarning\nwarnings.simplefilter(\"ignore\", FutureWarning)\n\ndef lat_lon_to_pixel(lat, lon, geotransform):\n    x = int((lon - geotransform[0]) / geotransform[1])\n    y = int((lat - geotransform[3]) / geotransform[5])\n    return x, y\n\n\ndef calculate_slope_aspect_for_single(elevation_data, pixel_size_x, pixel_size_y):\n    # Calculate slope using the Sobel operator\n    slope_x = np.gradient(elevation_data, pixel_size_x, axis=1)\n    slope_y = np.gradient(elevation_data, pixel_size_y, axis=0)\n    slope_rad = np.arctan(np.sqrt(slope_x ** 2 + slope_y ** 2))\n    slope_deg = np.degrees(slope_rad)\n\n    # Calculate aspect (direction of the steepest descent)\n    aspect_rad = np.arctan2(slope_y, -slope_x)\n    aspect_deg = (np.degrees(aspect_rad) + 360) % 360\n\n    return slope_deg, aspect_deg\n\n\ndef save_as_geotiff(data, output_file, src_file):\n    with rasterio.open(src_file) as src_dataset:\n        profile = src_dataset.profile\n        transform = src_dataset.transform\n\n        # Update the data type, count, and set the transform for the new dataset\n        profile.update(dtype=rasterio.float32, count=1, transform=transform)\n\n        # Create the new GeoTIFF file\n        with rasterio.open(output_file, 'w', **profile) as dst_dataset:\n            # Write the data to the new GeoTIFF\n            dst_dataset.write(data, 1)\n  \n\ndef calculate_slope_aspect(dem_file):\n    with rasterio.open(dem_file) as dataset:\n        # Read the DEM data as a numpy array\n        dem_data = dataset.read(1)\n\n        # Get the geotransform to convert pixel coordinates to geographic coordinates\n        transform = dataset.transform\n\n        # Calculate the slope and aspect using numpy\n        dx, dy = np.gradient(dem_data, transform[0], transform[4])\n        slope = np.arctan(np.sqrt(dx ** 2 + dy ** 2)) * (180.0 / np.pi)\n        aspect = np.arctan2(-dy, dx) * (180.0 / np.pi)\n\n        # Adjust aspect values to range from 0 to 360 degrees\n        aspect[aspect < 0] += 360\n        print(f\"slope shape: {slope.shape}\")\n        print(f\"aspect shape: {aspect.shape}\")\n        \n        \n    return slope, aspect\n  \ndef calculate_curvature(elevation_data, pixel_size_x, pixel_size_y):\n    # Calculate curvature using the Laplacian operator\n    curvature_x = np.gradient(np.gradient(elevation_data, pixel_size_x, axis=1), pixel_size_x, axis=1)\n    curvature_y = np.gradient(np.gradient(elevation_data, pixel_size_y, axis=0), pixel_size_y, axis=0)\n    curvature = curvature_x + curvature_y\n\n    return curvature\n\n  \ndef calculate_curvature(dem_file, sigma=1):\n    with rasterio.open(dem_file) as dataset:\n        # Read the DEM data as a numpy array\n        dem_data = dataset.read(1)\n\n        # Calculate the gradient using the Sobel filter\n        dx = sobel(dem_data, axis=1, mode='constant')\n        dy = sobel(dem_data, axis=0, mode='constant')\n\n        # Calculate the second derivatives using the Sobel filter\n        dxx = sobel(dx, axis=1, mode='constant')\n        dyy = sobel(dy, axis=0, mode='constant')\n\n        # Calculate the curvature using the second derivatives\n        curvature = dxx + dyy\n\n        # Smooth the curvature using Gaussian filtering (optional)\n        curvature = gaussian_filter(curvature, sigma)\n\n    return curvature\n  \ndef calculate_gradients(dem_file):\n    with rasterio.open(dem_file) as dataset:\n        # Read the DEM data as a numpy array\n        dem_data = dataset.read(1)\n\n        # Calculate the gradients along the North and East directions\n        dy, dx = np.gradient(dem_data, dataset.res[0], dataset.res[1])\n\n        # Calculate the Northness and Eastness\n        northness = np.arctan(dy / np.sqrt(dx**2 + dy**2))\n        eastness = np.arctan(dx / np.sqrt(dx**2 + dy**2))\n\n    return northness, eastness\n  \n  \ndef geotiff_to_csv(geotiff_file, csv_file, column_name):\n    # Open the GeoTIFF file\n    with rasterio.open(geotiff_file) as dataset:\n        # Get the pixel values as a 2D array\n        data = dataset.read(1)\n\n        # Get the geotransform to convert pixel coordinates to geographic coordinates\n        transform = dataset.transform\n\n        # Get the width and height of the GeoTIFF\n        height, width = data.shape\n\n        # Open the CSV file for writing\n        with open(csv_file, 'w', newline='') as csvfile:\n            csvwriter = csv.writer(csvfile)\n\n            # Write the CSV header\n            csvwriter.writerow(['Latitude', 'Longitude', 'x', 'y', column_name])\n\n            # Loop through each pixel and extract latitude, longitude, and image value\n            for y in range(height):\n                for x in range(width):\n                    # Get the pixel value\n                    image_value = data[y, x]\n\n                    # Convert pixel coordinates to geographic coordinates\n                    lon, lat = transform * (x, y)\n\n                    # Write the data to the CSV file\n                    csvwriter.writerow([lat, lon, x, y, image_value])\n\n  \ndef read_elevation_data(file_path, result_dem_csv_path, result_dem_feature_csv_path):\n    neighborhood_size=4\n    df = pd.read_csv(file_path)\n    \n    dataset = rasterio.open(geotiff_file)\n    data = dataset.read(1)\n\n    # Get the width and height of the GeoTIFF\n    height, width = data.shape\n    \n    # Create an empty DataFrame with column names\n    columns = ['lat', 'lon', 'elevation', 'slope', 'aspect', 'curvature', 'northness', 'eastness']\n    all_df = pd.DataFrame(columns=columns)\n    \n    all_df.to_csv(result_dem_feature_csv_path)\n    print(f\"DEM and other columns are saved to file {result_dem_feature_csv_path}\")\n    return all_df\n\n\n  \n# Usage example:\nresult_dem_csv_path = \"/home/chetana/gridmet_test_run/dem_template.csv\"\nresult_dem_feature_csv_path = \"/home/chetana/gridmet_test_run/dem_all.csv\"\n\n\ndem_file = \"/home/chetana/gridmet_test_run/dem_file.tif\"\nslope_file = '/home/chetana/gridmet_test_run/slope_file.tif'\naspect_file = '/home/chetana/gridmet_test_run/aspect_file.tif'\ncurvature_file = '/home/chetana/gridmet_test_run/curvature_file.tif'\nnorthness_file = '/home/chetana/gridmet_test_run/northness_file.tif'\neastness_file = '/home/chetana/gridmet_test_run/eastness_file.tif'\n\n\nslope, aspect = calculate_slope_aspect(dem_file)\ncurvature = calculate_curvature(dem_file)\nnorthness, eastness = calculate_gradients(dem_file)\n\n# Save the slope and aspect as new GeoTIFF files\nsave_as_geotiff(slope, slope_file, dem_file)\nsave_as_geotiff(aspect, aspect_file, dem_file)\nsave_as_geotiff(curvature, curvature_file, dem_file)\nsave_as_geotiff(northness, northness_file, dem_file)\nsave_as_geotiff(eastness, eastness_file, dem_file)\n\ngeotiff_to_csv(dem_file, dem_file+\".csv\", \"Elevation\")\ngeotiff_to_csv(slope_file, slope_file+\".csv\", \"Slope\")\ngeotiff_to_csv(aspect_file, aspect_file+\".csv\", \"Aspect\")\ngeotiff_to_csv(curvature_file, curvature_file+\".csv\", \"Curvature\")\ngeotiff_to_csv(northness_file, northness_file+\".csv\", \"Northness\")\ngeotiff_to_csv(eastness_file, eastness_file+\".csv\", \"Eastness\")\n\n# List of file paths for the CSV files\ncsv_files = [dem_file+\".csv\", slope_file+\".csv\", aspect_file+\".csv\", \n             curvature_file+\".csv\", northness_file+\".csv\", eastness_file+\".csv\"]\n\n# Initialize an empty list to store all dataframes\ndfs = []\n\n# Read each CSV file into separate dataframes\nfor file in csv_files:\n    df = pd.read_csv(file, encoding='utf-8')\n    dfs.append(df)\n\n# Merge the dataframes based on the latitude and longitude columns\nmerged_df = dfs[0]  # Start with the first dataframe\nfor i in range(1, len(dfs)):\n    merged_df = pd.merge(merged_df, dfs[i], on=['Latitude', 'Longitude', 'x', 'y'])\n\n# Save the merged dataframe to a new CSV file\nmerged_df.to_csv(result_dem_feature_csv_path, index=False)\n",
  "history_output" : "/home/chetana/gw-workspace/dzkk0pd1vvy/western_us_dem.py:107: RuntimeWarning: invalid value encountered in true_divide\n  northness = np.arctan(dy / np.sqrt(dx**2 + dy**2))\n/home/chetana/gw-workspace/dzkk0pd1vvy/western_us_dem.py:108: RuntimeWarning: invalid value encountered in true_divide\n  eastness = np.arctan(dx / np.sqrt(dx**2 + dy**2))\nslope shape: (666, 694)\naspect shape: (666, 694)\n",
  "history_begin_time" : 1694897888115,
  "history_end_time" : 1694897919598,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "100001",
  "indicator" : "Done"
},{
  "history_id" : "hE55anLijRks",
  "history_input" : "import numpy as np\nimport pandas as pd\nfrom osgeo import gdal\nimport warnings\nimport rasterio\nimport csv\nfrom rasterio.transform import Affine\nfrom scipy.ndimage import sobel, gaussian_filter\n\n# Set the warning filter globally to ignore the FutureWarning\nwarnings.simplefilter(\"ignore\", FutureWarning)\n\ndef lat_lon_to_pixel(lat, lon, geotransform):\n    x = int((lon - geotransform[0]) / geotransform[1])\n    y = int((lat - geotransform[3]) / geotransform[5])\n    return x, y\n\n\ndef calculate_slope_aspect_for_single(elevation_data, pixel_size_x, pixel_size_y):\n    # Calculate slope using the Sobel operator\n    slope_x = np.gradient(elevation_data, pixel_size_x, axis=1)\n    slope_y = np.gradient(elevation_data, pixel_size_y, axis=0)\n    slope_rad = np.arctan(np.sqrt(slope_x ** 2 + slope_y ** 2))\n    slope_deg = np.degrees(slope_rad)\n\n    # Calculate aspect (direction of the steepest descent)\n    aspect_rad = np.arctan2(slope_y, -slope_x)\n    aspect_deg = (np.degrees(aspect_rad) + 360) % 360\n\n    return slope_deg, aspect_deg\n\n\ndef save_as_geotiff(data, output_file, src_file):\n    with rasterio.open(src_file) as src_dataset:\n        profile = src_dataset.profile\n        transform = src_dataset.transform\n\n        # Update the data type, count, and set the transform for the new dataset\n        profile.update(dtype=rasterio.float32, count=1, transform=transform)\n\n        # Create the new GeoTIFF file\n        with rasterio.open(output_file, 'w', **profile) as dst_dataset:\n            # Write the data to the new GeoTIFF\n            dst_dataset.write(data, 1)\n  \n\ndef calculate_slope_aspect(dem_file):\n    with rasterio.open(dem_file) as dataset:\n        # Read the DEM data as a numpy array\n        dem_data = dataset.read(1)\n\n        # Get the geotransform to convert pixel coordinates to geographic coordinates\n        transform = dataset.transform\n\n        # Calculate the slope and aspect using numpy\n        dx, dy = np.gradient(dem_data, transform[0], transform[4])\n        slope = np.arctan(np.sqrt(dx ** 2 + dy ** 2)) * (180.0 / np.pi)\n        aspect = np.arctan2(-dy, dx) * (180.0 / np.pi)\n\n        # Adjust aspect values to range from 0 to 360 degrees\n        aspect[aspect < 0] += 360\n        print(f\"slope shape: {slope.shape}\")\n        print(f\"aspect shape: {aspect.shape}\")\n        \n        \n    return slope, aspect\n  \ndef calculate_curvature(elevation_data, pixel_size_x, pixel_size_y):\n    # Calculate curvature using the Laplacian operator\n    curvature_x = np.gradient(np.gradient(elevation_data, pixel_size_x, axis=1), pixel_size_x, axis=1)\n    curvature_y = np.gradient(np.gradient(elevation_data, pixel_size_y, axis=0), pixel_size_y, axis=0)\n    curvature = curvature_x + curvature_y\n\n    return curvature\n\n  \ndef calculate_curvature(dem_file, sigma=1):\n    with rasterio.open(dem_file) as dataset:\n        # Read the DEM data as a numpy array\n        dem_data = dataset.read(1)\n\n        # Calculate the gradient using the Sobel filter\n        dx = sobel(dem_data, axis=1, mode='constant')\n        dy = sobel(dem_data, axis=0, mode='constant')\n\n        # Calculate the second derivatives using the Sobel filter\n        dxx = sobel(dx, axis=1, mode='constant')\n        dyy = sobel(dy, axis=0, mode='constant')\n\n        # Calculate the curvature using the second derivatives\n        curvature = dxx + dyy\n\n        # Smooth the curvature using Gaussian filtering (optional)\n        curvature = gaussian_filter(curvature, sigma)\n\n    return curvature\n  \ndef calculate_gradients(dem_file):\n    with rasterio.open(dem_file) as dataset:\n        # Read the DEM data as a numpy array\n        dem_data = dataset.read(1)\n\n        # Calculate the gradients along the North and East directions\n        dy, dx = np.gradient(dem_data, dataset.res[0], dataset.res[1])\n\n        # Calculate the Northness and Eastness\n        northness = np.arctan(dy / np.sqrt(dx**2 + dy**2))\n        eastness = np.arctan(dx / np.sqrt(dx**2 + dy**2))\n\n    return northness, eastness\n  \n  \ndef geotiff_to_csv(geotiff_file, csv_file, column_name):\n    # Open the GeoTIFF file\n    with rasterio.open(geotiff_file) as dataset:\n        # Get the pixel values as a 2D array\n        data = dataset.read(1)\n\n        # Get the geotransform to convert pixel coordinates to geographic coordinates\n        transform = dataset.transform\n\n        # Get the width and height of the GeoTIFF\n        height, width = data.shape\n\n        # Open the CSV file for writing\n        with open(csv_file, 'w', newline='') as csvfile:\n            csvwriter = csv.writer(csvfile)\n\n            # Write the CSV header\n            csvwriter.writerow(['Latitude', 'Longitude', 'x', 'y', column_name])\n\n            # Loop through each pixel and extract latitude, longitude, and image value\n            for y in range(height):\n                for x in range(width):\n                    # Get the pixel value\n                    image_value = data[y, x]\n\n                    # Convert pixel coordinates to geographic coordinates\n                    lon, lat = transform * (x, y)\n\n                    # Write the data to the CSV file\n                    csvwriter.writerow([lat, lon, x, y, image_value])\n\n  \ndef read_elevation_data(file_path, result_dem_csv_path, result_dem_feature_csv_path):\n    neighborhood_size=4\n    df = pd.read_csv(file_path)\n    \n    dataset = rasterio.open(geotiff_file)\n    data = dataset.read(1)\n\n    # Get the width and height of the GeoTIFF\n    height, width = data.shape\n    \n    # Create an empty DataFrame with column names\n    columns = ['lat', 'lon', 'elevation', 'slope', 'aspect', 'curvature', 'northness', 'eastness']\n    all_df = pd.DataFrame(columns=columns)\n    \n    all_df.to_csv(result_dem_feature_csv_path)\n    print(f\"DEM and other columns are saved to file {result_dem_feature_csv_path}\")\n    return all_df\n\n\n  \n# Usage example:\nresult_dem_csv_path = \"/home/chetana/gridmet_test_run/dem_template.csv\"\nresult_dem_feature_csv_path = \"/home/chetana/gridmet_test_run/dem_all.csv\"\n\n\ndem_file = \"/home/chetana/gridmet_test_run/dem_file.tif\"\nslope_file = '/home/chetana/gridmet_test_run/slope_file.tif'\naspect_file = '/home/chetana/gridmet_test_run/aspect_file.tif'\ncurvature_file = '/home/chetana/gridmet_test_run/curvature_file.tif'\nnorthness_file = '/home/chetana/gridmet_test_run/northness_file.tif'\neastness_file = '/home/chetana/gridmet_test_run/eastness_file.tif'\n\n\nslope, aspect = calculate_slope_aspect(dem_file)\ncurvature = calculate_curvature(dem_file)\nnorthness, eastness = calculate_gradients(dem_file)\n\n# Save the slope and aspect as new GeoTIFF files\nsave_as_geotiff(slope, slope_file, dem_file)\nsave_as_geotiff(aspect, aspect_file, dem_file)\nsave_as_geotiff(curvature, curvature_file, dem_file)\nsave_as_geotiff(northness, northness_file, dem_file)\nsave_as_geotiff(eastness, eastness_file, dem_file)\n\ngeotiff_to_csv(dem_file, dem_file+\".csv\", \"Elevation\")\ngeotiff_to_csv(slope_file, slope_file+\".csv\", \"Slope\")\ngeotiff_to_csv(aspect_file, aspect_file+\".csv\", \"Aspect\")\ngeotiff_to_csv(curvature_file, curvature_file+\".csv\", \"Curvature\")\ngeotiff_to_csv(northness_file, northness_file+\".csv\", \"Northness\")\ngeotiff_to_csv(eastness_file, eastness_file+\".csv\", \"Eastness\")\n\n# List of file paths for the CSV files\ncsv_files = [dem_file+\".csv\", slope_file+\".csv\", aspect_file+\".csv\", \n             curvature_file+\".csv\", northness_file+\".csv\", eastness_file+\".csv\"]\n\n# Initialize an empty list to store all dataframes\ndfs = []\n\n# Read each CSV file into separate dataframes\nfor file in csv_files:\n    df = pd.read_csv(file, encoding='utf-8')\n    dfs.append(df)\n\n# Merge the dataframes based on the latitude and longitude columns\nmerged_df = dfs[0]  # Start with the first dataframe\nfor i in range(1, len(dfs)):\n    merged_df = pd.merge(merged_df, dfs[i], on=['Latitude', 'Longitude', 'x', 'y'])\n\n# Save the merged dataframe to a new CSV file\nmerged_df.to_csv(result_dem_feature_csv_path, index=False)\n",
  "history_output" : "Traceback (most recent call last):\n  File \"/home/chetana/gw-workspace/hE55anLijRks/western_us_dem.py\", line 3, in <module>\n    from osgeo import gdal\nModuleNotFoundError: No module named 'osgeo'\n",
  "history_begin_time" : 1694572934611,
  "history_end_time" : 1694572936020,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "R5TVBfp1G5r4",
  "history_input" : "import numpy as np\nimport pandas as pd\nfrom osgeo import gdal\nimport warnings\nimport rasterio\nimport csv\nfrom rasterio.transform import Affine\nfrom scipy.ndimage import sobel, gaussian_filter\n\n# Set the warning filter globally to ignore the FutureWarning\nwarnings.simplefilter(\"ignore\", FutureWarning)\n\ndef lat_lon_to_pixel(lat, lon, geotransform):\n    x = int((lon - geotransform[0]) / geotransform[1])\n    y = int((lat - geotransform[3]) / geotransform[5])\n    return x, y\n\n\ndef calculate_slope_aspect_for_single(elevation_data, pixel_size_x, pixel_size_y):\n    # Calculate slope using the Sobel operator\n    slope_x = np.gradient(elevation_data, pixel_size_x, axis=1)\n    slope_y = np.gradient(elevation_data, pixel_size_y, axis=0)\n    slope_rad = np.arctan(np.sqrt(slope_x ** 2 + slope_y ** 2))\n    slope_deg = np.degrees(slope_rad)\n\n    # Calculate aspect (direction of the steepest descent)\n    aspect_rad = np.arctan2(slope_y, -slope_x)\n    aspect_deg = (np.degrees(aspect_rad) + 360) % 360\n\n    return slope_deg, aspect_deg\n\n\ndef save_as_geotiff(data, output_file, src_file):\n    with rasterio.open(src_file) as src_dataset:\n        profile = src_dataset.profile\n        transform = src_dataset.transform\n\n        # Update the data type, count, and set the transform for the new dataset\n        profile.update(dtype=rasterio.float32, count=1, transform=transform)\n\n        # Create the new GeoTIFF file\n        with rasterio.open(output_file, 'w', **profile) as dst_dataset:\n            # Write the data to the new GeoTIFF\n            dst_dataset.write(data, 1)\n  \n\ndef calculate_slope_aspect(dem_file):\n    with rasterio.open(dem_file) as dataset:\n        # Read the DEM data as a numpy array\n        dem_data = dataset.read(1)\n\n        # Get the geotransform to convert pixel coordinates to geographic coordinates\n        transform = dataset.transform\n\n        # Calculate the slope and aspect using numpy\n        dx, dy = np.gradient(dem_data, transform[0], transform[4])\n        slope = np.arctan(np.sqrt(dx ** 2 + dy ** 2)) * (180.0 / np.pi)\n        aspect = np.arctan2(-dy, dx) * (180.0 / np.pi)\n\n        # Adjust aspect values to range from 0 to 360 degrees\n        aspect[aspect < 0] += 360\n        print(f\"slope shape: {slope.shape}\")\n        print(f\"aspect shape: {aspect.shape}\")\n        \n        \n    return slope, aspect\n  \ndef calculate_curvature(elevation_data, pixel_size_x, pixel_size_y):\n    # Calculate curvature using the Laplacian operator\n    curvature_x = np.gradient(np.gradient(elevation_data, pixel_size_x, axis=1), pixel_size_x, axis=1)\n    curvature_y = np.gradient(np.gradient(elevation_data, pixel_size_y, axis=0), pixel_size_y, axis=0)\n    curvature = curvature_x + curvature_y\n\n    return curvature\n\n  \ndef calculate_curvature(dem_file, sigma=1):\n    with rasterio.open(dem_file) as dataset:\n        # Read the DEM data as a numpy array\n        dem_data = dataset.read(1)\n\n        # Calculate the gradient using the Sobel filter\n        dx = sobel(dem_data, axis=1, mode='constant')\n        dy = sobel(dem_data, axis=0, mode='constant')\n\n        # Calculate the second derivatives using the Sobel filter\n        dxx = sobel(dx, axis=1, mode='constant')\n        dyy = sobel(dy, axis=0, mode='constant')\n\n        # Calculate the curvature using the second derivatives\n        curvature = dxx + dyy\n\n        # Smooth the curvature using Gaussian filtering (optional)\n        curvature = gaussian_filter(curvature, sigma)\n\n    return curvature\n  \ndef calculate_gradients(dem_file):\n    with rasterio.open(dem_file) as dataset:\n        # Read the DEM data as a numpy array\n        dem_data = dataset.read(1)\n\n        # Calculate the gradients along the North and East directions\n        dy, dx = np.gradient(dem_data, dataset.res[0], dataset.res[1])\n\n        # Calculate the Northness and Eastness\n        northness = np.arctan(dy / np.sqrt(dx**2 + dy**2))\n        eastness = np.arctan(dx / np.sqrt(dx**2 + dy**2))\n\n    return northness, eastness\n  \n  \ndef geotiff_to_csv(geotiff_file, csv_file, column_name):\n    # Open the GeoTIFF file\n    with rasterio.open(geotiff_file) as dataset:\n        # Get the pixel values as a 2D array\n        data = dataset.read(1)\n\n        # Get the geotransform to convert pixel coordinates to geographic coordinates\n        transform = dataset.transform\n\n        # Get the width and height of the GeoTIFF\n        height, width = data.shape\n\n        # Open the CSV file for writing\n        with open(csv_file, 'w', newline='') as csvfile:\n            csvwriter = csv.writer(csvfile)\n\n            # Write the CSV header\n            csvwriter.writerow(['Latitude', 'Longitude', 'x', 'y', column_name])\n\n            # Loop through each pixel and extract latitude, longitude, and image value\n            for y in range(height):\n                for x in range(width):\n                    # Get the pixel value\n                    image_value = data[y, x]\n\n                    # Convert pixel coordinates to geographic coordinates\n                    lon, lat = transform * (x, y)\n\n                    # Write the data to the CSV file\n                    csvwriter.writerow([lat, lon, x, y, image_value])\n\n  \ndef read_elevation_data(file_path, result_dem_csv_path, result_dem_feature_csv_path):\n    neighborhood_size=4\n    df = pd.read_csv(file_path)\n    \n    dataset = rasterio.open(geotiff_file)\n    data = dataset.read(1)\n\n    # Get the width and height of the GeoTIFF\n    height, width = data.shape\n    \n    # Create an empty DataFrame with column names\n    columns = ['lat', 'lon', 'elevation', 'slope', 'aspect', 'curvature', 'northness', 'eastness']\n    all_df = pd.DataFrame(columns=columns)\n    \n    all_df.to_csv(result_dem_feature_csv_path)\n    print(f\"DEM and other columns are saved to file {result_dem_feature_csv_path}\")\n    return all_df\n\n\n  \n# Usage example:\nresult_dem_csv_path = \"/home/chetana/gridmet_test_run/dem_template.csv\"\nresult_dem_feature_csv_path = \"/home/chetana/gridmet_test_run/dem_all.csv\"\n\n\ndem_file = \"/home/chetana/gridmet_test_run/dem_file.tif\"\nslope_file = '/home/chetana/gridmet_test_run/slope_file.tif'\naspect_file = '/home/chetana/gridmet_test_run/aspect_file.tif'\ncurvature_file = '/home/chetana/gridmet_test_run/curvature_file.tif'\nnorthness_file = '/home/chetana/gridmet_test_run/northness_file.tif'\neastness_file = '/home/chetana/gridmet_test_run/eastness_file.tif'\n\n\nslope, aspect = calculate_slope_aspect(dem_file)\ncurvature = calculate_curvature(dem_file)\nnorthness, eastness = calculate_gradients(dem_file)\n\n# Save the slope and aspect as new GeoTIFF files\nsave_as_geotiff(slope, slope_file, dem_file)\nsave_as_geotiff(aspect, aspect_file, dem_file)\nsave_as_geotiff(curvature, curvature_file, dem_file)\nsave_as_geotiff(northness, northness_file, dem_file)\nsave_as_geotiff(eastness, eastness_file, dem_file)\n\ngeotiff_to_csv(dem_file, dem_file+\".csv\", \"Elevation\")\ngeotiff_to_csv(slope_file, slope_file+\".csv\", \"Slope\")\ngeotiff_to_csv(aspect_file, aspect_file+\".csv\", \"Aspect\")\ngeotiff_to_csv(curvature_file, curvature_file+\".csv\", \"Curvature\")\ngeotiff_to_csv(northness_file, northness_file+\".csv\", \"Northness\")\ngeotiff_to_csv(eastness_file, eastness_file+\".csv\", \"Eastness\")\n\n# List of file paths for the CSV files\ncsv_files = [dem_file+\".csv\", slope_file+\".csv\", aspect_file+\".csv\", \n             curvature_file+\".csv\", northness_file+\".csv\", eastness_file+\".csv\"]\n\n# Initialize an empty list to store all dataframes\ndfs = []\n\n# Read each CSV file into separate dataframes\nfor file in csv_files:\n    df = pd.read_csv(file, encoding='utf-8')\n    dfs.append(df)\n\n# Merge the dataframes based on the latitude and longitude columns\nmerged_df = dfs[0]  # Start with the first dataframe\nfor i in range(1, len(dfs)):\n    merged_df = pd.merge(merged_df, dfs[i], on=['Latitude', 'Longitude', 'x', 'y'])\n\n# Save the merged dataframe to a new CSV file\nmerged_df.to_csv(result_dem_feature_csv_path, index=False)\n",
  "history_output" : "Traceback (most recent call last):\n  File \"/home/chetana/gw-workspace/R5TVBfp1G5r4/western_us_dem.py\", line 3, in <module>\n    from osgeo import gdal\nModuleNotFoundError: No module named 'osgeo'\n",
  "history_begin_time" : 1694572722936,
  "history_end_time" : 1694572724372,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "w5ugVPUQvyAy",
  "history_input" : "import numpy as np\nimport pandas as pd\nfrom osgeo import gdal\nimport warnings\nimport rasterio\nimport csv\nfrom rasterio.transform import Affine\nfrom scipy.ndimage import sobel, gaussian_filter\n\n# Set the warning filter globally to ignore the FutureWarning\nwarnings.simplefilter(\"ignore\", FutureWarning)\n\ndef lat_lon_to_pixel(lat, lon, geotransform):\n    x = int((lon - geotransform[0]) / geotransform[1])\n    y = int((lat - geotransform[3]) / geotransform[5])\n    return x, y\n\n\ndef calculate_slope_aspect_for_single(elevation_data, pixel_size_x, pixel_size_y):\n    # Calculate slope using the Sobel operator\n    slope_x = np.gradient(elevation_data, pixel_size_x, axis=1)\n    slope_y = np.gradient(elevation_data, pixel_size_y, axis=0)\n    slope_rad = np.arctan(np.sqrt(slope_x ** 2 + slope_y ** 2))\n    slope_deg = np.degrees(slope_rad)\n\n    # Calculate aspect (direction of the steepest descent)\n    aspect_rad = np.arctan2(slope_y, -slope_x)\n    aspect_deg = (np.degrees(aspect_rad) + 360) % 360\n\n    return slope_deg, aspect_deg\n\n\ndef save_as_geotiff(data, output_file, src_file):\n    with rasterio.open(src_file) as src_dataset:\n        profile = src_dataset.profile\n        transform = src_dataset.transform\n\n        # Update the data type, count, and set the transform for the new dataset\n        profile.update(dtype=rasterio.float32, count=1, transform=transform)\n\n        # Create the new GeoTIFF file\n        with rasterio.open(output_file, 'w', **profile) as dst_dataset:\n            # Write the data to the new GeoTIFF\n            dst_dataset.write(data, 1)\n  \n\ndef calculate_slope_aspect(dem_file):\n    with rasterio.open(dem_file) as dataset:\n        # Read the DEM data as a numpy array\n        dem_data = dataset.read(1)\n\n        # Get the geotransform to convert pixel coordinates to geographic coordinates\n        transform = dataset.transform\n\n        # Calculate the slope and aspect using numpy\n        dx, dy = np.gradient(dem_data, transform[0], transform[4])\n        slope = np.arctan(np.sqrt(dx ** 2 + dy ** 2)) * (180.0 / np.pi)\n        aspect = np.arctan2(-dy, dx) * (180.0 / np.pi)\n\n        # Adjust aspect values to range from 0 to 360 degrees\n        aspect[aspect < 0] += 360\n        print(f\"slope shape: {slope.shape}\")\n        print(f\"aspect shape: {aspect.shape}\")\n        \n        \n    return slope, aspect\n  \ndef calculate_curvature(elevation_data, pixel_size_x, pixel_size_y):\n    # Calculate curvature using the Laplacian operator\n    curvature_x = np.gradient(np.gradient(elevation_data, pixel_size_x, axis=1), pixel_size_x, axis=1)\n    curvature_y = np.gradient(np.gradient(elevation_data, pixel_size_y, axis=0), pixel_size_y, axis=0)\n    curvature = curvature_x + curvature_y\n\n    return curvature\n\n  \ndef calculate_curvature(dem_file, sigma=1):\n    with rasterio.open(dem_file) as dataset:\n        # Read the DEM data as a numpy array\n        dem_data = dataset.read(1)\n\n        # Calculate the gradient using the Sobel filter\n        dx = sobel(dem_data, axis=1, mode='constant')\n        dy = sobel(dem_data, axis=0, mode='constant')\n\n        # Calculate the second derivatives using the Sobel filter\n        dxx = sobel(dx, axis=1, mode='constant')\n        dyy = sobel(dy, axis=0, mode='constant')\n\n        # Calculate the curvature using the second derivatives\n        curvature = dxx + dyy\n\n        # Smooth the curvature using Gaussian filtering (optional)\n        curvature = gaussian_filter(curvature, sigma)\n\n    return curvature\n  \ndef calculate_gradients(dem_file):\n    with rasterio.open(dem_file) as dataset:\n        # Read the DEM data as a numpy array\n        dem_data = dataset.read(1)\n\n        # Calculate the gradients along the North and East directions\n        dy, dx = np.gradient(dem_data, dataset.res[0], dataset.res[1])\n\n        # Calculate the Northness and Eastness\n        northness = np.arctan(dy / np.sqrt(dx**2 + dy**2))\n        eastness = np.arctan(dx / np.sqrt(dx**2 + dy**2))\n\n    return northness, eastness\n  \n  \ndef geotiff_to_csv(geotiff_file, csv_file, column_name):\n    # Open the GeoTIFF file\n    with rasterio.open(geotiff_file) as dataset:\n        # Get the pixel values as a 2D array\n        data = dataset.read(1)\n\n        # Get the geotransform to convert pixel coordinates to geographic coordinates\n        transform = dataset.transform\n\n        # Get the width and height of the GeoTIFF\n        height, width = data.shape\n\n        # Open the CSV file for writing\n        with open(csv_file, 'w', newline='') as csvfile:\n            csvwriter = csv.writer(csvfile)\n\n            # Write the CSV header\n            csvwriter.writerow(['Latitude', 'Longitude', 'x', 'y', column_name])\n\n            # Loop through each pixel and extract latitude, longitude, and image value\n            for y in range(height):\n                for x in range(width):\n                    # Get the pixel value\n                    image_value = data[y, x]\n\n                    # Convert pixel coordinates to geographic coordinates\n                    lon, lat = transform * (x, y)\n\n                    # Write the data to the CSV file\n                    csvwriter.writerow([lat, lon, x, y, image_value])\n\n  \ndef read_elevation_data(file_path, result_dem_csv_path, result_dem_feature_csv_path):\n    neighborhood_size=4\n    df = pd.read_csv(file_path)\n    \n    dataset = rasterio.open(geotiff_file)\n    data = dataset.read(1)\n\n    # Get the width and height of the GeoTIFF\n    height, width = data.shape\n    \n    # Create an empty DataFrame with column names\n    columns = ['lat', 'lon', 'elevation', 'slope', 'aspect', 'curvature', 'northness', 'eastness']\n    all_df = pd.DataFrame(columns=columns)\n    \n    all_df.to_csv(result_dem_feature_csv_path)\n    print(f\"DEM and other columns are saved to file {result_dem_feature_csv_path}\")\n    return all_df\n\n\n  \n# Usage example:\nresult_dem_csv_path = \"/home/chetana/gridmet_test_run/dem_template.csv\"\nresult_dem_feature_csv_path = \"/home/chetana/gridmet_test_run/dem_all.csv\"\n\n\ndem_file = \"/home/chetana/gridmet_test_run/dem_file.tif\"\nslope_file = '/home/chetana/gridmet_test_run/slope_file.tif'\naspect_file = '/home/chetana/gridmet_test_run/aspect_file.tif'\ncurvature_file = '/home/chetana/gridmet_test_run/curvature_file.tif'\nnorthness_file = '/home/chetana/gridmet_test_run/northness_file.tif'\neastness_file = '/home/chetana/gridmet_test_run/eastness_file.tif'\n\n\nslope, aspect = calculate_slope_aspect(dem_file)\ncurvature = calculate_curvature(dem_file)\nnorthness, eastness = calculate_gradients(dem_file)\n\n# Save the slope and aspect as new GeoTIFF files\nsave_as_geotiff(slope, slope_file, dem_file)\nsave_as_geotiff(aspect, aspect_file, dem_file)\nsave_as_geotiff(curvature, curvature_file, dem_file)\nsave_as_geotiff(northness, northness_file, dem_file)\nsave_as_geotiff(eastness, eastness_file, dem_file)\n\ngeotiff_to_csv(dem_file, dem_file+\".csv\", \"Elevation\")\ngeotiff_to_csv(slope_file, slope_file+\".csv\", \"Slope\")\ngeotiff_to_csv(aspect_file, aspect_file+\".csv\", \"Aspect\")\ngeotiff_to_csv(curvature_file, curvature_file+\".csv\", \"Curvature\")\ngeotiff_to_csv(northness_file, northness_file+\".csv\", \"Northness\")\ngeotiff_to_csv(eastness_file, eastness_file+\".csv\", \"Eastness\")\n\n# List of file paths for the CSV files\ncsv_files = [dem_file+\".csv\", slope_file+\".csv\", aspect_file+\".csv\", \n             curvature_file+\".csv\", northness_file+\".csv\", eastness_file+\".csv\"]\n\n# Initialize an empty list to store all dataframes\ndfs = []\n\n# Read each CSV file into separate dataframes\nfor file in csv_files:\n    df = pd.read_csv(file, encoding='utf-8')\n    dfs.append(df)\n\n# Merge the dataframes based on the latitude and longitude columns\nmerged_df = dfs[0]  # Start with the first dataframe\nfor i in range(1, len(dfs)):\n    merged_df = pd.merge(merged_df, dfs[i], on=['Latitude', 'Longitude', 'x', 'y'])\n\n# Save the merged dataframe to a new CSV file\nmerged_df.to_csv(result_dem_feature_csv_path, index=False)\n",
  "history_output" : "Traceback (most recent call last):\n  File \"/home/chetana/gw-workspace/w5ugVPUQvyAy/western_us_dem.py\", line 3, in <module>\n    from osgeo import gdal\nModuleNotFoundError: No module named 'osgeo'\n",
  "history_begin_time" : 1694572714707,
  "history_end_time" : 1694572716097,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "vm3ked606kc",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1691531335813,
  "history_end_time" : 1691531335813,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "tq3z35",
  "indicator" : "Skipped"
},{
  "history_id" : "cjlkco0rpo6",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1691531292805,
  "history_end_time" : 1691531292805,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "tq3z35",
  "indicator" : "Skipped"
},{
  "history_id" : "qp0y2bklkxp",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1691531254670,
  "history_end_time" : 1691531284899,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "tq3z35",
  "indicator" : "Stopped"
},{
  "history_id" : "kh7ju7kh53w",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1691531163869,
  "history_end_time" : 1691531163869,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "tq3z35",
  "indicator" : "Skipped"
},{
  "history_id" : "991oo8torxa",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1691531120888,
  "history_end_time" : 1691531120888,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "tq3z35",
  "indicator" : "Skipped"
},{
  "history_id" : "39zpi978omm",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1691531060945,
  "history_end_time" : 1691531060945,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "tq3z35",
  "indicator" : "Skipped"
},{
  "history_id" : "zv5e23w49v7",
  "history_input" : "No code saved",
  "history_output" : "Skipped",
  "history_begin_time" : 1691530848327,
  "history_end_time" : 1691530848327,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "tq3z35",
  "indicator" : "Skipped"
},{
  "history_id" : "znorl58miy7",
  "history_input" : "import numpy as np\nimport pandas as pd\nfrom osgeo import gdal\nimport warnings\nimport rasterio\nimport csv\nfrom rasterio.transform import Affine\nfrom scipy.ndimage import sobel, gaussian_filter\n\n# Set the warning filter globally to ignore the FutureWarning\nwarnings.simplefilter(\"ignore\", FutureWarning)\n\ndef lat_lon_to_pixel(lat, lon, geotransform):\n    x = int((lon - geotransform[0]) / geotransform[1])\n    y = int((lat - geotransform[3]) / geotransform[5])\n    return x, y\n\n\ndef calculate_slope_aspect_for_single(elevation_data, pixel_size_x, pixel_size_y):\n    # Calculate slope using the Sobel operator\n    slope_x = np.gradient(elevation_data, pixel_size_x, axis=1)\n    slope_y = np.gradient(elevation_data, pixel_size_y, axis=0)\n    slope_rad = np.arctan(np.sqrt(slope_x ** 2 + slope_y ** 2))\n    slope_deg = np.degrees(slope_rad)\n\n    # Calculate aspect (direction of the steepest descent)\n    aspect_rad = np.arctan2(slope_y, -slope_x)\n    aspect_deg = (np.degrees(aspect_rad) + 360) % 360\n\n    return slope_deg, aspect_deg\n\n\ndef save_as_geotiff(data, output_file, src_file):\n    with rasterio.open(src_file) as src_dataset:\n        profile = src_dataset.profile\n        transform = src_dataset.transform\n\n        # Update the data type, count, and set the transform for the new dataset\n        profile.update(dtype=rasterio.float32, count=1, transform=transform)\n\n        # Create the new GeoTIFF file\n        with rasterio.open(output_file, 'w', **profile) as dst_dataset:\n            # Write the data to the new GeoTIFF\n            dst_dataset.write(data, 1)\n  \n\ndef calculate_slope_aspect(dem_file):\n    with rasterio.open(dem_file) as dataset:\n        # Read the DEM data as a numpy array\n        dem_data = dataset.read(1)\n\n        # Get the geotransform to convert pixel coordinates to geographic coordinates\n        transform = dataset.transform\n\n        # Calculate the slope and aspect using numpy\n        dx, dy = np.gradient(dem_data, transform[0], transform[4])\n        slope = np.arctan(np.sqrt(dx ** 2 + dy ** 2)) * (180.0 / np.pi)\n        aspect = np.arctan2(-dy, dx) * (180.0 / np.pi)\n\n        # Adjust aspect values to range from 0 to 360 degrees\n        aspect[aspect < 0] += 360\n        print(f\"slope shape: {slope.shape}\")\n        print(f\"aspect shape: {aspect.shape}\")\n        \n        \n    return slope, aspect\n  \ndef calculate_curvature(elevation_data, pixel_size_x, pixel_size_y):\n    # Calculate curvature using the Laplacian operator\n    curvature_x = np.gradient(np.gradient(elevation_data, pixel_size_x, axis=1), pixel_size_x, axis=1)\n    curvature_y = np.gradient(np.gradient(elevation_data, pixel_size_y, axis=0), pixel_size_y, axis=0)\n    curvature = curvature_x + curvature_y\n\n    return curvature\n\n  \ndef calculate_curvature(dem_file, sigma=1):\n    with rasterio.open(dem_file) as dataset:\n        # Read the DEM data as a numpy array\n        dem_data = dataset.read(1)\n\n        # Calculate the gradient using the Sobel filter\n        dx = sobel(dem_data, axis=1, mode='constant')\n        dy = sobel(dem_data, axis=0, mode='constant')\n\n        # Calculate the second derivatives using the Sobel filter\n        dxx = sobel(dx, axis=1, mode='constant')\n        dyy = sobel(dy, axis=0, mode='constant')\n\n        # Calculate the curvature using the second derivatives\n        curvature = dxx + dyy\n\n        # Smooth the curvature using Gaussian filtering (optional)\n        curvature = gaussian_filter(curvature, sigma)\n\n    return curvature\n  \ndef calculate_gradients(dem_file):\n    with rasterio.open(dem_file) as dataset:\n        # Read the DEM data as a numpy array\n        dem_data = dataset.read(1)\n\n        # Calculate the gradients along the North and East directions\n        dy, dx = np.gradient(dem_data, dataset.res[0], dataset.res[1])\n\n        # Calculate the Northness and Eastness\n        northness = np.arctan(dy / np.sqrt(dx**2 + dy**2))\n        eastness = np.arctan(dx / np.sqrt(dx**2 + dy**2))\n\n    return northness, eastness\n  \n  \ndef geotiff_to_csv(geotiff_file, csv_file, column_name):\n    # Open the GeoTIFF file\n    with rasterio.open(geotiff_file) as dataset:\n        # Get the pixel values as a 2D array\n        data = dataset.read(1)\n\n        # Get the geotransform to convert pixel coordinates to geographic coordinates\n        transform = dataset.transform\n\n        # Get the width and height of the GeoTIFF\n        height, width = data.shape\n\n        # Open the CSV file for writing\n        with open(csv_file, 'w', newline='') as csvfile:\n            csvwriter = csv.writer(csvfile)\n\n            # Write the CSV header\n            csvwriter.writerow(['Latitude', 'Longitude', 'x', 'y', column_name])\n\n            # Loop through each pixel and extract latitude, longitude, and image value\n            for y in range(height):\n                for x in range(width):\n                    # Get the pixel value\n                    image_value = data[y, x]\n\n                    # Convert pixel coordinates to geographic coordinates\n                    lon, lat = transform * (x, y)\n\n                    # Write the data to the CSV file\n                    csvwriter.writerow([lat, lon, x, y, image_value])\n\n  \ndef read_elevation_data(file_path, result_dem_csv_path, result_dem_feature_csv_path):\n    neighborhood_size=4\n    df = pd.read_csv(file_path)\n    \n    dataset = rasterio.open(geotiff_file)\n    data = dataset.read(1)\n\n    # Get the width and height of the GeoTIFF\n    height, width = data.shape\n    \n    # Create an empty DataFrame with column names\n    columns = ['lat', 'lon', 'elevation', 'slope', 'aspect', 'curvature', 'northness', 'eastness']\n    all_df = pd.DataFrame(columns=columns)\n    \n    all_df.to_csv(result_dem_feature_csv_path)\n    print(f\"DEM and other columns are saved to file {result_dem_feature_csv_path}\")\n    return all_df\n\n\n  \n# Usage example:\nresult_dem_csv_path = \"/home/chetana/gridmet_test_run/dem_template.csv\"\nresult_dem_feature_csv_path = \"/home/chetana/gridmet_test_run/dem_all.csv\"\n\n\ndem_file = \"/home/chetana/gridmet_test_run/dem_file.tif\"\nslope_file = '/home/chetana/gridmet_test_run/slope_file.tif'\naspect_file = '/home/chetana/gridmet_test_run/aspect_file.tif'\ncurvature_file = '/home/chetana/gridmet_test_run/curvature_file.tif'\nnorthness_file = '/home/chetana/gridmet_test_run/northness_file.tif'\neastness_file = '/home/chetana/gridmet_test_run/eastness_file.tif'\n\n\nslope, aspect = calculate_slope_aspect(dem_file)\ncurvature = calculate_curvature(dem_file)\nnorthness, eastness = calculate_gradients(dem_file)\n\n# Save the slope and aspect as new GeoTIFF files\nsave_as_geotiff(slope, slope_file, dem_file)\nsave_as_geotiff(aspect, aspect_file, dem_file)\nsave_as_geotiff(curvature, curvature_file, dem_file)\nsave_as_geotiff(northness, northness_file, dem_file)\nsave_as_geotiff(eastness, eastness_file, dem_file)\n\ngeotiff_to_csv(dem_file, dem_file+\".csv\", \"Elevation\")\ngeotiff_to_csv(slope_file, slope_file+\".csv\", \"Slope\")\ngeotiff_to_csv(aspect_file, aspect_file+\".csv\", \"Aspect\")\ngeotiff_to_csv(curvature_file, curvature_file+\".csv\", \"Curvature\")\ngeotiff_to_csv(northness_file, northness_file+\".csv\", \"Northness\")\ngeotiff_to_csv(eastness_file, eastness_file+\".csv\", \"Eastness\")\n\n# List of file paths for the CSV files\ncsv_files = [dem_file+\".csv\", slope_file+\".csv\", aspect_file+\".csv\", \n             curvature_file+\".csv\", northness_file+\".csv\", eastness_file+\".csv\"]\n\n# Initialize an empty list to store all dataframes\ndfs = []\n\n# Read each CSV file into separate dataframes\nfor file in csv_files:\n    df = pd.read_csv(file, encoding='utf-8')\n    dfs.append(df)\n\n# Merge the dataframes based on the latitude and longitude columns\nmerged_df = dfs[0]  # Start with the first dataframe\nfor i in range(1, len(dfs)):\n    merged_df = pd.merge(merged_df, dfs[i], on=['Latitude', 'Longitude', 'x', 'y'])\n\n# Save the merged dataframe to a new CSV file\nmerged_df.to_csv(result_dem_feature_csv_path, index=False)\n",
  "history_output" : "Traceback (most recent call last):\n  File \"/home/chetana/gw-workspace/znorl58miy7/western_us_dem.py\", line 3, in <module>\n    from osgeo import gdal\nModuleNotFoundError: No module named 'osgeo'\n",
  "history_begin_time" : 1691530718020,
  "history_end_time" : 1691530721104,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "tq3z35",
  "indicator" : "Stopped"
},{
  "history_id" : "e0og0gpd2x1",
  "history_input" : "import numpy as np\nimport pandas as pd\nfrom osgeo import gdal\nimport warnings\nimport rasterio\nimport csv\nfrom rasterio.transform import Affine\nfrom scipy.ndimage import sobel, gaussian_filter\n\n# Set the warning filter globally to ignore the FutureWarning\nwarnings.simplefilter(\"ignore\", FutureWarning)\n\ndef lat_lon_to_pixel(lat, lon, geotransform):\n    x = int((lon - geotransform[0]) / geotransform[1])\n    y = int((lat - geotransform[3]) / geotransform[5])\n    return x, y\n\n\ndef calculate_slope_aspect_for_single(elevation_data, pixel_size_x, pixel_size_y):\n    # Calculate slope using the Sobel operator\n    slope_x = np.gradient(elevation_data, pixel_size_x, axis=1)\n    slope_y = np.gradient(elevation_data, pixel_size_y, axis=0)\n    slope_rad = np.arctan(np.sqrt(slope_x ** 2 + slope_y ** 2))\n    slope_deg = np.degrees(slope_rad)\n\n    # Calculate aspect (direction of the steepest descent)\n    aspect_rad = np.arctan2(slope_y, -slope_x)\n    aspect_deg = (np.degrees(aspect_rad) + 360) % 360\n\n    return slope_deg, aspect_deg\n\n\ndef save_as_geotiff(data, output_file, src_file):\n    with rasterio.open(src_file) as src_dataset:\n        profile = src_dataset.profile\n        transform = src_dataset.transform\n\n        # Update the data type, count, and set the transform for the new dataset\n        profile.update(dtype=rasterio.float32, count=1, transform=transform)\n\n        # Create the new GeoTIFF file\n        with rasterio.open(output_file, 'w', **profile) as dst_dataset:\n            # Write the data to the new GeoTIFF\n            dst_dataset.write(data, 1)\n  \n\ndef calculate_slope_aspect(dem_file):\n    with rasterio.open(dem_file) as dataset:\n        # Read the DEM data as a numpy array\n        dem_data = dataset.read(1)\n\n        # Get the geotransform to convert pixel coordinates to geographic coordinates\n        transform = dataset.transform\n\n        # Calculate the slope and aspect using numpy\n        dx, dy = np.gradient(dem_data, transform[0], transform[4])\n        slope = np.arctan(np.sqrt(dx ** 2 + dy ** 2)) * (180.0 / np.pi)\n        aspect = np.arctan2(-dy, dx) * (180.0 / np.pi)\n\n        # Adjust aspect values to range from 0 to 360 degrees\n        aspect[aspect < 0] += 360\n        print(f\"slope shape: {slope.shape}\")\n        print(f\"aspect shape: {aspect.shape}\")\n        \n        \n    return slope, aspect\n  \ndef calculate_curvature(elevation_data, pixel_size_x, pixel_size_y):\n    # Calculate curvature using the Laplacian operator\n    curvature_x = np.gradient(np.gradient(elevation_data, pixel_size_x, axis=1), pixel_size_x, axis=1)\n    curvature_y = np.gradient(np.gradient(elevation_data, pixel_size_y, axis=0), pixel_size_y, axis=0)\n    curvature = curvature_x + curvature_y\n\n    return curvature\n\n  \ndef calculate_curvature(dem_file, sigma=1):\n    with rasterio.open(dem_file) as dataset:\n        # Read the DEM data as a numpy array\n        dem_data = dataset.read(1)\n\n        # Calculate the gradient using the Sobel filter\n        dx = sobel(dem_data, axis=1, mode='constant')\n        dy = sobel(dem_data, axis=0, mode='constant')\n\n        # Calculate the second derivatives using the Sobel filter\n        dxx = sobel(dx, axis=1, mode='constant')\n        dyy = sobel(dy, axis=0, mode='constant')\n\n        # Calculate the curvature using the second derivatives\n        curvature = dxx + dyy\n\n        # Smooth the curvature using Gaussian filtering (optional)\n        curvature = gaussian_filter(curvature, sigma)\n\n    return curvature\n  \ndef calculate_gradients(dem_file):\n    with rasterio.open(dem_file) as dataset:\n        # Read the DEM data as a numpy array\n        dem_data = dataset.read(1)\n\n        # Calculate the gradients along the North and East directions\n        dy, dx = np.gradient(dem_data, dataset.res[0], dataset.res[1])\n\n        # Calculate the Northness and Eastness\n        northness = np.arctan(dy / np.sqrt(dx**2 + dy**2))\n        eastness = np.arctan(dx / np.sqrt(dx**2 + dy**2))\n\n    return northness, eastness\n  \n  \ndef geotiff_to_csv(geotiff_file, csv_file, column_name):\n    # Open the GeoTIFF file\n    with rasterio.open(geotiff_file) as dataset:\n        # Get the pixel values as a 2D array\n        data = dataset.read(1)\n\n        # Get the geotransform to convert pixel coordinates to geographic coordinates\n        transform = dataset.transform\n\n        # Get the width and height of the GeoTIFF\n        height, width = data.shape\n\n        # Open the CSV file for writing\n        with open(csv_file, 'w', newline='') as csvfile:\n            csvwriter = csv.writer(csvfile)\n\n            # Write the CSV header\n            csvwriter.writerow(['Latitude', 'Longitude', 'x', 'y', column_name])\n\n            # Loop through each pixel and extract latitude, longitude, and image value\n            for y in range(height):\n                for x in range(width):\n                    # Get the pixel value\n                    image_value = data[y, x]\n\n                    # Convert pixel coordinates to geographic coordinates\n                    lon, lat = transform * (x, y)\n\n                    # Write the data to the CSV file\n                    csvwriter.writerow([lat, lon, x, y, image_value])\n\n  \ndef read_elevation_data(file_path, result_dem_csv_path, result_dem_feature_csv_path):\n    neighborhood_size=4\n    df = pd.read_csv(file_path)\n    \n    dataset = rasterio.open(geotiff_file)\n    data = dataset.read(1)\n\n    # Get the width and height of the GeoTIFF\n    height, width = data.shape\n    \n    # Create an empty DataFrame with column names\n    columns = ['lat', 'lon', 'elevation', 'slope', 'aspect', 'curvature', 'northness', 'eastness']\n    all_df = pd.DataFrame(columns=columns)\n    \n    all_df.to_csv(result_dem_feature_csv_path)\n    print(f\"DEM and other columns are saved to file {result_dem_feature_csv_path}\")\n    return all_df\n\n\n  \n# Usage example:\nresult_dem_csv_path = \"/home/chetana/gridmet_test_run/dem_template.csv\"\nresult_dem_feature_csv_path = \"/home/chetana/gridmet_test_run/dem_all.csv\"\n\n\ndem_file = \"/home/chetana/gridmet_test_run/dem_file.tif\"\nslope_file = '/home/chetana/gridmet_test_run/slope_file.tif'\naspect_file = '/home/chetana/gridmet_test_run/aspect_file.tif'\ncurvature_file = '/home/chetana/gridmet_test_run/curvature_file.tif'\nnorthness_file = '/home/chetana/gridmet_test_run/northness_file.tif'\neastness_file = '/home/chetana/gridmet_test_run/eastness_file.tif'\n\n\nslope, aspect = calculate_slope_aspect(dem_file)\ncurvature = calculate_curvature(dem_file)\nnorthness, eastness = calculate_gradients(dem_file)\n\n# Save the slope and aspect as new GeoTIFF files\nsave_as_geotiff(slope, slope_file, dem_file)\nsave_as_geotiff(aspect, aspect_file, dem_file)\nsave_as_geotiff(curvature, curvature_file, dem_file)\nsave_as_geotiff(northness, northness_file, dem_file)\nsave_as_geotiff(eastness, eastness_file, dem_file)\n\ngeotiff_to_csv(dem_file, dem_file+\".csv\", \"Elevation\")\ngeotiff_to_csv(slope_file, slope_file+\".csv\", \"Slope\")\ngeotiff_to_csv(aspect_file, aspect_file+\".csv\", \"Aspect\")\ngeotiff_to_csv(curvature_file, curvature_file+\".csv\", \"Curvature\")\ngeotiff_to_csv(northness_file, northness_file+\".csv\", \"Northness\")\ngeotiff_to_csv(eastness_file, eastness_file+\".csv\", \"Eastness\")\n\n# List of file paths for the CSV files\ncsv_files = [dem_file+\".csv\", slope_file+\".csv\", aspect_file+\".csv\", \n             curvature_file+\".csv\", northness_file+\".csv\", eastness_file+\".csv\"]\n\n# Initialize an empty list to store all dataframes\ndfs = []\n\n# Read each CSV file into separate dataframes\nfor file in csv_files:\n    df = pd.read_csv(file, encoding='utf-8')\n    dfs.append(df)\n\n# Merge the dataframes based on the latitude and longitude columns\nmerged_df = dfs[0]  # Start with the first dataframe\nfor i in range(1, len(dfs)):\n    merged_df = pd.merge(merged_df, dfs[i], on=['Latitude', 'Longitude', 'x', 'y'])\n\n# Save the merged dataframe to a new CSV file\nmerged_df.to_csv(result_dem_feature_csv_path, index=False)\n",
  "history_output" : "Traceback (most recent call last):\n  File \"/home/chetana/gw-workspace/e0og0gpd2x1/western_us_dem.py\", line 3, in <module>\n    from osgeo import gdal\nModuleNotFoundError: No module named 'osgeo'\n",
  "history_begin_time" : 1691530690829,
  "history_end_time" : 1691530716749,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "tq3z35",
  "indicator" : "Stopped"
},{
  "history_id" : "sq98l75csxi",
  "history_input" : "import numpy as np\nimport pandas as pd\nfrom osgeo import gdal\nimport warnings\nimport rasterio\nimport csv\nfrom rasterio.transform import Affine\nfrom scipy.ndimage import sobel, gaussian_filter\n\n# Set the warning filter globally to ignore the FutureWarning\nwarnings.simplefilter(\"ignore\", FutureWarning)\n\ndef lat_lon_to_pixel(lat, lon, geotransform):\n    x = int((lon - geotransform[0]) / geotransform[1])\n    y = int((lat - geotransform[3]) / geotransform[5])\n    return x, y\n\n\ndef calculate_slope_aspect_for_single(elevation_data, pixel_size_x, pixel_size_y):\n    # Calculate slope using the Sobel operator\n    slope_x = np.gradient(elevation_data, pixel_size_x, axis=1)\n    slope_y = np.gradient(elevation_data, pixel_size_y, axis=0)\n    slope_rad = np.arctan(np.sqrt(slope_x ** 2 + slope_y ** 2))\n    slope_deg = np.degrees(slope_rad)\n\n    # Calculate aspect (direction of the steepest descent)\n    aspect_rad = np.arctan2(slope_y, -slope_x)\n    aspect_deg = (np.degrees(aspect_rad) + 360) % 360\n\n    return slope_deg, aspect_deg\n\n\ndef save_as_geotiff(data, output_file, src_file):\n    with rasterio.open(src_file) as src_dataset:\n        profile = src_dataset.profile\n        transform = src_dataset.transform\n\n        # Update the data type, count, and set the transform for the new dataset\n        profile.update(dtype=rasterio.float32, count=1, transform=transform)\n\n        # Create the new GeoTIFF file\n        with rasterio.open(output_file, 'w', **profile) as dst_dataset:\n            # Write the data to the new GeoTIFF\n            dst_dataset.write(data, 1)\n  \n\ndef calculate_slope_aspect(dem_file):\n    with rasterio.open(dem_file) as dataset:\n        # Read the DEM data as a numpy array\n        dem_data = dataset.read(1)\n\n        # Get the geotransform to convert pixel coordinates to geographic coordinates\n        transform = dataset.transform\n\n        # Calculate the slope and aspect using numpy\n        dx, dy = np.gradient(dem_data, transform[0], transform[4])\n        slope = np.arctan(np.sqrt(dx ** 2 + dy ** 2)) * (180.0 / np.pi)\n        aspect = np.arctan2(-dy, dx) * (180.0 / np.pi)\n\n        # Adjust aspect values to range from 0 to 360 degrees\n        aspect[aspect < 0] += 360\n        print(f\"slope shape: {slope.shape}\")\n        print(f\"aspect shape: {aspect.shape}\")\n        \n        \n    return slope, aspect\n  \ndef calculate_curvature(elevation_data, pixel_size_x, pixel_size_y):\n    # Calculate curvature using the Laplacian operator\n    curvature_x = np.gradient(np.gradient(elevation_data, pixel_size_x, axis=1), pixel_size_x, axis=1)\n    curvature_y = np.gradient(np.gradient(elevation_data, pixel_size_y, axis=0), pixel_size_y, axis=0)\n    curvature = curvature_x + curvature_y\n\n    return curvature\n\n  \ndef calculate_curvature(dem_file, sigma=1):\n    with rasterio.open(dem_file) as dataset:\n        # Read the DEM data as a numpy array\n        dem_data = dataset.read(1)\n\n        # Calculate the gradient using the Sobel filter\n        dx = sobel(dem_data, axis=1, mode='constant')\n        dy = sobel(dem_data, axis=0, mode='constant')\n\n        # Calculate the second derivatives using the Sobel filter\n        dxx = sobel(dx, axis=1, mode='constant')\n        dyy = sobel(dy, axis=0, mode='constant')\n\n        # Calculate the curvature using the second derivatives\n        curvature = dxx + dyy\n\n        # Smooth the curvature using Gaussian filtering (optional)\n        curvature = gaussian_filter(curvature, sigma)\n\n    return curvature\n  \ndef calculate_gradients(dem_file):\n    with rasterio.open(dem_file) as dataset:\n        # Read the DEM data as a numpy array\n        dem_data = dataset.read(1)\n\n        # Calculate the gradients along the North and East directions\n        dy, dx = np.gradient(dem_data, dataset.res[0], dataset.res[1])\n\n        # Calculate the Northness and Eastness\n        northness = np.arctan(dy / np.sqrt(dx**2 + dy**2))\n        eastness = np.arctan(dx / np.sqrt(dx**2 + dy**2))\n\n    return northness, eastness\n  \n  \ndef geotiff_to_csv(geotiff_file, csv_file, column_name):\n    # Open the GeoTIFF file\n    with rasterio.open(geotiff_file) as dataset:\n        # Get the pixel values as a 2D array\n        data = dataset.read(1)\n\n        # Get the geotransform to convert pixel coordinates to geographic coordinates\n        transform = dataset.transform\n\n        # Get the width and height of the GeoTIFF\n        height, width = data.shape\n\n        # Open the CSV file for writing\n        with open(csv_file, 'w', newline='') as csvfile:\n            csvwriter = csv.writer(csvfile)\n\n            # Write the CSV header\n            csvwriter.writerow(['Latitude', 'Longitude', 'x', 'y', column_name])\n\n            # Loop through each pixel and extract latitude, longitude, and image value\n            for y in range(height):\n                for x in range(width):\n                    # Get the pixel value\n                    image_value = data[y, x]\n\n                    # Convert pixel coordinates to geographic coordinates\n                    lon, lat = transform * (x, y)\n\n                    # Write the data to the CSV file\n                    csvwriter.writerow([lat, lon, x, y, image_value])\n\n  \ndef read_elevation_data(file_path, result_dem_csv_path, result_dem_feature_csv_path):\n    neighborhood_size=4\n    df = pd.read_csv(file_path)\n    \n    dataset = rasterio.open(geotiff_file)\n    data = dataset.read(1)\n\n    # Get the width and height of the GeoTIFF\n    height, width = data.shape\n    \n    # Create an empty DataFrame with column names\n    columns = ['lat', 'lon', 'elevation', 'slope', 'aspect', 'curvature', 'northness', 'eastness']\n    all_df = pd.DataFrame(columns=columns)\n    \n    all_df.to_csv(result_dem_feature_csv_path)\n    print(f\"DEM and other columns are saved to file {result_dem_feature_csv_path}\")\n    return all_df\n\n\n  \n# Usage example:\nresult_dem_csv_path = \"/home/chetana/gridmet_test_run/dem_template.csv\"\nresult_dem_feature_csv_path = \"/home/chetana/gridmet_test_run/dem_all.csv\"\n\n\ndem_file = \"/home/chetana/gridmet_test_run/dem_file.tif\"\nslope_file = '/home/chetana/gridmet_test_run/slope_file.tif'\naspect_file = '/home/chetana/gridmet_test_run/aspect_file.tif'\ncurvature_file = '/home/chetana/gridmet_test_run/curvature_file.tif'\nnorthness_file = '/home/chetana/gridmet_test_run/northness_file.tif'\neastness_file = '/home/chetana/gridmet_test_run/eastness_file.tif'\n\n\nslope, aspect = calculate_slope_aspect(dem_file)\ncurvature = calculate_curvature(dem_file)\nnorthness, eastness = calculate_gradients(dem_file)\n\n# Save the slope and aspect as new GeoTIFF files\nsave_as_geotiff(slope, slope_file, dem_file)\nsave_as_geotiff(aspect, aspect_file, dem_file)\nsave_as_geotiff(curvature, curvature_file, dem_file)\nsave_as_geotiff(northness, northness_file, dem_file)\nsave_as_geotiff(eastness, eastness_file, dem_file)\n\ngeotiff_to_csv(dem_file, dem_file+\".csv\", \"Elevation\")\ngeotiff_to_csv(slope_file, slope_file+\".csv\", \"Slope\")\ngeotiff_to_csv(aspect_file, aspect_file+\".csv\", \"Aspect\")\ngeotiff_to_csv(curvature_file, curvature_file+\".csv\", \"Curvature\")\ngeotiff_to_csv(northness_file, northness_file+\".csv\", \"Northness\")\ngeotiff_to_csv(eastness_file, eastness_file+\".csv\", \"Eastness\")\n\n# List of file paths for the CSV files\ncsv_files = [dem_file+\".csv\", slope_file+\".csv\", aspect_file+\".csv\", \n             curvature_file+\".csv\", northness_file+\".csv\", eastness_file+\".csv\"]\n\n# Initialize an empty list to store all dataframes\ndfs = []\n\n# Read each CSV file into separate dataframes\nfor file in csv_files:\n    df = pd.read_csv(file, encoding='utf-8')\n    dfs.append(df)\n\n# Merge the dataframes based on the latitude and longitude columns\nmerged_df = dfs[0]  # Start with the first dataframe\nfor i in range(1, len(dfs)):\n    merged_df = pd.merge(merged_df, dfs[i], on=['Latitude', 'Longitude', 'x', 'y'])\n\n# Save the merged dataframe to a new CSV file\nmerged_df.to_csv(result_dem_feature_csv_path, index=False)\n",
  "history_output" : "",
  "history_begin_time" : 1691530618001,
  "history_end_time" : 1691530620308,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "tq3z35",
  "indicator" : "Failed"
},{
  "history_id" : "co1yzzbnb2l",
  "history_input" : "import numpy as np\nimport pandas as pd\nfrom osgeo import gdal\nimport warnings\nimport rasterio\nimport csv\nfrom rasterio.transform import Affine\nfrom scipy.ndimage import sobel, gaussian_filter\n\n# Set the warning filter globally to ignore the FutureWarning\nwarnings.simplefilter(\"ignore\", FutureWarning)\n\ndef lat_lon_to_pixel(lat, lon, geotransform):\n    x = int((lon - geotransform[0]) / geotransform[1])\n    y = int((lat - geotransform[3]) / geotransform[5])\n    return x, y\n\n\ndef calculate_slope_aspect_for_single(elevation_data, pixel_size_x, pixel_size_y):\n    # Calculate slope using the Sobel operator\n    slope_x = np.gradient(elevation_data, pixel_size_x, axis=1)\n    slope_y = np.gradient(elevation_data, pixel_size_y, axis=0)\n    slope_rad = np.arctan(np.sqrt(slope_x ** 2 + slope_y ** 2))\n    slope_deg = np.degrees(slope_rad)\n\n    # Calculate aspect (direction of the steepest descent)\n    aspect_rad = np.arctan2(slope_y, -slope_x)\n    aspect_deg = (np.degrees(aspect_rad) + 360) % 360\n\n    return slope_deg, aspect_deg\n\n\ndef save_as_geotiff(data, output_file, src_file):\n    with rasterio.open(src_file) as src_dataset:\n        profile = src_dataset.profile\n        transform = src_dataset.transform\n\n        # Update the data type, count, and set the transform for the new dataset\n        profile.update(dtype=rasterio.float32, count=1, transform=transform)\n\n        # Create the new GeoTIFF file\n        with rasterio.open(output_file, 'w', **profile) as dst_dataset:\n            # Write the data to the new GeoTIFF\n            dst_dataset.write(data, 1)\n  \n\ndef calculate_slope_aspect(dem_file):\n    with rasterio.open(dem_file) as dataset:\n        # Read the DEM data as a numpy array\n        dem_data = dataset.read(1)\n\n        # Get the geotransform to convert pixel coordinates to geographic coordinates\n        transform = dataset.transform\n\n        # Calculate the slope and aspect using numpy\n        dx, dy = np.gradient(dem_data, transform[0], transform[4])\n        slope = np.arctan(np.sqrt(dx ** 2 + dy ** 2)) * (180.0 / np.pi)\n        aspect = np.arctan2(-dy, dx) * (180.0 / np.pi)\n\n        # Adjust aspect values to range from 0 to 360 degrees\n        aspect[aspect < 0] += 360\n        print(f\"slope shape: {slope.shape}\")\n        print(f\"aspect shape: {aspect.shape}\")\n        \n        \n    return slope, aspect\n  \ndef calculate_curvature(elevation_data, pixel_size_x, pixel_size_y):\n    # Calculate curvature using the Laplacian operator\n    curvature_x = np.gradient(np.gradient(elevation_data, pixel_size_x, axis=1), pixel_size_x, axis=1)\n    curvature_y = np.gradient(np.gradient(elevation_data, pixel_size_y, axis=0), pixel_size_y, axis=0)\n    curvature = curvature_x + curvature_y\n\n    return curvature\n\n  \ndef calculate_curvature(dem_file, sigma=1):\n    with rasterio.open(dem_file) as dataset:\n        # Read the DEM data as a numpy array\n        dem_data = dataset.read(1)\n\n        # Calculate the gradient using the Sobel filter\n        dx = sobel(dem_data, axis=1, mode='constant')\n        dy = sobel(dem_data, axis=0, mode='constant')\n\n        # Calculate the second derivatives using the Sobel filter\n        dxx = sobel(dx, axis=1, mode='constant')\n        dyy = sobel(dy, axis=0, mode='constant')\n\n        # Calculate the curvature using the second derivatives\n        curvature = dxx + dyy\n\n        # Smooth the curvature using Gaussian filtering (optional)\n        curvature = gaussian_filter(curvature, sigma)\n\n    return curvature\n  \ndef calculate_gradients(dem_file):\n    with rasterio.open(dem_file) as dataset:\n        # Read the DEM data as a numpy array\n        dem_data = dataset.read(1)\n\n        # Calculate the gradients along the North and East directions\n        dy, dx = np.gradient(dem_data, dataset.res[0], dataset.res[1])\n\n        # Calculate the Northness and Eastness\n        northness = np.arctan(dy / np.sqrt(dx**2 + dy**2))\n        eastness = np.arctan(dx / np.sqrt(dx**2 + dy**2))\n\n    return northness, eastness\n  \n  \ndef geotiff_to_csv(geotiff_file, csv_file, column_name):\n    # Open the GeoTIFF file\n    with rasterio.open(geotiff_file) as dataset:\n        # Get the pixel values as a 2D array\n        data = dataset.read(1)\n\n        # Get the geotransform to convert pixel coordinates to geographic coordinates\n        transform = dataset.transform\n\n        # Get the width and height of the GeoTIFF\n        height, width = data.shape\n\n        # Open the CSV file for writing\n        with open(csv_file, 'w', newline='') as csvfile:\n            csvwriter = csv.writer(csvfile)\n\n            # Write the CSV header\n            csvwriter.writerow(['Latitude', 'Longitude', 'x', 'y', column_name])\n\n            # Loop through each pixel and extract latitude, longitude, and image value\n            for y in range(height):\n                for x in range(width):\n                    # Get the pixel value\n                    image_value = data[y, x]\n\n                    # Convert pixel coordinates to geographic coordinates\n                    lon, lat = transform * (x, y)\n\n                    # Write the data to the CSV file\n                    csvwriter.writerow([lat, lon, x, y, image_value])\n\n  \ndef read_elevation_data(file_path, result_dem_csv_path, result_dem_feature_csv_path):\n    neighborhood_size=4\n    df = pd.read_csv(file_path)\n    \n    dataset = rasterio.open(geotiff_file)\n    data = dataset.read(1)\n\n    # Get the width and height of the GeoTIFF\n    height, width = data.shape\n    \n    # Create an empty DataFrame with column names\n    columns = ['lat', 'lon', 'elevation', 'slope', 'aspect', 'curvature', 'northness', 'eastness']\n    all_df = pd.DataFrame(columns=columns)\n    \n    all_df.to_csv(result_dem_feature_csv_path)\n    print(f\"DEM and other columns are saved to file {result_dem_feature_csv_path}\")\n    return all_df\n\n\n  \n# Usage example:\nresult_dem_csv_path = \"/home/chetana/gridmet_test_run/dem_template.csv\"\nresult_dem_feature_csv_path = \"/home/chetana/gridmet_test_run/dem_all.csv\"\n\n\ndem_file = \"/home/chetana/gridmet_test_run/dem_file.tif\"\nslope_file = '/home/chetana/gridmet_test_run/slope_file.tif'\naspect_file = '/home/chetana/gridmet_test_run/aspect_file.tif'\ncurvature_file = '/home/chetana/gridmet_test_run/curvature_file.tif'\nnorthness_file = '/home/chetana/gridmet_test_run/northness_file.tif'\neastness_file = '/home/chetana/gridmet_test_run/eastness_file.tif'\n\n\nslope, aspect = calculate_slope_aspect(dem_file)\ncurvature = calculate_curvature(dem_file)\nnorthness, eastness = calculate_gradients(dem_file)\n\n# Save the slope and aspect as new GeoTIFF files\nsave_as_geotiff(slope, slope_file, dem_file)\nsave_as_geotiff(aspect, aspect_file, dem_file)\nsave_as_geotiff(curvature, curvature_file, dem_file)\nsave_as_geotiff(northness, northness_file, dem_file)\nsave_as_geotiff(eastness, eastness_file, dem_file)\n\ngeotiff_to_csv(dem_file, dem_file+\".csv\", \"Elevation\")\ngeotiff_to_csv(slope_file, slope_file+\".csv\", \"Slope\")\ngeotiff_to_csv(aspect_file, aspect_file+\".csv\", \"Aspect\")\ngeotiff_to_csv(curvature_file, curvature_file+\".csv\", \"Curvature\")\ngeotiff_to_csv(northness_file, northness_file+\".csv\", \"Northness\")\ngeotiff_to_csv(eastness_file, eastness_file+\".csv\", \"Eastness\")\n\n# List of file paths for the CSV files\ncsv_files = [dem_file+\".csv\", slope_file+\".csv\", aspect_file+\".csv\", \n             curvature_file+\".csv\", northness_file+\".csv\", eastness_file+\".csv\"]\n\n# Initialize an empty list to store all dataframes\ndfs = []\n\n# Read each CSV file into separate dataframes\nfor file in csv_files:\n    df = pd.read_csv(file, encoding='utf-8')\n    dfs.append(df)\n\n# Merge the dataframes based on the latitude and longitude columns\nmerged_df = dfs[0]  # Start with the first dataframe\nfor i in range(1, len(dfs)):\n    merged_df = pd.merge(merged_df, dfs[i], on=['Latitude', 'Longitude', 'x', 'y'])\n\n# Save the merged dataframe to a new CSV file\nmerged_df.to_csv(result_dem_feature_csv_path, index=False)\n",
  "history_output" : "Traceback (most recent call last):\n  File \"/home/chetana/gw-workspace/co1yzzbnb2l/western_us_dem.py\", line 3, in <module>\n    from osgeo import gdal\nModuleNotFoundError: No module named 'osgeo'\n",
  "history_begin_time" : 1691530600561,
  "history_end_time" : 1691530614283,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "tq3z35",
  "indicator" : "Stopped"
},{
  "history_id" : "dGaHkcIqohYJ",
  "history_input" : "import numpy as np\nimport pandas as pd\nfrom osgeo import gdal\nimport warnings\nimport rasterio\nimport csv\nfrom rasterio.transform import Affine\nfrom scipy.ndimage import sobel, gaussian_filter\n\n# Set the warning filter globally to ignore the FutureWarning\nwarnings.simplefilter(\"ignore\", FutureWarning)\n\ndef lat_lon_to_pixel(lat, lon, geotransform):\n    x = int((lon - geotransform[0]) / geotransform[1])\n    y = int((lat - geotransform[3]) / geotransform[5])\n    return x, y\n\n\ndef calculate_slope_aspect_for_single(elevation_data, pixel_size_x, pixel_size_y):\n    # Calculate slope using the Sobel operator\n    slope_x = np.gradient(elevation_data, pixel_size_x, axis=1)\n    slope_y = np.gradient(elevation_data, pixel_size_y, axis=0)\n    slope_rad = np.arctan(np.sqrt(slope_x ** 2 + slope_y ** 2))\n    slope_deg = np.degrees(slope_rad)\n\n    # Calculate aspect (direction of the steepest descent)\n    aspect_rad = np.arctan2(slope_y, -slope_x)\n    aspect_deg = (np.degrees(aspect_rad) + 360) % 360\n\n    return slope_deg, aspect_deg\n\n\ndef save_as_geotiff(data, output_file, src_file):\n    with rasterio.open(src_file) as src_dataset:\n        profile = src_dataset.profile\n        transform = src_dataset.transform\n\n        # Update the data type, count, and set the transform for the new dataset\n        profile.update(dtype=rasterio.float32, count=1, transform=transform)\n\n        # Create the new GeoTIFF file\n        with rasterio.open(output_file, 'w', **profile) as dst_dataset:\n            # Write the data to the new GeoTIFF\n            dst_dataset.write(data, 1)\n  \n\ndef calculate_slope_aspect(dem_file):\n    with rasterio.open(dem_file) as dataset:\n        # Read the DEM data as a numpy array\n        dem_data = dataset.read(1)\n\n        # Get the geotransform to convert pixel coordinates to geographic coordinates\n        transform = dataset.transform\n\n        # Calculate the slope and aspect using numpy\n        dx, dy = np.gradient(dem_data, transform[0], transform[4])\n        slope = np.arctan(np.sqrt(dx ** 2 + dy ** 2)) * (180.0 / np.pi)\n        aspect = np.arctan2(-dy, dx) * (180.0 / np.pi)\n\n        # Adjust aspect values to range from 0 to 360 degrees\n        aspect[aspect < 0] += 360\n        print(f\"slope shape: {slope.shape}\")\n        print(f\"aspect shape: {aspect.shape}\")\n        \n        \n    return slope, aspect\n  \ndef calculate_curvature(elevation_data, pixel_size_x, pixel_size_y):\n    # Calculate curvature using the Laplacian operator\n    curvature_x = np.gradient(np.gradient(elevation_data, pixel_size_x, axis=1), pixel_size_x, axis=1)\n    curvature_y = np.gradient(np.gradient(elevation_data, pixel_size_y, axis=0), pixel_size_y, axis=0)\n    curvature = curvature_x + curvature_y\n\n    return curvature\n\n  \ndef calculate_curvature(dem_file, sigma=1):\n    with rasterio.open(dem_file) as dataset:\n        # Read the DEM data as a numpy array\n        dem_data = dataset.read(1)\n\n        # Calculate the gradient using the Sobel filter\n        dx = sobel(dem_data, axis=1, mode='constant')\n        dy = sobel(dem_data, axis=0, mode='constant')\n\n        # Calculate the second derivatives using the Sobel filter\n        dxx = sobel(dx, axis=1, mode='constant')\n        dyy = sobel(dy, axis=0, mode='constant')\n\n        # Calculate the curvature using the second derivatives\n        curvature = dxx + dyy\n\n        # Smooth the curvature using Gaussian filtering (optional)\n        curvature = gaussian_filter(curvature, sigma)\n\n    return curvature\n  \ndef calculate_gradients(dem_file):\n    with rasterio.open(dem_file) as dataset:\n        # Read the DEM data as a numpy array\n        dem_data = dataset.read(1)\n\n        # Calculate the gradients along the North and East directions\n        dy, dx = np.gradient(dem_data, dataset.res[0], dataset.res[1])\n\n        # Calculate the Northness and Eastness\n        northness = np.arctan(dy / np.sqrt(dx**2 + dy**2))\n        eastness = np.arctan(dx / np.sqrt(dx**2 + dy**2))\n\n    return northness, eastness\n  \n  \ndef geotiff_to_csv(geotiff_file, csv_file, column_name):\n    # Open the GeoTIFF file\n    with rasterio.open(geotiff_file) as dataset:\n        # Get the pixel values as a 2D array\n        data = dataset.read(1)\n\n        # Get the geotransform to convert pixel coordinates to geographic coordinates\n        transform = dataset.transform\n\n        # Get the width and height of the GeoTIFF\n        height, width = data.shape\n\n        # Open the CSV file for writing\n        with open(csv_file, 'w', newline='') as csvfile:\n            csvwriter = csv.writer(csvfile)\n\n            # Write the CSV header\n            csvwriter.writerow(['Latitude', 'Longitude', 'x', 'y', column_name])\n\n            # Loop through each pixel and extract latitude, longitude, and image value\n            for y in range(height):\n                for x in range(width):\n                    # Get the pixel value\n                    image_value = data[y, x]\n\n                    # Convert pixel coordinates to geographic coordinates\n                    lon, lat = transform * (x, y)\n\n                    # Write the data to the CSV file\n                    csvwriter.writerow([lat, lon, x, y, image_value])\n\n  \ndef read_elevation_data(file_path, result_dem_csv_path, result_dem_feature_csv_path):\n    neighborhood_size=4\n    df = pd.read_csv(file_path)\n    \n    dataset = rasterio.open(geotiff_file)\n    data = dataset.read(1)\n\n    # Get the width and height of the GeoTIFF\n    height, width = data.shape\n    \n    # Create an empty DataFrame with column names\n    columns = ['lat', 'lon', 'elevation', 'slope', 'aspect', 'curvature', 'northness', 'eastness']\n    all_df = pd.DataFrame(columns=columns)\n    \n    all_df.to_csv(result_dem_feature_csv_path)\n    print(f\"DEM and other columns are saved to file {result_dem_feature_csv_path}\")\n    return all_df\n\n\n  \n# Usage example:\nresult_dem_csv_path = \"/home/chetana/gridmet_test_run/dem_template.csv\"\nresult_dem_feature_csv_path = \"/home/chetana/gridmet_test_run/dem_all.csv\"\n\n\ndem_file = \"/home/chetana/gridmet_test_run/dem_file.tif\"\nslope_file = '/home/chetana/gridmet_test_run/slope_file.tif'\naspect_file = '/home/chetana/gridmet_test_run/aspect_file.tif'\ncurvature_file = '/home/chetana/gridmet_test_run/curvature_file.tif'\nnorthness_file = '/home/chetana/gridmet_test_run/northness_file.tif'\neastness_file = '/home/chetana/gridmet_test_run/eastness_file.tif'\n\n\nslope, aspect = calculate_slope_aspect(dem_file)\ncurvature = calculate_curvature(dem_file)\nnorthness, eastness = calculate_gradients(dem_file)\n\n# Save the slope and aspect as new GeoTIFF files\nsave_as_geotiff(slope, slope_file, dem_file)\nsave_as_geotiff(aspect, aspect_file, dem_file)\nsave_as_geotiff(curvature, curvature_file, dem_file)\nsave_as_geotiff(northness, northness_file, dem_file)\nsave_as_geotiff(eastness, eastness_file, dem_file)\n\ngeotiff_to_csv(dem_file, dem_file+\".csv\", \"Elevation\")\ngeotiff_to_csv(slope_file, slope_file+\".csv\", \"Slope\")\ngeotiff_to_csv(aspect_file, aspect_file+\".csv\", \"Aspect\")\ngeotiff_to_csv(curvature_file, curvature_file+\".csv\", \"Curvature\")\ngeotiff_to_csv(northness_file, northness_file+\".csv\", \"Northness\")\ngeotiff_to_csv(eastness_file, eastness_file+\".csv\", \"Eastness\")\n\n# List of file paths for the CSV files\ncsv_files = [dem_file+\".csv\", slope_file+\".csv\", aspect_file+\".csv\", \n             curvature_file+\".csv\", northness_file+\".csv\", eastness_file+\".csv\"]\n\n# Initialize an empty list to store all dataframes\ndfs = []\n\n# Read each CSV file into separate dataframes\nfor file in csv_files:\n    df = pd.read_csv(file, encoding='utf-8')\n    dfs.append(df)\n\n# Merge the dataframes based on the latitude and longitude columns\nmerged_df = dfs[0]  # Start with the first dataframe\nfor i in range(1, len(dfs)):\n    merged_df = pd.merge(merged_df, dfs[i], on=['Latitude', 'Longitude', 'x', 'y'])\n\n# Save the merged dataframe to a new CSV file\nmerged_df.to_csv(result_dem_feature_csv_path, index=False)\n",
  "history_output" : "/home/chetana/gw-workspace/dGaHkcIqohYJ/western_us_dem.py:107: RuntimeWarning: invalid value encountered in true_divide\n  northness = np.arctan(dy / np.sqrt(dx**2 + dy**2))\n/home/chetana/gw-workspace/dGaHkcIqohYJ/western_us_dem.py:108: RuntimeWarning: invalid value encountered in true_divide\n  eastness = np.arctan(dx / np.sqrt(dx**2 + dy**2))\nslope shape: (666, 694)\naspect shape: (666, 694)\n",
  "history_begin_time" : 1690261427808,
  "history_end_time" : 1690261441919,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "8cS9A8dQoAxo",
  "history_input" : "import numpy as np\nimport pandas as pd\nfrom osgeo import gdal\nimport warnings\nimport rasterio\nimport csv\nfrom rasterio.transform import Affine\nfrom scipy.ndimage import sobel, gaussian_filter\n\n# Set the warning filter globally to ignore the FutureWarning\nwarnings.simplefilter(\"ignore\", FutureWarning)\n\ndef lat_lon_to_pixel(lat, lon, geotransform):\n    x = int((lon - geotransform[0]) / geotransform[1])\n    y = int((lat - geotransform[3]) / geotransform[5])\n    return x, y\n\n\ndef calculate_slope_aspect_for_single(elevation_data, pixel_size_x, pixel_size_y):\n    # Calculate slope using the Sobel operator\n    slope_x = np.gradient(elevation_data, pixel_size_x, axis=1)\n    slope_y = np.gradient(elevation_data, pixel_size_y, axis=0)\n    slope_rad = np.arctan(np.sqrt(slope_x ** 2 + slope_y ** 2))\n    slope_deg = np.degrees(slope_rad)\n\n    # Calculate aspect (direction of the steepest descent)\n    aspect_rad = np.arctan2(slope_y, -slope_x)\n    aspect_deg = (np.degrees(aspect_rad) + 360) % 360\n\n    return slope_deg, aspect_deg\n\n\ndef save_as_geotiff(data, output_file, src_file):\n    with rasterio.open(src_file) as src_dataset:\n        profile = src_dataset.profile\n        transform = src_dataset.transform\n\n        # Update the data type, count, and set the transform for the new dataset\n        profile.update(dtype=rasterio.float32, count=1, transform=transform)\n\n        # Create the new GeoTIFF file\n        with rasterio.open(output_file, 'w', **profile) as dst_dataset:\n            # Write the data to the new GeoTIFF\n            dst_dataset.write(data, 1)\n  \n\ndef calculate_slope_aspect(dem_file):\n    with rasterio.open(dem_file) as dataset:\n        # Read the DEM data as a numpy array\n        dem_data = dataset.read(1)\n\n        # Get the geotransform to convert pixel coordinates to geographic coordinates\n        transform = dataset.transform\n\n        # Calculate the slope and aspect using numpy\n        dx, dy = np.gradient(dem_data, transform[0], transform[4])\n        slope = np.arctan(np.sqrt(dx ** 2 + dy ** 2)) * (180.0 / np.pi)\n        aspect = np.arctan2(-dy, dx) * (180.0 / np.pi)\n\n        # Adjust aspect values to range from 0 to 360 degrees\n        aspect[aspect < 0] += 360\n        print(f\"slope shape: {slope.shape}\")\n        print(f\"aspect shape: {aspect.shape}\")\n        \n        \n    return slope, aspect\n  \ndef calculate_curvature(elevation_data, pixel_size_x, pixel_size_y):\n    # Calculate curvature using the Laplacian operator\n    curvature_x = np.gradient(np.gradient(elevation_data, pixel_size_x, axis=1), pixel_size_x, axis=1)\n    curvature_y = np.gradient(np.gradient(elevation_data, pixel_size_y, axis=0), pixel_size_y, axis=0)\n    curvature = curvature_x + curvature_y\n\n    return curvature\n\n  \ndef calculate_curvature(dem_file, sigma=1):\n    with rasterio.open(dem_file) as dataset:\n        # Read the DEM data as a numpy array\n        dem_data = dataset.read(1)\n\n        # Calculate the gradient using the Sobel filter\n        dx = sobel(dem_data, axis=1, mode='constant')\n        dy = sobel(dem_data, axis=0, mode='constant')\n\n        # Calculate the second derivatives using the Sobel filter\n        dxx = sobel(dx, axis=1, mode='constant')\n        dyy = sobel(dy, axis=0, mode='constant')\n\n        # Calculate the curvature using the second derivatives\n        curvature = dxx + dyy\n\n        # Smooth the curvature using Gaussian filtering (optional)\n        curvature = gaussian_filter(curvature, sigma)\n\n    return curvature\n  \ndef calculate_gradients(dem_file):\n    with rasterio.open(dem_file) as dataset:\n        # Read the DEM data as a numpy array\n        dem_data = dataset.read(1)\n\n        # Calculate the gradients along the North and East directions\n        dy, dx = np.gradient(dem_data, dataset.res[0], dataset.res[1])\n\n        # Calculate the Northness and Eastness\n        northness = np.arctan(dy / np.sqrt(dx**2 + dy**2))\n        eastness = np.arctan(dx / np.sqrt(dx**2 + dy**2))\n\n    return northness, eastness\n  \n  \ndef geotiff_to_csv(geotiff_file, csv_file):\n    # Open the GeoTIFF file\n    with rasterio.open(geotiff_file) as dataset:\n        # Get the pixel values as a 2D array\n        data = dataset.read(1)\n\n        # Get the geotransform to convert pixel coordinates to geographic coordinates\n        transform = dataset.transform\n\n        # Get the width and height of the GeoTIFF\n        height, width = data.shape\n\n        # Open the CSV file for writing\n        with open(csv_file, 'w', newline='') as csvfile:\n            csvwriter = csv.writer(csvfile)\n\n            # Write the CSV header\n            csvwriter.writerow(['Latitude', 'Longitude', 'x', 'y', 'Elevation'])\n\n            # Loop through each pixel and extract latitude, longitude, and image value\n            for y in range(height):\n                for x in range(width):\n                    # Get the pixel value\n                    image_value = data[y, x]\n\n                    # Convert pixel coordinates to geographic coordinates\n                    lon, lat = transform * (x, y)\n\n                    # Write the data to the CSV file\n                    csvwriter.writerow([lat, lon, x, y, image_value])\n\n  \ndef read_elevation_data(file_path, result_dem_csv_path, result_dem_feature_csv_path):\n    neighborhood_size=4\n    df = pd.read_csv(file_path)\n    \n    dataset = rasterio.open(geotiff_file)\n    data = dataset.read(1)\n\n    # Get the width and height of the GeoTIFF\n    height, width = data.shape\n    \n    # Create an empty DataFrame with column names\n    columns = ['lat', 'lon', 'elevation', 'slope', 'aspect', 'curvature', 'northness', 'eastness']\n    all_df = pd.DataFrame(columns=columns)\n    \n    all_df.to_csv(result_dem_feature_csv_path)\n    print(f\"DEM and other columns are saved to file {result_dem_feature_csv_path}\")\n    return all_df\n\n\n  \n# Usage example:\nresult_dem_csv_path = \"/home/chetana/gridmet_test_run/dem_template.csv\"\nresult_dem_feature_csv_path = \"/home/chetana/gridmet_test_run/dem_all.csv\"\n\n\ndem_file = \"/home/chetana/gridmet_test_run/dem_file.tif\"\nslope_file = '/home/chetana/gridmet_test_run/slope_file.tif'\naspect_file = '/home/chetana/gridmet_test_run/aspect_file.tif'\ncurvature_file = '/home/chetana/gridmet_test_run/curvature_file.tif'\nnorthness_file = '/home/chetana/gridmet_test_run/northness_file.tif'\neastness_file = '/home/chetana/gridmet_test_run/eastness_file.tif'\n\n\nslope, aspect = calculate_slope_aspect(dem_file)\ncurvature = calculate_curvature(dem_file)\nnorthness, eastness = calculate_gradients(dem_file)\n\n# Save the slope and aspect as new GeoTIFF files\nsave_as_geotiff(slope, slope_file, dem_file)\nsave_as_geotiff(aspect, aspect_file, dem_file)\nsave_as_geotiff(curvature, curvature_file, dem_file)\nsave_as_geotiff(northness, northness_file, dem_file)\nsave_as_geotiff(eastness, eastness_file, dem_file)\n\ngeotiff_to_csv(dem_file, dem_file+\".csv\")\ngeotiff_to_csv(slope_file, slope_file+\".csv\")\ngeotiff_to_csv(aspect_file, aspect_file+\".csv\")\ngeotiff_to_csv(curvature_file, curvature_file+\".csv\")\ngeotiff_to_csv(northness_file, northness_file+\".csv\")\ngeotiff_to_csv(eastness_file, eastness_file+\".csv\")\n\n# List of file paths for the CSV files\ncsv_files = [dem_file+\".csv\", slope_file+\".csv\", aspect_file+\".csv\", \n             curvature_file+\".csv\", northness_file+\".csv\", eastness_file+\".csv\"]\n\n# Initialize an empty list to store all dataframes\ndfs = []\n\n# Read each CSV file into separate dataframes\nfor file in csv_files:\n    df = pd.read_csv(file, encoding='utf-8')\n    dfs.append(df)\n\n# Merge the dataframes based on the latitude and longitude columns\nmerged_df = dfs[0]  # Start with the first dataframe\nfor i in range(1, len(dfs)):\n    merged_df = pd.merge(merged_df, dfs[i], on=['Latitude', 'Longitude', 'x', 'y'])\n\n# Save the merged dataframe to a new CSV file\nmerged_df.to_csv(result_dem_feature_csv_path, index=False)\n",
  "history_output" : "/home/chetana/gw-workspace/8cS9A8dQoAxo/western_us_dem.py:107: RuntimeWarning: invalid value encountered in true_divide\n  northness = np.arctan(dy / np.sqrt(dx**2 + dy**2))\n/home/chetana/gw-workspace/8cS9A8dQoAxo/western_us_dem.py:108: RuntimeWarning: invalid value encountered in true_divide\n  eastness = np.arctan(dx / np.sqrt(dx**2 + dy**2))\nslope shape: (666, 694)\naspect shape: (666, 694)\n",
  "history_begin_time" : 1690261302691,
  "history_end_time" : 1690261316508,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "4d7pceQwMCfK",
  "history_input" : "import numpy as np\nimport pandas as pd\nfrom osgeo import gdal\nimport warnings\nimport rasterio\nimport csv\nfrom rasterio.transform import Affine\nfrom scipy.ndimage import sobel, gaussian_filter\n\n# Set the warning filter globally to ignore the FutureWarning\nwarnings.simplefilter(\"ignore\", FutureWarning)\n\ndef lat_lon_to_pixel(lat, lon, geotransform):\n    x = int((lon - geotransform[0]) / geotransform[1])\n    y = int((lat - geotransform[3]) / geotransform[5])\n    return x, y\n\n\ndef calculate_slope_aspect_for_single(elevation_data, pixel_size_x, pixel_size_y):\n    # Calculate slope using the Sobel operator\n    slope_x = np.gradient(elevation_data, pixel_size_x, axis=1)\n    slope_y = np.gradient(elevation_data, pixel_size_y, axis=0)\n    slope_rad = np.arctan(np.sqrt(slope_x ** 2 + slope_y ** 2))\n    slope_deg = np.degrees(slope_rad)\n\n    # Calculate aspect (direction of the steepest descent)\n    aspect_rad = np.arctan2(slope_y, -slope_x)\n    aspect_deg = (np.degrees(aspect_rad) + 360) % 360\n\n    return slope_deg, aspect_deg\n\n\ndef save_as_geotiff(data, output_file, src_file):\n    with rasterio.open(src_file) as src_dataset:\n        profile = src_dataset.profile\n        transform = src_dataset.transform\n\n        # Update the data type, count, and set the transform for the new dataset\n        profile.update(dtype=rasterio.float32, count=1, transform=transform)\n\n        # Create the new GeoTIFF file\n        with rasterio.open(output_file, 'w', **profile) as dst_dataset:\n            # Write the data to the new GeoTIFF\n            dst_dataset.write(data, 1)\n  \n\ndef calculate_slope_aspect(dem_file):\n    with rasterio.open(dem_file) as dataset:\n        # Read the DEM data as a numpy array\n        dem_data = dataset.read(1)\n\n        # Get the geotransform to convert pixel coordinates to geographic coordinates\n        transform = dataset.transform\n\n        # Calculate the slope and aspect using numpy\n        dx, dy = np.gradient(dem_data, transform[0], transform[4])\n        slope = np.arctan(np.sqrt(dx ** 2 + dy ** 2)) * (180.0 / np.pi)\n        aspect = np.arctan2(-dy, dx) * (180.0 / np.pi)\n\n        # Adjust aspect values to range from 0 to 360 degrees\n        aspect[aspect < 0] += 360\n        print(f\"slope shape: {slope.shape}\")\n        print(f\"aspect shape: {aspect.shape}\")\n        \n        \n    return slope, aspect\n  \ndef calculate_curvature(elevation_data, pixel_size_x, pixel_size_y):\n    # Calculate curvature using the Laplacian operator\n    curvature_x = np.gradient(np.gradient(elevation_data, pixel_size_x, axis=1), pixel_size_x, axis=1)\n    curvature_y = np.gradient(np.gradient(elevation_data, pixel_size_y, axis=0), pixel_size_y, axis=0)\n    curvature = curvature_x + curvature_y\n\n    return curvature\n\n  \ndef calculate_curvature(dem_file, sigma=1):\n    with rasterio.open(dem_file) as dataset:\n        # Read the DEM data as a numpy array\n        dem_data = dataset.read(1)\n\n        # Calculate the gradient using the Sobel filter\n        dx = sobel(dem_data, axis=1, mode='constant')\n        dy = sobel(dem_data, axis=0, mode='constant')\n\n        # Calculate the second derivatives using the Sobel filter\n        dxx = sobel(dx, axis=1, mode='constant')\n        dyy = sobel(dy, axis=0, mode='constant')\n\n        # Calculate the curvature using the second derivatives\n        curvature = dxx + dyy\n\n        # Smooth the curvature using Gaussian filtering (optional)\n        curvature = gaussian_filter(curvature, sigma)\n\n    return curvature\n  \ndef calculate_gradients(dem_file):\n    with rasterio.open(dem_file) as dataset:\n        # Read the DEM data as a numpy array\n        dem_data = dataset.read(1)\n\n        # Calculate the gradients along the North and East directions\n        dy, dx = np.gradient(dem_data, dataset.res[0], dataset.res[1])\n\n        # Calculate the Northness and Eastness\n        northness = np.arctan(dy / np.sqrt(dx**2 + dy**2))\n        eastness = np.arctan(dx / np.sqrt(dx**2 + dy**2))\n\n    return northness, eastness\n  \n  \ndef geotiff_to_csv(geotiff_file, csv_file):\n    # Open the GeoTIFF file\n    with rasterio.open(geotiff_file) as dataset:\n        # Get the pixel values as a 2D array\n        data = dataset.read(1)\n\n        # Get the geotransform to convert pixel coordinates to geographic coordinates\n        transform = dataset.transform\n\n        # Get the width and height of the GeoTIFF\n        height, width = data.shape\n\n        # Open the CSV file for writing\n        with open(csv_file, 'w', newline='') as csvfile:\n            csvwriter = csv.writer(csvfile)\n\n            # Write the CSV header\n            csvwriter.writerow(['Latitude', 'Longitude', 'x', 'y', 'Elevation'])\n\n            # Loop through each pixel and extract latitude, longitude, and image value\n            for y in range(height):\n                for x in range(width):\n                    # Get the pixel value\n                    image_value = data[y, x]\n\n                    # Convert pixel coordinates to geographic coordinates\n                    lon, lat = transform * (x, y)\n\n                    # Write the data to the CSV file\n                    csvwriter.writerow([lat, lon, x, y, image_value])\n\n  \ndef read_elevation_data(file_path, result_dem_csv_path, result_dem_feature_csv_path):\n    neighborhood_size=4\n    df = pd.read_csv(file_path)\n    \n    dataset = rasterio.open(geotiff_file)\n    data = dataset.read(1)\n\n    # Get the width and height of the GeoTIFF\n    height, width = data.shape\n    \n    # Create an empty DataFrame with column names\n    columns = ['lat', 'lon', 'elevation', 'slope', 'aspect', 'curvature', 'northness', 'eastness']\n    all_df = pd.DataFrame(columns=columns)\n    \n    all_df.to_csv(result_dem_feature_csv_path)\n    print(f\"DEM and other columns are saved to file {result_dem_feature_csv_path}\")\n    return all_df\n\n\n  \n# Usage example:\nresult_dem_csv_path = \"/home/chetana/gridmet_test_run/dem_template.csv\"\nresult_dem_feature_csv_path = \"/home/chetana/gridmet_test_run/dem_all.csv\"\n\n\ndem_file = \"/home/chetana/gridmet_test_run/dem_file.tif\"\nslope_file = '/home/chetana/gridmet_test_run/slope_file.tif'\naspect_file = '/home/chetana/gridmet_test_run/aspect_file.tif'\ncurvature_file = '/home/chetana/gridmet_test_run/curvature_file.tif'\nnorthness_file = '/home/chetana/gridmet_test_run/northness_file.tif'\neastness_file = '/home/chetana/gridmet_test_run/eastness_file.tif'\n\n\nslope, aspect = calculate_slope_aspect(dem_file)\ncurvature = calculate_curvature(dem_file)\nnorthness, eastness = calculate_gradients(dem_file)\n\n# Save the slope and aspect as new GeoTIFF files\nsave_as_geotiff(slope, slope_file, dem_file)\nsave_as_geotiff(aspect, aspect_file, dem_file)\nsave_as_geotiff(curvature, curvature_file, dem_file)\nsave_as_geotiff(northness, northness_file, dem_file)\nsave_as_geotiff(eastness, eastness_file, dem_file)\n\ngeotiff_to_csv(dem_file, dem_file+\".csv\")\ngeotiff_to_csv(slope_file, slope_file+\".csv\")\ngeotiff_to_csv(aspect_file, aspect_file+\".csv\")\ngeotiff_to_csv(curvature_file, curvature_file+\".csv\")\ngeotiff_to_csv(northness_file, northness_file+\".csv\")\ngeotiff_to_csv(eastness_file, eastness_file+\".csv\")\n\n# List of file paths for the CSV files\ncsv_files = [dem_file+\".csv\", slope_file+\".csv\", aspect_file+\".csv\", \n             curvature_file+\".csv\", northness_file+\".csv\", eastness_file+\".csv\"]\n\n# Initialize an empty list to store all dataframes\ndfs = []\n\n# Read each CSV file into separate dataframes\nfor file in csv_files:\n    df = pd.read_csv(file, encoding='utf-8')\n    dfs.append(df)\n\n# Merge the dataframes based on the latitude and longitude columns\nmerged_df = dfs[0]  # Start with the first dataframe\nfor i in range(1, len(dfs)):\n    merged_df = pd.merge(merged_df, dfs[i], on=['Latitude', 'Longitude'])\n\n# Save the merged dataframe to a new CSV file\nmerged_df.to_csv(result_dem_feature_csv_path, index=False)\n",
  "history_output" : "/home/chetana/gw-workspace/4d7pceQwMCfK/western_us_dem.py:107: RuntimeWarning: invalid value encountered in true_divide\n  northness = np.arctan(dy / np.sqrt(dx**2 + dy**2))\n/home/chetana/gw-workspace/4d7pceQwMCfK/western_us_dem.py:108: RuntimeWarning: invalid value encountered in true_divide\n  eastness = np.arctan(dx / np.sqrt(dx**2 + dy**2))\nslope shape: (666, 694)\naspect shape: (666, 694)\n",
  "history_begin_time" : 1690261260758,
  "history_end_time" : 1690261275968,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "XCHeSv7CWHkz",
  "history_input" : "import numpy as np\nimport pandas as pd\nfrom osgeo import gdal\nimport warnings\nimport rasterio\nimport csv\nfrom rasterio.transform import Affine\nfrom scipy.ndimage import sobel, gaussian_filter\n\n# Set the warning filter globally to ignore the FutureWarning\nwarnings.simplefilter(\"ignore\", FutureWarning)\n\ndef lat_lon_to_pixel(lat, lon, geotransform):\n    x = int((lon - geotransform[0]) / geotransform[1])\n    y = int((lat - geotransform[3]) / geotransform[5])\n    return x, y\n\n\ndef calculate_slope_aspect_for_single(elevation_data, pixel_size_x, pixel_size_y):\n    # Calculate slope using the Sobel operator\n    slope_x = np.gradient(elevation_data, pixel_size_x, axis=1)\n    slope_y = np.gradient(elevation_data, pixel_size_y, axis=0)\n    slope_rad = np.arctan(np.sqrt(slope_x ** 2 + slope_y ** 2))\n    slope_deg = np.degrees(slope_rad)\n\n    # Calculate aspect (direction of the steepest descent)\n    aspect_rad = np.arctan2(slope_y, -slope_x)\n    aspect_deg = (np.degrees(aspect_rad) + 360) % 360\n\n    return slope_deg, aspect_deg\n\n\ndef save_as_geotiff(data, output_file, src_file):\n    with rasterio.open(src_file) as src_dataset:\n        profile = src_dataset.profile\n        transform = src_dataset.transform\n\n        # Update the data type, count, and set the transform for the new dataset\n        profile.update(dtype=rasterio.float32, count=1, transform=transform)\n\n        # Create the new GeoTIFF file\n        with rasterio.open(output_file, 'w', **profile) as dst_dataset:\n            # Write the data to the new GeoTIFF\n            dst_dataset.write(data, 1)\n  \n\ndef calculate_slope_aspect(dem_file):\n    with rasterio.open(dem_file) as dataset:\n        # Read the DEM data as a numpy array\n        dem_data = dataset.read(1)\n\n        # Get the geotransform to convert pixel coordinates to geographic coordinates\n        transform = dataset.transform\n\n        # Calculate the slope and aspect using numpy\n        dx, dy = np.gradient(dem_data, transform[0], transform[4])\n        slope = np.arctan(np.sqrt(dx ** 2 + dy ** 2)) * (180.0 / np.pi)\n        aspect = np.arctan2(-dy, dx) * (180.0 / np.pi)\n\n        # Adjust aspect values to range from 0 to 360 degrees\n        aspect[aspect < 0] += 360\n        print(f\"slope shape: {slope.shape}\")\n        print(f\"aspect shape: {aspect.shape}\")\n        \n        \n    return slope, aspect\n  \ndef calculate_curvature(elevation_data, pixel_size_x, pixel_size_y):\n    # Calculate curvature using the Laplacian operator\n    curvature_x = np.gradient(np.gradient(elevation_data, pixel_size_x, axis=1), pixel_size_x, axis=1)\n    curvature_y = np.gradient(np.gradient(elevation_data, pixel_size_y, axis=0), pixel_size_y, axis=0)\n    curvature = curvature_x + curvature_y\n\n    return curvature\n\n  \ndef calculate_curvature(dem_file, sigma=1):\n    with rasterio.open(dem_file) as dataset:\n        # Read the DEM data as a numpy array\n        dem_data = dataset.read(1)\n\n        # Calculate the gradient using the Sobel filter\n        dx = sobel(dem_data, axis=1, mode='constant')\n        dy = sobel(dem_data, axis=0, mode='constant')\n\n        # Calculate the second derivatives using the Sobel filter\n        dxx = sobel(dx, axis=1, mode='constant')\n        dyy = sobel(dy, axis=0, mode='constant')\n\n        # Calculate the curvature using the second derivatives\n        curvature = dxx + dyy\n\n        # Smooth the curvature using Gaussian filtering (optional)\n        curvature = gaussian_filter(curvature, sigma)\n\n    return curvature\n  \ndef calculate_gradients(dem_file):\n    with rasterio.open(dem_file) as dataset:\n        # Read the DEM data as a numpy array\n        dem_data = dataset.read(1)\n\n        # Calculate the gradients along the North and East directions\n        dy, dx = np.gradient(dem_data, dataset.res[0], dataset.res[1])\n\n        # Calculate the Northness and Eastness\n        northness = np.arctan(dy / np.sqrt(dx**2 + dy**2))\n        eastness = np.arctan(dx / np.sqrt(dx**2 + dy**2))\n\n    return northness, eastness\n  \n  \ndef geotiff_to_csv(geotiff_file, csv_file):\n    # Open the GeoTIFF file\n    with rasterio.open(geotiff_file) as dataset:\n        # Get the pixel values as a 2D array\n        data = dataset.read(1)\n\n        # Get the geotransform to convert pixel coordinates to geographic coordinates\n        transform = dataset.transform\n\n        # Get the width and height of the GeoTIFF\n        height, width = data.shape\n\n        # Open the CSV file for writing\n        with open(csv_file, 'w', newline='') as csvfile:\n            csvwriter = csv.writer(csvfile)\n\n            # Write the CSV header\n            csvwriter.writerow(['Latitude', 'Longitude', 'x', 'y', 'Elevation'])\n\n            # Loop through each pixel and extract latitude, longitude, and image value\n            for y in range(height):\n                for x in range(width):\n                    # Get the pixel value\n                    image_value = data[y, x]\n\n                    # Convert pixel coordinates to geographic coordinates\n                    lon, lat = transform * (x, y)\n\n                    # Write the data to the CSV file\n                    csvwriter.writerow([lat, lon, x, y, image_value])\n\n  \ndef read_elevation_data(file_path, result_dem_csv_path, result_dem_feature_csv_path):\n    neighborhood_size=4\n    df = pd.read_csv(file_path)\n    \n    dataset = rasterio.open(geotiff_file)\n    data = dataset.read(1)\n\n    # Get the width and height of the GeoTIFF\n    height, width = data.shape\n    \n    # Create an empty DataFrame with column names\n    columns = ['lat', 'lon', 'elevation', 'slope', 'aspect', 'curvature', 'northness', 'eastness']\n    all_df = pd.DataFrame(columns=columns)\n    \n    all_df.to_csv(result_dem_feature_csv_path)\n    print(f\"DEM and other columns are saved to file {result_dem_feature_csv_path}\")\n    return all_df\n\n\n  \n# Usage example:\nresult_dem_csv_path = \"/home/chetana/gridmet_test_run/dem_template.csv\"\nresult_dem_feature_csv_path = \"/home/chetana/gridmet_test_run/dem_all.csv\"\n\n\ndem_file = \"/home/chetana/gridmet_test_run/dem_file.tif\"\nslope_file = '/home/chetana/gridmet_test_run/slope_file.tif'\naspect_file = '/home/chetana/gridmet_test_run/aspect_file.tif'\ncurvature_file = '/home/chetana/gridmet_test_run/curvature_file.tif'\nnorthness_file = '/home/chetana/gridmet_test_run/northness_file.tif'\neastness_file = '/home/chetana/gridmet_test_run/eastness_file.tif'\n\n\nslope, aspect = calculate_slope_aspect(dem_file)\ncurvature = calculate_curvature(dem_file)\nnorthness, eastness = calculate_gradients(dem_file)\n\n# Save the slope and aspect as new GeoTIFF files\nsave_as_geotiff(slope, slope_file, dem_file)\nsave_as_geotiff(aspect, aspect_file, dem_file)\nsave_as_geotiff(curvature, curvature_file, dem_file)\nsave_as_geotiff(northness, northness_file, dem_file)\nsave_as_geotiff(eastness, eastness_file, dem_file)\n\ngeotiff_to_csv(dem_file, dem_file+\".csv\")\ngeotiff_to_csv(slope_file, slope_file+\".csv\")\ngeotiff_to_csv(aspect_file, aspect_file+\".csv\")\ngeotiff_to_csv(curvature_file, curvature_file+\".csv\")\ngeotiff_to_csv(northness_file, northness_file+\".csv\")\ngeotiff_to_csv(eastness_file, eastness_file+\".csv\")\n\n# List of file paths for the CSV files\ncsv_files = [dem_file+\".csv\", slope_file+\".csv\", aspect_file+\".csv\", \n             curvature_file+\".csv\", northness_file+\".csv\", eastness_file+\".csv\"]\n\n# Initialize an empty list to store all dataframes\ndfs = []\n\n# Read each CSV file into separate dataframes\nfor file in csv_files:\n    df = pd.read_csv(file, encoding='utf-8')\n    dfs.append(df)\n\n# Merge the dataframes based on the latitude and longitude columns\nmerged_df = dfs[0]  # Start with the first dataframe\nfor i in range(1, len(dfs)):\n    merged_df = pd.merge(merged_df, dfs[i], on=['latitude', 'longitude'])\n\n# Save the merged dataframe to a new CSV file\nmerged_df.to_csv(result_dem_feature_csv_path, index=False)\n",
  "history_output" : "/home/chetana/gw-workspace/XCHeSv7CWHkz/western_us_dem.py:107: RuntimeWarning: invalid value encountered in true_divide\n  northness = np.arctan(dy / np.sqrt(dx**2 + dy**2))\n/home/chetana/gw-workspace/XCHeSv7CWHkz/western_us_dem.py:108: RuntimeWarning: invalid value encountered in true_divide\n  eastness = np.arctan(dx / np.sqrt(dx**2 + dy**2))\nslope shape: (666, 694)\naspect shape: (666, 694)\nTraceback (most recent call last):\n  File \"/home/chetana/gw-workspace/XCHeSv7CWHkz/western_us_dem.py\", line 211, in <module>\n    merged_df = pd.merge(merged_df, dfs[i], on=['latitude', 'longitude'])\n  File \"/home/chetana/anaconda3/lib/python3.9/site-packages/pandas/core/reshape/merge.py\", line 110, in merge\n    op = _MergeOperation(\n  File \"/home/chetana/anaconda3/lib/python3.9/site-packages/pandas/core/reshape/merge.py\", line 703, in __init__\n    ) = self._get_merge_keys()\n  File \"/home/chetana/anaconda3/lib/python3.9/site-packages/pandas/core/reshape/merge.py\", line 1162, in _get_merge_keys\n    right_keys.append(right._get_label_or_level_values(rk))\n  File \"/home/chetana/anaconda3/lib/python3.9/site-packages/pandas/core/generic.py\", line 1850, in _get_label_or_level_values\n    raise KeyError(key)\nKeyError: 'latitude'\n",
  "history_begin_time" : 1690261180853,
  "history_end_time" : 1690261191392,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : null,
  "indicator" : "Failed"
},{
  "history_id" : "j0owTJRqvDqA",
  "history_input" : "import numpy as np\nimport pandas as pd\nfrom osgeo import gdal\nimport warnings\nimport rasterio\nimport csv\nfrom rasterio.transform import Affine\nfrom scipy.ndimage import sobel, gaussian_filter\n\n# Set the warning filter globally to ignore the FutureWarning\nwarnings.simplefilter(\"ignore\", FutureWarning)\n\ndef lat_lon_to_pixel(lat, lon, geotransform):\n    x = int((lon - geotransform[0]) / geotransform[1])\n    y = int((lat - geotransform[3]) / geotransform[5])\n    return x, y\n\n\ndef calculate_slope_aspect_for_single(elevation_data, pixel_size_x, pixel_size_y):\n    # Calculate slope using the Sobel operator\n    slope_x = np.gradient(elevation_data, pixel_size_x, axis=1)\n    slope_y = np.gradient(elevation_data, pixel_size_y, axis=0)\n    slope_rad = np.arctan(np.sqrt(slope_x ** 2 + slope_y ** 2))\n    slope_deg = np.degrees(slope_rad)\n\n    # Calculate aspect (direction of the steepest descent)\n    aspect_rad = np.arctan2(slope_y, -slope_x)\n    aspect_deg = (np.degrees(aspect_rad) + 360) % 360\n\n    return slope_deg, aspect_deg\n\n\ndef save_as_geotiff(data, output_file, src_file):\n    with rasterio.open(src_file) as src_dataset:\n        profile = src_dataset.profile\n        transform = src_dataset.transform\n\n        # Update the data type, count, and set the transform for the new dataset\n        profile.update(dtype=rasterio.float32, count=1, transform=transform)\n\n        # Create the new GeoTIFF file\n        with rasterio.open(output_file, 'w', **profile) as dst_dataset:\n            # Write the data to the new GeoTIFF\n            dst_dataset.write(data, 1)\n  \n\ndef calculate_slope_aspect(dem_file):\n    with rasterio.open(dem_file) as dataset:\n        # Read the DEM data as a numpy array\n        dem_data = dataset.read(1)\n\n        # Get the geotransform to convert pixel coordinates to geographic coordinates\n        transform = dataset.transform\n\n        # Calculate the slope and aspect using numpy\n        dx, dy = np.gradient(dem_data, transform[0], transform[4])\n        slope = np.arctan(np.sqrt(dx ** 2 + dy ** 2)) * (180.0 / np.pi)\n        aspect = np.arctan2(-dy, dx) * (180.0 / np.pi)\n\n        # Adjust aspect values to range from 0 to 360 degrees\n        aspect[aspect < 0] += 360\n        print(f\"slope shape: {slope.shape}\")\n        print(f\"aspect shape: {aspect.shape}\")\n        \n        \n    return slope, aspect\n  \ndef calculate_curvature(elevation_data, pixel_size_x, pixel_size_y):\n    # Calculate curvature using the Laplacian operator\n    curvature_x = np.gradient(np.gradient(elevation_data, pixel_size_x, axis=1), pixel_size_x, axis=1)\n    curvature_y = np.gradient(np.gradient(elevation_data, pixel_size_y, axis=0), pixel_size_y, axis=0)\n    curvature = curvature_x + curvature_y\n\n    return curvature\n\n  \ndef calculate_curvature(dem_file, sigma=1):\n    with rasterio.open(dem_file) as dataset:\n        # Read the DEM data as a numpy array\n        dem_data = dataset.read(1)\n\n        # Calculate the gradient using the Sobel filter\n        dx = sobel(dem_data, axis=1, mode='constant')\n        dy = sobel(dem_data, axis=0, mode='constant')\n\n        # Calculate the second derivatives using the Sobel filter\n        dxx = sobel(dx, axis=1, mode='constant')\n        dyy = sobel(dy, axis=0, mode='constant')\n\n        # Calculate the curvature using the second derivatives\n        curvature = dxx + dyy\n\n        # Smooth the curvature using Gaussian filtering (optional)\n        curvature = gaussian_filter(curvature, sigma)\n\n    return curvature\n  \ndef calculate_gradients(dem_file):\n    with rasterio.open(dem_file) as dataset:\n        # Read the DEM data as a numpy array\n        dem_data = dataset.read(1)\n\n        # Calculate the gradients along the North and East directions\n        dy, dx = np.gradient(dem_data, dataset.res[0], dataset.res[1])\n\n        # Calculate the Northness and Eastness\n        northness = np.arctan(dy / np.sqrt(dx**2 + dy**2))\n        eastness = np.arctan(dx / np.sqrt(dx**2 + dy**2))\n\n    return northness, eastness\n  \n  \ndef geotiff_to_csv(geotiff_file, csv_file):\n    # Open the GeoTIFF file\n    with rasterio.open(geotiff_file) as dataset:\n        # Get the pixel values as a 2D array\n        data = dataset.read(1)\n\n        # Get the geotransform to convert pixel coordinates to geographic coordinates\n        transform = dataset.transform\n\n        # Get the width and height of the GeoTIFF\n        height, width = data.shape\n\n        # Open the CSV file for writing\n        with open(csv_file, 'w', newline='') as csvfile:\n            csvwriter = csv.writer(csvfile)\n\n            # Write the CSV header\n            csvwriter.writerow(['Latitude', 'Longitude', 'x', 'y', 'Elevation'])\n\n            # Loop through each pixel and extract latitude, longitude, and image value\n            for y in range(height):\n                for x in range(width):\n                    # Get the pixel value\n                    image_value = data[y, x]\n\n                    # Convert pixel coordinates to geographic coordinates\n                    lon, lat = transform * (x, y)\n\n                    # Write the data to the CSV file\n                    csvwriter.writerow([lat, lon, x, y, image_value])\n\n  \ndef read_elevation_data(file_path, result_dem_csv_path, result_dem_feature_csv_path):\n    neighborhood_size=4\n    df = pd.read_csv(file_path)\n    \n    dataset = rasterio.open(geotiff_file)\n    data = dataset.read(1)\n\n    # Get the width and height of the GeoTIFF\n    height, width = data.shape\n    \n    # Create an empty DataFrame with column names\n    columns = ['lat', 'lon', 'elevation', 'slope', 'aspect', 'curvature', 'northness', 'eastness']\n    all_df = pd.DataFrame(columns=columns)\n    \n    all_df.to_csv(result_dem_feature_csv_path)\n    print(f\"DEM and other columns are saved to file {result_dem_feature_csv_path}\")\n    return all_df\n\n\n  \n# Usage example:\nresult_dem_csv_path = \"/home/chetana/gridmet_test_run/dem_template.csv\"\nresult_dem_feature_csv_path = \"/home/chetana/gridmet_test_run/dem_all.csv\"\n\n\ndem_file = \"/home/chetana/gridmet_test_run/dem_file.tif\"\nslope_file = '/home/chetana/gridmet_test_run/slope_file.tif'\naspect_file = '/home/chetana/gridmet_test_run/aspect_file.tif'\ncurvature_file = '/home/chetana/gridmet_test_run/curvature_file.tif'\nnorthness_file = '/home/chetana/gridmet_test_run/northness_file.tif'\neastness_file = '/home/chetana/gridmet_test_run/eastness_file.tif'\n\n\nslope, aspect = calculate_slope_aspect(dem_file)\ncurvature = calculate_curvature(dem_file)\nnorthness, eastness = calculate_gradients(dem_file)\n\n# Save the slope and aspect as new GeoTIFF files\nsave_as_geotiff(slope, slope_file, dem_file)\nsave_as_geotiff(aspect, aspect_file, dem_file)\nsave_as_geotiff(curvature, curvature_file, dem_file)\nsave_as_geotiff(northness, northness_file, dem_file)\nsave_as_geotiff(eastness, eastness_file, dem_file)\n\ngeotiff_to_csv(dem_file, dem_file+\".csv\")\ngeotiff_to_csv(slope_file, slope_file+\".csv\")\ngeotiff_to_csv(aspect_file, aspect_file+\".csv\")\ngeotiff_to_csv(curvature_file, curvature_file+\".csv\")\ngeotiff_to_csv(northness_file, northness_file+\".csv\")\ngeotiff_to_csv(eastness_file, eastness_file+\".csv\")\n\n# List of file paths for the CSV files\ncsv_files = [dem_file, slope_file, aspect_file, curvature_file, \n             northness_file, eastness_file]\n\n# Initialize an empty list to store all dataframes\ndfs = []\n\n# Read each CSV file into separate dataframes\nfor file in csv_files:\n    df = pd.read_csv(file, encoding='utf-8')\n    dfs.append(df)\n\n# Merge the dataframes based on the latitude and longitude columns\nmerged_df = dfs[0]  # Start with the first dataframe\nfor i in range(1, len(dfs)):\n    merged_df = pd.merge(merged_df, dfs[i], on=['latitude', 'longitude'])\n\n# Save the merged dataframe to a new CSV file\nmerged_df.to_csv(result_dem_feature_csv_path, index=False)\n",
  "history_output" : "/home/chetana/gw-workspace/j0owTJRqvDqA/western_us_dem.py:107: RuntimeWarning: invalid value encountered in true_divide\n  northness = np.arctan(dy / np.sqrt(dx**2 + dy**2))\n/home/chetana/gw-workspace/j0owTJRqvDqA/western_us_dem.py:108: RuntimeWarning: invalid value encountered in true_divide\n  eastness = np.arctan(dx / np.sqrt(dx**2 + dy**2))\nslope shape: (666, 694)\naspect shape: (666, 694)\nTraceback (most recent call last):\n  File \"/home/chetana/gw-workspace/j0owTJRqvDqA/western_us_dem.py\", line 205, in <module>\n    df = pd.read_csv(file, encoding='utf-8')\n  File \"/home/chetana/anaconda3/lib/python3.9/site-packages/pandas/util/_decorators.py\", line 211, in wrapper\n    return func(*args, **kwargs)\n  File \"/home/chetana/anaconda3/lib/python3.9/site-packages/pandas/util/_decorators.py\", line 331, in wrapper\n    return func(*args, **kwargs)\n  File \"/home/chetana/anaconda3/lib/python3.9/site-packages/pandas/io/parsers/readers.py\", line 950, in read_csv\n    return _read(filepath_or_buffer, kwds)\n  File \"/home/chetana/anaconda3/lib/python3.9/site-packages/pandas/io/parsers/readers.py\", line 611, in _read\n    return parser.read(nrows)\n  File \"/home/chetana/anaconda3/lib/python3.9/site-packages/pandas/io/parsers/readers.py\", line 1778, in read\n    ) = self._engine.read(  # type: ignore[attr-defined]\n  File \"/home/chetana/anaconda3/lib/python3.9/site-packages/pandas/io/parsers/c_parser_wrapper.py\", line 230, in read\n    chunks = self._reader.read_low_memory(nrows)\n  File \"pandas/_libs/parsers.pyx\", line 808, in pandas._libs.parsers.TextReader.read_low_memory\n  File \"pandas/_libs/parsers.pyx\", line 866, in pandas._libs.parsers.TextReader._read_rows\n  File \"pandas/_libs/parsers.pyx\", line 852, in pandas._libs.parsers.TextReader._tokenize_rows\n  File \"pandas/_libs/parsers.pyx\", line 1973, in pandas._libs.parsers.raise_parser_error\npandas.errors.ParserError: Error tokenizing data. C error: Expected 5 fields in line 26, saw 11\n",
  "history_begin_time" : 1690261095699,
  "history_end_time" : 1690261104805,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : null,
  "indicator" : "Failed"
},{
  "history_id" : "md4JsEofEfT6",
  "history_input" : "import numpy as np\nimport pandas as pd\nfrom osgeo import gdal\nimport warnings\nimport rasterio\nimport csv\nfrom rasterio.transform import Affine\nfrom scipy.ndimage import sobel, gaussian_filter\n\n# Set the warning filter globally to ignore the FutureWarning\nwarnings.simplefilter(\"ignore\", FutureWarning)\n\ndef lat_lon_to_pixel(lat, lon, geotransform):\n    x = int((lon - geotransform[0]) / geotransform[1])\n    y = int((lat - geotransform[3]) / geotransform[5])\n    return x, y\n\n\ndef calculate_slope_aspect_for_single(elevation_data, pixel_size_x, pixel_size_y):\n    # Calculate slope using the Sobel operator\n    slope_x = np.gradient(elevation_data, pixel_size_x, axis=1)\n    slope_y = np.gradient(elevation_data, pixel_size_y, axis=0)\n    slope_rad = np.arctan(np.sqrt(slope_x ** 2 + slope_y ** 2))\n    slope_deg = np.degrees(slope_rad)\n\n    # Calculate aspect (direction of the steepest descent)\n    aspect_rad = np.arctan2(slope_y, -slope_x)\n    aspect_deg = (np.degrees(aspect_rad) + 360) % 360\n\n    return slope_deg, aspect_deg\n\n\ndef save_as_geotiff(data, output_file, src_file):\n    with rasterio.open(src_file) as src_dataset:\n        profile = src_dataset.profile\n        transform = src_dataset.transform\n\n        # Update the data type, count, and set the transform for the new dataset\n        profile.update(dtype=rasterio.float32, count=1, transform=transform)\n\n        # Create the new GeoTIFF file\n        with rasterio.open(output_file, 'w', **profile) as dst_dataset:\n            # Write the data to the new GeoTIFF\n            dst_dataset.write(data, 1)\n  \n\ndef calculate_slope_aspect(dem_file):\n    with rasterio.open(dem_file) as dataset:\n        # Read the DEM data as a numpy array\n        dem_data = dataset.read(1)\n\n        # Get the geotransform to convert pixel coordinates to geographic coordinates\n        transform = dataset.transform\n\n        # Calculate the slope and aspect using numpy\n        dx, dy = np.gradient(dem_data, transform[0], transform[4])\n        slope = np.arctan(np.sqrt(dx ** 2 + dy ** 2)) * (180.0 / np.pi)\n        aspect = np.arctan2(-dy, dx) * (180.0 / np.pi)\n\n        # Adjust aspect values to range from 0 to 360 degrees\n        aspect[aspect < 0] += 360\n        print(f\"slope shape: {slope.shape}\")\n        print(f\"aspect shape: {aspect.shape}\")\n        \n        \n    return slope, aspect\n  \ndef calculate_curvature(elevation_data, pixel_size_x, pixel_size_y):\n    # Calculate curvature using the Laplacian operator\n    curvature_x = np.gradient(np.gradient(elevation_data, pixel_size_x, axis=1), pixel_size_x, axis=1)\n    curvature_y = np.gradient(np.gradient(elevation_data, pixel_size_y, axis=0), pixel_size_y, axis=0)\n    curvature = curvature_x + curvature_y\n\n    return curvature\n\n  \ndef calculate_curvature(dem_file, sigma=1):\n    with rasterio.open(dem_file) as dataset:\n        # Read the DEM data as a numpy array\n        dem_data = dataset.read(1)\n\n        # Calculate the gradient using the Sobel filter\n        dx = sobel(dem_data, axis=1, mode='constant')\n        dy = sobel(dem_data, axis=0, mode='constant')\n\n        # Calculate the second derivatives using the Sobel filter\n        dxx = sobel(dx, axis=1, mode='constant')\n        dyy = sobel(dy, axis=0, mode='constant')\n\n        # Calculate the curvature using the second derivatives\n        curvature = dxx + dyy\n\n        # Smooth the curvature using Gaussian filtering (optional)\n        curvature = gaussian_filter(curvature, sigma)\n\n    return curvature\n  \ndef calculate_gradients(dem_file):\n    with rasterio.open(dem_file) as dataset:\n        # Read the DEM data as a numpy array\n        dem_data = dataset.read(1)\n\n        # Calculate the gradients along the North and East directions\n        dy, dx = np.gradient(dem_data, dataset.res[0], dataset.res[1])\n\n        # Calculate the Northness and Eastness\n        northness = np.arctan(dy / np.sqrt(dx**2 + dy**2))\n        eastness = np.arctan(dx / np.sqrt(dx**2 + dy**2))\n\n    return northness, eastness\n  \n  \ndef geotiff_to_csv(geotiff_file, csv_file):\n    # Open the GeoTIFF file\n    with rasterio.open(geotiff_file) as dataset:\n        # Get the pixel values as a 2D array\n        data = dataset.read(1)\n\n        # Get the geotransform to convert pixel coordinates to geographic coordinates\n        transform = dataset.transform\n\n        # Get the width and height of the GeoTIFF\n        height, width = data.shape\n\n        # Open the CSV file for writing\n        with open(csv_file, 'w', newline='') as csvfile:\n            csvwriter = csv.writer(csvfile)\n\n            # Write the CSV header\n            csvwriter.writerow(['Latitude', 'Longitude', 'x', 'y', 'Elevation'])\n\n            # Loop through each pixel and extract latitude, longitude, and image value\n            for y in range(height):\n                for x in range(width):\n                    # Get the pixel value\n                    image_value = data[y, x]\n\n                    # Convert pixel coordinates to geographic coordinates\n                    lon, lat = transform * (x, y)\n\n                    # Write the data to the CSV file\n                    csvwriter.writerow([lat, lon, x, y, image_value])\n\n  \ndef read_elevation_data(file_path, result_dem_csv_path, result_dem_feature_csv_path):\n    neighborhood_size=4\n    df = pd.read_csv(file_path)\n    \n    dataset = rasterio.open(geotiff_file)\n    data = dataset.read(1)\n\n    # Get the width and height of the GeoTIFF\n    height, width = data.shape\n    \n    # Create an empty DataFrame with column names\n    columns = ['lat', 'lon', 'elevation', 'slope', 'aspect', 'curvature', 'northness', 'eastness']\n    all_df = pd.DataFrame(columns=columns)\n    \n    all_df.to_csv(result_dem_feature_csv_path)\n    print(f\"DEM and other columns are saved to file {result_dem_feature_csv_path}\")\n    return all_df\n\n\n  \n# Usage example:\nresult_dem_csv_path = \"/home/chetana/gridmet_test_run/dem_template.csv\"\nresult_dem_feature_csv_path = \"/home/chetana/gridmet_test_run/dem_all.csv\"\n\n\ndem_file = \"/home/chetana/gridmet_test_run/dem_file.tif\"\nslope_file = '/home/chetana/gridmet_test_run/slope_file.tif'\naspect_file = '/home/chetana/gridmet_test_run/aspect_file.tif'\ncurvature_file = '/home/chetana/gridmet_test_run/curvature_file.tif'\nnorthness_file = '/home/chetana/gridmet_test_run/northness_file.tif'\neastness_file = '/home/chetana/gridmet_test_run/eastness_file.tif'\n\n\nslope, aspect = calculate_slope_aspect(dem_file)\ncurvature = calculate_curvature(dem_file)\nnorthness, eastness = calculate_gradients(dem_file)\n\n# Save the slope and aspect as new GeoTIFF files\nsave_as_geotiff(slope, slope_file, dem_file)\nsave_as_geotiff(aspect, aspect_file, dem_file)\nsave_as_geotiff(curvature, curvature_file, dem_file)\nsave_as_geotiff(northness, northness_file, dem_file)\nsave_as_geotiff(eastness, eastness_file, dem_file)\n\ngeotiff_to_csv(dem_file, dem_file+\".csv\")\ngeotiff_to_csv(slope_file, slope_file+\".csv\")\ngeotiff_to_csv(aspect_file, aspect_file+\".csv\")\ngeotiff_to_csv(curvature_file, curvature_file+\".csv\")\ngeotiff_to_csv(northness_file, northness_file+\".csv\")\ngeotiff_to_csv(eastness_file, eastness_file+\".csv\")\n\n# List of file paths for the CSV files\ncsv_files = [dem_file, slope_file, aspect_file, curvature_file, \n             northness_file, eastness_file]\n\n# Initialize an empty list to store all dataframes\ndfs = []\n\n# Read each CSV file into separate dataframes\nfor file in csv_files:\n    df = pd.read_csv(file)\n    dfs.append(df)\n\n# Merge the dataframes based on the latitude and longitude columns\nmerged_df = dfs[0]  # Start with the first dataframe\nfor i in range(1, len(dfs)):\n    merged_df = pd.merge(merged_df, dfs[i], on=['latitude', 'longitude'])\n\n# Save the merged dataframe to a new CSV file\nmerged_df.to_csv(result_dem_feature_csv_path, index=False)\n",
  "history_output" : "/home/chetana/gw-workspace/md4JsEofEfT6/western_us_dem.py:107: RuntimeWarning: invalid value encountered in true_divide\n  northness = np.arctan(dy / np.sqrt(dx**2 + dy**2))\n/home/chetana/gw-workspace/md4JsEofEfT6/western_us_dem.py:108: RuntimeWarning: invalid value encountered in true_divide\n  eastness = np.arctan(dx / np.sqrt(dx**2 + dy**2))\nslope shape: (666, 694)\naspect shape: (666, 694)\nTraceback (most recent call last):\n  File \"/home/chetana/gw-workspace/md4JsEofEfT6/western_us_dem.py\", line 205, in <module>\n    df = pd.read_csv(file)\n  File \"/home/chetana/anaconda3/lib/python3.9/site-packages/pandas/util/_decorators.py\", line 211, in wrapper\n    return func(*args, **kwargs)\n  File \"/home/chetana/anaconda3/lib/python3.9/site-packages/pandas/util/_decorators.py\", line 331, in wrapper\n    return func(*args, **kwargs)\n  File \"/home/chetana/anaconda3/lib/python3.9/site-packages/pandas/io/parsers/readers.py\", line 950, in read_csv\n    return _read(filepath_or_buffer, kwds)\n  File \"/home/chetana/anaconda3/lib/python3.9/site-packages/pandas/io/parsers/readers.py\", line 605, in _read\n    parser = TextFileReader(filepath_or_buffer, **kwds)\n  File \"/home/chetana/anaconda3/lib/python3.9/site-packages/pandas/io/parsers/readers.py\", line 1442, in __init__\n    self._engine = self._make_engine(f, self.engine)\n  File \"/home/chetana/anaconda3/lib/python3.9/site-packages/pandas/io/parsers/readers.py\", line 1753, in _make_engine\n    return mapping[engine](f, **self.options)\n  File \"/home/chetana/anaconda3/lib/python3.9/site-packages/pandas/io/parsers/c_parser_wrapper.py\", line 79, in __init__\n    self._reader = parsers.TextReader(src, **kwds)\n  File \"pandas/_libs/parsers.pyx\", line 547, in pandas._libs.parsers.TextReader.__cinit__\n  File \"pandas/_libs/parsers.pyx\", line 636, in pandas._libs.parsers.TextReader._get_header\n  File \"pandas/_libs/parsers.pyx\", line 852, in pandas._libs.parsers.TextReader._tokenize_rows\n  File \"pandas/_libs/parsers.pyx\", line 1965, in pandas._libs.parsers.raise_parser_error\nUnicodeDecodeError: 'utf-8' codec can't decode byte 0xb6 in position 18: invalid start byte\n",
  "history_begin_time" : 1690261041183,
  "history_end_time" : 1690261050135,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : null,
  "indicator" : "Failed"
},{
  "history_id" : "VpuW3hTzGVHH",
  "history_input" : "import numpy as np\nimport pandas as pd\nfrom osgeo import gdal\nimport warnings\nimport rasterio\nimport csv\nfrom rasterio.transform import Affine\nfrom scipy.ndimage import sobel, gaussian_filter\n\n# Set the warning filter globally to ignore the FutureWarning\nwarnings.simplefilter(\"ignore\", FutureWarning)\n\ndef lat_lon_to_pixel(lat, lon, geotransform):\n    x = int((lon - geotransform[0]) / geotransform[1])\n    y = int((lat - geotransform[3]) / geotransform[5])\n    return x, y\n\n\ndef calculate_slope_aspect_for_single(elevation_data, pixel_size_x, pixel_size_y):\n    # Calculate slope using the Sobel operator\n    slope_x = np.gradient(elevation_data, pixel_size_x, axis=1)\n    slope_y = np.gradient(elevation_data, pixel_size_y, axis=0)\n    slope_rad = np.arctan(np.sqrt(slope_x ** 2 + slope_y ** 2))\n    slope_deg = np.degrees(slope_rad)\n\n    # Calculate aspect (direction of the steepest descent)\n    aspect_rad = np.arctan2(slope_y, -slope_x)\n    aspect_deg = (np.degrees(aspect_rad) + 360) % 360\n\n    return slope_deg, aspect_deg\n\n\ndef save_as_geotiff(data, output_file, src_file):\n    with rasterio.open(src_file) as src_dataset:\n        profile = src_dataset.profile\n        transform = src_dataset.transform\n\n        # Update the data type, count, and set the transform for the new dataset\n        profile.update(dtype=rasterio.float32, count=1, transform=transform)\n\n        # Create the new GeoTIFF file\n        with rasterio.open(output_file, 'w', **profile) as dst_dataset:\n            # Write the data to the new GeoTIFF\n            dst_dataset.write(data, 1)\n  \n\ndef calculate_slope_aspect(dem_file):\n    with rasterio.open(dem_file) as dataset:\n        # Read the DEM data as a numpy array\n        dem_data = dataset.read(1)\n\n        # Get the geotransform to convert pixel coordinates to geographic coordinates\n        transform = dataset.transform\n\n        # Calculate the slope and aspect using numpy\n        dx, dy = np.gradient(dem_data, transform[0], transform[4])\n        slope = np.arctan(np.sqrt(dx ** 2 + dy ** 2)) * (180.0 / np.pi)\n        aspect = np.arctan2(-dy, dx) * (180.0 / np.pi)\n\n        # Adjust aspect values to range from 0 to 360 degrees\n        aspect[aspect < 0] += 360\n        print(f\"slope shape: {slope.shape}\")\n        print(f\"aspect shape: {aspect.shape}\")\n        \n        \n    return slope, aspect\n  \ndef calculate_curvature(elevation_data, pixel_size_x, pixel_size_y):\n    # Calculate curvature using the Laplacian operator\n    curvature_x = np.gradient(np.gradient(elevation_data, pixel_size_x, axis=1), pixel_size_x, axis=1)\n    curvature_y = np.gradient(np.gradient(elevation_data, pixel_size_y, axis=0), pixel_size_y, axis=0)\n    curvature = curvature_x + curvature_y\n\n    return curvature\n\n  \ndef calculate_curvature(dem_file, sigma=1):\n    with rasterio.open(dem_file) as dataset:\n        # Read the DEM data as a numpy array\n        dem_data = dataset.read(1)\n\n        # Calculate the gradient using the Sobel filter\n        dx = sobel(dem_data, axis=1, mode='constant')\n        dy = sobel(dem_data, axis=0, mode='constant')\n\n        # Calculate the second derivatives using the Sobel filter\n        dxx = sobel(dx, axis=1, mode='constant')\n        dyy = sobel(dy, axis=0, mode='constant')\n\n        # Calculate the curvature using the second derivatives\n        curvature = dxx + dyy\n\n        # Smooth the curvature using Gaussian filtering (optional)\n        curvature = gaussian_filter(curvature, sigma)\n\n    return curvature\n  \ndef calculate_gradients(dem_file):\n    with rasterio.open(dem_file) as dataset:\n        # Read the DEM data as a numpy array\n        dem_data = dataset.read(1)\n\n        # Calculate the gradients along the North and East directions\n        dy, dx = np.gradient(dem_data, dataset.res[0], dataset.res[1])\n\n        # Calculate the Northness and Eastness\n        northness = np.arctan(dy / np.sqrt(dx**2 + dy**2))\n        eastness = np.arctan(dx / np.sqrt(dx**2 + dy**2))\n\n    return northness, eastness\n  \n  \ndef geotiff_to_csv(geotiff_file, csv_file):\n    # Open the GeoTIFF file\n    with rasterio.open(geotiff_file) as dataset:\n        # Get the pixel values as a 2D array\n        data = dataset.read(1)\n\n        # Get the geotransform to convert pixel coordinates to geographic coordinates\n        transform = dataset.transform\n\n        # Get the width and height of the GeoTIFF\n        height, width = data.shape\n\n        # Open the CSV file for writing\n        with open(csv_file, 'w', newline='') as csvfile:\n            csvwriter = csv.writer(csvfile)\n\n            # Write the CSV header\n            csvwriter.writerow(['Latitude', 'Longitude', 'x', 'y', 'Elevation'])\n\n            # Loop through each pixel and extract latitude, longitude, and image value\n            for y in range(height):\n                for x in range(width):\n                    # Get the pixel value\n                    image_value = data[y, x]\n\n                    # Convert pixel coordinates to geographic coordinates\n                    lon, lat = transform * (x, y)\n\n                    # Write the data to the CSV file\n                    csvwriter.writerow([lat, lon, x, y, image_value])\n\n  \ndef read_elevation_data(file_path, result_dem_csv_path, result_dem_feature_csv_path):\n    neighborhood_size=4\n    df = pd.read_csv(file_path)\n    \n    dataset = rasterio.open(geotiff_file)\n    data = dataset.read(1)\n\n    # Get the width and height of the GeoTIFF\n    height, width = data.shape\n    \n    # Create an empty DataFrame with column names\n    columns = ['lat', 'lon', 'elevation', 'slope', 'aspect', 'curvature', 'northness', 'eastness']\n    all_df = pd.DataFrame(columns=columns)\n    \n    all_df.to_csv(result_dem_feature_csv_path)\n    print(f\"DEM and other columns are saved to file {result_dem_feature_csv_path}\")\n    return all_df\n\n\n  \n# Usage example:\nresult_dem_csv_path = \"/home/chetana/gridmet_test_run/dem_template.csv\"\nresult_dem_feature_csv_path = \"/home/chetana/gridmet_test_run/dem_all.csv\"\n\n\ndem_file = \"/home/chetana/gridmet_test_run/dem_file.tif\"\nslope_file = '/home/chetana/gridmet_test_run/slope_file.tif'\naspect_file = '/home/chetana/gridmet_test_run/aspect_file.tif'\ncurvature_file = '/home/chetana/gridmet_test_run/curvature_file.tif'\nnorthness_file = '/home/chetana/gridmet_test_run/northness_file.tif'\neastness_file = '/home/chetana/gridmet_test_run/eastness_file.tif'\n\n\nslope, aspect = calculate_slope_aspect(dem_file)\ncurvature = calculate_curvature(dem_file)\nnorthness, eastness = calculate_gradients(dem_file)\n\n# Save the slope and aspect as new GeoTIFF files\nsave_as_geotiff(slope, slope_file, dem_file)\nsave_as_geotiff(aspect, aspect_file, dem_file)\nsave_as_geotiff(curvature, curvature_file, dem_file)\nsave_as_geotiff(northness, northness_file, dem_file)\nsave_as_geotiff(eastness, eastness_file, dem_file)\n\ngeotiff_to_csv(dem_file, dem_file+\".csv\")\ngeotiff_to_csv(slope_file, slope_file+\".csv\")\ngeotiff_to_csv(aspect_file, aspect_file+\".csv\")\ngeotiff_to_csv(curvature_file, curvature_file+\".csv\")\ngeotiff_to_csv(northness_file, northness_file+\".csv\")\ngeotiff_to_csv(eastness_file, eastness_file+\".csv\")\n\n#generate_all_elevation_variables(\"/home/chetana/gridmet_test_run/output_4km_clipped.tif\", result_dem_csv_path, result_dem_feature_csv_path)\n\n\n\n#final_dem_all_cols = read_elevation_data(\"/home/chetana/gridmet_test_run/output_4km_clipped.tif\")\n",
  "history_output" : "/home/chetana/gw-workspace/VpuW3hTzGVHH/western_us_dem.py:107: RuntimeWarning: invalid value encountered in true_divide\n  northness = np.arctan(dy / np.sqrt(dx**2 + dy**2))\n/home/chetana/gw-workspace/VpuW3hTzGVHH/western_us_dem.py:108: RuntimeWarning: invalid value encountered in true_divide\n  eastness = np.arctan(dx / np.sqrt(dx**2 + dy**2))\nslope shape: (666, 694)\naspect shape: (666, 694)\n",
  "history_begin_time" : 1690260450645,
  "history_end_time" : 1690260459515,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "7gIvhDI1P23p",
  "history_input" : "import numpy as np\nimport pandas as pd\nfrom osgeo import gdal\nimport warnings\nimport rasterio\nimport csv\nfrom rasterio.transform import Affine\nfrom scipy.ndimage import sobel, gaussian_filter\n\n# Set the warning filter globally to ignore the FutureWarning\nwarnings.simplefilter(\"ignore\", FutureWarning)\n\ndef lat_lon_to_pixel(lat, lon, geotransform):\n    x = int((lon - geotransform[0]) / geotransform[1])\n    y = int((lat - geotransform[3]) / geotransform[5])\n    return x, y\n\n\ndef calculate_slope_aspect_for_single(elevation_data, pixel_size_x, pixel_size_y):\n    # Calculate slope using the Sobel operator\n    slope_x = np.gradient(elevation_data, pixel_size_x, axis=1)\n    slope_y = np.gradient(elevation_data, pixel_size_y, axis=0)\n    slope_rad = np.arctan(np.sqrt(slope_x ** 2 + slope_y ** 2))\n    slope_deg = np.degrees(slope_rad)\n\n    # Calculate aspect (direction of the steepest descent)\n    aspect_rad = np.arctan2(slope_y, -slope_x)\n    aspect_deg = (np.degrees(aspect_rad) + 360) % 360\n\n    return slope_deg, aspect_deg\n\n\ndef save_as_geotiff(data, output_file, src_file):\n    with rasterio.open(src_file) as src_dataset:\n        profile = src_dataset.profile\n        transform = src_dataset.transform\n\n        # Update the data type, count, and set the transform for the new dataset\n        profile.update(dtype=rasterio.float32, count=1, transform=transform)\n\n        # Create the new GeoTIFF file\n        with rasterio.open(output_file, 'w', **profile) as dst_dataset:\n            # Write the data to the new GeoTIFF\n            dst_dataset.write(data, 1)\n  \n\ndef calculate_slope_aspect(dem_file):\n    with rasterio.open(dem_file) as dataset:\n        # Read the DEM data as a numpy array\n        dem_data = dataset.read(1)\n\n        # Get the geotransform to convert pixel coordinates to geographic coordinates\n        transform = dataset.transform\n\n        # Calculate the slope and aspect using numpy\n        dx, dy = np.gradient(dem_data, transform[0], transform[4])\n        slope = np.arctan(np.sqrt(dx ** 2 + dy ** 2)) * (180.0 / np.pi)\n        aspect = np.arctan2(-dy, dx) * (180.0 / np.pi)\n\n        # Adjust aspect values to range from 0 to 360 degrees\n        aspect[aspect < 0] += 360\n        print(f\"slope shape: {slope.shape}\")\n        print(f\"aspect shape: {aspect.shape}\")\n        \n        \n    return slope, aspect\n  \ndef calculate_curvature(elevation_data, pixel_size_x, pixel_size_y):\n    # Calculate curvature using the Laplacian operator\n    curvature_x = np.gradient(np.gradient(elevation_data, pixel_size_x, axis=1), pixel_size_x, axis=1)\n    curvature_y = np.gradient(np.gradient(elevation_data, pixel_size_y, axis=0), pixel_size_y, axis=0)\n    curvature = curvature_x + curvature_y\n\n    return curvature\n\n  \ndef calculate_curvature(dem_file, sigma=1):\n    with rasterio.open(dem_file) as dataset:\n        # Read the DEM data as a numpy array\n        dem_data = dataset.read(1)\n\n        # Calculate the gradient using the Sobel filter\n        dx = sobel(dem_data, axis=1, mode='constant')\n        dy = sobel(dem_data, axis=0, mode='constant')\n\n        # Calculate the second derivatives using the Sobel filter\n        dxx = sobel(dx, axis=1, mode='constant')\n        dyy = sobel(dy, axis=0, mode='constant')\n\n        # Calculate the curvature using the second derivatives\n        curvature = dxx + dyy\n\n        # Smooth the curvature using Gaussian filtering (optional)\n        curvature = gaussian_filter(curvature, sigma)\n\n    return curvature\n  \ndef calculate_gradients(dem_file):\n    with rasterio.open(dem_file) as dataset:\n        # Read the DEM data as a numpy array\n        dem_data = dataset.read(1)\n\n        # Calculate the gradients along the North and East directions\n        dy, dx = np.gradient(dem_data, dataset.res[0], dataset.res[1])\n\n        # Calculate the Northness and Eastness\n        northness = np.arctan(dy / np.sqrt(dx**2 + dy**2))\n        eastness = np.arctan(dx / np.sqrt(dx**2 + dy**2))\n\n    return northness, eastness\n  \n  \ndef geotiff_to_csv(geotiff_file, csv_file):\n    # Open the GeoTIFF file\n    with rasterio.open(geotiff_file) as dataset:\n        # Get the pixel values as a 2D array\n        data = dataset.read(1)\n\n        # Get the geotransform to convert pixel coordinates to geographic coordinates\n        transform = dataset.transform\n\n        # Get the width and height of the GeoTIFF\n        height, width = data.shape\n\n        # Open the CSV file for writing\n        with open(csv_file, 'w', newline='') as csvfile:\n            csvwriter = csv.writer(csvfile)\n\n            # Write the CSV header\n            csvwriter.writerow(['Latitude', 'Longitude', 'x', 'y', 'Elevation'])\n\n            # Loop through each pixel and extract latitude, longitude, and image value\n            for y in range(height):\n                for x in range(width):\n                    # Get the pixel value\n                    image_value = data[y, x]\n\n                    # Convert pixel coordinates to geographic coordinates\n                    lon, lat = transform * (x, y)\n\n                    # Write the data to the CSV file\n                    csvwriter.writerow([lat, lon, x, y, image_value])\n\n  \ndef read_elevation_data(file_path, result_dem_csv_path, result_dem_feature_csv_path):\n    neighborhood_size=4\n    df = pd.read_csv(file_path)\n    \n    dataset = rasterio.open(geotiff_file)\n    data = dataset.read(1)\n\n    # Get the width and height of the GeoTIFF\n    height, width = data.shape\n    \n    # Create an empty DataFrame with column names\n    columns = ['lat', 'lon', 'elevation', 'slope', 'aspect', 'curvature', 'northness', 'eastness']\n    all_df = pd.DataFrame(columns=columns)\n    \n    all_df.to_csv(result_dem_feature_csv_path)\n    print(f\"DEM and other columns are saved to file {result_dem_feature_csv_path}\")\n    return all_df\n\n\n  \n# Usage example:\nresult_dem_csv_path = \"/home/chetana/gridmet_test_run/dem_template.csv\"\nresult_dem_feature_csv_path = \"/home/chetana/gridmet_test_run/dem_all.csv\"\n\n\ndem_file = \"/home/chetana/gridmet_test_run/output_4km_clipped.tif\"\nslope_file = '/home/chetana/gridmet_test_run/slope_file.tif'\naspect_file = '/home/chetana/gridmet_test_run/aspect_file.tif'\ncurvature_file = '/home/chetana/gridmet_test_run/curvature_file.tif'\nnorthness_file = '/home/chetana/gridmet_test_run/northness_file.tif'\neastness_file = '/home/chetana/gridmet_test_run/eastness_file.tif'\n\n#geotiff_to_csv(dem_file, result_dem_csv_path)\n\n\nslope, aspect = calculate_slope_aspect(dem_file)\ncurvature = calculate_curvature(dem_file)\nnorthness, eastness = calculate_gradients(dem_file)\n\n# Save the slope and aspect as new GeoTIFF files\nsave_as_geotiff(slope, slope_file, dem_file)\nsave_as_geotiff(aspect, aspect_file, dem_file)\nsave_as_geotiff(curvature, curvature_file, dem_file)\nsave_as_geotiff(northness, northness_file, dem_file)\nsave_as_geotiff(eastness, eastness_file, dem_file)\n\ngeotiff_to_csv(dem_file, dem_file+\".csv\")\ngeotiff_to_csv(slope_file, slope_file+\".csv\")\ngeotiff_to_csv(aspect_file, aspect_file+\".csv\")\ngeotiff_to_csv(curvature_file, curvature_file+\".csv\")\ngeotiff_to_csv(northness_file, northness_file+\".csv\")\ngeotiff_to_csv(eastness_file, eastness_file+\".csv\")\n\n#generate_all_elevation_variables(\"/home/chetana/gridmet_test_run/output_4km_clipped.tif\", result_dem_csv_path, result_dem_feature_csv_path)\n\n\n\n#final_dem_all_cols = read_elevation_data(\"/home/chetana/gridmet_test_run/output_4km_clipped.tif\")\n",
  "history_output" : "/home/chetana/gw-workspace/7gIvhDI1P23p/western_us_dem.py:107: RuntimeWarning: invalid value encountered in true_divide\n  northness = np.arctan(dy / np.sqrt(dx**2 + dy**2))\n/home/chetana/gw-workspace/7gIvhDI1P23p/western_us_dem.py:108: RuntimeWarning: invalid value encountered in true_divide\n  eastness = np.arctan(dx / np.sqrt(dx**2 + dy**2))\nslope shape: (666, 694)\naspect shape: (666, 694)\n",
  "history_begin_time" : 1690260295692,
  "history_end_time" : 1690260304684,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "eVr45NhOh1V0",
  "history_input" : "import numpy as np\nimport pandas as pd\nfrom osgeo import gdal\nimport warnings\nimport rasterio\nimport csv\nfrom rasterio.transform import Affine\nfrom scipy.ndimage import sobel, gaussian_filter\n\n# Set the warning filter globally to ignore the FutureWarning\nwarnings.simplefilter(\"ignore\", FutureWarning)\n\ndef lat_lon_to_pixel(lat, lon, geotransform):\n    x = int((lon - geotransform[0]) / geotransform[1])\n    y = int((lat - geotransform[3]) / geotransform[5])\n    return x, y\n\n\ndef calculate_slope_aspect_for_single(elevation_data, pixel_size_x, pixel_size_y):\n    # Calculate slope using the Sobel operator\n    slope_x = np.gradient(elevation_data, pixel_size_x, axis=1)\n    slope_y = np.gradient(elevation_data, pixel_size_y, axis=0)\n    slope_rad = np.arctan(np.sqrt(slope_x ** 2 + slope_y ** 2))\n    slope_deg = np.degrees(slope_rad)\n\n    # Calculate aspect (direction of the steepest descent)\n    aspect_rad = np.arctan2(slope_y, -slope_x)\n    aspect_deg = (np.degrees(aspect_rad) + 360) % 360\n\n    return slope_deg, aspect_deg\n\n\ndef save_as_geotiff(data, output_file, src_file):\n    with rasterio.open(src_file) as src_dataset:\n        profile = src_dataset.profile\n        transform = src_dataset.transform\n\n        # Update the data type, count, and set the transform for the new dataset\n        profile.update(dtype=rasterio.float32, count=1, transform=transform)\n\n        # Create the new GeoTIFF file\n        with rasterio.open(output_file, 'w', **profile) as dst_dataset:\n            # Write the data to the new GeoTIFF\n            dst_dataset.write(data, 1)\n  \n\ndef calculate_slope_aspect(dem_file):\n    with rasterio.open(dem_file) as dataset:\n        # Read the DEM data as a numpy array\n        dem_data = dataset.read(1)\n\n        # Get the geotransform to convert pixel coordinates to geographic coordinates\n        transform = dataset.transform\n\n        # Calculate the slope and aspect using numpy\n        dx, dy = np.gradient(dem_data, transform[0], transform[4])\n        slope = np.arctan(np.sqrt(dx ** 2 + dy ** 2)) * (180.0 / np.pi)\n        aspect = np.arctan2(-dy, dx) * (180.0 / np.pi)\n\n        # Adjust aspect values to range from 0 to 360 degrees\n        aspect[aspect < 0] += 360\n        print(f\"slope shape: {slope.shape}\")\n        print(f\"aspect shape: {aspect.shape}\")\n        \n        \n    return slope, aspect\n  \ndef calculate_curvature(elevation_data, pixel_size_x, pixel_size_y):\n    # Calculate curvature using the Laplacian operator\n    curvature_x = np.gradient(np.gradient(elevation_data, pixel_size_x, axis=1), pixel_size_x, axis=1)\n    curvature_y = np.gradient(np.gradient(elevation_data, pixel_size_y, axis=0), pixel_size_y, axis=0)\n    curvature = curvature_x + curvature_y\n\n    return curvature\n\n  \ndef calculate_curvature(dem_file, sigma=1):\n    with rasterio.open(dem_file) as dataset:\n        # Read the DEM data as a numpy array\n        dem_data = dataset.read(1)\n\n        # Calculate the gradient using the Sobel filter\n        dx = sobel(dem_data, axis=1, mode='constant')\n        dy = sobel(dem_data, axis=0, mode='constant')\n\n        # Calculate the second derivatives using the Sobel filter\n        dxx = sobel(dx, axis=1, mode='constant')\n        dyy = sobel(dy, axis=0, mode='constant')\n\n        # Calculate the curvature using the second derivatives\n        curvature = dxx + dyy\n\n        # Smooth the curvature using Gaussian filtering (optional)\n        curvature = gaussian_filter(curvature, sigma)\n\n    return curvature\n  \ndef calculate_gradients(dem_file):\n    with rasterio.open(dem_file) as dataset:\n        # Read the DEM data as a numpy array\n        dem_data = dataset.read(1)\n\n        # Calculate the gradients along the North and East directions\n        dy, dx = np.gradient(dem_data, dataset.res[0], dataset.res[1])\n\n        # Calculate the Northness and Eastness\n        northness = np.arctan(dy / np.sqrt(dx**2 + dy**2))\n        eastness = np.arctan(dx / np.sqrt(dx**2 + dy**2))\n\n    return northness, eastness\n  \n  \ndef geotiff_to_csv(geotiff_file, csv_file):\n    # Open the GeoTIFF file\n    with rasterio.open(geotiff_file) as dataset:\n        # Get the pixel values as a 2D array\n        data = dataset.read(1)\n\n        # Get the geotransform to convert pixel coordinates to geographic coordinates\n        transform = dataset.transform\n\n        # Get the width and height of the GeoTIFF\n        height, width = data.shape\n\n        # Open the CSV file for writing\n        with open(csv_file, 'w', newline='') as csvfile:\n            csvwriter = csv.writer(csvfile)\n\n            # Write the CSV header\n            csvwriter.writerow(['Latitude', 'Longitude', 'x', 'y', 'Elevation'])\n\n            # Loop through each pixel and extract latitude, longitude, and image value\n            for y in range(height):\n                for x in range(width):\n                    # Get the pixel value\n                    image_value = data[y, x]\n\n                    # Convert pixel coordinates to geographic coordinates\n                    lon, lat = transform * (x, y)\n\n                    # Write the data to the CSV file\n                    csvwriter.writerow([lat, lon, x, y, image_value])\n\n  \ndef read_elevation_data(file_path, result_dem_csv_path, result_dem_feature_csv_path):\n    neighborhood_size=4\n    df = pd.read_csv(file_path)\n    \n    dataset = rasterio.open(geotiff_file)\n    data = dataset.read(1)\n\n    # Get the width and height of the GeoTIFF\n    height, width = data.shape\n    \n    # Create an empty DataFrame with column names\n    columns = ['lat', 'lon', 'elevation', 'slope', 'aspect', 'curvature', 'northness', 'eastness']\n    all_df = pd.DataFrame(columns=columns)\n    \n    print(f\"neighborhood_size // 2 = {neighborhood_size // 2}\")\n    \n    for index, row in original_df.iterrows():\n      # Access individual row elements using row['column_name']\n      # Convert latitude and longitude to pixel indices\n      x = row[\"x\"]\n      y = row[\"y\"]\n      lat = row['Latitude']\n      lon = row['Longitude']\n      elevation = row['Elevation']\n      \n      if index % 500 == 0:\n        print(f\"processing {x} {y}\")\n\t  \n      if x < neighborhood_size // 2 or y < neighborhood_size // 2 or x > (width - neighborhood_size // 2) or y > (height - neighborhood_size // 2):\n      \tdata_row = {\n            'lat': lat,\n            'lon': lon,\n            'elevation': elevation,\n            'slope': -1,\n            'aspect': -1,\n            'curvature': -1,\n            'northness': -1,\n            'eastness': -1\n        }\n      else:\n        # Read a small neighborhood of elevation data around the selected point\n        small_elevation_data = band.ReadAsArray(x - neighborhood_size // 2, y - neighborhood_size // 2, neighborhood_size, neighborhood_size)\n\n        # Calculate slope and aspect\n        slope_data, aspect_data = calculate_slope_aspect(small_elevation_data, pixel_size_x, pixel_size_y)\n\n        # Calculate curvature\n        curvature_data = calculate_curvature(small_elevation_data, pixel_size_x, pixel_size_y)\n        northness_data = np.abs(np.sin(np.radians(aspect_data)))\n        eastness_data = np.abs(np.cos(np.radians(aspect_data)))\n\n\n        data_row = {\n            'lat': lat,\n            'lon': lon,\n            'elevation': elevation,\n            'slope': slope_data[neighborhood_size // 2, neighborhood_size // 2],\n            'aspect': aspect_data[neighborhood_size // 2, neighborhood_size // 2],\n            'curvature': curvature_data[neighborhood_size // 2, neighborhood_size // 2],\n            'northness': northness_data[neighborhood_size // 2, neighborhood_size // 2],\n            'eastness': eastness_data[neighborhood_size // 2, neighborhood_size // 2]\n        }\n      \n      \n      # Append a row to the DataFrame\n      all_df = all_df.append(data_row, ignore_index=True)\n    \n    all_df.to_csv(result_dem_feature_csv_path)\n    print(f\"DEM and other columns are saved to file {result_dem_feature_csv_path}\")\n    return all_df\n\n\n  \n# Usage example:\nresult_dem_csv_path = \"/home/chetana/gridmet_test_run/dem_template.csv\"\nresult_dem_feature_csv_path = \"/home/chetana/gridmet_test_run/dem_all.csv\"\n\n\ndem_file = \"/home/chetana/gridmet_test_run/output_4km_clipped.tif\"\nslope_file = '/home/chetana/gridmet_test_run/slope_file.tif'\naspect_file = '/home/chetana/gridmet_test_run/aspect_file.tif'\ncurvature_file = '/home/chetana/gridmet_test_run/curvature_file.tif'\nnorthness_file = '/home/chetana/gridmet_test_run/northness_file.tif'\neastness_file = '/home/chetana/gridmet_test_run/eastness_file.tif'\n\n#geotiff_to_csv(dem_file, result_dem_csv_path)\n\n\nslope, aspect = calculate_slope_aspect(dem_file)\ncurvature = calculate_curvature(dem_file)\nnorthness, eastness = calculate_gradients(dem_file)\n\n# Save the slope and aspect as new GeoTIFF files\nsave_as_geotiff(slope, slope_file, dem_file)\nsave_as_geotiff(aspect, aspect_file, dem_file)\nsave_as_geotiff(curvature, curvature_file, dem_file)\nsave_as_geotiff(northness, northness_file, dem_file)\nsave_as_geotiff(eastness, eastness_file, dem_file)\n\n\n#generate_all_elevation_variables(\"/home/chetana/gridmet_test_run/output_4km_clipped.tif\", result_dem_csv_path, result_dem_feature_csv_path)\n\n\n\n#final_dem_all_cols = read_elevation_data(\"/home/chetana/gridmet_test_run/output_4km_clipped.tif\")\n",
  "history_output" : "/home/chetana/gw-workspace/eVr45NhOh1V0/western_us_dem.py:107: RuntimeWarning: invalid value encountered in true_divide\n  northness = np.arctan(dy / np.sqrt(dx**2 + dy**2))\n/home/chetana/gw-workspace/eVr45NhOh1V0/western_us_dem.py:108: RuntimeWarning: invalid value encountered in true_divide\n  eastness = np.arctan(dx / np.sqrt(dx**2 + dy**2))\nslope shape: (666, 694)\naspect shape: (666, 694)\n",
  "history_begin_time" : 1690259970965,
  "history_end_time" : 1690259972344,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "j3Pm6hwj4Avy",
  "history_input" : "import numpy as np\nimport pandas as pd\nfrom osgeo import gdal\nimport warnings\nimport rasterio\nimport csv\nfrom rasterio.transform import Affine\nfrom scipy.ndimage import sobel, gaussian_filter\n\n# Set the warning filter globally to ignore the FutureWarning\nwarnings.simplefilter(\"ignore\", FutureWarning)\n\ndef lat_lon_to_pixel(lat, lon, geotransform):\n    x = int((lon - geotransform[0]) / geotransform[1])\n    y = int((lat - geotransform[3]) / geotransform[5])\n    return x, y\n\n\ndef calculate_slope_aspect_for_single(elevation_data, pixel_size_x, pixel_size_y):\n    # Calculate slope using the Sobel operator\n    slope_x = np.gradient(elevation_data, pixel_size_x, axis=1)\n    slope_y = np.gradient(elevation_data, pixel_size_y, axis=0)\n    slope_rad = np.arctan(np.sqrt(slope_x ** 2 + slope_y ** 2))\n    slope_deg = np.degrees(slope_rad)\n\n    # Calculate aspect (direction of the steepest descent)\n    aspect_rad = np.arctan2(slope_y, -slope_x)\n    aspect_deg = (np.degrees(aspect_rad) + 360) % 360\n\n    return slope_deg, aspect_deg\n\n\ndef save_as_geotiff(data, output_file, src_file):\n    with rasterio.open(src_file) as src_dataset:\n        profile = src_dataset.profile\n        transform = src_dataset.transform\n\n        # Update the data type, count, and set the transform for the new dataset\n        profile.update(dtype=rasterio.float32, count=1, transform=transform)\n\n        # Create the new GeoTIFF file\n        with rasterio.open(output_file, 'w', **profile) as dst_dataset:\n            # Write the data to the new GeoTIFF\n            dst_dataset.write(data, 1)\n  \n\ndef calculate_slope_aspect(dem_file):\n    with rasterio.open(dem_file) as dataset:\n        # Read the DEM data as a numpy array\n        dem_data = dataset.read(1)\n\n        # Get the geotransform to convert pixel coordinates to geographic coordinates\n        transform = dataset.transform\n\n        # Calculate the slope and aspect using numpy\n        dx, dy = np.gradient(dem_data, transform[0], transform[4])\n        slope = np.arctan(np.sqrt(dx ** 2 + dy ** 2)) * (180.0 / np.pi)\n        aspect = np.arctan2(-dy, dx) * (180.0 / np.pi)\n\n        # Adjust aspect values to range from 0 to 360 degrees\n        aspect[aspect < 0] += 360\n        print(f\"slope shape: {slope.shape}\")\n        print(f\"aspect shape: {aspect.shape}\")\n        \n        \n    return slope, aspect\n  \ndef calculate_curvature(elevation_data, pixel_size_x, pixel_size_y):\n    # Calculate curvature using the Laplacian operator\n    curvature_x = np.gradient(np.gradient(elevation_data, pixel_size_x, axis=1), pixel_size_x, axis=1)\n    curvature_y = np.gradient(np.gradient(elevation_data, pixel_size_y, axis=0), pixel_size_y, axis=0)\n    curvature = curvature_x + curvature_y\n\n    return curvature\n\n  \ndef calculate_curvature(dem_file, sigma=1):\n    with rasterio.open(dem_file) as dataset:\n        # Read the DEM data as a numpy array\n        dem_data = dataset.read(1)\n\n        # Calculate the gradient using the Sobel filter\n        dx = sobel(dem_data, axis=1, mode='constant')\n        dy = sobel(dem_data, axis=0, mode='constant')\n\n        # Calculate the second derivatives using the Sobel filter\n        dxx = sobel(dx, axis=1, mode='constant')\n        dyy = sobel(dy, axis=0, mode='constant')\n\n        # Calculate the curvature using the second derivatives\n        curvature = dxx + dyy\n\n        # Smooth the curvature using Gaussian filtering (optional)\n        curvature = gaussian_filter(curvature, sigma)\n\n    return curvature\n  \n  \ndef geotiff_to_csv(geotiff_file, csv_file):\n    # Open the GeoTIFF file\n    with rasterio.open(geotiff_file) as dataset:\n        # Get the pixel values as a 2D array\n        data = dataset.read(1)\n\n        # Get the geotransform to convert pixel coordinates to geographic coordinates\n        transform = dataset.transform\n\n        # Get the width and height of the GeoTIFF\n        height, width = data.shape\n\n        # Open the CSV file for writing\n        with open(csv_file, 'w', newline='') as csvfile:\n            csvwriter = csv.writer(csvfile)\n\n            # Write the CSV header\n            csvwriter.writerow(['Latitude', 'Longitude', 'x', 'y', 'Elevation'])\n\n            # Loop through each pixel and extract latitude, longitude, and image value\n            for y in range(height):\n                for x in range(width):\n                    # Get the pixel value\n                    image_value = data[y, x]\n\n                    # Convert pixel coordinates to geographic coordinates\n                    lon, lat = transform * (x, y)\n\n                    # Write the data to the CSV file\n                    csvwriter.writerow([lat, lon, x, y, image_value])\n\n  \ndef read_elevation_data(file_path, result_dem_csv_path, result_dem_feature_csv_path):\n    neighborhood_size=4\n    df = pd.read_csv(file_path)\n    \n    dataset = rasterio.open(geotiff_file)\n    data = dataset.read(1)\n\n    # Get the width and height of the GeoTIFF\n    height, width = data.shape\n    \n    # Create an empty DataFrame with column names\n    columns = ['lat', 'lon', 'elevation', 'slope', 'aspect', 'curvature', 'northness', 'eastness']\n    all_df = pd.DataFrame(columns=columns)\n    \n    print(f\"neighborhood_size // 2 = {neighborhood_size // 2}\")\n    \n    for index, row in original_df.iterrows():\n      # Access individual row elements using row['column_name']\n      # Convert latitude and longitude to pixel indices\n      x = row[\"x\"]\n      y = row[\"y\"]\n      lat = row['Latitude']\n      lon = row['Longitude']\n      elevation = row['Elevation']\n      \n      if index % 500 == 0:\n        print(f\"processing {x} {y}\")\n\t  \n      if x < neighborhood_size // 2 or y < neighborhood_size // 2 or x > (width - neighborhood_size // 2) or y > (height - neighborhood_size // 2):\n      \tdata_row = {\n            'lat': lat,\n            'lon': lon,\n            'elevation': elevation,\n            'slope': -1,\n            'aspect': -1,\n            'curvature': -1,\n            'northness': -1,\n            'eastness': -1\n        }\n      else:\n        # Read a small neighborhood of elevation data around the selected point\n        small_elevation_data = band.ReadAsArray(x - neighborhood_size // 2, y - neighborhood_size // 2, neighborhood_size, neighborhood_size)\n\n        # Calculate slope and aspect\n        slope_data, aspect_data = calculate_slope_aspect(small_elevation_data, pixel_size_x, pixel_size_y)\n\n        # Calculate curvature\n        curvature_data = calculate_curvature(small_elevation_data, pixel_size_x, pixel_size_y)\n        northness_data = np.abs(np.sin(np.radians(aspect_data)))\n        eastness_data = np.abs(np.cos(np.radians(aspect_data)))\n\n\n        data_row = {\n            'lat': lat,\n            'lon': lon,\n            'elevation': elevation,\n            'slope': slope_data[neighborhood_size // 2, neighborhood_size // 2],\n            'aspect': aspect_data[neighborhood_size // 2, neighborhood_size // 2],\n            'curvature': curvature_data[neighborhood_size // 2, neighborhood_size // 2],\n            'northness': northness_data[neighborhood_size // 2, neighborhood_size // 2],\n            'eastness': eastness_data[neighborhood_size // 2, neighborhood_size // 2]\n        }\n      \n      \n      # Append a row to the DataFrame\n      all_df = all_df.append(data_row, ignore_index=True)\n    \n    all_df.to_csv(result_dem_feature_csv_path)\n    print(f\"DEM and other columns are saved to file {result_dem_feature_csv_path}\")\n    return all_df\n\n\n  \n# Usage example:\nresult_dem_csv_path = \"/home/chetana/gridmet_test_run/dem_template.csv\"\nresult_dem_feature_csv_path = \"/home/chetana/gridmet_test_run/dem_all.csv\"\n\n\ndem_file = \"/home/chetana/gridmet_test_run/output_4km_clipped.tif\"\nslope_file = '/home/chetana/gridmet_test_run/slope_file.tif'\naspect_file = '/home/chetana/gridmet_test_run/aspect_file.tif'\ncurvature_file = '/home/chetana/gridmet_test_run/curvature_file.tif'\n\n\n#geotiff_to_csv(dem_file, result_dem_csv_path)\n\n\nslope, aspect = calculate_slope_aspect(dem_file)\ncurvature = calculate_curvature(dem_file)\n\n# Save the slope and aspect as new GeoTIFF files\nsave_as_geotiff(slope, slope_file, dem_file)\nsave_as_geotiff(aspect, aspect_file, dem_file)\nsave_as_geotiff(curvature, curvature_file, dem_file)\n\n\n#generate_all_elevation_variables(\"/home/chetana/gridmet_test_run/output_4km_clipped.tif\", result_dem_csv_path, result_dem_feature_csv_path)\n\n\n\n#final_dem_all_cols = read_elevation_data(\"/home/chetana/gridmet_test_run/output_4km_clipped.tif\")\n",
  "history_output" : "slope shape: (666, 694)\naspect shape: (666, 694)\n",
  "history_begin_time" : 1690259694643,
  "history_end_time" : 1690259696885,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "3a0JdQOddlTL",
  "history_input" : "import numpy as np\nimport pandas as pd\nfrom osgeo import gdal\nimport warnings\nimport rasterio\nimport csv\nfrom rasterio.transform import Affine\n\n# Set the warning filter globally to ignore the FutureWarning\nwarnings.simplefilter(\"ignore\", FutureWarning)\n\ndef lat_lon_to_pixel(lat, lon, geotransform):\n    x = int((lon - geotransform[0]) / geotransform[1])\n    y = int((lat - geotransform[3]) / geotransform[5])\n    return x, y\n\n\ndef calculate_slope_aspect_for_single(elevation_data, pixel_size_x, pixel_size_y):\n    # Calculate slope using the Sobel operator\n    slope_x = np.gradient(elevation_data, pixel_size_x, axis=1)\n    slope_y = np.gradient(elevation_data, pixel_size_y, axis=0)\n    slope_rad = np.arctan(np.sqrt(slope_x ** 2 + slope_y ** 2))\n    slope_deg = np.degrees(slope_rad)\n\n    # Calculate aspect (direction of the steepest descent)\n    aspect_rad = np.arctan2(slope_y, -slope_x)\n    aspect_deg = (np.degrees(aspect_rad) + 360) % 360\n\n    return slope_deg, aspect_deg\n\n\ndef save_as_geotiff(data, output_file, src_file):\n    with rasterio.open(src_file) as src_dataset:\n        profile = src_dataset.profile\n        transform = src_dataset.transform\n\n        # Update the data type, count, and set the transform for the new dataset\n        profile.update(dtype=rasterio.float32, count=1, transform=transform)\n\n        # Create the new GeoTIFF file\n        with rasterio.open(output_file, 'w', **profile) as dst_dataset:\n            # Write the data to the new GeoTIFF\n            dst_dataset.write(data, 1)\n  \n\ndef calculate_slope_aspect(dem_file):\n    with rasterio.open(dem_file) as dataset:\n        # Read the DEM data as a numpy array\n        dem_data = dataset.read(1)\n\n        # Get the geotransform to convert pixel coordinates to geographic coordinates\n        transform = dataset.transform\n\n        # Calculate the slope and aspect using numpy\n        dx, dy = np.gradient(dem_data, transform[0], transform[4])\n        slope = np.arctan(np.sqrt(dx ** 2 + dy ** 2)) * (180.0 / np.pi)\n        aspect = np.arctan2(-dy, dx) * (180.0 / np.pi)\n\n        # Adjust aspect values to range from 0 to 360 degrees\n        aspect[aspect < 0] += 360\n        print(f\"slope shape: {slope.shape}\")\n        print(f\"aspect shape: {aspect.shape}\")\n        \n        \n    return slope, aspect\n  \ndef calculate_curvature(elevation_data, pixel_size_x, pixel_size_y):\n    # Calculate curvature using the Laplacian operator\n    curvature_x = np.gradient(np.gradient(elevation_data, pixel_size_x, axis=1), pixel_size_x, axis=1)\n    curvature_y = np.gradient(np.gradient(elevation_data, pixel_size_y, axis=0), pixel_size_y, axis=0)\n    curvature = curvature_x + curvature_y\n\n    return curvature\n\n  \ndef calculate_curvature(dem_file, sigma=1):\n    with rasterio.open(dem_file) as dataset:\n        # Read the DEM data as a numpy array\n        dem_data = dataset.read(1)\n\n        # Calculate the gradient using the Sobel filter\n        dx = sobel(dem_data, axis=1, mode='constant')\n        dy = sobel(dem_data, axis=0, mode='constant')\n\n        # Calculate the second derivatives using the Sobel filter\n        dxx = sobel(dx, axis=1, mode='constant')\n        dyy = sobel(dy, axis=0, mode='constant')\n\n        # Calculate the curvature using the second derivatives\n        curvature = dxx + dyy\n\n        # Smooth the curvature using Gaussian filtering (optional)\n        curvature = gaussian_filter(curvature, sigma)\n\n    return curvature\n  \n  \ndef geotiff_to_csv(geotiff_file, csv_file):\n    # Open the GeoTIFF file\n    with rasterio.open(geotiff_file) as dataset:\n        # Get the pixel values as a 2D array\n        data = dataset.read(1)\n\n        # Get the geotransform to convert pixel coordinates to geographic coordinates\n        transform = dataset.transform\n\n        # Get the width and height of the GeoTIFF\n        height, width = data.shape\n\n        # Open the CSV file for writing\n        with open(csv_file, 'w', newline='') as csvfile:\n            csvwriter = csv.writer(csvfile)\n\n            # Write the CSV header\n            csvwriter.writerow(['Latitude', 'Longitude', 'x', 'y', 'Elevation'])\n\n            # Loop through each pixel and extract latitude, longitude, and image value\n            for y in range(height):\n                for x in range(width):\n                    # Get the pixel value\n                    image_value = data[y, x]\n\n                    # Convert pixel coordinates to geographic coordinates\n                    lon, lat = transform * (x, y)\n\n                    # Write the data to the CSV file\n                    csvwriter.writerow([lat, lon, x, y, image_value])\n\n  \ndef read_elevation_data(file_path, result_dem_csv_path, result_dem_feature_csv_path):\n    neighborhood_size=4\n    df = pd.read_csv(file_path)\n    \n    dataset = rasterio.open(geotiff_file)\n    data = dataset.read(1)\n\n    # Get the width and height of the GeoTIFF\n    height, width = data.shape\n    \n    # Create an empty DataFrame with column names\n    columns = ['lat', 'lon', 'elevation', 'slope', 'aspect', 'curvature', 'northness', 'eastness']\n    all_df = pd.DataFrame(columns=columns)\n    \n    print(f\"neighborhood_size // 2 = {neighborhood_size // 2}\")\n    \n    for index, row in original_df.iterrows():\n      # Access individual row elements using row['column_name']\n      # Convert latitude and longitude to pixel indices\n      x = row[\"x\"]\n      y = row[\"y\"]\n      lat = row['Latitude']\n      lon = row['Longitude']\n      elevation = row['Elevation']\n      \n      if index % 500 == 0:\n        print(f\"processing {x} {y}\")\n\t  \n      if x < neighborhood_size // 2 or y < neighborhood_size // 2 or x > (width - neighborhood_size // 2) or y > (height - neighborhood_size // 2):\n      \tdata_row = {\n            'lat': lat,\n            'lon': lon,\n            'elevation': elevation,\n            'slope': -1,\n            'aspect': -1,\n            'curvature': -1,\n            'northness': -1,\n            'eastness': -1\n        }\n      else:\n        # Read a small neighborhood of elevation data around the selected point\n        small_elevation_data = band.ReadAsArray(x - neighborhood_size // 2, y - neighborhood_size // 2, neighborhood_size, neighborhood_size)\n\n        # Calculate slope and aspect\n        slope_data, aspect_data = calculate_slope_aspect(small_elevation_data, pixel_size_x, pixel_size_y)\n\n        # Calculate curvature\n        curvature_data = calculate_curvature(small_elevation_data, pixel_size_x, pixel_size_y)\n        northness_data = np.abs(np.sin(np.radians(aspect_data)))\n        eastness_data = np.abs(np.cos(np.radians(aspect_data)))\n\n\n        data_row = {\n            'lat': lat,\n            'lon': lon,\n            'elevation': elevation,\n            'slope': slope_data[neighborhood_size // 2, neighborhood_size // 2],\n            'aspect': aspect_data[neighborhood_size // 2, neighborhood_size // 2],\n            'curvature': curvature_data[neighborhood_size // 2, neighborhood_size // 2],\n            'northness': northness_data[neighborhood_size // 2, neighborhood_size // 2],\n            'eastness': eastness_data[neighborhood_size // 2, neighborhood_size // 2]\n        }\n      \n      \n      # Append a row to the DataFrame\n      all_df = all_df.append(data_row, ignore_index=True)\n    \n    all_df.to_csv(result_dem_feature_csv_path)\n    print(f\"DEM and other columns are saved to file {result_dem_feature_csv_path}\")\n    return all_df\n\n\n  \n# Usage example:\nresult_dem_csv_path = \"/home/chetana/gridmet_test_run/dem_template.csv\"\nresult_dem_feature_csv_path = \"/home/chetana/gridmet_test_run/dem_all.csv\"\n\n\ndem_file = \"/home/chetana/gridmet_test_run/output_4km_clipped.tif\"\nslope_file = '/home/chetana/gridmet_test_run/slope_file.tif'\naspect_file = '/home/chetana/gridmet_test_run/aspect_file.tif'\ncurvature_file = '/home/chetana/gridmet_test_run/curvature_file.tif'\n\n\n#geotiff_to_csv(dem_file, result_dem_csv_path)\n\n\nslope, aspect = calculate_slope_aspect(dem_file)\ncurvature = calculate_curvature(dem_file)\n\n# Save the slope and aspect as new GeoTIFF files\nsave_as_geotiff(slope, slope_file, dem_file)\nsave_as_geotiff(aspect, aspect_file, dem_file)\nsave_as_geotiff(curvature, curvature_file, dem_file)\n\n\n#generate_all_elevation_variables(\"/home/chetana/gridmet_test_run/output_4km_clipped.tif\", result_dem_csv_path, result_dem_feature_csv_path)\n\n\n\n#final_dem_all_cols = read_elevation_data(\"/home/chetana/gridmet_test_run/output_4km_clipped.tif\")\n",
  "history_output" : "slope shape: (666, 694)\naspect shape: (666, 694)\nTraceback (most recent call last):\n  File \"/home/chetana/gw-workspace/3a0JdQOddlTL/western_us_dem.py\", line 218, in <module>\n    curvature = calculate_curvature(dem_file)\n  File \"/home/chetana/gw-workspace/3a0JdQOddlTL/western_us_dem.py\", line 82, in calculate_curvature\n    dx = sobel(dem_data, axis=1, mode='constant')\nNameError: name 'sobel' is not defined\n",
  "history_begin_time" : 1690259677530,
  "history_end_time" : 1690259678316,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : null,
  "indicator" : "Failed"
},{
  "history_id" : "luL7DDnjwTu7",
  "history_input" : "import numpy as np\nimport pandas as pd\nfrom osgeo import gdal\nimport warnings\nimport rasterio\nimport csv\nfrom rasterio.transform import Affine\n\n# Set the warning filter globally to ignore the FutureWarning\nwarnings.simplefilter(\"ignore\", FutureWarning)\n\ndef lat_lon_to_pixel(lat, lon, geotransform):\n    x = int((lon - geotransform[0]) / geotransform[1])\n    y = int((lat - geotransform[3]) / geotransform[5])\n    return x, y\n\n\ndef calculate_slope_aspect_for_single(elevation_data, pixel_size_x, pixel_size_y):\n    # Calculate slope using the Sobel operator\n    slope_x = np.gradient(elevation_data, pixel_size_x, axis=1)\n    slope_y = np.gradient(elevation_data, pixel_size_y, axis=0)\n    slope_rad = np.arctan(np.sqrt(slope_x ** 2 + slope_y ** 2))\n    slope_deg = np.degrees(slope_rad)\n\n    # Calculate aspect (direction of the steepest descent)\n    aspect_rad = np.arctan2(slope_y, -slope_x)\n    aspect_deg = (np.degrees(aspect_rad) + 360) % 360\n\n    return slope_deg, aspect_deg\n\n\ndef save_as_geotiff(data, output_file, src_file):\n    with rasterio.open(src_file) as src_dataset:\n        profile = src_dataset.profile\n        transform = src_dataset.transform\n\n        # Update the data type, count, and set the transform for the new dataset\n        profile.update(dtype=rasterio.float32, count=1, transform=transform)\n\n        # Create the new GeoTIFF file\n        with rasterio.open(output_file, 'w', **profile) as dst_dataset:\n            # Write the data to the new GeoTIFF\n            dst_dataset.write(data, 1)\n  \n\ndef calculate_slope_aspect(dem_file):\n    with rasterio.open(dem_file) as dataset:\n        # Read the DEM data as a numpy array\n        dem_data = dataset.read(1)\n\n        # Get the geotransform to convert pixel coordinates to geographic coordinates\n        transform = dataset.transform\n\n        # Calculate the slope and aspect using numpy\n        dx, dy = np.gradient(dem_data, transform[0], transform[4])\n        slope = np.arctan(np.sqrt(dx ** 2 + dy ** 2)) * (180.0 / np.pi)\n        aspect = np.arctan2(-dy, dx) * (180.0 / np.pi)\n\n        # Adjust aspect values to range from 0 to 360 degrees\n        aspect[aspect < 0] += 360\n        print(f\"slope shape: {slope.shape}\")\n        print(f\"aspect shape: {aspect.shape}\")\n        \n        \n    return slope, aspect\n  \ndef calculate_curvature(elevation_data, pixel_size_x, pixel_size_y):\n    # Calculate curvature using the Laplacian operator\n    curvature_x = np.gradient(np.gradient(elevation_data, pixel_size_x, axis=1), pixel_size_x, axis=1)\n    curvature_y = np.gradient(np.gradient(elevation_data, pixel_size_y, axis=0), pixel_size_y, axis=0)\n    curvature = curvature_x + curvature_y\n\n    return curvature\n\ndef geotiff_to_csv(geotiff_file, csv_file):\n    # Open the GeoTIFF file\n    with rasterio.open(geotiff_file) as dataset:\n        # Get the pixel values as a 2D array\n        data = dataset.read(1)\n\n        # Get the geotransform to convert pixel coordinates to geographic coordinates\n        transform = dataset.transform\n\n        # Get the width and height of the GeoTIFF\n        height, width = data.shape\n\n        # Open the CSV file for writing\n        with open(csv_file, 'w', newline='') as csvfile:\n            csvwriter = csv.writer(csvfile)\n\n            # Write the CSV header\n            csvwriter.writerow(['Latitude', 'Longitude', 'x', 'y', 'Elevation'])\n\n            # Loop through each pixel and extract latitude, longitude, and image value\n            for y in range(height):\n                for x in range(width):\n                    # Get the pixel value\n                    image_value = data[y, x]\n\n                    # Convert pixel coordinates to geographic coordinates\n                    lon, lat = transform * (x, y)\n\n                    # Write the data to the CSV file\n                    csvwriter.writerow([lat, lon, x, y, image_value])\n\n  \ndef read_elevation_data(file_path, result_dem_csv_path, result_dem_feature_csv_path):\n    neighborhood_size=4\n    df = pd.read_csv(file_path)\n    \n    dataset = rasterio.open(geotiff_file)\n    data = dataset.read(1)\n\n    # Get the width and height of the GeoTIFF\n    height, width = data.shape\n    \n    # Create an empty DataFrame with column names\n    columns = ['lat', 'lon', 'elevation', 'slope', 'aspect', 'curvature', 'northness', 'eastness']\n    all_df = pd.DataFrame(columns=columns)\n    \n    print(f\"neighborhood_size // 2 = {neighborhood_size // 2}\")\n    \n    for index, row in original_df.iterrows():\n      # Access individual row elements using row['column_name']\n      # Convert latitude and longitude to pixel indices\n      x = row[\"x\"]\n      y = row[\"y\"]\n      lat = row['Latitude']\n      lon = row['Longitude']\n      elevation = row['Elevation']\n      \n      if index % 500 == 0:\n        print(f\"processing {x} {y}\")\n\t  \n      if x < neighborhood_size // 2 or y < neighborhood_size // 2 or x > (width - neighborhood_size // 2) or y > (height - neighborhood_size // 2):\n      \tdata_row = {\n            'lat': lat,\n            'lon': lon,\n            'elevation': elevation,\n            'slope': -1,\n            'aspect': -1,\n            'curvature': -1,\n            'northness': -1,\n            'eastness': -1\n        }\n      else:\n        # Read a small neighborhood of elevation data around the selected point\n        small_elevation_data = band.ReadAsArray(x - neighborhood_size // 2, y - neighborhood_size // 2, neighborhood_size, neighborhood_size)\n\n        # Calculate slope and aspect\n        slope_data, aspect_data = calculate_slope_aspect(small_elevation_data, pixel_size_x, pixel_size_y)\n\n        # Calculate curvature\n        curvature_data = calculate_curvature(small_elevation_data, pixel_size_x, pixel_size_y)\n        northness_data = np.abs(np.sin(np.radians(aspect_data)))\n        eastness_data = np.abs(np.cos(np.radians(aspect_data)))\n\n\n        data_row = {\n            'lat': lat,\n            'lon': lon,\n            'elevation': elevation,\n            'slope': slope_data[neighborhood_size // 2, neighborhood_size // 2],\n            'aspect': aspect_data[neighborhood_size // 2, neighborhood_size // 2],\n            'curvature': curvature_data[neighborhood_size // 2, neighborhood_size // 2],\n            'northness': northness_data[neighborhood_size // 2, neighborhood_size // 2],\n            'eastness': eastness_data[neighborhood_size // 2, neighborhood_size // 2]\n        }\n      \n      \n      # Append a row to the DataFrame\n      all_df = all_df.append(data_row, ignore_index=True)\n    \n    all_df.to_csv(result_dem_feature_csv_path)\n    print(f\"DEM and other columns are saved to file {result_dem_feature_csv_path}\")\n    return all_df\n\n\n  \n# Usage example:\nresult_dem_csv_path = \"/home/chetana/gridmet_test_run/dem_template.csv\"\nresult_dem_feature_csv_path = \"/home/chetana/gridmet_test_run/dem_all.csv\"\n\n\ndem_file = \"/home/chetana/gridmet_test_run/output_4km_clipped.tif\"\nslope_file = '/home/chetana/gridmet_test_run/slope_file.tif'\naspect_file = '/home/chetana/gridmet_test_run/aspect_file.tif'\n\n#geotiff_to_csv(dem_file, result_dem_csv_path)\n\n\nslope, aspect = calculate_slope_aspect(dem_file)\n\n# Save the slope and aspect as new GeoTIFF files\nsave_as_geotiff(slope, slope_file, dem_file)\nsave_as_geotiff(aspect, aspect_file, dem_file)\n\n\n#generate_all_elevation_variables(\"/home/chetana/gridmet_test_run/output_4km_clipped.tif\", result_dem_csv_path, result_dem_feature_csv_path)\n\n\n\n#final_dem_all_cols = read_elevation_data(\"/home/chetana/gridmet_test_run/output_4km_clipped.tif\")\n",
  "history_output" : "slope shape: (666, 694)\naspect shape: (666, 694)\n",
  "history_begin_time" : 1690259518303,
  "history_end_time" : 1690259519280,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "7n5tqVx3bqil",
  "history_input" : "import numpy as np\nimport pandas as pd\nfrom osgeo import gdal\nimport warnings\nimport rasterio\nimport csv\nfrom rasterio.transform import Affine\n\n# Set the warning filter globally to ignore the FutureWarning\nwarnings.simplefilter(\"ignore\", FutureWarning)\n\ndef lat_lon_to_pixel(lat, lon, geotransform):\n    x = int((lon - geotransform[0]) / geotransform[1])\n    y = int((lat - geotransform[3]) / geotransform[5])\n    return x, y\n\n\ndef calculate_slope_aspect_for_single(elevation_data, pixel_size_x, pixel_size_y):\n    # Calculate slope using the Sobel operator\n    slope_x = np.gradient(elevation_data, pixel_size_x, axis=1)\n    slope_y = np.gradient(elevation_data, pixel_size_y, axis=0)\n    slope_rad = np.arctan(np.sqrt(slope_x ** 2 + slope_y ** 2))\n    slope_deg = np.degrees(slope_rad)\n\n    # Calculate aspect (direction of the steepest descent)\n    aspect_rad = np.arctan2(slope_y, -slope_x)\n    aspect_deg = (np.degrees(aspect_rad) + 360) % 360\n\n    return slope_deg, aspect_deg\n\n\ndef save_as_geotiff(data, output_file, src_file):\n    with rasterio.open(src_file) as src_dataset:\n        profile = src_dataset.profile\n        a, b, c, d, e, f = src_dataset.transform\n\n        # Update the data type, count, and set the transform for the new dataset\n        profile.update(dtype=rasterio.float32, count=1, transform=Affine(a, b, c, d, e, f))\n\n        # Create the new GeoTIFF file\n        with rasterio.open(output_file, 'w', **profile) as dst_dataset:\n            # Write the data to the new GeoTIFF\n            dst_dataset.write(data, 1)\n  \n\ndef calculate_slope_aspect(dem_file):\n    with rasterio.open(dem_file) as dataset:\n        # Read the DEM data as a numpy array\n        dem_data = dataset.read(1)\n\n        # Get the geotransform to convert pixel coordinates to geographic coordinates\n        transform = dataset.transform\n\n        # Calculate the slope and aspect using numpy\n        dx, dy = np.gradient(dem_data, transform[0], transform[4])\n        slope = np.arctan(np.sqrt(dx ** 2 + dy ** 2)) * (180.0 / np.pi)\n        aspect = np.arctan2(-dy, dx) * (180.0 / np.pi)\n\n        # Adjust aspect values to range from 0 to 360 degrees\n        aspect[aspect < 0] += 360\n        print(f\"slope shape: {slope.shape}\")\n        print(f\"aspect shape: {aspect.shape}\")\n        \n        \n    return slope, aspect\n  \ndef calculate_curvature(elevation_data, pixel_size_x, pixel_size_y):\n    # Calculate curvature using the Laplacian operator\n    curvature_x = np.gradient(np.gradient(elevation_data, pixel_size_x, axis=1), pixel_size_x, axis=1)\n    curvature_y = np.gradient(np.gradient(elevation_data, pixel_size_y, axis=0), pixel_size_y, axis=0)\n    curvature = curvature_x + curvature_y\n\n    return curvature\n\ndef geotiff_to_csv(geotiff_file, csv_file):\n    # Open the GeoTIFF file\n    with rasterio.open(geotiff_file) as dataset:\n        # Get the pixel values as a 2D array\n        data = dataset.read(1)\n\n        # Get the geotransform to convert pixel coordinates to geographic coordinates\n        transform = dataset.transform\n\n        # Get the width and height of the GeoTIFF\n        height, width = data.shape\n\n        # Open the CSV file for writing\n        with open(csv_file, 'w', newline='') as csvfile:\n            csvwriter = csv.writer(csvfile)\n\n            # Write the CSV header\n            csvwriter.writerow(['Latitude', 'Longitude', 'x', 'y', 'Elevation'])\n\n            # Loop through each pixel and extract latitude, longitude, and image value\n            for y in range(height):\n                for x in range(width):\n                    # Get the pixel value\n                    image_value = data[y, x]\n\n                    # Convert pixel coordinates to geographic coordinates\n                    lon, lat = transform * (x, y)\n\n                    # Write the data to the CSV file\n                    csvwriter.writerow([lat, lon, x, y, image_value])\n\n  \ndef read_elevation_data(file_path, result_dem_csv_path, result_dem_feature_csv_path):\n    neighborhood_size=4\n    df = pd.read_csv(file_path)\n    \n    dataset = rasterio.open(geotiff_file)\n    data = dataset.read(1)\n\n    # Get the width and height of the GeoTIFF\n    height, width = data.shape\n    \n    # Create an empty DataFrame with column names\n    columns = ['lat', 'lon', 'elevation', 'slope', 'aspect', 'curvature', 'northness', 'eastness']\n    all_df = pd.DataFrame(columns=columns)\n    \n    print(f\"neighborhood_size // 2 = {neighborhood_size // 2}\")\n    \n    for index, row in original_df.iterrows():\n      # Access individual row elements using row['column_name']\n      # Convert latitude and longitude to pixel indices\n      x = row[\"x\"]\n      y = row[\"y\"]\n      lat = row['Latitude']\n      lon = row['Longitude']\n      elevation = row['Elevation']\n      \n      if index % 500 == 0:\n        print(f\"processing {x} {y}\")\n\t  \n      if x < neighborhood_size // 2 or y < neighborhood_size // 2 or x > (width - neighborhood_size // 2) or y > (height - neighborhood_size // 2):\n      \tdata_row = {\n            'lat': lat,\n            'lon': lon,\n            'elevation': elevation,\n            'slope': -1,\n            'aspect': -1,\n            'curvature': -1,\n            'northness': -1,\n            'eastness': -1\n        }\n      else:\n        # Read a small neighborhood of elevation data around the selected point\n        small_elevation_data = band.ReadAsArray(x - neighborhood_size // 2, y - neighborhood_size // 2, neighborhood_size, neighborhood_size)\n\n        # Calculate slope and aspect\n        slope_data, aspect_data = calculate_slope_aspect(small_elevation_data, pixel_size_x, pixel_size_y)\n\n        # Calculate curvature\n        curvature_data = calculate_curvature(small_elevation_data, pixel_size_x, pixel_size_y)\n        northness_data = np.abs(np.sin(np.radians(aspect_data)))\n        eastness_data = np.abs(np.cos(np.radians(aspect_data)))\n\n\n        data_row = {\n            'lat': lat,\n            'lon': lon,\n            'elevation': elevation,\n            'slope': slope_data[neighborhood_size // 2, neighborhood_size // 2],\n            'aspect': aspect_data[neighborhood_size // 2, neighborhood_size // 2],\n            'curvature': curvature_data[neighborhood_size // 2, neighborhood_size // 2],\n            'northness': northness_data[neighborhood_size // 2, neighborhood_size // 2],\n            'eastness': eastness_data[neighborhood_size // 2, neighborhood_size // 2]\n        }\n      \n      \n      # Append a row to the DataFrame\n      all_df = all_df.append(data_row, ignore_index=True)\n    \n    all_df.to_csv(result_dem_feature_csv_path)\n    print(f\"DEM and other columns are saved to file {result_dem_feature_csv_path}\")\n    return all_df\n\n\n  \n# Usage example:\nresult_dem_csv_path = \"/home/chetana/gridmet_test_run/dem_template.csv\"\nresult_dem_feature_csv_path = \"/home/chetana/gridmet_test_run/dem_all.csv\"\n\n\ndem_file = \"/home/chetana/gridmet_test_run/output_4km_clipped.tif\"\nslope_file = '/home/chetana/gridmet_test_run/slope_file.tif'\naspect_file = '/home/chetana/gridmet_test_run/aspect_file.tif'\n\n#geotiff_to_csv(dem_file, result_dem_csv_path)\n\n\nslope, aspect = calculate_slope_aspect(dem_file)\n\n# Save the slope and aspect as new GeoTIFF files\nsave_as_geotiff(slope, slope_file, dem_file)\nsave_as_geotiff(aspect, aspect_file, dem_file)\n\n\n#generate_all_elevation_variables(\"/home/chetana/gridmet_test_run/output_4km_clipped.tif\", result_dem_csv_path, result_dem_feature_csv_path)\n\n\n\n#final_dem_all_cols = read_elevation_data(\"/home/chetana/gridmet_test_run/output_4km_clipped.tif\")\n",
  "history_output" : "slope shape: (666, 694)\naspect shape: (666, 694)\nTraceback (most recent call last):\n  File \"/home/chetana/gw-workspace/7n5tqVx3bqil/western_us_dem.py\", line 195, in <module>\n    save_as_geotiff(slope, slope_file, dem_file)\n  File \"/home/chetana/gw-workspace/7n5tqVx3bqil/western_us_dem.py\", line 35, in save_as_geotiff\n    a, b, c, d, e, f = src_dataset.transform\nValueError: too many values to unpack (expected 6)\n",
  "history_begin_time" : 1690259467302,
  "history_end_time" : 1690259468158,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : null,
  "indicator" : "Failed"
},{
  "history_id" : "GzoryWAku408",
  "history_input" : "import numpy as np\nimport pandas as pd\nfrom osgeo import gdal\nimport warnings\nimport rasterio\nimport csv\nfrom rasterio.transform import Affine\n\n# Set the warning filter globally to ignore the FutureWarning\nwarnings.simplefilter(\"ignore\", FutureWarning)\n\ndef lat_lon_to_pixel(lat, lon, geotransform):\n    x = int((lon - geotransform[0]) / geotransform[1])\n    y = int((lat - geotransform[3]) / geotransform[5])\n    return x, y\n\n\ndef calculate_slope_aspect_for_single(elevation_data, pixel_size_x, pixel_size_y):\n    # Calculate slope using the Sobel operator\n    slope_x = np.gradient(elevation_data, pixel_size_x, axis=1)\n    slope_y = np.gradient(elevation_data, pixel_size_y, axis=0)\n    slope_rad = np.arctan(np.sqrt(slope_x ** 2 + slope_y ** 2))\n    slope_deg = np.degrees(slope_rad)\n\n    # Calculate aspect (direction of the steepest descent)\n    aspect_rad = np.arctan2(slope_y, -slope_x)\n    aspect_deg = (np.degrees(aspect_rad) + 360) % 360\n\n    return slope_deg, aspect_deg\n\n\ndef save_as_geotiff(data, output_file, src_file):\n    with rasterio.open(src_file) as src_dataset:\n        profile = src_dataset.profile\n\n        # Update the data type, count, and set the transform for the new dataset\n        profile.update(dtype=rasterio.float32, count=1, transform=Affine.from_gdal(*src_dataset.transform))\n\n        # Create the new GeoTIFF file\n        with rasterio.open(output_file, 'w', **profile) as dst_dataset:\n            # Write the data to the new GeoTIFF\n            dst_dataset.write(data, 1)\n  \n\ndef calculate_slope_aspect(dem_file):\n    with rasterio.open(dem_file) as dataset:\n        # Read the DEM data as a numpy array\n        dem_data = dataset.read(1)\n\n        # Get the geotransform to convert pixel coordinates to geographic coordinates\n        transform = dataset.transform\n\n        # Calculate the slope and aspect using numpy\n        dx, dy = np.gradient(dem_data, transform[0], transform[4])\n        slope = np.arctan(np.sqrt(dx ** 2 + dy ** 2)) * (180.0 / np.pi)\n        aspect = np.arctan2(-dy, dx) * (180.0 / np.pi)\n\n        # Adjust aspect values to range from 0 to 360 degrees\n        aspect[aspect < 0] += 360\n        print(f\"slope shape: {slope.shape}\")\n        print(f\"aspect shape: {aspect.shape}\")\n        \n        \n    return slope, aspect\n  \ndef calculate_curvature(elevation_data, pixel_size_x, pixel_size_y):\n    # Calculate curvature using the Laplacian operator\n    curvature_x = np.gradient(np.gradient(elevation_data, pixel_size_x, axis=1), pixel_size_x, axis=1)\n    curvature_y = np.gradient(np.gradient(elevation_data, pixel_size_y, axis=0), pixel_size_y, axis=0)\n    curvature = curvature_x + curvature_y\n\n    return curvature\n\ndef geotiff_to_csv(geotiff_file, csv_file):\n    # Open the GeoTIFF file\n    with rasterio.open(geotiff_file) as dataset:\n        # Get the pixel values as a 2D array\n        data = dataset.read(1)\n\n        # Get the geotransform to convert pixel coordinates to geographic coordinates\n        transform = dataset.transform\n\n        # Get the width and height of the GeoTIFF\n        height, width = data.shape\n\n        # Open the CSV file for writing\n        with open(csv_file, 'w', newline='') as csvfile:\n            csvwriter = csv.writer(csvfile)\n\n            # Write the CSV header\n            csvwriter.writerow(['Latitude', 'Longitude', 'x', 'y', 'Elevation'])\n\n            # Loop through each pixel and extract latitude, longitude, and image value\n            for y in range(height):\n                for x in range(width):\n                    # Get the pixel value\n                    image_value = data[y, x]\n\n                    # Convert pixel coordinates to geographic coordinates\n                    lon, lat = transform * (x, y)\n\n                    # Write the data to the CSV file\n                    csvwriter.writerow([lat, lon, x, y, image_value])\n\n  \ndef read_elevation_data(file_path, result_dem_csv_path, result_dem_feature_csv_path):\n    neighborhood_size=4\n    df = pd.read_csv(file_path)\n    \n    dataset = rasterio.open(geotiff_file)\n    data = dataset.read(1)\n\n    # Get the width and height of the GeoTIFF\n    height, width = data.shape\n    \n    # Create an empty DataFrame with column names\n    columns = ['lat', 'lon', 'elevation', 'slope', 'aspect', 'curvature', 'northness', 'eastness']\n    all_df = pd.DataFrame(columns=columns)\n    \n    print(f\"neighborhood_size // 2 = {neighborhood_size // 2}\")\n    \n    for index, row in original_df.iterrows():\n      # Access individual row elements using row['column_name']\n      # Convert latitude and longitude to pixel indices\n      x = row[\"x\"]\n      y = row[\"y\"]\n      lat = row['Latitude']\n      lon = row['Longitude']\n      elevation = row['Elevation']\n      \n      if index % 500 == 0:\n        print(f\"processing {x} {y}\")\n\t  \n      if x < neighborhood_size // 2 or y < neighborhood_size // 2 or x > (width - neighborhood_size // 2) or y > (height - neighborhood_size // 2):\n      \tdata_row = {\n            'lat': lat,\n            'lon': lon,\n            'elevation': elevation,\n            'slope': -1,\n            'aspect': -1,\n            'curvature': -1,\n            'northness': -1,\n            'eastness': -1\n        }\n      else:\n        # Read a small neighborhood of elevation data around the selected point\n        small_elevation_data = band.ReadAsArray(x - neighborhood_size // 2, y - neighborhood_size // 2, neighborhood_size, neighborhood_size)\n\n        # Calculate slope and aspect\n        slope_data, aspect_data = calculate_slope_aspect(small_elevation_data, pixel_size_x, pixel_size_y)\n\n        # Calculate curvature\n        curvature_data = calculate_curvature(small_elevation_data, pixel_size_x, pixel_size_y)\n        northness_data = np.abs(np.sin(np.radians(aspect_data)))\n        eastness_data = np.abs(np.cos(np.radians(aspect_data)))\n\n\n        data_row = {\n            'lat': lat,\n            'lon': lon,\n            'elevation': elevation,\n            'slope': slope_data[neighborhood_size // 2, neighborhood_size // 2],\n            'aspect': aspect_data[neighborhood_size // 2, neighborhood_size // 2],\n            'curvature': curvature_data[neighborhood_size // 2, neighborhood_size // 2],\n            'northness': northness_data[neighborhood_size // 2, neighborhood_size // 2],\n            'eastness': eastness_data[neighborhood_size // 2, neighborhood_size // 2]\n        }\n      \n      \n      # Append a row to the DataFrame\n      all_df = all_df.append(data_row, ignore_index=True)\n    \n    all_df.to_csv(result_dem_feature_csv_path)\n    print(f\"DEM and other columns are saved to file {result_dem_feature_csv_path}\")\n    return all_df\n\n\n  \n# Usage example:\nresult_dem_csv_path = \"/home/chetana/gridmet_test_run/dem_template.csv\"\nresult_dem_feature_csv_path = \"/home/chetana/gridmet_test_run/dem_all.csv\"\n\n\ndem_file = \"/home/chetana/gridmet_test_run/output_4km_clipped.tif\"\nslope_file = '/home/chetana/gridmet_test_run/slope_file.tif'\naspect_file = '/home/chetana/gridmet_test_run/aspect_file.tif'\n\n#geotiff_to_csv(dem_file, result_dem_csv_path)\n\n\nslope, aspect = calculate_slope_aspect(dem_file)\n\n# Save the slope and aspect as new GeoTIFF files\nsave_as_geotiff(slope, slope_file, dem_file)\nsave_as_geotiff(aspect, aspect_file, dem_file)\n\n\n#generate_all_elevation_variables(\"/home/chetana/gridmet_test_run/output_4km_clipped.tif\", result_dem_csv_path, result_dem_feature_csv_path)\n\n\n\n#final_dem_all_cols = read_elevation_data(\"/home/chetana/gridmet_test_run/output_4km_clipped.tif\")\n",
  "history_output" : "slope shape: (666, 694)\naspect shape: (666, 694)\nTraceback (most recent call last):\n  File \"/home/chetana/gw-workspace/GzoryWAku408/western_us_dem.py\", line 194, in <module>\n    save_as_geotiff(slope, slope_file, dem_file)\n  File \"/home/chetana/gw-workspace/GzoryWAku408/western_us_dem.py\", line 37, in save_as_geotiff\n    profile.update(dtype=rasterio.float32, count=1, transform=Affine.from_gdal(*src_dataset.transform))\nTypeError: from_gdal() takes 7 positional arguments but 10 were given\n",
  "history_begin_time" : 1690259300905,
  "history_end_time" : 1690259301725,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : null,
  "indicator" : "Failed"
},{
  "history_id" : "TqOSFt00365y",
  "history_input" : "import numpy as np\nimport pandas as pd\nfrom osgeo import gdal\nimport warnings\nimport rasterio\nimport csv\nfrom rasterio.transform import Affine\n\n# Set the warning filter globally to ignore the FutureWarning\nwarnings.simplefilter(\"ignore\", FutureWarning)\n\ndef lat_lon_to_pixel(lat, lon, geotransform):\n    x = int((lon - geotransform[0]) / geotransform[1])\n    y = int((lat - geotransform[3]) / geotransform[5])\n    return x, y\n\n\ndef calculate_slope_aspect_for_single(elevation_data, pixel_size_x, pixel_size_y):\n    # Calculate slope using the Sobel operator\n    slope_x = np.gradient(elevation_data, pixel_size_x, axis=1)\n    slope_y = np.gradient(elevation_data, pixel_size_y, axis=0)\n    slope_rad = np.arctan(np.sqrt(slope_x ** 2 + slope_y ** 2))\n    slope_deg = np.degrees(slope_rad)\n\n    # Calculate aspect (direction of the steepest descent)\n    aspect_rad = np.arctan2(slope_y, -slope_x)\n    aspect_deg = (np.degrees(aspect_rad) + 360) % 360\n\n    return slope_deg, aspect_deg\n\n\ndef save_as_geotiff(data, output_file, src_file):\n    with rasterio.open(src_file) as src_dataset:\n        profile = src_dataset.profile\n\n        # Update the data type, count, and set the transform for the new dataset\n        profile.update(dtype=rasterio.float32, count=1, transform=Affine.from_gdal(*profile[\"transform\"]))\n\n        # Create the new GeoTIFF file\n        with rasterio.open(output_file, 'w', **profile) as dst_dataset:\n            # Write the data to the new GeoTIFF\n            dst_dataset.write(data, 1)\n  \n\ndef calculate_slope_aspect(dem_file):\n    with rasterio.open(dem_file) as dataset:\n        # Read the DEM data as a numpy array\n        dem_data = dataset.read(1)\n\n        # Get the geotransform to convert pixel coordinates to geographic coordinates\n        transform = dataset.transform\n\n        # Calculate the slope and aspect using numpy\n        dx, dy = np.gradient(dem_data, transform[0], transform[4])\n        slope = np.arctan(np.sqrt(dx ** 2 + dy ** 2)) * (180.0 / np.pi)\n        aspect = np.arctan2(-dy, dx) * (180.0 / np.pi)\n\n        # Adjust aspect values to range from 0 to 360 degrees\n        aspect[aspect < 0] += 360\n        print(f\"slope shape: {slope.shape}\")\n        print(f\"aspect shape: {aspect.shape}\")\n        \n        \n    return slope, aspect\n  \ndef calculate_curvature(elevation_data, pixel_size_x, pixel_size_y):\n    # Calculate curvature using the Laplacian operator\n    curvature_x = np.gradient(np.gradient(elevation_data, pixel_size_x, axis=1), pixel_size_x, axis=1)\n    curvature_y = np.gradient(np.gradient(elevation_data, pixel_size_y, axis=0), pixel_size_y, axis=0)\n    curvature = curvature_x + curvature_y\n\n    return curvature\n\ndef geotiff_to_csv(geotiff_file, csv_file):\n    # Open the GeoTIFF file\n    with rasterio.open(geotiff_file) as dataset:\n        # Get the pixel values as a 2D array\n        data = dataset.read(1)\n\n        # Get the geotransform to convert pixel coordinates to geographic coordinates\n        transform = dataset.transform\n\n        # Get the width and height of the GeoTIFF\n        height, width = data.shape\n\n        # Open the CSV file for writing\n        with open(csv_file, 'w', newline='') as csvfile:\n            csvwriter = csv.writer(csvfile)\n\n            # Write the CSV header\n            csvwriter.writerow(['Latitude', 'Longitude', 'x', 'y', 'Elevation'])\n\n            # Loop through each pixel and extract latitude, longitude, and image value\n            for y in range(height):\n                for x in range(width):\n                    # Get the pixel value\n                    image_value = data[y, x]\n\n                    # Convert pixel coordinates to geographic coordinates\n                    lon, lat = transform * (x, y)\n\n                    # Write the data to the CSV file\n                    csvwriter.writerow([lat, lon, x, y, image_value])\n\n  \ndef read_elevation_data(file_path, result_dem_csv_path, result_dem_feature_csv_path):\n    neighborhood_size=4\n    df = pd.read_csv(file_path)\n    \n    dataset = rasterio.open(geotiff_file)\n    data = dataset.read(1)\n\n    # Get the width and height of the GeoTIFF\n    height, width = data.shape\n    \n    # Create an empty DataFrame with column names\n    columns = ['lat', 'lon', 'elevation', 'slope', 'aspect', 'curvature', 'northness', 'eastness']\n    all_df = pd.DataFrame(columns=columns)\n    \n    print(f\"neighborhood_size // 2 = {neighborhood_size // 2}\")\n    \n    for index, row in original_df.iterrows():\n      # Access individual row elements using row['column_name']\n      # Convert latitude and longitude to pixel indices\n      x = row[\"x\"]\n      y = row[\"y\"]\n      lat = row['Latitude']\n      lon = row['Longitude']\n      elevation = row['Elevation']\n      \n      if index % 500 == 0:\n        print(f\"processing {x} {y}\")\n\t  \n      if x < neighborhood_size // 2 or y < neighborhood_size // 2 or x > (width - neighborhood_size // 2) or y > (height - neighborhood_size // 2):\n      \tdata_row = {\n            'lat': lat,\n            'lon': lon,\n            'elevation': elevation,\n            'slope': -1,\n            'aspect': -1,\n            'curvature': -1,\n            'northness': -1,\n            'eastness': -1\n        }\n      else:\n        # Read a small neighborhood of elevation data around the selected point\n        small_elevation_data = band.ReadAsArray(x - neighborhood_size // 2, y - neighborhood_size // 2, neighborhood_size, neighborhood_size)\n\n        # Calculate slope and aspect\n        slope_data, aspect_data = calculate_slope_aspect(small_elevation_data, pixel_size_x, pixel_size_y)\n\n        # Calculate curvature\n        curvature_data = calculate_curvature(small_elevation_data, pixel_size_x, pixel_size_y)\n        northness_data = np.abs(np.sin(np.radians(aspect_data)))\n        eastness_data = np.abs(np.cos(np.radians(aspect_data)))\n\n\n        data_row = {\n            'lat': lat,\n            'lon': lon,\n            'elevation': elevation,\n            'slope': slope_data[neighborhood_size // 2, neighborhood_size // 2],\n            'aspect': aspect_data[neighborhood_size // 2, neighborhood_size // 2],\n            'curvature': curvature_data[neighborhood_size // 2, neighborhood_size // 2],\n            'northness': northness_data[neighborhood_size // 2, neighborhood_size // 2],\n            'eastness': eastness_data[neighborhood_size // 2, neighborhood_size // 2]\n        }\n      \n      \n      # Append a row to the DataFrame\n      all_df = all_df.append(data_row, ignore_index=True)\n    \n    all_df.to_csv(result_dem_feature_csv_path)\n    print(f\"DEM and other columns are saved to file {result_dem_feature_csv_path}\")\n    return all_df\n\n\n  \n# Usage example:\nresult_dem_csv_path = \"/home/chetana/gridmet_test_run/dem_template.csv\"\nresult_dem_feature_csv_path = \"/home/chetana/gridmet_test_run/dem_all.csv\"\n\n\ndem_file = \"/home/chetana/gridmet_test_run/output_4km_clipped.tif\"\nslope_file = '/home/chetana/gridmet_test_run/slope_file.tif'\naspect_file = '/home/chetana/gridmet_test_run/aspect_file.tif'\n\n#geotiff_to_csv(dem_file, result_dem_csv_path)\n\n\nslope, aspect = calculate_slope_aspect(dem_file)\n\n# Save the slope and aspect as new GeoTIFF files\nsave_as_geotiff(slope, slope_file, dem_file)\nsave_as_geotiff(aspect, aspect_file, dem_file)\n\n\n#generate_all_elevation_variables(\"/home/chetana/gridmet_test_run/output_4km_clipped.tif\", result_dem_csv_path, result_dem_feature_csv_path)\n\n\n\n#final_dem_all_cols = read_elevation_data(\"/home/chetana/gridmet_test_run/output_4km_clipped.tif\")\n",
  "history_output" : "slope shape: (666, 694)\naspect shape: (666, 694)\nTraceback (most recent call last):\n  File \"/home/chetana/gw-workspace/TqOSFt00365y/western_us_dem.py\", line 194, in <module>\n    save_as_geotiff(slope, slope_file, dem_file)\n  File \"/home/chetana/gw-workspace/TqOSFt00365y/western_us_dem.py\", line 37, in save_as_geotiff\n    profile.update(dtype=rasterio.float32, count=1, transform=Affine.from_gdal(*profile[\"transform\"]))\nTypeError: from_gdal() takes 7 positional arguments but 10 were given\n",
  "history_begin_time" : 1690259161088,
  "history_end_time" : 1690259161891,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : null,
  "indicator" : "Failed"
},{
  "history_id" : "dEPtcTvcdYlo",
  "history_input" : "import numpy as np\nimport pandas as pd\nfrom osgeo import gdal\nimport warnings\nimport rasterio\nimport csv\n\n# Set the warning filter globally to ignore the FutureWarning\nwarnings.simplefilter(\"ignore\", FutureWarning)\n\ndef lat_lon_to_pixel(lat, lon, geotransform):\n    x = int((lon - geotransform[0]) / geotransform[1])\n    y = int((lat - geotransform[3]) / geotransform[5])\n    return x, y\n\n\ndef calculate_slope_aspect_for_single(elevation_data, pixel_size_x, pixel_size_y):\n    # Calculate slope using the Sobel operator\n    slope_x = np.gradient(elevation_data, pixel_size_x, axis=1)\n    slope_y = np.gradient(elevation_data, pixel_size_y, axis=0)\n    slope_rad = np.arctan(np.sqrt(slope_x ** 2 + slope_y ** 2))\n    slope_deg = np.degrees(slope_rad)\n\n    # Calculate aspect (direction of the steepest descent)\n    aspect_rad = np.arctan2(slope_y, -slope_x)\n    aspect_deg = (np.degrees(aspect_rad) + 360) % 360\n\n    return slope_deg, aspect_deg\n\n\ndef save_as_geotiff(data, output_file, src_file):\n    with rasterio.open(src_file) as src_dataset:\n        profile = src_dataset.profile\n\n        # Update the data type, count, and set the transform for the new dataset\n        profile.update(dtype=rasterio.float32, count=1, transform=Affine.from_gdal(*profile[\"transform\"]))\n\n        # Create the new GeoTIFF file\n        with rasterio.open(output_file, 'w', **profile) as dst_dataset:\n            # Write the data to the new GeoTIFF\n            dst_dataset.write(data, 1)\n  \n\ndef calculate_slope_aspect(dem_file):\n    with rasterio.open(dem_file) as dataset:\n        # Read the DEM data as a numpy array\n        dem_data = dataset.read(1)\n\n        # Get the geotransform to convert pixel coordinates to geographic coordinates\n        transform = dataset.transform\n\n        # Calculate the slope and aspect using numpy\n        dx, dy = np.gradient(dem_data, transform[0], transform[4])\n        slope = np.arctan(np.sqrt(dx ** 2 + dy ** 2)) * (180.0 / np.pi)\n        aspect = np.arctan2(-dy, dx) * (180.0 / np.pi)\n\n        # Adjust aspect values to range from 0 to 360 degrees\n        aspect[aspect < 0] += 360\n        print(f\"slope shape: {slope.shape}\")\n        print(f\"aspect shape: {aspect.shape}\")\n        \n        \n    return slope, aspect\n  \ndef calculate_curvature(elevation_data, pixel_size_x, pixel_size_y):\n    # Calculate curvature using the Laplacian operator\n    curvature_x = np.gradient(np.gradient(elevation_data, pixel_size_x, axis=1), pixel_size_x, axis=1)\n    curvature_y = np.gradient(np.gradient(elevation_data, pixel_size_y, axis=0), pixel_size_y, axis=0)\n    curvature = curvature_x + curvature_y\n\n    return curvature\n\ndef geotiff_to_csv(geotiff_file, csv_file):\n    # Open the GeoTIFF file\n    with rasterio.open(geotiff_file) as dataset:\n        # Get the pixel values as a 2D array\n        data = dataset.read(1)\n\n        # Get the geotransform to convert pixel coordinates to geographic coordinates\n        transform = dataset.transform\n\n        # Get the width and height of the GeoTIFF\n        height, width = data.shape\n\n        # Open the CSV file for writing\n        with open(csv_file, 'w', newline='') as csvfile:\n            csvwriter = csv.writer(csvfile)\n\n            # Write the CSV header\n            csvwriter.writerow(['Latitude', 'Longitude', 'x', 'y', 'Elevation'])\n\n            # Loop through each pixel and extract latitude, longitude, and image value\n            for y in range(height):\n                for x in range(width):\n                    # Get the pixel value\n                    image_value = data[y, x]\n\n                    # Convert pixel coordinates to geographic coordinates\n                    lon, lat = transform * (x, y)\n\n                    # Write the data to the CSV file\n                    csvwriter.writerow([lat, lon, x, y, image_value])\n\n  \ndef read_elevation_data(file_path, result_dem_csv_path, result_dem_feature_csv_path):\n    neighborhood_size=4\n    df = pd.read_csv(file_path)\n    \n    dataset = rasterio.open(geotiff_file)\n    data = dataset.read(1)\n\n    # Get the width and height of the GeoTIFF\n    height, width = data.shape\n    \n    # Create an empty DataFrame with column names\n    columns = ['lat', 'lon', 'elevation', 'slope', 'aspect', 'curvature', 'northness', 'eastness']\n    all_df = pd.DataFrame(columns=columns)\n    \n    print(f\"neighborhood_size // 2 = {neighborhood_size // 2}\")\n    \n    for index, row in original_df.iterrows():\n      # Access individual row elements using row['column_name']\n      # Convert latitude and longitude to pixel indices\n      x = row[\"x\"]\n      y = row[\"y\"]\n      lat = row['Latitude']\n      lon = row['Longitude']\n      elevation = row['Elevation']\n      \n      if index % 500 == 0:\n        print(f\"processing {x} {y}\")\n\t  \n      if x < neighborhood_size // 2 or y < neighborhood_size // 2 or x > (width - neighborhood_size // 2) or y > (height - neighborhood_size // 2):\n      \tdata_row = {\n            'lat': lat,\n            'lon': lon,\n            'elevation': elevation,\n            'slope': -1,\n            'aspect': -1,\n            'curvature': -1,\n            'northness': -1,\n            'eastness': -1\n        }\n      else:\n        # Read a small neighborhood of elevation data around the selected point\n        small_elevation_data = band.ReadAsArray(x - neighborhood_size // 2, y - neighborhood_size // 2, neighborhood_size, neighborhood_size)\n\n        # Calculate slope and aspect\n        slope_data, aspect_data = calculate_slope_aspect(small_elevation_data, pixel_size_x, pixel_size_y)\n\n        # Calculate curvature\n        curvature_data = calculate_curvature(small_elevation_data, pixel_size_x, pixel_size_y)\n        northness_data = np.abs(np.sin(np.radians(aspect_data)))\n        eastness_data = np.abs(np.cos(np.radians(aspect_data)))\n\n\n        data_row = {\n            'lat': lat,\n            'lon': lon,\n            'elevation': elevation,\n            'slope': slope_data[neighborhood_size // 2, neighborhood_size // 2],\n            'aspect': aspect_data[neighborhood_size // 2, neighborhood_size // 2],\n            'curvature': curvature_data[neighborhood_size // 2, neighborhood_size // 2],\n            'northness': northness_data[neighborhood_size // 2, neighborhood_size // 2],\n            'eastness': eastness_data[neighborhood_size // 2, neighborhood_size // 2]\n        }\n      \n      \n      # Append a row to the DataFrame\n      all_df = all_df.append(data_row, ignore_index=True)\n    \n    all_df.to_csv(result_dem_feature_csv_path)\n    print(f\"DEM and other columns are saved to file {result_dem_feature_csv_path}\")\n    return all_df\n\n\n  \n# Usage example:\nresult_dem_csv_path = \"/home/chetana/gridmet_test_run/dem_template.csv\"\nresult_dem_feature_csv_path = \"/home/chetana/gridmet_test_run/dem_all.csv\"\n\n\ndem_file = \"/home/chetana/gridmet_test_run/output_4km_clipped.tif\"\nslope_file = '/home/chetana/gridmet_test_run/slope_file.tif'\naspect_file = '/home/chetana/gridmet_test_run/aspect_file.tif'\n\n#geotiff_to_csv(dem_file, result_dem_csv_path)\n\n\nslope, aspect = calculate_slope_aspect(dem_file)\n\n# Save the slope and aspect as new GeoTIFF files\nsave_as_geotiff(slope, slope_file, dem_file)\nsave_as_geotiff(aspect, aspect_file, dem_file)\n\n\n#generate_all_elevation_variables(\"/home/chetana/gridmet_test_run/output_4km_clipped.tif\", result_dem_csv_path, result_dem_feature_csv_path)\n\n\n\n#final_dem_all_cols = read_elevation_data(\"/home/chetana/gridmet_test_run/output_4km_clipped.tif\")\n",
  "history_output" : "slope shape: (666, 694)\naspect shape: (666, 694)\nTraceback (most recent call last):\n  File \"/home/chetana/gw-workspace/dEPtcTvcdYlo/western_us_dem.py\", line 193, in <module>\n    save_as_geotiff(slope, slope_file, dem_file)\n  File \"/home/chetana/gw-workspace/dEPtcTvcdYlo/western_us_dem.py\", line 36, in save_as_geotiff\n    profile.update(dtype=rasterio.float32, count=1, transform=Affine.from_gdal(*profile[\"transform\"]))\nNameError: name 'Affine' is not defined\n",
  "history_begin_time" : 1690259132152,
  "history_end_time" : 1690259133027,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : null,
  "indicator" : "Failed"
},{
  "history_id" : "PvMeML3iWNRw",
  "history_input" : "import numpy as np\nimport pandas as pd\nfrom osgeo import gdal\nimport warnings\nimport rasterio\nimport csv\n\n# Set the warning filter globally to ignore the FutureWarning\nwarnings.simplefilter(\"ignore\", FutureWarning)\n\ndef lat_lon_to_pixel(lat, lon, geotransform):\n    x = int((lon - geotransform[0]) / geotransform[1])\n    y = int((lat - geotransform[3]) / geotransform[5])\n    return x, y\n\n\ndef calculate_slope_aspect_for_single(elevation_data, pixel_size_x, pixel_size_y):\n    # Calculate slope using the Sobel operator\n    slope_x = np.gradient(elevation_data, pixel_size_x, axis=1)\n    slope_y = np.gradient(elevation_data, pixel_size_y, axis=0)\n    slope_rad = np.arctan(np.sqrt(slope_x ** 2 + slope_y ** 2))\n    slope_deg = np.degrees(slope_rad)\n\n    # Calculate aspect (direction of the steepest descent)\n    aspect_rad = np.arctan2(slope_y, -slope_x)\n    aspect_deg = (np.degrees(aspect_rad) + 360) % 360\n\n    return slope_deg, aspect_deg\n\n\ndef save_as_geotiff(data, output_file, src_file):\n    with rasterio.open(src_file) as src_dataset:\n        profile = src_dataset.profile\n\n        # Update the data type, count, and set the transform for the new dataset\n        profile.update(dtype=rasterio.float32, count=1, transform=Affine.from_gdal(*profile[\"transform\"]))\n\n        # Create the new GeoTIFF file\n        with rasterio.open(output_file, 'w', **profile) as dst_dataset:\n            # Write the data to the new GeoTIFF\n            dst_dataset.write(data, 1)\n  \n\ndef calculate_slope_aspect(dem_file):\n    with rasterio.open(dem_file) as dataset:\n        # Read the DEM data as a numpy array\n        dem_data = dataset.read(1)\n\n        # Get the geotransform to convert pixel coordinates to geographic coordinates\n        transform = dataset.transform\n\n        # Calculate the slope and aspect using numpy\n        dx, dy = np.gradient(dem_data, transform[0], transform[4])\n        slope = np.arctan(np.sqrt(dx ** 2 + dy ** 2)) * (180.0 / np.pi)\n        aspect = np.arctan2(-dy, dx) * (180.0 / np.pi)\n\n        # Adjust aspect values to range from 0 to 360 degrees\n        aspect[aspect < 0] += 360\n\t\tprint(f\"slope shape: {slope.shape}\")\n        print(f\"aspect shape: {aspect.shape}\")\n        \n        \n    return slope, aspect\n  \ndef calculate_curvature(elevation_data, pixel_size_x, pixel_size_y):\n    # Calculate curvature using the Laplacian operator\n    curvature_x = np.gradient(np.gradient(elevation_data, pixel_size_x, axis=1), pixel_size_x, axis=1)\n    curvature_y = np.gradient(np.gradient(elevation_data, pixel_size_y, axis=0), pixel_size_y, axis=0)\n    curvature = curvature_x + curvature_y\n\n    return curvature\n\ndef geotiff_to_csv(geotiff_file, csv_file):\n    # Open the GeoTIFF file\n    with rasterio.open(geotiff_file) as dataset:\n        # Get the pixel values as a 2D array\n        data = dataset.read(1)\n\n        # Get the geotransform to convert pixel coordinates to geographic coordinates\n        transform = dataset.transform\n\n        # Get the width and height of the GeoTIFF\n        height, width = data.shape\n\n        # Open the CSV file for writing\n        with open(csv_file, 'w', newline='') as csvfile:\n            csvwriter = csv.writer(csvfile)\n\n            # Write the CSV header\n            csvwriter.writerow(['Latitude', 'Longitude', 'x', 'y', 'Elevation'])\n\n            # Loop through each pixel and extract latitude, longitude, and image value\n            for y in range(height):\n                for x in range(width):\n                    # Get the pixel value\n                    image_value = data[y, x]\n\n                    # Convert pixel coordinates to geographic coordinates\n                    lon, lat = transform * (x, y)\n\n                    # Write the data to the CSV file\n                    csvwriter.writerow([lat, lon, x, y, image_value])\n\n  \ndef read_elevation_data(file_path, result_dem_csv_path, result_dem_feature_csv_path):\n    neighborhood_size=4\n    df = pd.read_csv(file_path)\n    \n    dataset = rasterio.open(geotiff_file)\n    data = dataset.read(1)\n\n    # Get the width and height of the GeoTIFF\n    height, width = data.shape\n    \n    # Create an empty DataFrame with column names\n    columns = ['lat', 'lon', 'elevation', 'slope', 'aspect', 'curvature', 'northness', 'eastness']\n    all_df = pd.DataFrame(columns=columns)\n    \n    print(f\"neighborhood_size // 2 = {neighborhood_size // 2}\")\n    \n    for index, row in original_df.iterrows():\n      # Access individual row elements using row['column_name']\n      # Convert latitude and longitude to pixel indices\n      x = row[\"x\"]\n      y = row[\"y\"]\n      lat = row['Latitude']\n      lon = row['Longitude']\n      elevation = row['Elevation']\n      \n      if index % 500 == 0:\n        print(f\"processing {x} {y}\")\n\t  \n      if x < neighborhood_size // 2 or y < neighborhood_size // 2 or x > (width - neighborhood_size // 2) or y > (height - neighborhood_size // 2):\n      \tdata_row = {\n            'lat': lat,\n            'lon': lon,\n            'elevation': elevation,\n            'slope': -1,\n            'aspect': -1,\n            'curvature': -1,\n            'northness': -1,\n            'eastness': -1\n        }\n      else:\n        # Read a small neighborhood of elevation data around the selected point\n        small_elevation_data = band.ReadAsArray(x - neighborhood_size // 2, y - neighborhood_size // 2, neighborhood_size, neighborhood_size)\n\n        # Calculate slope and aspect\n        slope_data, aspect_data = calculate_slope_aspect(small_elevation_data, pixel_size_x, pixel_size_y)\n\n        # Calculate curvature\n        curvature_data = calculate_curvature(small_elevation_data, pixel_size_x, pixel_size_y)\n        northness_data = np.abs(np.sin(np.radians(aspect_data)))\n        eastness_data = np.abs(np.cos(np.radians(aspect_data)))\n\n\n        data_row = {\n            'lat': lat,\n            'lon': lon,\n            'elevation': elevation,\n            'slope': slope_data[neighborhood_size // 2, neighborhood_size // 2],\n            'aspect': aspect_data[neighborhood_size // 2, neighborhood_size // 2],\n            'curvature': curvature_data[neighborhood_size // 2, neighborhood_size // 2],\n            'northness': northness_data[neighborhood_size // 2, neighborhood_size // 2],\n            'eastness': eastness_data[neighborhood_size // 2, neighborhood_size // 2]\n        }\n      \n      \n      # Append a row to the DataFrame\n      all_df = all_df.append(data_row, ignore_index=True)\n    \n    all_df.to_csv(result_dem_feature_csv_path)\n    print(f\"DEM and other columns are saved to file {result_dem_feature_csv_path}\")\n    return all_df\n\n\n  \n# Usage example:\nresult_dem_csv_path = \"/home/chetana/gridmet_test_run/dem_template.csv\"\nresult_dem_feature_csv_path = \"/home/chetana/gridmet_test_run/dem_all.csv\"\n\n\ndem_file = \"/home/chetana/gridmet_test_run/output_4km_clipped.tif\"\nslope_file = '/home/chetana/gridmet_test_run/slope_file.tif'\naspect_file = '/home/chetana/gridmet_test_run/aspect_file.tif'\n\n#geotiff_to_csv(dem_file, result_dem_csv_path)\n\n\nslope, aspect = calculate_slope_aspect(dem_file)\n\n# Save the slope and aspect as new GeoTIFF files\nsave_as_geotiff(slope, slope_file, dem_file)\nsave_as_geotiff(aspect, aspect_file, dem_file)\n\n\n#generate_all_elevation_variables(\"/home/chetana/gridmet_test_run/output_4km_clipped.tif\", result_dem_csv_path, result_dem_feature_csv_path)\n\n\n\n#final_dem_all_cols = read_elevation_data(\"/home/chetana/gridmet_test_run/output_4km_clipped.tif\")\n",
  "history_output" : "  File \"/home/chetana/gw-workspace/PvMeML3iWNRw/western_us_dem.py\", line 59\n    print(f\"slope shape: {slope.shape}\")\nTabError: inconsistent use of tabs and spaces in indentation\n",
  "history_begin_time" : 1690259044261,
  "history_end_time" : 1690259044312,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : null,
  "indicator" : "Failed"
},{
  "history_id" : "QNYSnltJh7gz",
  "history_input" : "import numpy as np\nimport pandas as pd\nfrom osgeo import gdal\nimport warnings\nimport rasterio\nimport csv\n\n# Set the warning filter globally to ignore the FutureWarning\nwarnings.simplefilter(\"ignore\", FutureWarning)\n\ndef lat_lon_to_pixel(lat, lon, geotransform):\n    x = int((lon - geotransform[0]) / geotransform[1])\n    y = int((lat - geotransform[3]) / geotransform[5])\n    return x, y\n\n\ndef calculate_slope_aspect(elevation_data, pixel_size_x, pixel_size_y):\n    # Calculate slope using the Sobel operator\n    slope_x = np.gradient(elevation_data, pixel_size_x, axis=1)\n    slope_y = np.gradient(elevation_data, pixel_size_y, axis=0)\n    slope_rad = np.arctan(np.sqrt(slope_x ** 2 + slope_y ** 2))\n    slope_deg = np.degrees(slope_rad)\n\n    # Calculate aspect (direction of the steepest descent)\n    aspect_rad = np.arctan2(slope_y, -slope_x)\n    aspect_deg = (np.degrees(aspect_rad) + 360) % 360\n\n    return slope_deg, aspect_deg\n\n\ndef calculate_curvature(elevation_data, pixel_size_x, pixel_size_y):\n    # Calculate curvature using the Laplacian operator\n    curvature_x = np.gradient(np.gradient(elevation_data, pixel_size_x, axis=1), pixel_size_x, axis=1)\n    curvature_y = np.gradient(np.gradient(elevation_data, pixel_size_y, axis=0), pixel_size_y, axis=0)\n    curvature = curvature_x + curvature_y\n\n    return curvature\n\ndef geotiff_to_csv(geotiff_file, csv_file):\n    # Open the GeoTIFF file\n    with rasterio.open(geotiff_file) as dataset:\n        # Get the pixel values as a 2D array\n        data = dataset.read(1)\n\n        # Get the geotransform to convert pixel coordinates to geographic coordinates\n        transform = dataset.transform\n\n        # Get the width and height of the GeoTIFF\n        height, width = data.shape\n\n        # Open the CSV file for writing\n        with open(csv_file, 'w', newline='') as csvfile:\n            csvwriter = csv.writer(csvfile)\n\n            # Write the CSV header\n            csvwriter.writerow(['Latitude', 'Longitude', 'x', 'y', 'Elevation'])\n\n            # Loop through each pixel and extract latitude, longitude, and image value\n            for y in range(height):\n                for x in range(width):\n                    # Get the pixel value\n                    image_value = data[y, x]\n\n                    # Convert pixel coordinates to geographic coordinates\n                    lon, lat = transform * (x, y)\n\n                    # Write the data to the CSV file\n                    csvwriter.writerow([lat, lon, x, y, image_value])\n\n  \ndef read_elevation_data(file_path, neighborhood_size=4):\n    original_df, geotransform = read_elevation_data_only(file_path)\n    \n    # Create an empty DataFrame with column names\n    columns = ['lat', 'lon', 'elevation', 'slope', 'aspect', 'curvature', 'northness', 'eastness']\n    all_df = pd.DataFrame(columns=columns)\n    \n    print(f\"neighborhood_size // 2 = {neighborhood_size // 2}\")\n    \n    for index, row in original_df.iterrows():\n      # Access individual row elements using row['column_name']\n      # Convert latitude and longitude to pixel indices\n      x, y = lat_lon_to_pixel(row['Latitude'], row['Longitude'], geotransform)\n      \n      if index % 10 == 0:\n        print(f\"processing {x} {y}\")\n\t  \n      if x < neighborhood_size // 2 or y < neighborhood_size // 2 or x > (raster_width - neighborhood_size // 2) or y > (raster_height - neighborhood_size // 2):\n      \tdata_row = {\n            'lat': row['Latitude'],\n            'lon': row['Longitude'],\n            'elevation': row['Elevation'],\n            'slope': -1,\n            'aspect': -1,\n            'curvature': -1,\n            'northness': -1,\n            'eastness': -1\n        }\n      else:\n        # Read a small neighborhood of elevation data around the selected point\n        small_elevation_data = band.ReadAsArray(x - neighborhood_size // 2, y - neighborhood_size // 2, neighborhood_size, neighborhood_size)\n\n        # Calculate slope and aspect\n        slope_data, aspect_data = calculate_slope_aspect(small_elevation_data, pixel_size_x, pixel_size_y)\n\n        # Calculate curvature\n        curvature_data = calculate_curvature(small_elevation_data, pixel_size_x, pixel_size_y)\n        northness_data = np.abs(np.sin(np.radians(aspect_data)))\n        eastness_data = np.abs(np.cos(np.radians(aspect_data)))\n\n\n        data_row = {\n            'lat': row['Latitude'],\n            'lon': row['Longitude'],\n            'elevation': row['Elevation'],\n            'slope': slope_data[neighborhood_size // 2, neighborhood_size // 2],\n            'aspect': aspect_data[neighborhood_size // 2, neighborhood_size // 2],\n            'curvature': curvature_data[neighborhood_size // 2, neighborhood_size // 2],\n            'northness': northness_data[neighborhood_size // 2, neighborhood_size // 2],\n            'eastness': eastness_data[neighborhood_size // 2, neighborhood_size // 2]\n        }\n      \n      \n      # Append a row to the DataFrame\n      all_df = all_df.append(data_row, ignore_index=True)\n    \n    all_df.to_csv(result_dem_feature_csv_path)\n    print(f\"DEM and other columns are saved to file {result_dem_feature_csv_path}\")\n    return all_df\n\n\n\n# Usage example:\nresult_dem_csv_path = \"/home/chetana/gridmet_test_run/dem_template.csv\"\nresult_dem_feature_csv_path = \"/home/chetana/gridmet_test_run/dem_all.csv\"\ngeotiff_to_csv(\"/home/chetana/gridmet_test_run/output_4km_clipped.tif\", result_dem_csv_path)\n#final_dem_all_cols = read_elevation_data(\"/home/chetana/gridmet_test_run/output_4km_clipped.tif\")\n",
  "history_output" : "",
  "history_begin_time" : 1690257925211,
  "history_end_time" : 1690257927168,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "bzn5HlXAAIQ6",
  "history_input" : "import numpy as np\nimport pandas as pd\nfrom osgeo import gdal\nimport warnings\nimport rasterio\nimport csv\n\n# Set the warning filter globally to ignore the FutureWarning\nwarnings.simplefilter(\"ignore\", FutureWarning)\n\ndef lat_lon_to_pixel(lat, lon, geotransform):\n    x = int((lon - geotransform[0]) / geotransform[1])\n    y = int((lat - geotransform[3]) / geotransform[5])\n    return x, y\n\n\ndef calculate_slope_aspect(elevation_data, pixel_size_x, pixel_size_y):\n    # Calculate slope using the Sobel operator\n    slope_x = np.gradient(elevation_data, pixel_size_x, axis=1)\n    slope_y = np.gradient(elevation_data, pixel_size_y, axis=0)\n    slope_rad = np.arctan(np.sqrt(slope_x ** 2 + slope_y ** 2))\n    slope_deg = np.degrees(slope_rad)\n\n    # Calculate aspect (direction of the steepest descent)\n    aspect_rad = np.arctan2(slope_y, -slope_x)\n    aspect_deg = (np.degrees(aspect_rad) + 360) % 360\n\n    return slope_deg, aspect_deg\n\n\ndef calculate_curvature(elevation_data, pixel_size_x, pixel_size_y):\n    # Calculate curvature using the Laplacian operator\n    curvature_x = np.gradient(np.gradient(elevation_data, pixel_size_x, axis=1), pixel_size_x, axis=1)\n    curvature_y = np.gradient(np.gradient(elevation_data, pixel_size_y, axis=0), pixel_size_y, axis=0)\n    curvature = curvature_x + curvature_y\n\n    return curvature\n\n\ndef read_elevation_data_only(file_path):\n    dataset = gdal.Open(file_path)\n    if dataset is None:\n      print(\"Error: Could not open the file.\")\n      return None\n\n    result_dem_csv_path = \"/home/chetana/gridmet_test_run/dem_template.csv\"\n    result_dem_feature_csv_path = \"/home/chetana/gridmet_test_run/dem_all.csv\"\n\n    print(f\"start to first convert geotiff to {result_dem_csv_path}\")\n\n    band = dataset.GetRasterBand(1)\n    elevation_data = band.ReadAsArray()\n\n    # Get geotransform information\n    geotransform = dataset.GetGeoTransform()\n    min_lon, pixel_size_x, _, max_lat, _, pixel_size_y = geotransform\n\n    # Calculate raster size\n    raster_width = dataset.RasterXSize\n    raster_height = dataset.RasterYSize\n\n    # Generate latitude and longitude arrays\n    lats = np.arange(max_lat, max_lat - pixel_size_y * raster_height, -pixel_size_y)\n    lons = np.arange(min_lon, min_lon + pixel_size_x * raster_width, pixel_size_x)\n\n    # Create meshgrid of latitude and longitude\n    lon_grid, lat_grid = np.meshgrid(lons, lats)\n\n    # Flatten the data and the lat/lon grids\n    elevation_data_flat = elevation_data.flatten()\n    lat_grid_flat = lat_grid.flatten()\n    lon_grid_flat = lon_grid.flatten()\n\n    # Create a DataFrame to store the data\n    df = pd.DataFrame({\n      'Latitude': lat_grid_flat,\n      'Longitude': lon_grid_flat,\n      'Elevation': elevation_data_flat,\n    })\n\n    df.to_csv(result_dem_csv_path)\n    print(f\"DEM geotif is saved to a csv file with only elevation {result_dem_csv_path}\")\n    return df, geotransform\n\ndef geotiff_to_csv(geotiff_file, csv_file):\n    # Open the GeoTIFF file\n    with rasterio.open(geotiff_file) as dataset:\n        # Get the pixel values as a 2D array\n        data = dataset.read(1)\n\n        # Get the geotransform to convert pixel coordinates to geographic coordinates\n        transform = dataset.transform\n\n        # Get the width and height of the GeoTIFF\n        height, width = data.shape\n\n        # Open the CSV file for writing\n        with open(csv_file, 'w', newline='') as csvfile:\n            csvwriter = csv.writer(csvfile)\n\n            # Write the CSV header\n            csvwriter.writerow(['Latitude', 'Longitude', 'Image Value'])\n\n            # Loop through each pixel and extract latitude, longitude, and image value\n            for y in range(height):\n                for x in range(width):\n                    # Get the pixel value\n                    image_value = data[y, x]\n\n                    # Convert pixel coordinates to geographic coordinates\n                    lon, lat = transform * (x, y)\n\n                    # Write the data to the CSV file\n                    csvwriter.writerow([lat, lon, image_value])\n  \n  \ndef read_elevation_data(file_path, neighborhood_size=4):\n    original_df, geotransform = read_elevation_data_only(file_path)\n    \n    # Create an empty DataFrame with column names\n    columns = ['lat', 'lon', 'elevation', 'slope', 'aspect', 'curvature', 'northness', 'eastness']\n    all_df = pd.DataFrame(columns=columns)\n    \n    print(f\"neighborhood_size // 2 = {neighborhood_size // 2}\")\n    \n    for index, row in original_df.iterrows():\n      # Access individual row elements using row['column_name']\n      # Convert latitude and longitude to pixel indices\n      x, y = lat_lon_to_pixel(row['Latitude'], row['Longitude'], geotransform)\n      \n      if index % 10 == 0:\n        print(f\"processing {x} {y}\")\n\t  \n      if x < neighborhood_size // 2 or y < neighborhood_size // 2 or x > (raster_width - neighborhood_size // 2) or y > (raster_height - neighborhood_size // 2):\n      \tdata_row = {\n            'lat': row['Latitude'],\n            'lon': row['Longitude'],\n            'elevation': row['Elevation'],\n            'slope': -1,\n            'aspect': -1,\n            'curvature': -1,\n            'northness': -1,\n            'eastness': -1\n        }\n      else:\n        # Read a small neighborhood of elevation data around the selected point\n        small_elevation_data = band.ReadAsArray(x - neighborhood_size // 2, y - neighborhood_size // 2, neighborhood_size, neighborhood_size)\n\n        # Calculate slope and aspect\n        slope_data, aspect_data = calculate_slope_aspect(small_elevation_data, pixel_size_x, pixel_size_y)\n\n        # Calculate curvature\n        curvature_data = calculate_curvature(small_elevation_data, pixel_size_x, pixel_size_y)\n        northness_data = np.abs(np.sin(np.radians(aspect_data)))\n        eastness_data = np.abs(np.cos(np.radians(aspect_data)))\n\n\n        data_row = {\n            'lat': row['Latitude'],\n            'lon': row['Longitude'],\n            'elevation': row['Elevation'],\n            'slope': slope_data[neighborhood_size // 2, neighborhood_size // 2],\n            'aspect': aspect_data[neighborhood_size // 2, neighborhood_size // 2],\n            'curvature': curvature_data[neighborhood_size // 2, neighborhood_size // 2],\n            'northness': northness_data[neighborhood_size // 2, neighborhood_size // 2],\n            'eastness': eastness_data[neighborhood_size // 2, neighborhood_size // 2]\n        }\n      \n      \n      # Append a row to the DataFrame\n      all_df = all_df.append(data_row, ignore_index=True)\n    \n    all_df.to_csv(result_dem_feature_csv_path)\n    print(f\"DEM and other columns are saved to file {result_dem_feature_csv_path}\")\n    return all_df\n\n\n\n# Usage example:\nresult_dem_csv_path = \"/home/chetana/gridmet_test_run/dem_template.csv\"\nresult_dem_feature_csv_path = \"/home/chetana/gridmet_test_run/dem_all.csv\"\ngeotiff_to_csv(\"/home/chetana/gridmet_test_run/output_4km_clipped.tif\", result_dem_csv_path)\n#final_dem_all_cols = read_elevation_data(\"/home/chetana/gridmet_test_run/output_4km_clipped.tif\")\n",
  "history_output" : "",
  "history_begin_time" : 1690257807700,
  "history_end_time" : 1690257809588,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "uVqGEykwTyGc",
  "history_input" : "import numpy as np\nimport pandas as pd\nfrom osgeo import gdal\nimport warnings\nimport rasterio\n\n# Set the warning filter globally to ignore the FutureWarning\nwarnings.simplefilter(\"ignore\", FutureWarning)\n\ndef lat_lon_to_pixel(lat, lon, geotransform):\n    x = int((lon - geotransform[0]) / geotransform[1])\n    y = int((lat - geotransform[3]) / geotransform[5])\n    return x, y\n\n\ndef calculate_slope_aspect(elevation_data, pixel_size_x, pixel_size_y):\n    # Calculate slope using the Sobel operator\n    slope_x = np.gradient(elevation_data, pixel_size_x, axis=1)\n    slope_y = np.gradient(elevation_data, pixel_size_y, axis=0)\n    slope_rad = np.arctan(np.sqrt(slope_x ** 2 + slope_y ** 2))\n    slope_deg = np.degrees(slope_rad)\n\n    # Calculate aspect (direction of the steepest descent)\n    aspect_rad = np.arctan2(slope_y, -slope_x)\n    aspect_deg = (np.degrees(aspect_rad) + 360) % 360\n\n    return slope_deg, aspect_deg\n\n\ndef calculate_curvature(elevation_data, pixel_size_x, pixel_size_y):\n    # Calculate curvature using the Laplacian operator\n    curvature_x = np.gradient(np.gradient(elevation_data, pixel_size_x, axis=1), pixel_size_x, axis=1)\n    curvature_y = np.gradient(np.gradient(elevation_data, pixel_size_y, axis=0), pixel_size_y, axis=0)\n    curvature = curvature_x + curvature_y\n\n    return curvature\n\n\ndef read_elevation_data_only(file_path):\n    dataset = gdal.Open(file_path)\n    if dataset is None:\n      print(\"Error: Could not open the file.\")\n      return None\n\n    result_dem_csv_path = \"/home/chetana/gridmet_test_run/dem_template.csv\"\n    result_dem_feature_csv_path = \"/home/chetana/gridmet_test_run/dem_all.csv\"\n\n    print(f\"start to first convert geotiff to {result_dem_csv_path}\")\n\n    band = dataset.GetRasterBand(1)\n    elevation_data = band.ReadAsArray()\n\n    # Get geotransform information\n    geotransform = dataset.GetGeoTransform()\n    min_lon, pixel_size_x, _, max_lat, _, pixel_size_y = geotransform\n\n    # Calculate raster size\n    raster_width = dataset.RasterXSize\n    raster_height = dataset.RasterYSize\n\n    # Generate latitude and longitude arrays\n    lats = np.arange(max_lat, max_lat - pixel_size_y * raster_height, -pixel_size_y)\n    lons = np.arange(min_lon, min_lon + pixel_size_x * raster_width, pixel_size_x)\n\n    # Create meshgrid of latitude and longitude\n    lon_grid, lat_grid = np.meshgrid(lons, lats)\n\n    # Flatten the data and the lat/lon grids\n    elevation_data_flat = elevation_data.flatten()\n    lat_grid_flat = lat_grid.flatten()\n    lon_grid_flat = lon_grid.flatten()\n\n    # Create a DataFrame to store the data\n    df = pd.DataFrame({\n      'Latitude': lat_grid_flat,\n      'Longitude': lon_grid_flat,\n      'Elevation': elevation_data_flat,\n    })\n\n    df.to_csv(result_dem_csv_path)\n    print(f\"DEM geotif is saved to a csv file with only elevation {result_dem_csv_path}\")\n    return df, geotransform\n\ndef geotiff_to_csv(geotiff_file, csv_file):\n    # Open the GeoTIFF file\n    with rasterio.open(geotiff_file) as dataset:\n        # Get the pixel values as a 2D array\n        data = dataset.read(1)\n\n        # Get the geotransform to convert pixel coordinates to geographic coordinates\n        transform = dataset.transform\n\n        # Get the width and height of the GeoTIFF\n        height, width = data.shape\n\n        # Open the CSV file for writing\n        with open(csv_file, 'w', newline='') as csvfile:\n            csvwriter = csv.writer(csvfile)\n\n            # Write the CSV header\n            csvwriter.writerow(['Latitude', 'Longitude', 'Image Value'])\n\n            # Loop through each pixel and extract latitude, longitude, and image value\n            for y in range(height):\n                for x in range(width):\n                    # Get the pixel value\n                    image_value = data[y, x]\n\n                    # Convert pixel coordinates to geographic coordinates\n                    lon, lat = transform * (x, y)\n\n                    # Write the data to the CSV file\n                    csvwriter.writerow([lat, lon, image_value])\n  \n  \ndef read_elevation_data(file_path, neighborhood_size=4):\n    original_df, geotransform = read_elevation_data_only(file_path)\n    \n    # Create an empty DataFrame with column names\n    columns = ['lat', 'lon', 'elevation', 'slope', 'aspect', 'curvature', 'northness', 'eastness']\n    all_df = pd.DataFrame(columns=columns)\n    \n    print(f\"neighborhood_size // 2 = {neighborhood_size // 2}\")\n    \n    for index, row in original_df.iterrows():\n      # Access individual row elements using row['column_name']\n      # Convert latitude and longitude to pixel indices\n      x, y = lat_lon_to_pixel(row['Latitude'], row['Longitude'], geotransform)\n      \n      if index % 10 == 0:\n        print(f\"processing {x} {y}\")\n\t  \n      if x < neighborhood_size // 2 or y < neighborhood_size // 2 or x > (raster_width - neighborhood_size // 2) or y > (raster_height - neighborhood_size // 2):\n      \tdata_row = {\n            'lat': row['Latitude'],\n            'lon': row['Longitude'],\n            'elevation': row['Elevation'],\n            'slope': -1,\n            'aspect': -1,\n            'curvature': -1,\n            'northness': -1,\n            'eastness': -1\n        }\n      else:\n        # Read a small neighborhood of elevation data around the selected point\n        small_elevation_data = band.ReadAsArray(x - neighborhood_size // 2, y - neighborhood_size // 2, neighborhood_size, neighborhood_size)\n\n        # Calculate slope and aspect\n        slope_data, aspect_data = calculate_slope_aspect(small_elevation_data, pixel_size_x, pixel_size_y)\n\n        # Calculate curvature\n        curvature_data = calculate_curvature(small_elevation_data, pixel_size_x, pixel_size_y)\n        northness_data = np.abs(np.sin(np.radians(aspect_data)))\n        eastness_data = np.abs(np.cos(np.radians(aspect_data)))\n\n\n        data_row = {\n            'lat': row['Latitude'],\n            'lon': row['Longitude'],\n            'elevation': row['Elevation'],\n            'slope': slope_data[neighborhood_size // 2, neighborhood_size // 2],\n            'aspect': aspect_data[neighborhood_size // 2, neighborhood_size // 2],\n            'curvature': curvature_data[neighborhood_size // 2, neighborhood_size // 2],\n            'northness': northness_data[neighborhood_size // 2, neighborhood_size // 2],\n            'eastness': eastness_data[neighborhood_size // 2, neighborhood_size // 2]\n        }\n      \n      \n      # Append a row to the DataFrame\n      all_df = all_df.append(data_row, ignore_index=True)\n    \n    all_df.to_csv(result_dem_feature_csv_path)\n    print(f\"DEM and other columns are saved to file {result_dem_feature_csv_path}\")\n    return all_df\n\n\n\n# Usage example:\nresult_dem_csv_path = \"/home/chetana/gridmet_test_run/dem_template.csv\"\nresult_dem_feature_csv_path = \"/home/chetana/gridmet_test_run/dem_all.csv\"\ngeotiff_to_csv(\"/home/chetana/gridmet_test_run/output_4km_clipped.tif\", result_dem_csv_path)\n#final_dem_all_cols = read_elevation_data(\"/home/chetana/gridmet_test_run/output_4km_clipped.tif\")\n",
  "history_output" : "Traceback (most recent call last):\n  File \"/home/chetana/gw-workspace/uVqGEykwTyGc/western_us_dem.py\", line 181, in <module>\n    geotiff_to_csv(\"/home/chetana/gridmet_test_run/output_4km_clipped.tif\", result_dem_csv_path)\n  File \"/home/chetana/gw-workspace/uVqGEykwTyGc/western_us_dem.py\", line 98, in geotiff_to_csv\n    csvwriter = csv.writer(csvfile)\nNameError: name 'csv' is not defined\n",
  "history_begin_time" : 1690257791139,
  "history_end_time" : 1690257795571,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : null,
  "indicator" : "Failed"
},{
  "history_id" : "ntIx1hNHkIhl",
  "history_input" : "import numpy as np\nimport pandas as pd\nfrom osgeo import gdal\nimport warnings\n\n# Set the warning filter globally to ignore the FutureWarning\nwarnings.simplefilter(\"ignore\", FutureWarning)\n\ndef lat_lon_to_pixel(lat, lon, geotransform):\n    x = int((lon - geotransform[0]) / geotransform[1])\n    y = int((lat - geotransform[3]) / geotransform[5])\n    return x, y\n\n\ndef calculate_slope_aspect(elevation_data, pixel_size_x, pixel_size_y):\n    # Calculate slope using the Sobel operator\n    slope_x = np.gradient(elevation_data, pixel_size_x, axis=1)\n    slope_y = np.gradient(elevation_data, pixel_size_y, axis=0)\n    slope_rad = np.arctan(np.sqrt(slope_x ** 2 + slope_y ** 2))\n    slope_deg = np.degrees(slope_rad)\n\n    # Calculate aspect (direction of the steepest descent)\n    aspect_rad = np.arctan2(slope_y, -slope_x)\n    aspect_deg = (np.degrees(aspect_rad) + 360) % 360\n\n    return slope_deg, aspect_deg\n\n\ndef calculate_curvature(elevation_data, pixel_size_x, pixel_size_y):\n    # Calculate curvature using the Laplacian operator\n    curvature_x = np.gradient(np.gradient(elevation_data, pixel_size_x, axis=1), pixel_size_x, axis=1)\n    curvature_y = np.gradient(np.gradient(elevation_data, pixel_size_y, axis=0), pixel_size_y, axis=0)\n    curvature = curvature_x + curvature_y\n\n    return curvature\n\n\ndef read_elevation_data_only(file_path):\n    dataset = gdal.Open(file_path)\n    if dataset is None:\n      print(\"Error: Could not open the file.\")\n      return None\n\n    result_dem_csv_path = \"/home/chetana/gridmet_test_run/dem_template.csv\"\n    result_dem_feature_csv_path = \"/home/chetana/gridmet_test_run/dem_all.csv\"\n\n    print(f\"start to first convert geotiff to {result_dem_csv_path}\")\n\n    band = dataset.GetRasterBand(1)\n    elevation_data = band.ReadAsArray()\n\n    # Get geotransform information\n    geotransform = dataset.GetGeoTransform()\n    min_lon, pixel_size_x, _, max_lat, _, pixel_size_y = geotransform\n\n    # Calculate raster size\n    raster_width = dataset.RasterXSize\n    raster_height = dataset.RasterYSize\n\n    # Generate latitude and longitude arrays\n    lats = np.arange(max_lat, max_lat - pixel_size_y * raster_height, -pixel_size_y)\n    lons = np.arange(min_lon, min_lon + pixel_size_x * raster_width, pixel_size_x)\n\n    # Create meshgrid of latitude and longitude\n    lon_grid, lat_grid = np.meshgrid(lons, lats)\n\n    # Flatten the data and the lat/lon grids\n    elevation_data_flat = elevation_data.flatten()\n    lat_grid_flat = lat_grid.flatten()\n    lon_grid_flat = lon_grid.flatten()\n\n    # Create a DataFrame to store the data\n    df = pd.DataFrame({\n      'Latitude': lat_grid_flat,\n      'Longitude': lon_grid_flat,\n      'Elevation': elevation_data_flat,\n    })\n\n    df.to_csv(result_dem_csv_path)\n    print(f\"DEM geotif is saved to a csv file with only elevation {result_dem_csv_path}\")\n    return df, geotransform\n\ndef geotiff_to_csv(geotiff_file, csv_file):\n    # Open the GeoTIFF file\n    with rasterio.open(geotiff_file) as dataset:\n        # Get the pixel values as a 2D array\n        data = dataset.read(1)\n\n        # Get the geotransform to convert pixel coordinates to geographic coordinates\n        transform = dataset.transform\n\n        # Get the width and height of the GeoTIFF\n        height, width = data.shape\n\n        # Open the CSV file for writing\n        with open(csv_file, 'w', newline='') as csvfile:\n            csvwriter = csv.writer(csvfile)\n\n            # Write the CSV header\n            csvwriter.writerow(['Latitude', 'Longitude', 'Image Value'])\n\n            # Loop through each pixel and extract latitude, longitude, and image value\n            for y in range(height):\n                for x in range(width):\n                    # Get the pixel value\n                    image_value = data[y, x]\n\n                    # Convert pixel coordinates to geographic coordinates\n                    lon, lat = transform * (x, y)\n\n                    # Write the data to the CSV file\n                    csvwriter.writerow([lat, lon, image_value])\n  \n  \ndef read_elevation_data(file_path, neighborhood_size=4):\n    original_df, geotransform = read_elevation_data_only(file_path)\n    \n    # Create an empty DataFrame with column names\n    columns = ['lat', 'lon', 'elevation', 'slope', 'aspect', 'curvature', 'northness', 'eastness']\n    all_df = pd.DataFrame(columns=columns)\n    \n    print(f\"neighborhood_size // 2 = {neighborhood_size // 2}\")\n    \n    for index, row in original_df.iterrows():\n      # Access individual row elements using row['column_name']\n      # Convert latitude and longitude to pixel indices\n      x, y = lat_lon_to_pixel(row['Latitude'], row['Longitude'], geotransform)\n      \n      if index % 10 == 0:\n        print(f\"processing {x} {y}\")\n\t  \n      if x < neighborhood_size // 2 or y < neighborhood_size // 2 or x > (raster_width - neighborhood_size // 2) or y > (raster_height - neighborhood_size // 2):\n      \tdata_row = {\n            'lat': row['Latitude'],\n            'lon': row['Longitude'],\n            'elevation': row['Elevation'],\n            'slope': -1,\n            'aspect': -1,\n            'curvature': -1,\n            'northness': -1,\n            'eastness': -1\n        }\n      else:\n        # Read a small neighborhood of elevation data around the selected point\n        small_elevation_data = band.ReadAsArray(x - neighborhood_size // 2, y - neighborhood_size // 2, neighborhood_size, neighborhood_size)\n\n        # Calculate slope and aspect\n        slope_data, aspect_data = calculate_slope_aspect(small_elevation_data, pixel_size_x, pixel_size_y)\n\n        # Calculate curvature\n        curvature_data = calculate_curvature(small_elevation_data, pixel_size_x, pixel_size_y)\n        northness_data = np.abs(np.sin(np.radians(aspect_data)))\n        eastness_data = np.abs(np.cos(np.radians(aspect_data)))\n\n\n        data_row = {\n            'lat': row['Latitude'],\n            'lon': row['Longitude'],\n            'elevation': row['Elevation'],\n            'slope': slope_data[neighborhood_size // 2, neighborhood_size // 2],\n            'aspect': aspect_data[neighborhood_size // 2, neighborhood_size // 2],\n            'curvature': curvature_data[neighborhood_size // 2, neighborhood_size // 2],\n            'northness': northness_data[neighborhood_size // 2, neighborhood_size // 2],\n            'eastness': eastness_data[neighborhood_size // 2, neighborhood_size // 2]\n        }\n      \n      \n      # Append a row to the DataFrame\n      all_df = all_df.append(data_row, ignore_index=True)\n    \n    all_df.to_csv(result_dem_feature_csv_path)\n    print(f\"DEM and other columns are saved to file {result_dem_feature_csv_path}\")\n    return all_df\n\n\n\n# Usage example:\nresult_dem_csv_path = \"/home/chetana/gridmet_test_run/dem_template.csv\"\nresult_dem_feature_csv_path = \"/home/chetana/gridmet_test_run/dem_all.csv\"\ngeotiff_to_csv(\"/home/chetana/gridmet_test_run/output_4km_clipped.tif\", result_dem_csv_path)\n#final_dem_all_cols = read_elevation_data(\"/home/chetana/gridmet_test_run/output_4km_clipped.tif\")\n",
  "history_output" : "Traceback (most recent call last):\n  File \"/home/chetana/gw-workspace/ntIx1hNHkIhl/western_us_dem.py\", line 180, in <module>\n    geotiff_to_csv(\"/home/chetana/gridmet_test_run/output_4km_clipped.tif\", result_dem_csv_path)\n  File \"/home/chetana/gw-workspace/ntIx1hNHkIhl/western_us_dem.py\", line 85, in geotiff_to_csv\n    with rasterio.open(geotiff_file) as dataset:\nNameError: name 'rasterio' is not defined\n",
  "history_begin_time" : 1690257778679,
  "history_end_time" : 1690257779204,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : null,
  "indicator" : "Failed"
},{
  "history_id" : "ChyF4O3UFHGm",
  "history_input" : "import numpy as np\nimport pandas as pd\nfrom osgeo import gdal\nimport warnings\n\n# Set the warning filter globally to ignore the FutureWarning\nwarnings.simplefilter(\"ignore\", FutureWarning)\n\ndef lat_lon_to_pixel(lat, lon, geotransform):\n    x = int((lon - geotransform[0]) / geotransform[1])\n    y = int((lat - geotransform[3]) / geotransform[5])\n    return x, y\n\n\ndef calculate_slope_aspect(elevation_data, pixel_size_x, pixel_size_y):\n    # Calculate slope using the Sobel operator\n    slope_x = np.gradient(elevation_data, pixel_size_x, axis=1)\n    slope_y = np.gradient(elevation_data, pixel_size_y, axis=0)\n    slope_rad = np.arctan(np.sqrt(slope_x ** 2 + slope_y ** 2))\n    slope_deg = np.degrees(slope_rad)\n\n    # Calculate aspect (direction of the steepest descent)\n    aspect_rad = np.arctan2(slope_y, -slope_x)\n    aspect_deg = (np.degrees(aspect_rad) + 360) % 360\n\n    return slope_deg, aspect_deg\n\n\ndef calculate_curvature(elevation_data, pixel_size_x, pixel_size_y):\n    # Calculate curvature using the Laplacian operator\n    curvature_x = np.gradient(np.gradient(elevation_data, pixel_size_x, axis=1), pixel_size_x, axis=1)\n    curvature_y = np.gradient(np.gradient(elevation_data, pixel_size_y, axis=0), pixel_size_y, axis=0)\n    curvature = curvature_x + curvature_y\n\n    return curvature\n\n\ndef read_elevation_data_only(file_path):\n    dataset = gdal.Open(file_path)\n    if dataset is None:\n      print(\"Error: Could not open the file.\")\n      return None\n\n    result_dem_csv_path = \"/home/chetana/gridmet_test_run/dem_template.csv\"\n    result_dem_feature_csv_path = \"/home/chetana/gridmet_test_run/dem_all.csv\"\n\n    print(f\"start to first convert geotiff to {result_dem_csv_path}\")\n\n    band = dataset.GetRasterBand(1)\n    elevation_data = band.ReadAsArray()\n\n    # Get geotransform information\n    geotransform = dataset.GetGeoTransform()\n    min_lon, pixel_size_x, _, max_lat, _, pixel_size_y = geotransform\n\n    # Calculate raster size\n    raster_width = dataset.RasterXSize\n    raster_height = dataset.RasterYSize\n\n    # Generate latitude and longitude arrays\n    lats = np.arange(max_lat, max_lat - pixel_size_y * raster_height, -pixel_size_y)\n    lons = np.arange(min_lon, min_lon + pixel_size_x * raster_width, pixel_size_x)\n\n    # Create meshgrid of latitude and longitude\n    lon_grid, lat_grid = np.meshgrid(lons, lats)\n\n    # Flatten the data and the lat/lon grids\n    elevation_data_flat = elevation_data.flatten()\n    lat_grid_flat = lat_grid.flatten()\n    lon_grid_flat = lon_grid.flatten()\n\n    # Create a DataFrame to store the data\n    df = pd.DataFrame({\n      'Latitude': lat_grid_flat,\n      'Longitude': lon_grid_flat,\n      'Elevation': elevation_data_flat,\n    })\n\n    df.to_csv(result_dem_csv_path)\n    print(f\"DEM geotif is saved to a csv file with only elevation {result_dem_csv_path}\")\n    return df, geotransform\n\n  \ndef read_elevation_data(file_path, neighborhood_size=4):\n    original_df, geotransform = read_elevation_data_only(file_path)\n    \n    # Create an empty DataFrame with column names\n    columns = ['lat', 'lon', 'elevation', 'slope', 'aspect', 'curvature', 'northness', 'eastness']\n    all_df = pd.DataFrame(columns=columns)\n    \n    print(f\"neighborhood_size // 2 = {neighborhood_size // 2}\")\n    \n    for index, row in original_df.iterrows():\n      # Access individual row elements using row['column_name']\n      # Convert latitude and longitude to pixel indices\n      x, y = lat_lon_to_pixel(row['Latitude'], row['Longitude'], geotransform)\n      \n      if index % 10 == 0:\n        print(f\"processing {x} {y}\")\n\t  \n      if x < neighborhood_size // 2 or y < neighborhood_size // 2 or x > (raster_width - neighborhood_size // 2) or y > (raster_height - neighborhood_size // 2):\n      \tdata_row = {\n            'lat': row['Latitude'],\n            'lon': row['Longitude'],\n            'elevation': row['Elevation'],\n            'slope': -1,\n            'aspect': -1,\n            'curvature': -1,\n            'northness': -1,\n            'eastness': -1\n        }\n      else:\n        # Read a small neighborhood of elevation data around the selected point\n        small_elevation_data = band.ReadAsArray(x - neighborhood_size // 2, y - neighborhood_size // 2, neighborhood_size, neighborhood_size)\n\n        # Calculate slope and aspect\n        slope_data, aspect_data = calculate_slope_aspect(small_elevation_data, pixel_size_x, pixel_size_y)\n\n        # Calculate curvature\n        curvature_data = calculate_curvature(small_elevation_data, pixel_size_x, pixel_size_y)\n        northness_data = np.abs(np.sin(np.radians(aspect_data)))\n        eastness_data = np.abs(np.cos(np.radians(aspect_data)))\n\n\n        data_row = {\n            'lat': row['Latitude'],\n            'lon': row['Longitude'],\n            'elevation': row['Elevation'],\n            'slope': slope_data[neighborhood_size // 2, neighborhood_size // 2],\n            'aspect': aspect_data[neighborhood_size // 2, neighborhood_size // 2],\n            'curvature': curvature_data[neighborhood_size // 2, neighborhood_size // 2],\n            'northness': northness_data[neighborhood_size // 2, neighborhood_size // 2],\n            'eastness': eastness_data[neighborhood_size // 2, neighborhood_size // 2]\n        }\n      \n      \n      # Append a row to the DataFrame\n      all_df = all_df.append(data_row, ignore_index=True)\n    \n    all_df.to_csv(result_dem_feature_csv_path)\n    print(f\"DEM and other columns are saved to file {result_dem_feature_csv_path}\")\n    return all_df\n\n\n\n# Usage example:\nread_elevation_data(\"/home/chetana/gridmet_test_run/output_4km_clipped.tif\")\n#final_dem_all_cols = read_elevation_data(\"/home/chetana/gridmet_test_run/output_4km_clipped.tif\")\n",
  "history_output" : "start to first convert geotiff to /home/chetana/gridmet_test_run/dem_template.csv\nDEM geotif is saved to a csv file with only elevation /home/chetana/gridmet_test_run/dem_template.csv\nneighborhood_size // 2 = 2\nprocessing 0 0\nprocessing 10 0\nprocessing 20 0\nprocessing 30 0\nprocessing 40 0\nprocessing 50 0\nprocessing 60 0\nprocessing 70 0\nprocessing 80 0\nprocessing 90 0\nprocessing 100 0\nprocessing 110 0\nprocessing 120 0\nprocessing 130 0\nprocessing 140 0\nprocessing 150 0\nprocessing 160 0\nprocessing 170 0\nprocessing 180 0\nprocessing 190 0\nprocessing 200 0\nprocessing 210 0\nprocessing 220 0\nprocessing 230 0\nprocessing 240 0\nprocessing 250 0\nprocessing 260 0\nprocessing 270 0\nprocessing 280 0\nprocessing 290 0\nprocessing 300 0\nprocessing 310 0\nprocessing 320 0\nprocessing 330 0\nprocessing 340 0\nprocessing 350 0\nprocessing 360 0\nprocessing 370 0\nprocessing 380 0\nprocessing 390 0\nprocessing 400 0\nprocessing 410 0\nprocessing 420 0\nprocessing 430 0\nprocessing 440 0\nprocessing 450 0\nprocessing 460 0\nprocessing 470 0\nprocessing 480 0\nprocessing 490 0\nprocessing 500 0\nprocessing 510 0\nprocessing 520 0\nprocessing 530 0\nprocessing 540 0\nprocessing 550 0\nprocessing 560 0\nprocessing 570 0\nprocessing 580 0\nprocessing 590 0\nprocessing 600 0\nprocessing 610 0\nprocessing 620 0\nprocessing 630 0\nprocessing 640 0\nprocessing 650 0\nprocessing 660 0\nprocessing 670 0\nprocessing 680 0\nprocessing 690 0\nprocessing 6 -1\nprocessing 16 -1\nprocessing 26 -1\nprocessing 36 -1\nprocessing 46 -1\nprocessing 56 -1\nprocessing 66 -1\nprocessing 76 -1\nprocessing 86 -1\nprocessing 96 -1\nprocessing 106 -1\nprocessing 116 -1\nprocessing 126 -1\nprocessing 136 -1\nprocessing 146 -1\nprocessing 156 -1\nprocessing 166 -1\nprocessing 176 -1\nprocessing 186 -1\nprocessing 196 -1\nprocessing 206 -1\nprocessing 216 -1\nprocessing 226 -1\nprocessing 236 -1\nprocessing 246 -1\nprocessing 256 -1\nprocessing 266 -1\nprocessing 276 -1\nprocessing 286 -1\nprocessing 296 -1\nprocessing 306 -1\nprocessing 316 -1\nprocessing 326 -1\nprocessing 336 -1\nprocessing 346 -1\nprocessing 356 -1\nprocessing 366 -1\nprocessing 376 -1\nprocessing 386 -1\nprocessing 396 -1\nprocessing 406 -1\nprocessing 416 -1\nprocessing 426 -1\nprocessing 436 -1\nprocessing 446 -1\nprocessing 456 -1\nprocessing 466 -1\nprocessing 476 -1\nprocessing 486 -1\nprocessing 496 -1\nprocessing 506 -1\nprocessing 516 -1\nprocessing 526 -1\nprocessing 536 -1\nprocessing 546 -1\nprocessing 556 -1\nprocessing 566 -1\nprocessing 576 -1\nprocessing 586 -1\nprocessing 596 -1\nprocessing 606 -1\nprocessing 616 -1\nprocessing 626 -1\nprocessing 636 -1\nprocessing 646 -1\nprocessing 656 -1\nprocessing 666 -1\nprocessing 676 -1\nprocessing 686 -1\nprocessing 2 -2\nprocessing 12 -2\nprocessing 22 -2\nprocessing 32 -2\nprocessing 42 -2\nprocessing 52 -2\nprocessing 62 -2\nprocessing 72 -2\nprocessing 82 -2\nprocessing 92 -2\nprocessing 102 -2\nprocessing 112 -2\nprocessing 122 -2\nprocessing 132 -2\nprocessing 142 -2\nprocessing 152 -2\nprocessing 162 -2\nprocessing 172 -2\nprocessing 182 -2\nprocessing 192 -2\nprocessing 202 -2\nprocessing 212 -2\nprocessing 222 -2\nprocessing 232 -2\nprocessing 242 -2\nprocessing 252 -2\nprocessing 262 -2\nprocessing 272 -2\nprocessing 282 -2\nprocessing 292 -2\nprocessing 302 -2\nprocessing 312 -2\nprocessing 322 -2\nprocessing 332 -2\nprocessing 342 -2\nprocessing 352 -2\nprocessing 362 -2\nprocessing 372 -2\nprocessing 382 -2\nprocessing 392 -2\nprocessing 402 -2\nprocessing 412 -2\nprocessing 422 -2\nprocessing 432 -2\nprocessing 442 -2\nprocessing 452 -2\nprocessing 462 -2\nprocessing 472 -2\nprocessing 482 -2\nprocessing 492 -2\nprocessing 502 -2\nprocessing 512 -2\nprocessing 522 -2\nprocessing 532 -2\nprocessing 542 -2\nprocessing 552 -2\nprocessing 562 -2\nprocessing 572 -2\nprocessing 582 -2\nprocessing 592 -2\nprocessing 602 -2\nprocessing 612 -2\nprocessing 622 -2\nprocessing 632 -2\nprocessing 642 -2\nprocessing 652 -2\nprocessing 662 -2\nprocessing 672 -2\nprocessing 682 -2\nprocessing 692 -2\nprocessing 8 -3\nprocessing 18 -3\nprocessing 28 -3\nprocessing 38 -3\nprocessing 48 -3\nprocessing 58 -3\nprocessing 68 -3\nprocessing 78 -3\nprocessing 88 -3\nprocessing 98 -3\nprocessing 108 -3\nprocessing 118 -3\nprocessing 128 -3\nprocessing 138 -3\nprocessing 148 -3\nprocessing 158 -3\nprocessing 168 -3\nprocessing 178 -3\nprocessing 188 -3\nprocessing 198 -3\nprocessing 208 -3\nprocessing 218 -3\nprocessing 228 -3\nprocessing 238 -3\nprocessing 248 -3\nprocessing 258 -3\nprocessing 268 -3\nprocessing 278 -3\nprocessing 288 -3\nprocessing 298 -3\nprocessing 308 -3\nprocessing 318 -3\nprocessing 328 -3\nprocessing 338 -3\nprocessing 348 -3\nprocessing 358 -3\nprocessing 368 -3\nprocessing 378 -3\nprocessing 388 -3\nprocessing 398 -3\nprocessing 408 -3\nprocessing 418 -3\nprocessing 428 -3\nprocessing 438 -3\nprocessing 448 -3\nprocessing 458 -3\nprocessing 468 -3\nprocessing 478 -3\nprocessing 488 -3\nprocessing 498 -3\nprocessing 508 -3\nprocessing 518 -3\nprocessing 528 -3\nprocessing 538 -3\nprocessing 548 -3\nprocessing 558 -3\nprocessing 568 -3\nprocessing 578 -3\nprocessing 588 -3\nprocessing 598 -3\nprocessing 608 -3\nprocessing 618 -3\nprocessing 628 -3\nprocessing 638 -3\nprocessing 648 -3\nprocessing 658 -3\nprocessing 668 -3\nprocessing 678 -3\nprocessing 688 -3\nprocessing 4 -4\nprocessing 14 -4\nprocessing 24 -4\nprocessing 34 -4\nprocessing 44 -4\nprocessing 54 -4\nprocessing 64 -4\nprocessing 74 -4\nprocessing 84 -4\nprocessing 94 -4\nprocessing 104 -4\nprocessing 114 -4\nprocessing 124 -4\nprocessing 134 -4\nprocessing 144 -4\nprocessing 154 -4\nprocessing 164 -4\nprocessing 174 -4\nprocessing 184 -4\nprocessing 194 -4\nprocessing 204 -4\nprocessing 214 -4\nprocessing 224 -4\nprocessing 234 -4\nprocessing 244 -4\nprocessing 254 -4\nprocessing 264 -4\nprocessing 274 -4\nprocessing 284 -4\nprocessing 294 -4\nprocessing 304 -4\nprocessing 314 -4\nprocessing 324 -4\nprocessing 334 -4\nprocessing 344 -4\nprocessing 354 -4\nprocessing 364 -4\nprocessing 374 -4\nprocessing 384 -4\nprocessing 394 -4\nprocessing 404 -4\nprocessing 414 -4\nprocessing 424 -4\nprocessing 434 -4\nprocessing 444 -4\nprocessing 454 -4\nprocessing 464 -4\nprocessing 474 -4\nprocessing 484 -4\nprocessing 494 -4\nprocessing 504 -4\nprocessing 514 -4\nprocessing 524 -4\nprocessing 534 -4\nprocessing 544 -4\nprocessing 554 -4\nprocessing 564 -4\nprocessing 574 -4\nprocessing 584 -4\nprocessing 594 -4\nprocessing 604 -4\nprocessing 614 -4\nprocessing 624 -4\nprocessing 634 -4\nprocessing 644 -4\nprocessing 654 -4\nprocessing 664 -4\nprocessing 674 -4\nprocessing 684 -4\nprocessing 0 -5\nprocessing 10 -5\nprocessing 20 -5\nprocessing 30 -5\nprocessing 40 -5\nprocessing 50 -5\nprocessing 60 -5\nprocessing 70 -5\nprocessing 80 -5\nprocessing 90 -5\nprocessing 100 -5\nprocessing 110 -5\nprocessing 120 -5\nprocessing 130 -5\nprocessing 140 -5\nprocessing 150 -5\nprocessing 160 -5\nprocessing 170 -5\nprocessing 180 -5\nprocessing 190 -5\nprocessing 200 -5\nprocessing 210 -5\nprocessing 220 -5\nprocessing 230 -5\nprocessing 240 -5\nprocessing 250 -5\nprocessing 260 -5\nprocessing 270 -5\nprocessing 280 -5\nprocessing 290 -5\nprocessing 300 -5\nprocessing 310 -5\nprocessing 320 -5\nprocessing 330 -5\nprocessing 340 -5\nprocessing 350 -5\nprocessing 360 -5\nprocessing 370 -5\nprocessing 380 -5\nprocessing 390 -5\nprocessing 400 -5\nprocessing 410 -5\nprocessing 420 -5\nprocessing 430 -5\nprocessing 440 -5\nprocessing 450 -5\nprocessing 460 -5\nprocessing 470 -5\nprocessing 480 -5\nprocessing 490 -5\nprocessing 500 -5\nprocessing 510 -5\nprocessing 520 -5\nprocessing 530 -5\nprocessing 540 -5\nprocessing 550 -5\nprocessing 560 -5\nprocessing 570 -5\nprocessing 580 -5\nprocessing 590 -5\nprocessing 600 -5\nprocessing 610 -5\nprocessing 620 -5\nprocessing 630 -5\nprocessing 640 -5\nprocessing 650 -5\nprocessing 660 -5\nprocessing 670 -5\nprocessing 680 -5\nprocessing 690 -5\nprocessing 6 -6\nprocessing 16 -6\nprocessing 26 -6\nprocessing 36 -6\nprocessing 46 -6\nprocessing 56 -6\nprocessing 66 -6\nprocessing 76 -6\nprocessing 86 -6\nprocessing 96 -6\nprocessing 106 -6\nprocessing 116 -6\nprocessing 126 -6\nprocessing 136 -6\nprocessing 146 -6\nprocessing 156 -6\nprocessing 166 -6\nprocessing 176 -6\nprocessing 186 -6\nprocessing 196 -6\nprocessing 206 -6\nprocessing 216 -6\nprocessing 226 -6\nprocessing 236 -6\nprocessing 246 -6\nprocessing 256 -6\nprocessing 266 -6\nprocessing 276 -6\nprocessing 286 -6\nprocessing 296 -6\nprocessing 306 -6\nprocessing 316 -6\nprocessing 326 -6\nprocessing 336 -6\nprocessing 346 -6\nprocessing 356 -6\nprocessing 366 -6\nprocessing 376 -6\nprocessing 386 -6\nprocessing 396 -6\nprocessing 406 -6\nprocessing 416 -6\nprocessing 426 -6\nprocessing 436 -6\nprocessing 446 -6\nprocessing 456 -6\nprocessing 466 -6\nprocessing 476 -6\nprocessing 486 -6\nprocessing 496 -6\nprocessing 506 -6\nprocessing 516 -6\nprocessing 526 -6\nprocessing 536 -6\nprocessing 546 -6\nprocessing 556 -6\nprocessing 566 -6\nprocessing 576 -6\nprocessing 586 -6\nprocessing 596 -6\nprocessing 606 -6\nprocessing 616 -6\nprocessing 626 -6\nprocessing 636 -6\nprocessing 646 -6\nprocessing 656 -6\nprocessing 666 -6\nprocessing 676 -6\nprocessing 686 -6\nprocessing 2 -7\nprocessing 12 -7\nprocessing 22 -7\nprocessing 32 -7\nprocessing 42 -7\nprocessing 52 -7\nprocessing 62 -7\nprocessing 72 -7\nprocessing 82 -7\nprocessing 92 -7\nprocessing 102 -7\nprocessing 112 -7\nprocessing 122 -7\nprocessing 132 -7\nprocessing 142 -7\nprocessing 152 -7\nprocessing 162 -7\nprocessing 172 -7\nprocessing 182 -7\nprocessing 192 -7\nprocessing 202 -7\nprocessing 212 -7\nprocessing 222 -7\nprocessing 232 -7\nprocessing 242 -7\nprocessing 252 -7\nprocessing 262 -7\nprocessing 272 -7\nprocessing 282 -7\nprocessing 292 -7\nprocessing 302 -7\nprocessing 312 -7\nprocessing 322 -7\nprocessing 332 -7\nprocessing 342 -7\nprocessing 352 -7\nprocessing 362 -7\nprocessing 372 -7\nprocessing 382 -7\nprocessing 392 -7\nprocessing 402 -7\nprocessing 412 -7\nprocessing 422 -7\nprocessing 432 -7\nprocessing 442 -7\nprocessing 452 -7\nprocessing 462 -7\nprocessing 472 -7\nprocessing 482 -7\nprocessing 492 -7\nprocessing 502 -7\nprocessing 512 -7\nprocessing 522 -7\nprocessing 532 -7\nprocessing 542 -7\nprocessing 552 -7\nprocessing 562 -7\nprocessing 572 -7\nprocessing 582 -7\nprocessing 592 -7\nprocessing 602 -7\nprocessing 612 -7\nprocessing 622 -7\nprocessing 632 -7\nprocessing 642 -7\nprocessing 652 -7\nprocessing 662 -7\nprocessing 672 -7\nprocessing 682 -7\nprocessing 692 -7\nprocessing 8 -8\nprocessing 18 -8\nprocessing 28 -8\nprocessing 38 -8\nprocessing 48 -8\nprocessing 58 -8\nprocessing 68 -8\nprocessing 78 -8\nprocessing 88 -8\nprocessing 98 -8\nprocessing 108 -8\nprocessing 118 -8\nprocessing 128 -8\nprocessing 138 -8\nprocessing 148 -8\nprocessing 158 -8\nprocessing 168 -8\nprocessing 178 -8\nprocessing 188 -8\nprocessing 198 -8\nprocessing 208 -8\nprocessing 218 -8\nprocessing 228 -8\nprocessing 238 -8\nprocessing 248 -8\nprocessing 258 -8\nprocessing 268 -8\nprocessing 278 -8\nprocessing 288 -8\nprocessing 298 -8\nprocessing 308 -8\nprocessing 318 -8\nprocessing 328 -8\nprocessing 338 -8\nprocessing 348 -8\nprocessing 358 -8\nprocessing 368 -8\nprocessing 378 -8\nprocessing 388 -8\nprocessing 398 -8\nprocessing 408 -8\nprocessing 418 -8\nprocessing 428 -8\nprocessing 438 -8\nprocessing 448 -8\nprocessing 458 -8\nprocessing 468 -8\nprocessing 478 -8\nprocessing 488 -8\nprocessing 498 -8\nprocessing 508 -8\nprocessing 518 -8\nprocessing 528 -8\nprocessing 538 -8\nprocessing 548 -8\nprocessing 558 -8\nprocessing 568 -8\nprocessing 578 -8\nprocessing 588 -8\nprocessing 598 -8\nprocessing 608 -8\nprocessing 618 -8\nprocessing 628 -8\nprocessing 638 -8\nprocessing 648 -8\nprocessing 658 -8\nprocessing 668 -8\nprocessing 678 -8\nprocessing 688 -8\nprocessing 4 -9\nprocessing 14 -9\nprocessing 24 -9\nprocessing 34 -9\nprocessing 44 -9\nprocessing 54 -9\nprocessing 64 -9\nprocessing 74 -9\nprocessing 84 -9\nprocessing 94 -9\nprocessing 104 -9\nprocessing 114 -9\nprocessing 124 -9\nprocessing 134 -9\nprocessing 144 -9\nprocessing 154 -9\nprocessing 164 -9\nprocessing 174 -9\nprocessing 184 -9\nprocessing 194 -9\nprocessing 204 -9\nprocessing 214 -9\nprocessing 224 -9\nprocessing 234 -9\nprocessing 244 -9\nprocessing 254 -9\nprocessing 264 -9\nprocessing 274 -9\nprocessing 284 -9\nprocessing 294 -9\nprocessing 304 -9\nprocessing 314 -9\nprocessing 324 -9\nprocessing 334 -9\nprocessing 344 -9\nprocessing 354 -9\nprocessing 364 -9\nprocessing 374 -9\nprocessing 384 -9\nprocessing 394 -9\nprocessing 404 -9\nprocessing 414 -9\nprocessing 424 -9\nprocessing 434 -9\nprocessing 444 -9\nprocessing 454 -9\nprocessing 464 -9\nprocessing 474 -9\nprocessing 484 -9\nprocessing 494 -9\nprocessing 504 -9\nprocessing 514 -9\nprocessing 524 -9\nprocessing 534 -9\nprocessing 544 -9\nprocessing 554 -9\nprocessing 564 -9\nprocessing 574 -9\nprocessing 584 -9\nprocessing 594 -9\nprocessing 604 -9\nprocessing 614 -9\nprocessing 624 -9\nprocessing 634 -9\nprocessing 644 -9\nprocessing 654 -9\nprocessing 664 -9\nprocessing 674 -9\nprocessing 684 -9\nprocessing 0 -10\nprocessing 10 -10\nprocessing 20 -10\nprocessing 30 -10\nprocessing 40 -10\nprocessing 50 -10\nprocessing 60 -10\nprocessing 70 -10\nprocessing 80 -10\nprocessing 90 -10\nprocessing 100 -10\nprocessing 110 -10\nprocessing 120 -10\nprocessing 130 -10\nprocessing 140 -10\nprocessing 150 -10\nprocessing 160 -10\nprocessing 170 -10\nprocessing 180 -10\nprocessing 190 -10\nprocessing 200 -10\nprocessing 210 -10\nprocessing 220 -10\nprocessing 230 -10\nprocessing 240 -10\nprocessing 250 -10\nprocessing 260 -10\nprocessing 270 -10\nprocessing 280 -10\nprocessing 290 -10\nprocessing 300 -10\nprocessing 310 -10\nprocessing 320 -10\nprocessing 330 -10\nprocessing 340 -10\nprocessing 350 -10\nprocessing 360 -10\nprocessing 370 -10\nprocessing 380 -10\nprocessing 390 -10\nprocessing 400 -10\nprocessing 410 -10\nprocessing 420 -10\nprocessing 430 -10\nprocessing 440 -10\nprocessing 450 -10\nprocessing 460 -10\nprocessing 470 -10\nprocessing 480 -10\nprocessing 490 -10\nprocessing 500 -10\nprocessing 510 -10\nprocessing 520 -10\nprocessing 530 -10\nprocessing 540 -10\nprocessing 550 -10\nprocessing 560 -10\nprocessing 570 -10\nprocessing 580 -10\nprocessing 590 -10\nprocessing 600 -10\nprocessing 610 -10\nprocessing 620 -10\nprocessing 630 -10\nprocessing 640 -10\nprocessing 650 -10\nprocessing 660 -10\nprocessing 670 -10\nprocessing 680 -10\nprocessing 690 -10\nprocessing 6 -11\nprocessing 16 -11\nprocessing 26 -11\nprocessing 36 -11\nprocessing 46 -11\nprocessing 56 -11\nprocessing 66 -11\nprocessing 76 -11\nprocessing 86 -11\nprocessing 96 -11\nprocessing 106 -11\nprocessing 116 -11\nprocessing 126 -11\nprocessing 136 -11\nprocessing 146 -11\nprocessing 156 -11\nprocessing 166 -11\nprocessing 176 -11\nprocessing 186 -11\nprocessing 196 -11\nprocessing 206 -11\nprocessing 216 -11\nprocessing 226 -11\nprocessing 236 -11\nprocessing 246 -11\nprocessing 256 -11\nprocessing 266 -11\nprocessing 276 -11\nprocessing 286 -11\nprocessing 296 -11\nprocessing 306 -11\nprocessing 316 -11\nprocessing 326 -11\nprocessing 336 -11\nprocessing 346 -11\nprocessing 356 -11\nprocessing 366 -11\nprocessing 376 -11\nprocessing 386 -11\nprocessing 396 -11\nprocessing 406 -11\nprocessing 416 -11\nprocessing 426 -11\nprocessing 436 -11\nprocessing 446 -11\nprocessing 456 -11\nprocessing 466 -11\nprocessing 476 -11\nprocessing 486 -11\nprocessing 496 -11\nprocessing 506 -11\nprocessing 516 -11\nprocessing 526 -11\nprocessing 536 -11\nprocessing 546 -11\nprocessing 556 -11\nprocessing 566 -11\nprocessing 576 -11\nprocessing 586 -11\nprocessing 596 -11\nprocessing 606 -11\nprocessing 616 -11\nprocessing 626 -11\nprocessing 636 -11\nprocessing 646 -11\nprocessing 656 -11\nprocessing 666 -11\nprocessing 676 -11\nprocessing 686 -11\nprocessing 2 -12\nprocessing 12 -12\nprocessing 22 -12\nprocessing 32 -12\nprocessing 42 -12\nprocessing 52 -12\nprocessing 62 -12\nprocessing 72 -12\nprocessing 82 -12\nprocessing 92 -12\nprocessing 102 -12\nprocessing 112 -12\nprocessing 122 -12\nprocessing 132 -12\nprocessing 142 -12\nprocessing 152 -12\nprocessing 162 -12\nprocessing 172 -12\nprocessing 182 -12\nprocessing 192 -12\nprocessing 202 -12\nprocessing 212 -12\nprocessing 222 -12\nprocessing 232 -12\nprocessing 242 -12\nprocessing 252 -12\nprocessing 262 -12\nprocessing 272 -12\nprocessing 282 -12\nprocessing 292 -12\nprocessing 302 -12\nprocessing 312 -12\nprocessing 322 -12\nprocessing 332 -12\nprocessing 342 -12\nprocessing 352 -12\nprocessing 362 -12\nprocessing 372 -12\nprocessing 382 -12\nprocessing 392 -12\nprocessing 402 -12\nprocessing 412 -12\nprocessing 422 -12\nprocessing 432 -12\nprocessing 442 -12\nprocessing 452 -12\nprocessing 462 -12\nprocessing 472 -12\nprocessing 482 -12\nprocessing 492 -12\nprocessing 502 -12\nprocessing 512 -12\nprocessing 522 -12\nprocessing 532 -12\nprocessing 542 -12\nprocessing 552 -12\nprocessing 562 -12\nprocessing 572 -12\nprocessing 582 -12\nprocessing 592 -12\nprocessing 602 -12\nprocessing 612 -12\nprocessing 622 -12\nprocessing 632 -12\nprocessing 642 -12\nprocessing 652 -12\nprocessing 662 -12\nprocessing 672 -12\nprocessing 682 -12\nprocessing 692 -12\nprocessing 8 -13\nprocessing 18 -13\nprocessing 28 -13\nprocessing 38 -13\nprocessing 48 -13\nprocessing 58 -13\nprocessing 68 -13\nprocessing 78 -13\nprocessing 88 -13\nprocessing 98 -13\nprocessing 108 -13\nprocessing 118 -13\nprocessing 128 -13\nprocessing 138 -13\nprocessing 148 -13\nprocessing 158 -13\nprocessing 168 -13\nprocessing 178 -13\nprocessing 188 -13\nprocessing 198 -13\nprocessing 208 -13\nprocessing 218 -13\nprocessing 228 -13\nprocessing 238 -13\nprocessing 248 -13\nprocessing 258 -13\nprocessing 268 -13\nprocessing 278 -13\nprocessing 288 -13\nprocessing 298 -13\nprocessing 308 -13\nprocessing 318 -13\nprocessing 328 -13\nprocessing 338 -13\nprocessing 348 -13\nprocessing 358 -13\nprocessing 368 -13\nprocessing 378 -13\nprocessing 388 -13\nprocessing 398 -13\nprocessing 408 -13\nprocessing 418 -13\nprocessing 428 -13\nprocessing 438 -13\nprocessing 448 -13\nprocessing 458 -13\nprocessing 468 -13\nprocessing 478 -13\nprocessing 488 -13\nprocessing 498 -13\nprocessing 508 -13\nprocessing 518 -13\nprocessing 528 -13\nprocessing 538 -13\nprocessing 548 -13\nprocessing 558 -13\nprocessing 568 -13\nprocessing 578 -13\nprocessing 588 -13\nprocessing 598 -13\nprocessing 608 -13\nprocessing 618 -13\nprocessing 628 -13\nprocessing 638 -13\nprocessing 648 -13\nprocessing 658 -13\nprocessing 668 -13\nprocessing 678 -13\nprocessing 688 -13\nprocessing 4 -14\nprocessing 14 -14\nprocessing 24 -14\nprocessing 34 -14\nprocessing 44 -14\nprocessing 54 -14\nprocessing 64 -14\nprocessing 74 -14\nprocessing 84 -14\nprocessing 94 -14\nprocessing 104 -14\nprocessing 114 -14\nprocessing 124 -14\nprocessing 134 -14\nprocessing 144 -14\nprocessing 154 -14\nprocessing 164 -14\nprocessing 174 -14\nprocessing 184 -14\nprocessing 194 -14\nprocessing 204 -14\nprocessing 214 -14\nprocessing 224 -14\nprocessing 234 -14\nprocessing 244 -14\nprocessing 254 -14\nprocessing 264 -14\nprocessing 274 -14\nprocessing 284 -14\nprocessing 294 -14\nprocessing 304 -14\nprocessing 314 -14\nprocessing 324 -14\nprocessing 334 -14\nprocessing 344 -14\nprocessing 354 -14\nprocessing 364 -14\nprocessing 374 -14\nprocessing 384 -14\nprocessing 394 -14\nprocessing 404 -14\nprocessing 414 -14\nprocessing 424 -14\nprocessing 434 -14\nprocessing 444 -14\nprocessing 454 -14\nprocessing 464 -14\nprocessing 474 -14\nprocessing 484 -14\nprocessing 494 -14\nprocessing 504 -14\nprocessing 514 -14\nprocessing 524 -14\nprocessing 534 -14\nprocessing 544 -14\nprocessing 554 -14\nprocessing 564 -14\nprocessing 574 -14\nprocessing 584 -14\nprocessing 594 -14\nprocessing 604 -14\nprocessing 614 -14\nprocessing 624 -14\nprocessing 634 -14\nprocessing 644 -14\nprocessing 654 -14\nprocessing 664 -14\nprocessing 674 -14\nprocessing 684 -14\nprocessing 0 -15\nprocessing 10 -15\nprocessing 20 -15\nprocessing 30 -15\nprocessing 40 -15\nprocessing 50 -15\nprocessing 60 -15\nprocessing 70 -15\nprocessing 80 -15\nprocessing 90 -15\nprocessing 100 -15\nprocessing 110 -15\nprocessing 120 -15\nprocessing 130 -15\nprocessing 140 -15\nprocessing 150 -15\nprocessing 160 -15\nprocessing 170 -15\nprocessing 180 -15\nprocessing 190 -15\nprocessing 200 -15\nprocessing 210 -15\nprocessing 220 -15\nprocessing 230 -15\nprocessing 240 -15\nprocessing 250 -15\nprocessing 260 -15\nprocessing 270 -15\nprocessing 280 -15\nprocessing 290 -15\nprocessing 300 -15\nprocessing 310 -15\nprocessing 320 -15\nprocessing 330 -15\nprocessing 340 -15\nprocessing 350 -15\nprocessing 360 -15\nprocessing 370 -15\nprocessing 380 -15\nprocessing 390 -15\nprocessing 400 -15\nprocessing 410 -15\nprocessing 420 -15\nprocessing 430 -15\nprocessing 440 -15\nprocessing 450 -15\nprocessing 460 -15\nprocessing 470 -15\nprocessing 480 -15\nprocessing 490 -15\nprocessing 500 -15\nprocessing 510 -15\nprocessing 520 -15\nprocessing 530 -15\nprocessing 540 -15\nprocessing 550 -15\nprocessing 560 -15\nprocessing 570 -15\nprocessing 580 -15\nprocessing 590 -15\nprocessing 600 -15\nprocessing 610 -15\nprocessing 620 -15\nprocessing 630 -15\nprocessing 640 -15\nprocessing 650 -15\nprocessing 660 -15\nprocessing 670 -15\nprocessing 680 -15\nprocessing 690 -15\nprocessing 6 -16\nprocessing 16 -16\nprocessing 26 -16\nprocessing 36 -16\nprocessing 46 -16\nprocessing 56 -16\nprocessing 66 -16\nprocessing 76 -16\nprocessing 86 -16\nprocessing 96 -16\nprocessing 106 -16\nprocessing 116 -16\nprocessing 126 -16\nprocessing 136 -16\nprocessing 146 -16\nprocessing 156 -16\nprocessing 166 -16\nprocessing 176 -16\nprocessing 186 -16\nprocessing 196 -16\nprocessing 206 -16\nprocessing 216 -16\nprocessing 226 -16\nprocessing 236 -16\nprocessing 246 -16\nprocessing 256 -16\nprocessing 266 -16\nprocessing 276 -16\nprocessing 286 -16\nprocessing 296 -16\nprocessing 306 -16\nprocessing 316 -16\nprocessing 326 -16\nprocessing 336 -16\nprocessing 346 -16\nprocessing 356 -16\nprocessing 366 -16\nprocessing 376 -16\nprocessing 386 -16\nprocessing 396 -16\nprocessing 406 -16\nprocessing 416 -16\nprocessing 426 -16\nprocessing 436 -16\nprocessing 446 -16\nprocessing 456 -16\nprocessing 466 -16\nprocessing 476 -16\nprocessing 486 -16\nprocessing 496 -16\nprocessing 506 -16\nprocessing 516 -16\nprocessing 526 -16\nprocessing 536 -16\nprocessing 546 -16\nprocessing 556 -16\nprocessing 566 -16\nprocessing 576 -16\nprocessing 586 -16\nprocessing 596 -16\nprocessing 606 -16\nprocessing 616 -16\nprocessing 626 -16\nprocessing 636 -16\nprocessing 646 -16\nprocessing 656 -16\nprocessing 666 -16\nprocessing 676 -16\nprocessing 686 -16\nprocessing 2 -17\nprocessing 12 -17\nprocessing 22 -17\nprocessing 32 -17\nprocessing 42 -17\nprocessing 52 -17\nprocessing 62 -17\nprocessing 72 -17\nprocessing 82 -17\nprocessing 92 -17\nprocessing 102 -17\nprocessing 112 -17\nprocessing 122 -17\nprocessing 132 -17\nprocessing 142 -17\nprocessing 152 -17\nprocessing 162 -17\nprocessing 172 -17\nprocessing 182 -17\nprocessing 192 -17\nprocessing 202 -17\nprocessing 212 -17\nprocessing 222 -17\nprocessing 232 -17\nprocessing 242 -17\nprocessing 252 -17\nprocessing 262 -17\nprocessing 272 -17\nprocessing 282 -17\nprocessing 292 -17\nprocessing 302 -17\nprocessing 312 -17\nprocessing 322 -17\nprocessing 332 -17\nprocessing 342 -17\nprocessing 352 -17\nprocessing 362 -17\nprocessing 372 -17\nprocessing 382 -17\nprocessing 392 -17\nprocessing 402 -17\nprocessing 412 -17\nprocessing 422 -17\nprocessing 432 -17\nprocessing 442 -17\nprocessing 452 -17\nprocessing 462 -17\nprocessing 472 -17\nprocessing 482 -17\nprocessing 492 -17\nprocessing 502 -17\nprocessing 512 -17\nprocessing 522 -17\nprocessing 532 -17\nprocessing 542 -17\nprocessing 552 -17\nprocessing 562 -17\nprocessing 572 -17\nprocessing 582 -17\nprocessing 592 -17\nprocessing 602 -17\nprocessing 612 -17\nprocessing 622 -17\nprocessing 632 -17\nprocessing 642 -17\nprocessing 652 -17\nprocessing 662 -17\nprocessing 672 -17\nprocessing 682 -17\nprocessing 692 -17\nprocessing 8 -18\nprocessing 18 -18\nprocessing 28 -18\nprocessing 38 -18\nprocessing 48 -18\nprocessing 58 -18\nprocessing 68 -18\nprocessing 78 -18\nprocessing 88 -18\nprocessing 98 -18\nprocessing 108 -18\nprocessing 118 -18\nprocessing 128 -18\nprocessing 138 -18\nprocessing 148 -18\nprocessing 158 -18\nprocessing 168 -18\nprocessing 178 -18\nprocessing 188 -18\nprocessing 198 -18\nprocessing 208 -18\nprocessing 218 -18\nprocessing 228 -18\nprocessing 238 -18\nprocessing 248 -18\nprocessing 258 -18\nprocessing 268 -18\nprocessing 278 -18\nprocessing 288 -18\nprocessing 298 -18\nprocessing 308 -18\nprocessing 318 -18\nprocessing 328 -18\nprocessing 338 -18\nprocessing 348 -18\nprocessing 358 -18\nprocessing 368 -18\nprocessing 378 -18\nprocessing 388 -18\nprocessing 398 -18\nprocessing 408 -18\nprocessing 418 -18\nprocessing 428 -18\nprocessing 438 -18\nprocessing 448 -18\nprocessing 458 -18\nprocessing 468 -18\nprocessing 478 -18\nprocessing 488 -18\nprocessing 498 -18\nprocessing 508 -18\nprocessing 518 -18\nprocessing 528 -18\nprocessing 538 -18\nprocessing 548 -18\nprocessing 558 -18\nprocessing 568 -18\nprocessing 578 -18\nprocessing 588 -18\nprocessing 598 -18\nprocessing 608 -18\nprocessing 618 -18\nprocessing 628 -18\nprocessing 638 -18\nprocessing 648 -18\nprocessing 658 -18\nprocessing 668 -18\nprocessing 678 -18\nprocessing 688 -18\nprocessing 4 -19\nprocessing 14 -19\nprocessing 24 -19\nprocessing 34 -19\nprocessing 44 -19\nprocessing 54 -19\nprocessing 64 -19\nprocessing 74 -19\nprocessing 84 -19\nprocessing 94 -19\nprocessing 104 -19\nprocessing 114 -19\nprocessing 124 -19\nprocessing 134 -19\n",
  "history_begin_time" : 1690257507954,
  "history_end_time" : 1690257523358,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : null,
  "indicator" : "Failed"
},{
  "history_id" : "dhW4EZ51jnID",
  "history_input" : "import numpy as np\nimport pandas as pd\nfrom osgeo import gdal\nimport warnings\n\n# Set the warning filter globally to ignore the FutureWarning\nwarnings.simplefilter(\"ignore\", FutureWarning)\n\ndef lat_lon_to_pixel(lat, lon, geotransform):\n    x = int((lon - geotransform[0]) / geotransform[1])\n    y = int((lat - geotransform[3]) / geotransform[5])\n    return x, y\n\n\ndef calculate_slope_aspect(elevation_data, pixel_size_x, pixel_size_y):\n    # Calculate slope using the Sobel operator\n    slope_x = np.gradient(elevation_data, pixel_size_x, axis=1)\n    slope_y = np.gradient(elevation_data, pixel_size_y, axis=0)\n    slope_rad = np.arctan(np.sqrt(slope_x ** 2 + slope_y ** 2))\n    slope_deg = np.degrees(slope_rad)\n\n    # Calculate aspect (direction of the steepest descent)\n    aspect_rad = np.arctan2(slope_y, -slope_x)\n    aspect_deg = (np.degrees(aspect_rad) + 360) % 360\n\n    return slope_deg, aspect_deg\n\n\ndef calculate_curvature(elevation_data, pixel_size_x, pixel_size_y):\n    # Calculate curvature using the Laplacian operator\n    curvature_x = np.gradient(np.gradient(elevation_data, pixel_size_x, axis=1), pixel_size_x, axis=1)\n    curvature_y = np.gradient(np.gradient(elevation_data, pixel_size_y, axis=0), pixel_size_y, axis=0)\n    curvature = curvature_x + curvature_y\n\n    return curvature\n\n\ndef read_elevation_data_only(file_path):\n    dataset = gdal.Open(file_path)\n    if dataset is None:\n      print(\"Error: Could not open the file.\")\n      return None\n\n    result_dem_csv_path = \"/home/chetana/gridmet_test_run/dem_template.csv\"\n    result_dem_feature_csv_path = \"/home/chetana/gridmet_test_run/dem_all.csv\"\n\n    print(f\"start to first convert geotiff to {result_dem_csv_path}\")\n\n    band = dataset.GetRasterBand(1)\n    elevation_data = band.ReadAsArray()\n\n    # Get geotransform information\n    geotransform = dataset.GetGeoTransform()\n    min_lon, pixel_size_x, _, max_lat, _, pixel_size_y = geotransform\n\n    # Calculate raster size\n    raster_width = dataset.RasterXSize\n    raster_height = dataset.RasterYSize\n\n    # Generate latitude and longitude arrays\n    lats = np.arange(max_lat, max_lat - pixel_size_y * raster_height, -pixel_size_y)\n    lons = np.arange(min_lon, min_lon + pixel_size_x * raster_width, pixel_size_x)\n\n    # Create meshgrid of latitude and longitude\n    lon_grid, lat_grid = np.meshgrid(lons, lats)\n\n    # Flatten the data and the lat/lon grids\n    elevation_data_flat = elevation_data.flatten()\n    lat_grid_flat = lat_grid.flatten()\n    lon_grid_flat = lon_grid.flatten()\n\n    # Create a DataFrame to store the data\n    df = pd.DataFrame({\n      'Latitude': lat_grid_flat,\n      'Longitude': lon_grid_flat,\n      'Elevation': elevation_data_flat,\n    })\n\n    df.to_csv(result_dem_csv_path)\n    print(f\"DEM geotif is saved to a csv file with only elevation {result_dem_csv_path}\")\n    return df\n\n  \ndef read_elevation_data(file_path, neighborhood_size=4):\n    original_df = read_elevation_data_only(file_path)\n    \n    # Create an empty DataFrame with column names\n    columns = ['lat', 'lon', 'elevation', 'slope', 'aspect', 'curvature', 'northness', 'eastness']\n    all_df = pd.DataFrame(columns=columns)\n    \n    print(f\"neighborhood_size // 2 = {neighborhood_size // 2}\")\n    \n    for index, row in original_df.iterrows():\n      # Access individual row elements using row['column_name']\n      # Convert latitude and longitude to pixel indices\n      x, y = lat_lon_to_pixel(row['Latitude'], row['Longitude'], geotransform)\n      \n      if index % 10 == 0:\n        print(f\"processing {x} {y}\")\n\t  \n      if x < neighborhood_size // 2 or y < neighborhood_size // 2 or x > (raster_width - neighborhood_size // 2) or y > (raster_height - neighborhood_size // 2):\n      \tdata_row = {\n            'lat': row['Latitude'],\n            'lon': row['Longitude'],\n            'elevation': row['Elevation'],\n            'slope': -1,\n            'aspect': -1,\n            'curvature': -1,\n            'northness': -1,\n            'eastness': -1\n        }\n      else:\n        # Read a small neighborhood of elevation data around the selected point\n        small_elevation_data = band.ReadAsArray(x - neighborhood_size // 2, y - neighborhood_size // 2, neighborhood_size, neighborhood_size)\n\n        # Calculate slope and aspect\n        slope_data, aspect_data = calculate_slope_aspect(small_elevation_data, pixel_size_x, pixel_size_y)\n\n        # Calculate curvature\n        curvature_data = calculate_curvature(small_elevation_data, pixel_size_x, pixel_size_y)\n        northness_data = np.abs(np.sin(np.radians(aspect_data)))\n        eastness_data = np.abs(np.cos(np.radians(aspect_data)))\n\n\n        data_row = {\n            'lat': row['Latitude'],\n            'lon': row['Longitude'],\n            'elevation': row['Elevation'],\n            'slope': slope_data[neighborhood_size // 2, neighborhood_size // 2],\n            'aspect': aspect_data[neighborhood_size // 2, neighborhood_size // 2],\n            'curvature': curvature_data[neighborhood_size // 2, neighborhood_size // 2],\n            'northness': northness_data[neighborhood_size // 2, neighborhood_size // 2],\n            'eastness': eastness_data[neighborhood_size // 2, neighborhood_size // 2]\n        }\n      \n      \n      # Append a row to the DataFrame\n      all_df = all_df.append(data_row, ignore_index=True)\n    \n    all_df.to_csv(result_dem_feature_csv_path)\n    print(f\"DEM and other columns are saved to file {result_dem_feature_csv_path}\")\n    return all_df\n\n\n\n# Usage example:\nread_elevation_data(\"/home/chetana/gridmet_test_run/output_4km_clipped.tif\")\n#final_dem_all_cols = read_elevation_data(\"/home/chetana/gridmet_test_run/output_4km_clipped.tif\")\n",
  "history_output" : "start to first convert geotiff to /home/chetana/gridmet_test_run/dem_template.csv\nDEM geotif is saved to a csv file with only elevation /home/chetana/gridmet_test_run/dem_template.csv\nneighborhood_size // 2 = 2\nTraceback (most recent call last):\n  File \"/home/chetana/gw-workspace/dhW4EZ51jnID/western_us_dem.py\", line 147, in <module>\n    read_elevation_data(\"/home/chetana/gridmet_test_run/output_4km_clipped.tif\")\n  File \"/home/chetana/gw-workspace/dhW4EZ51jnID/western_us_dem.py\", line 96, in read_elevation_data\n    x, y = lat_lon_to_pixel(row['Latitude'], row['Longitude'], geotransform)\nNameError: name 'geotransform' is not defined\n",
  "history_begin_time" : 1690257369531,
  "history_end_time" : 1690257371940,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : null,
  "indicator" : "Failed"
},{
  "history_id" : "Yp5jaYzlGn45",
  "history_input" : "import numpy as np\nimport pandas as pd\nfrom osgeo import gdal\nimport warnings\n\n# Set the warning filter globally to ignore the FutureWarning\nwarnings.simplefilter(\"ignore\", FutureWarning)\n\ndef lat_lon_to_pixel(lat, lon, geotransform):\n    x = int((lon - geotransform[0]) / geotransform[1])\n    y = int((lat - geotransform[3]) / geotransform[5])\n    return x, y\n\n\ndef calculate_slope_aspect(elevation_data, pixel_size_x, pixel_size_y):\n    # Calculate slope using the Sobel operator\n    slope_x = np.gradient(elevation_data, pixel_size_x, axis=1)\n    slope_y = np.gradient(elevation_data, pixel_size_y, axis=0)\n    slope_rad = np.arctan(np.sqrt(slope_x ** 2 + slope_y ** 2))\n    slope_deg = np.degrees(slope_rad)\n\n    # Calculate aspect (direction of the steepest descent)\n    aspect_rad = np.arctan2(slope_y, -slope_x)\n    aspect_deg = (np.degrees(aspect_rad) + 360) % 360\n\n    return slope_deg, aspect_deg\n\n\ndef calculate_curvature(elevation_data, pixel_size_x, pixel_size_y):\n    # Calculate curvature using the Laplacian operator\n    curvature_x = np.gradient(np.gradient(elevation_data, pixel_size_x, axis=1), pixel_size_x, axis=1)\n    curvature_y = np.gradient(np.gradient(elevation_data, pixel_size_y, axis=0), pixel_size_y, axis=0)\n    curvature = curvature_x + curvature_y\n\n    return curvature\n\n\ndef read_elevation_data_only(file_path):\n  \tdataset = gdal.Open(file_path)\n  \tif dataset is None:\n  \t  print(\"Error: Could not open the file.\")\n  \t  return None\n\t\n  \tresult_dem_csv_path = \"/home/chetana/gridmet_test_run/dem_template.csv\"\n  \tresult_dem_feature_csv_path = \"/home/chetana/gridmet_test_run/dem_all.csv\"\n    \n  \tprint(f\"start to first convert geotiff to {result_dem_csv_path}\")\n    \n  \tband = dataset.GetRasterBand(1)\n  \televation_data = band.ReadAsArray()\n\n  \t# Get geotransform information\n  \tgeotransform = dataset.GetGeoTransform()\n  \tmin_lon, pixel_size_x, _, max_lat, _, pixel_size_y = geotransform\n\n  \t# Calculate raster size\n  \traster_width = dataset.RasterXSize\n  \traster_height = dataset.RasterYSize\n\n  \t# Generate latitude and longitude arrays\n  \tlats = np.arange(max_lat, max_lat - pixel_size_y * raster_height, -pixel_size_y)\n  \tlons = np.arange(min_lon, min_lon + pixel_size_x * raster_width, pixel_size_x)\n\n  \t# Create meshgrid of latitude and longitude\n  \tlon_grid, lat_grid = np.meshgrid(lons, lats)\n\n  \t# Flatten the data and the lat/lon grids\n  \televation_data_flat = elevation_data.flatten()\n  \tlat_grid_flat = lat_grid.flatten()\n  \tlon_grid_flat = lon_grid.flatten()\n\n  \t# Create a DataFrame to store the data\n  \tdf = pd.DataFrame({\n  \t  'Latitude': lat_grid_flat,\n  \t  'Longitude': lon_grid_flat,\n  \t  'Elevation': elevation_data_flat,\n  \t})\n    \n  \tdf.to_csv(result_dem_csv_path)\n  \tprint(f\"DEM geotif is saved to a csv file with only elevation {result_dem_csv_path}\")\n    return df\n\n  \ndef read_elevation_data(file_path, neighborhood_size=4):\n    original_df = read_elevation_data_only(file_path)\n    \n    # Create an empty DataFrame with column names\n    columns = ['lat', 'lon', 'elevation', 'slope', 'aspect', 'curvature', 'northness', 'eastness']\n    all_df = pd.DataFrame(columns=columns)\n    \n    print(f\"neighborhood_size // 2 = {neighborhood_size // 2}\")\n    \n    for index, row in original_df.iterrows():\n      # Access individual row elements using row['column_name']\n      # Convert latitude and longitude to pixel indices\n      x, y = lat_lon_to_pixel(row['Latitude'], row['Longitude'], geotransform)\n      \n      if index % 10 == 0:\n        print(f\"processing {x} {y}\")\n\t  \n      if x < neighborhood_size // 2 or y < neighborhood_size // 2 or x > (raster_width - neighborhood_size // 2) or y > (raster_height - neighborhood_size // 2):\n      \tdata_row = {\n            'lat': row['Latitude'],\n            'lon': row['Longitude'],\n            'elevation': row['Elevation'],\n            'slope': -1,\n            'aspect': -1,\n            'curvature': -1,\n            'northness': -1,\n            'eastness': -1\n        }\n      else:\n        # Read a small neighborhood of elevation data around the selected point\n        small_elevation_data = band.ReadAsArray(x - neighborhood_size // 2, y - neighborhood_size // 2, neighborhood_size, neighborhood_size)\n\n        # Calculate slope and aspect\n        slope_data, aspect_data = calculate_slope_aspect(small_elevation_data, pixel_size_x, pixel_size_y)\n\n        # Calculate curvature\n        curvature_data = calculate_curvature(small_elevation_data, pixel_size_x, pixel_size_y)\n        northness_data = np.abs(np.sin(np.radians(aspect_data)))\n        eastness_data = np.abs(np.cos(np.radians(aspect_data)))\n\n\n        data_row = {\n            'lat': row['Latitude'],\n            'lon': row['Longitude'],\n            'elevation': row['Elevation'],\n            'slope': slope_data[neighborhood_size // 2, neighborhood_size // 2],\n            'aspect': aspect_data[neighborhood_size // 2, neighborhood_size // 2],\n            'curvature': curvature_data[neighborhood_size // 2, neighborhood_size // 2],\n            'northness': northness_data[neighborhood_size // 2, neighborhood_size // 2],\n            'eastness': eastness_data[neighborhood_size // 2, neighborhood_size // 2]\n        }\n      \n      \n      # Append a row to the DataFrame\n      all_df = all_df.append(data_row, ignore_index=True)\n    \n    all_df.to_csv(result_dem_feature_csv_path)\n    print(f\"DEM and other columns are saved to file {result_dem_feature_csv_path}\")\n    return all_df\n\n\n\n# Usage example:\nread_elevation_data(\"/home/chetana/gridmet_test_run/output_4km_clipped.tif\")\n#final_dem_all_cols = read_elevation_data(\"/home/chetana/gridmet_test_run/output_4km_clipped.tif\")\n",
  "history_output" : "  File \"/home/chetana/gw-workspace/Yp5jaYzlGn45/western_us_dem.py\", line 81\n    return df\n             ^\nIndentationError: unindent does not match any outer indentation level\n",
  "history_begin_time" : 1690257287128,
  "history_end_time" : 1690257287184,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : null,
  "indicator" : "Failed"
},{
  "history_id" : "Jz30k6iW5mjG",
  "history_input" : "import numpy as np\nimport pandas as pd\nfrom osgeo import gdal\nimport warnings\n\n# Set the warning filter globally to ignore the FutureWarning\nwarnings.simplefilter(\"ignore\", FutureWarning)\n\ndef lat_lon_to_pixel(lat, lon, geotransform):\n    x = int((lon - geotransform[0]) / geotransform[1])\n    y = int((lat - geotransform[3]) / geotransform[5])\n    return x, y\n\n\ndef calculate_slope_aspect(elevation_data, pixel_size_x, pixel_size_y):\n    # Calculate slope using the Sobel operator\n    slope_x = np.gradient(elevation_data, pixel_size_x, axis=1)\n    slope_y = np.gradient(elevation_data, pixel_size_y, axis=0)\n    slope_rad = np.arctan(np.sqrt(slope_x ** 2 + slope_y ** 2))\n    slope_deg = np.degrees(slope_rad)\n\n    # Calculate aspect (direction of the steepest descent)\n    aspect_rad = np.arctan2(slope_y, -slope_x)\n    aspect_deg = (np.degrees(aspect_rad) + 360) % 360\n\n    return slope_deg, aspect_deg\n\n\ndef calculate_curvature(elevation_data, pixel_size_x, pixel_size_y):\n    # Calculate curvature using the Laplacian operator\n    curvature_x = np.gradient(np.gradient(elevation_data, pixel_size_x, axis=1), pixel_size_x, axis=1)\n    curvature_y = np.gradient(np.gradient(elevation_data, pixel_size_y, axis=0), pixel_size_y, axis=0)\n    curvature = curvature_x + curvature_y\n\n    return curvature\n\n\ndef read_elevation_data_only(file_path):\n  \tdataset = gdal.Open(file_path)\n  \tif dataset is None:\n  \t  print(\"Error: Could not open the file.\")\n  \t  return None\n\t\n  \tresult_dem_csv_path = \"/home/chetana/gridmet_test_run/dem_template.csv\"\n  \tresult_dem_feature_csv_path = \"/home/chetana/gridmet_test_run/dem_all.csv\"\n    \n  \tprint(f\"start to first convert geotiff to {result_dem_csv_path}\")\n    \n  \tband = dataset.GetRasterBand(1)\n  \televation_data = band.ReadAsArray()\n\n  \t# Get geotransform information\n  \tgeotransform = dataset.GetGeoTransform()\n  \tmin_lon, pixel_size_x, _, max_lat, _, pixel_size_y = geotransform\n\n  \t# Calculate raster size\n  \traster_width = dataset.RasterXSize\n  \traster_height = dataset.RasterYSize\n\n  \t# Generate latitude and longitude arrays\n  \tlats = np.arange(max_lat, max_lat - pixel_size_y * raster_height, -pixel_size_y)\n  \tlons = np.arange(min_lon, min_lon + pixel_size_x * raster_width, pixel_size_x)\n\n  \t# Create meshgrid of latitude and longitude\n  \tlon_grid, lat_grid = np.meshgrid(lons, lats)\n\n  \t# Flatten the data and the lat/lon grids\n  \televation_data_flat = elevation_data.flatten()\n  \tlat_grid_flat = lat_grid.flatten()\n  \tlon_grid_flat = lon_grid.flatten()\n\n  \t# Create a DataFrame to store the data\n  \tdf = pd.DataFrame({\n  \t  'Latitude': lat_grid_flat,\n  \t  'Longitude': lon_grid_flat,\n  \t  'Elevation': elevation_data_flat,\n  \t})\n    \n  \tdf.to_csv(result_dem_csv_path)\n  \tprint(f\"DEM geotif is saved to a csv file with only elevation {result_dem_csv_path}\")\n\n  \ndef read_elevation_data(file_path, neighborhood_size=6):\n    \n    \n    # Create an empty DataFrame with column names\n    columns = ['lat', 'lon', 'elevation', 'slope', 'aspect', 'curvature', 'northness', 'eastness']\n    all_df = pd.DataFrame(columns=columns)\n    \n    print(f\"neighborhood_size // 2 = {neighborhood_size // 2}\")\n    \n    for index, row in df.iterrows():\n      # Access individual row elements using row['column_name']\n      # Convert latitude and longitude to pixel indices\n      x, y = lat_lon_to_pixel(row['Latitude'], row['Longitude'], geotransform)\n      \n      if index %1000 == 0:\n        print(f\"processing {x} {y}\")\n\t  \n      if x < neighborhood_size // 2 or y < neighborhood_size // 2 or x > (raster_width - neighborhood_size // 2) or y > (raster_height - neighborhood_size // 2):\n      \tdata_row = {\n            'lat': row['Latitude'],\n            'lon': row['Longitude'],\n            'elevation': row['Elevation'],\n            'slope': -1,\n            'aspect': -1,\n            'curvature': -1,\n            'northness': -1,\n            'eastness': -1\n        }\n      else:\n        # Read a small neighborhood of elevation data around the selected point\n        small_elevation_data = band.ReadAsArray(x - neighborhood_size // 2, y - neighborhood_size // 2, neighborhood_size, neighborhood_size)\n\n        # Calculate slope and aspect\n        slope_data, aspect_data = calculate_slope_aspect(small_elevation_data, pixel_size_x, pixel_size_y)\n\n        # Calculate curvature\n        curvature_data = calculate_curvature(small_elevation_data, pixel_size_x, pixel_size_y)\n        northness_data = np.abs(np.sin(np.radians(aspect_data)))\n        eastness_data = np.abs(np.cos(np.radians(aspect_data)))\n\n\n        data_row = {\n            'lat': row['Latitude'],\n            'lon': row['Longitude'],\n            'elevation': row['Elevation'],\n            'slope': slope_data[neighborhood_size // 2, neighborhood_size // 2],\n            'aspect': aspect_data[neighborhood_size // 2, neighborhood_size // 2],\n            'curvature': curvature_data[neighborhood_size // 2, neighborhood_size // 2],\n            'northness': northness_data[neighborhood_size // 2, neighborhood_size // 2],\n            'eastness': eastness_data[neighborhood_size // 2, neighborhood_size // 2]\n        }\n      \n      \n      # Append a row to the DataFrame\n      all_df = all_df.append(data_row, ignore_index=True)\n    \n    all_df.to_csv(result_dem_feature_csv_path)\n    print(f\"DEM and other columns are saved to file {result_dem_feature_csv_path}\")\n    return all_df\n\n\n\n# Usage example:\nread_elevation_data_only(\"/home/chetana/gridmet_test_run/output_4km_clipped.tif\")\n#final_dem_all_cols = read_elevation_data(\"/home/chetana/gridmet_test_run/output_4km_clipped.tif\")\n",
  "history_output" : "start to first convert geotiff to /home/chetana/gridmet_test_run/dem_template.csv\nDEM geotif is saved to a csv file with only elevation /home/chetana/gridmet_test_run/dem_template.csv\n",
  "history_begin_time" : 1690257117960,
  "history_end_time" : 1690257120342,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "It95OYYWNjHj",
  "history_input" : "import numpy as np\nimport pandas as pd\nfrom osgeo import gdal\nimport warnings\n\n# Set the warning filter globally to ignore the FutureWarning\nwarnings.simplefilter(\"ignore\", FutureWarning)\n\ndef lat_lon_to_pixel(lat, lon, geotransform):\n    x = int((lon - geotransform[0]) / geotransform[1])\n    y = int((lat - geotransform[3]) / geotransform[5])\n    return x, y\n\n\ndef calculate_slope_aspect(elevation_data, pixel_size_x, pixel_size_y):\n    # Calculate slope using the Sobel operator\n    slope_x = np.gradient(elevation_data, pixel_size_x, axis=1)\n    slope_y = np.gradient(elevation_data, pixel_size_y, axis=0)\n    slope_rad = np.arctan(np.sqrt(slope_x ** 2 + slope_y ** 2))\n    slope_deg = np.degrees(slope_rad)\n\n    # Calculate aspect (direction of the steepest descent)\n    aspect_rad = np.arctan2(slope_y, -slope_x)\n    aspect_deg = (np.degrees(aspect_rad) + 360) % 360\n\n    return slope_deg, aspect_deg\n\n\ndef calculate_curvature(elevation_data, pixel_size_x, pixel_size_y):\n    # Calculate curvature using the Laplacian operator\n    curvature_x = np.gradient(np.gradient(elevation_data, pixel_size_x, axis=1), pixel_size_x, axis=1)\n    curvature_y = np.gradient(np.gradient(elevation_data, pixel_size_y, axis=0), pixel_size_y, axis=0)\n    curvature = curvature_x + curvature_y\n\n    return curvature\n\n\ndef read_elevation_data_only(file_path):\n  \tdataset = gdal.Open(file_path)\n  \tif dataset is None:\n  \t  print(\"Error: Could not open the file.\")\n  \t  return None\n\t\n  \tresult_dem_csv_path = \"/home/chetana/gridmet_test_run/dem_template.csv\"\n  \tresult_dem_feature_csv_path = \"/home/chetana/gridmet_test_run/dem_all.csv\"\n    \n  \tprint(f\"start to first convert geotiff to {result_dem_csv_path}\")\n    \n    band = dataset.GetRasterBand(1)\n    elevation_data = band.ReadAsArray()\n\n    # Get geotransform information\n    geotransform = dataset.GetGeoTransform()\n    min_lon, pixel_size_x, _, max_lat, _, pixel_size_y = geotransform\n\n    # Calculate raster size\n    raster_width = dataset.RasterXSize\n    raster_height = dataset.RasterYSize\n\n    # Generate latitude and longitude arrays\n    lats = np.arange(max_lat, max_lat - pixel_size_y * raster_height, -pixel_size_y)\n    lons = np.arange(min_lon, min_lon + pixel_size_x * raster_width, pixel_size_x)\n\n    # Create meshgrid of latitude and longitude\n    lon_grid, lat_grid = np.meshgrid(lons, lats)\n\n    # Flatten the data and the lat/lon grids\n    elevation_data_flat = elevation_data.flatten()\n    lat_grid_flat = lat_grid.flatten()\n    lon_grid_flat = lon_grid.flatten()\n\n    # Create a DataFrame to store the data\n    df = pd.DataFrame({\n      'Latitude': lat_grid_flat,\n      'Longitude': lon_grid_flat,\n      'Elevation': elevation_data_flat,\n    })\n    \n    df.to_csv(result_dem_csv_path)\n    print(f\"DEM geotif is saved to a csv file with only elevation {result_dem_csv_path}\")\n\n  \ndef read_elevation_data(file_path, neighborhood_size=6):\n    \n    \n    # Create an empty DataFrame with column names\n    columns = ['lat', 'lon', 'elevation', 'slope', 'aspect', 'curvature', 'northness', 'eastness']\n    all_df = pd.DataFrame(columns=columns)\n    \n    print(f\"neighborhood_size // 2 = {neighborhood_size // 2}\")\n    \n    for index, row in df.iterrows():\n      # Access individual row elements using row['column_name']\n      # Convert latitude and longitude to pixel indices\n      x, y = lat_lon_to_pixel(row['Latitude'], row['Longitude'], geotransform)\n      \n      if index %1000 == 0:\n        print(f\"processing {x} {y}\")\n\t  \n      if x < neighborhood_size // 2 or y < neighborhood_size // 2 or x > (raster_width - neighborhood_size // 2) or y > (raster_height - neighborhood_size // 2):\n      \tdata_row = {\n            'lat': row['Latitude'],\n            'lon': row['Longitude'],\n            'elevation': row['Elevation'],\n            'slope': -1,\n            'aspect': -1,\n            'curvature': -1,\n            'northness': -1,\n            'eastness': -1\n        }\n      else:\n        # Read a small neighborhood of elevation data around the selected point\n        small_elevation_data = band.ReadAsArray(x - neighborhood_size // 2, y - neighborhood_size // 2, neighborhood_size, neighborhood_size)\n\n        # Calculate slope and aspect\n        slope_data, aspect_data = calculate_slope_aspect(small_elevation_data, pixel_size_x, pixel_size_y)\n\n        # Calculate curvature\n        curvature_data = calculate_curvature(small_elevation_data, pixel_size_x, pixel_size_y)\n        northness_data = np.abs(np.sin(np.radians(aspect_data)))\n        eastness_data = np.abs(np.cos(np.radians(aspect_data)))\n\n\n        data_row = {\n            'lat': row['Latitude'],\n            'lon': row['Longitude'],\n            'elevation': row['Elevation'],\n            'slope': slope_data[neighborhood_size // 2, neighborhood_size // 2],\n            'aspect': aspect_data[neighborhood_size // 2, neighborhood_size // 2],\n            'curvature': curvature_data[neighborhood_size // 2, neighborhood_size // 2],\n            'northness': northness_data[neighborhood_size // 2, neighborhood_size // 2],\n            'eastness': eastness_data[neighborhood_size // 2, neighborhood_size // 2]\n        }\n      \n      \n      # Append a row to the DataFrame\n      all_df = all_df.append(data_row, ignore_index=True)\n    \n    all_df.to_csv(result_dem_feature_csv_path)\n    print(f\"DEM and other columns are saved to file {result_dem_feature_csv_path}\")\n    return all_df\n\n\n\n# Usage example:\nread_elevation_data_only(\"/home/chetana/gridmet_test_run/output_4km_clipped.tif\")\n#final_dem_all_cols = read_elevation_data(\"/home/chetana/gridmet_test_run/output_4km_clipped.tif\")\n",
  "history_output" : "  File \"/home/chetana/gw-workspace/It95OYYWNjHj/western_us_dem.py\", line 49\n    band = dataset.GetRasterBand(1)\n                                   ^\nIndentationError: unindent does not match any outer indentation level\n",
  "history_begin_time" : 1690257068528,
  "history_end_time" : 1690257068584,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : null,
  "indicator" : "Failed"
},{
  "history_id" : "gl068KTKHn93",
  "history_input" : "import numpy as np\nimport pandas as pd\nfrom osgeo import gdal\nimport warnings\n\n# Set the warning filter globally to ignore the FutureWarning\nwarnings.simplefilter(\"ignore\", FutureWarning)\n\ndef lat_lon_to_pixel(lat, lon, geotransform):\n    x = int((lon - geotransform[0]) / geotransform[1])\n    y = int((lat - geotransform[3]) / geotransform[5])\n    return x, y\n\n\ndef calculate_slope_aspect(elevation_data, pixel_size_x, pixel_size_y):\n    # Calculate slope using the Sobel operator\n    slope_x = np.gradient(elevation_data, pixel_size_x, axis=1)\n    slope_y = np.gradient(elevation_data, pixel_size_y, axis=0)\n    slope_rad = np.arctan(np.sqrt(slope_x ** 2 + slope_y ** 2))\n    slope_deg = np.degrees(slope_rad)\n\n    # Calculate aspect (direction of the steepest descent)\n    aspect_rad = np.arctan2(slope_y, -slope_x)\n    aspect_deg = (np.degrees(aspect_rad) + 360) % 360\n\n    return slope_deg, aspect_deg\n\n\ndef calculate_curvature(elevation_data, pixel_size_x, pixel_size_y):\n    # Calculate curvature using the Laplacian operator\n    curvature_x = np.gradient(np.gradient(elevation_data, pixel_size_x, axis=1), pixel_size_x, axis=1)\n    curvature_y = np.gradient(np.gradient(elevation_data, pixel_size_y, axis=0), pixel_size_y, axis=0)\n    curvature = curvature_x + curvature_y\n\n    return curvature\n\n\ndef read_elevation_data_only(file_path):\n  \tdataset = gdal.Open(file_path)\n  \tif dataset is None:\n  \t  print(\"Error: Could not open the file.\")\n  \t  return None\n\t\n  \tresult_dem_csv_path = \"/home/chetana/gridmet_test_run/dem_template.csv\"\n  \tresult_dem_feature_csv_path = \"/home/chetana/gridmet_test_run/dem_all.csv\"\n    \n    print(f\"start to first convert geotiff to {result_dem_csv_path}\")\n    \n    band = dataset.GetRasterBand(1)\n    elevation_data = band.ReadAsArray()\n\n    # Get geotransform information\n    geotransform = dataset.GetGeoTransform()\n    min_lon, pixel_size_x, _, max_lat, _, pixel_size_y = geotransform\n\n    # Calculate raster size\n    raster_width = dataset.RasterXSize\n    raster_height = dataset.RasterYSize\n\n    # Generate latitude and longitude arrays\n    lats = np.arange(max_lat, max_lat - pixel_size_y * raster_height, -pixel_size_y)\n    lons = np.arange(min_lon, min_lon + pixel_size_x * raster_width, pixel_size_x)\n\n    # Create meshgrid of latitude and longitude\n    lon_grid, lat_grid = np.meshgrid(lons, lats)\n\n    # Flatten the data and the lat/lon grids\n    elevation_data_flat = elevation_data.flatten()\n    lat_grid_flat = lat_grid.flatten()\n    lon_grid_flat = lon_grid.flatten()\n\n    # Create a DataFrame to store the data\n    df = pd.DataFrame({\n      'Latitude': lat_grid_flat,\n      'Longitude': lon_grid_flat,\n      'Elevation': elevation_data_flat,\n    })\n    \n    df.to_csv(result_dem_csv_path)\n    print(f\"DEM geotif is saved to a csv file with only elevation {result_dem_csv_path}\")\n\n  \ndef read_elevation_data(file_path, neighborhood_size=6):\n    \n    \n    # Create an empty DataFrame with column names\n    columns = ['lat', 'lon', 'elevation', 'slope', 'aspect', 'curvature', 'northness', 'eastness']\n    all_df = pd.DataFrame(columns=columns)\n    \n    print(f\"neighborhood_size // 2 = {neighborhood_size // 2}\")\n    \n    for index, row in df.iterrows():\n      # Access individual row elements using row['column_name']\n      # Convert latitude and longitude to pixel indices\n      x, y = lat_lon_to_pixel(row['Latitude'], row['Longitude'], geotransform)\n      \n      if index %1000 == 0:\n        print(f\"processing {x} {y}\")\n\t  \n      if x < neighborhood_size // 2 or y < neighborhood_size // 2 or x > (raster_width - neighborhood_size // 2) or y > (raster_height - neighborhood_size // 2):\n      \tdata_row = {\n            'lat': row['Latitude'],\n            'lon': row['Longitude'],\n            'elevation': row['Elevation'],\n            'slope': -1,\n            'aspect': -1,\n            'curvature': -1,\n            'northness': -1,\n            'eastness': -1\n        }\n      else:\n        # Read a small neighborhood of elevation data around the selected point\n        small_elevation_data = band.ReadAsArray(x - neighborhood_size // 2, y - neighborhood_size // 2, neighborhood_size, neighborhood_size)\n\n        # Calculate slope and aspect\n        slope_data, aspect_data = calculate_slope_aspect(small_elevation_data, pixel_size_x, pixel_size_y)\n\n        # Calculate curvature\n        curvature_data = calculate_curvature(small_elevation_data, pixel_size_x, pixel_size_y)\n        northness_data = np.abs(np.sin(np.radians(aspect_data)))\n        eastness_data = np.abs(np.cos(np.radians(aspect_data)))\n\n\n        data_row = {\n            'lat': row['Latitude'],\n            'lon': row['Longitude'],\n            'elevation': row['Elevation'],\n            'slope': slope_data[neighborhood_size // 2, neighborhood_size // 2],\n            'aspect': aspect_data[neighborhood_size // 2, neighborhood_size // 2],\n            'curvature': curvature_data[neighborhood_size // 2, neighborhood_size // 2],\n            'northness': northness_data[neighborhood_size // 2, neighborhood_size // 2],\n            'eastness': eastness_data[neighborhood_size // 2, neighborhood_size // 2]\n        }\n      \n      \n      # Append a row to the DataFrame\n      all_df = all_df.append(data_row, ignore_index=True)\n    \n    all_df.to_csv(result_dem_feature_csv_path)\n    print(f\"DEM and other columns are saved to file {result_dem_feature_csv_path}\")\n    return all_df\n\n\n\n# Usage example:\nread_elevation_data_only(\"/home/chetana/gridmet_test_run/output_4km_clipped.tif\")\n#final_dem_all_cols = read_elevation_data(\"/home/chetana/gridmet_test_run/output_4km_clipped.tif\")\n",
  "history_output" : "  File \"/home/chetana/gw-workspace/gl068KTKHn93/western_us_dem.py\", line 47\n    print(f\"start to first convert geotiff to {result_dem_csv_path}\")\n                                                                     ^\nIndentationError: unindent does not match any outer indentation level\n",
  "history_begin_time" : 1690257061142,
  "history_end_time" : 1690257061198,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : null,
  "indicator" : "Failed"
},{
  "history_id" : "Ujz8UV0xpU0V",
  "history_input" : "import numpy as np\nimport pandas as pd\nfrom osgeo import gdal\nimport warnings\n\n# Set the warning filter globally to ignore the FutureWarning\nwarnings.simplefilter(\"ignore\", FutureWarning)\n\ndef lat_lon_to_pixel(lat, lon, geotransform):\n    x = int((lon - geotransform[0]) / geotransform[1])\n    y = int((lat - geotransform[3]) / geotransform[5])\n    return x, y\n\n\ndef calculate_slope_aspect(elevation_data, pixel_size_x, pixel_size_y):\n    # Calculate slope using the Sobel operator\n    slope_x = np.gradient(elevation_data, pixel_size_x, axis=1)\n    slope_y = np.gradient(elevation_data, pixel_size_y, axis=0)\n    slope_rad = np.arctan(np.sqrt(slope_x ** 2 + slope_y ** 2))\n    slope_deg = np.degrees(slope_rad)\n\n    # Calculate aspect (direction of the steepest descent)\n    aspect_rad = np.arctan2(slope_y, -slope_x)\n    aspect_deg = (np.degrees(aspect_rad) + 360) % 360\n\n    return slope_deg, aspect_deg\n\n\ndef calculate_curvature(elevation_data, pixel_size_x, pixel_size_y):\n    # Calculate curvature using the Laplacian operator\n    curvature_x = np.gradient(np.gradient(elevation_data, pixel_size_x, axis=1), pixel_size_x, axis=1)\n    curvature_y = np.gradient(np.gradient(elevation_data, pixel_size_y, axis=0), pixel_size_y, axis=0)\n    curvature = curvature_x + curvature_y\n\n    return curvature\n\n\ndef read_elevation_data_only(file_path):\n  \tdataset = gdal.Open(file_path)\n  \tif dataset is None:\n  \t  print(\"Error: Could not open the file.\")\n  \t  return None\n\t\n    result_dem_csv_path = \"/home/chetana/gridmet_test_run/dem_template.csv\"\n    result_dem_feature_csv_path = \"/home/chetana/gridmet_test_run/dem_all.csv\"\n    \n    print(f\"start to first convert geotiff to {result_dem_csv_path}\")\n    \n    band = dataset.GetRasterBand(1)\n    elevation_data = band.ReadAsArray()\n\n    # Get geotransform information\n    geotransform = dataset.GetGeoTransform()\n    min_lon, pixel_size_x, _, max_lat, _, pixel_size_y = geotransform\n\n    # Calculate raster size\n    raster_width = dataset.RasterXSize\n    raster_height = dataset.RasterYSize\n\n    # Generate latitude and longitude arrays\n    lats = np.arange(max_lat, max_lat - pixel_size_y * raster_height, -pixel_size_y)\n    lons = np.arange(min_lon, min_lon + pixel_size_x * raster_width, pixel_size_x)\n\n    # Create meshgrid of latitude and longitude\n    lon_grid, lat_grid = np.meshgrid(lons, lats)\n\n    # Flatten the data and the lat/lon grids\n    elevation_data_flat = elevation_data.flatten()\n    lat_grid_flat = lat_grid.flatten()\n    lon_grid_flat = lon_grid.flatten()\n\n    # Create a DataFrame to store the data\n    df = pd.DataFrame({\n      'Latitude': lat_grid_flat,\n      'Longitude': lon_grid_flat,\n      'Elevation': elevation_data_flat,\n    })\n    \n    df.to_csv(result_dem_csv_path)\n    print(f\"DEM geotif is saved to a csv file with only elevation {result_dem_csv_path}\")\n\n  \ndef read_elevation_data(file_path, neighborhood_size=6):\n    \n    \n    # Create an empty DataFrame with column names\n    columns = ['lat', 'lon', 'elevation', 'slope', 'aspect', 'curvature', 'northness', 'eastness']\n    all_df = pd.DataFrame(columns=columns)\n    \n    print(f\"neighborhood_size // 2 = {neighborhood_size // 2}\")\n    \n    for index, row in df.iterrows():\n      # Access individual row elements using row['column_name']\n      # Convert latitude and longitude to pixel indices\n      x, y = lat_lon_to_pixel(row['Latitude'], row['Longitude'], geotransform)\n      \n      if index %1000 == 0:\n        print(f\"processing {x} {y}\")\n\t  \n      if x < neighborhood_size // 2 or y < neighborhood_size // 2 or x > (raster_width - neighborhood_size // 2) or y > (raster_height - neighborhood_size // 2):\n      \tdata_row = {\n            'lat': row['Latitude'],\n            'lon': row['Longitude'],\n            'elevation': row['Elevation'],\n            'slope': -1,\n            'aspect': -1,\n            'curvature': -1,\n            'northness': -1,\n            'eastness': -1\n        }\n      else:\n        # Read a small neighborhood of elevation data around the selected point\n        small_elevation_data = band.ReadAsArray(x - neighborhood_size // 2, y - neighborhood_size // 2, neighborhood_size, neighborhood_size)\n\n        # Calculate slope and aspect\n        slope_data, aspect_data = calculate_slope_aspect(small_elevation_data, pixel_size_x, pixel_size_y)\n\n        # Calculate curvature\n        curvature_data = calculate_curvature(small_elevation_data, pixel_size_x, pixel_size_y)\n        northness_data = np.abs(np.sin(np.radians(aspect_data)))\n        eastness_data = np.abs(np.cos(np.radians(aspect_data)))\n\n\n        data_row = {\n            'lat': row['Latitude'],\n            'lon': row['Longitude'],\n            'elevation': row['Elevation'],\n            'slope': slope_data[neighborhood_size // 2, neighborhood_size // 2],\n            'aspect': aspect_data[neighborhood_size // 2, neighborhood_size // 2],\n            'curvature': curvature_data[neighborhood_size // 2, neighborhood_size // 2],\n            'northness': northness_data[neighborhood_size // 2, neighborhood_size // 2],\n            'eastness': eastness_data[neighborhood_size // 2, neighborhood_size // 2]\n        }\n      \n      \n      # Append a row to the DataFrame\n      all_df = all_df.append(data_row, ignore_index=True)\n    \n    all_df.to_csv(result_dem_feature_csv_path)\n    print(f\"DEM and other columns are saved to file {result_dem_feature_csv_path}\")\n    return all_df\n\n\n\n# Usage example:\nread_elevation_data_only(\"/home/chetana/gridmet_test_run/output_4km_clipped.tif\")\n#final_dem_all_cols = read_elevation_data(\"/home/chetana/gridmet_test_run/output_4km_clipped.tif\")\n",
  "history_output" : "  File \"/home/chetana/gw-workspace/Ujz8UV0xpU0V/western_us_dem.py\", line 44\n    result_dem_csv_path = \"/home/chetana/gridmet_test_run/dem_template.csv\"\n                                                                           ^\nIndentationError: unindent does not match any outer indentation level\n",
  "history_begin_time" : 1690257051135,
  "history_end_time" : 1690257051194,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : null,
  "indicator" : "Failed"
},{
  "history_id" : "wyAej3SXUywU",
  "history_input" : "import numpy as np\nimport pandas as pd\nfrom osgeo import gdal\nimport warnings\n\n# Set the warning filter globally to ignore the FutureWarning\nwarnings.simplefilter(\"ignore\", FutureWarning)\n\ndef lat_lon_to_pixel(lat, lon, geotransform):\n    x = int((lon - geotransform[0]) / geotransform[1])\n    y = int((lat - geotransform[3]) / geotransform[5])\n    return x, y\n\n\ndef calculate_slope_aspect(elevation_data, pixel_size_x, pixel_size_y):\n    # Calculate slope using the Sobel operator\n    slope_x = np.gradient(elevation_data, pixel_size_x, axis=1)\n    slope_y = np.gradient(elevation_data, pixel_size_y, axis=0)\n    slope_rad = np.arctan(np.sqrt(slope_x ** 2 + slope_y ** 2))\n    slope_deg = np.degrees(slope_rad)\n\n    # Calculate aspect (direction of the steepest descent)\n    aspect_rad = np.arctan2(slope_y, -slope_x)\n    aspect_deg = (np.degrees(aspect_rad) + 360) % 360\n\n    return slope_deg, aspect_deg\n\n\ndef calculate_curvature(elevation_data, pixel_size_x, pixel_size_y):\n    # Calculate curvature using the Laplacian operator\n    curvature_x = np.gradient(np.gradient(elevation_data, pixel_size_x, axis=1), pixel_size_x, axis=1)\n    curvature_y = np.gradient(np.gradient(elevation_data, pixel_size_y, axis=0), pixel_size_y, axis=0)\n    curvature = curvature_x + curvature_y\n\n    return curvature\n\n\ndef read_elevation_data_only(file_path):\n  \tdataset = gdal.Open(file_path)\n  \tif dataset is None:\n      print(\"Error: Could not open the file.\")\n      return None\n\t\n    result_dem_csv_path = \"/home/chetana/gridmet_test_run/dem_template.csv\"\n    result_dem_feature_csv_path = \"/home/chetana/gridmet_test_run/dem_all.csv\"\n    \n    print(f\"start to first convert geotiff to {result_dem_csv_path}\")\n    \n    band = dataset.GetRasterBand(1)\n    elevation_data = band.ReadAsArray()\n\n    # Get geotransform information\n    geotransform = dataset.GetGeoTransform()\n    min_lon, pixel_size_x, _, max_lat, _, pixel_size_y = geotransform\n\n    # Calculate raster size\n    raster_width = dataset.RasterXSize\n    raster_height = dataset.RasterYSize\n\n    # Generate latitude and longitude arrays\n    lats = np.arange(max_lat, max_lat - pixel_size_y * raster_height, -pixel_size_y)\n    lons = np.arange(min_lon, min_lon + pixel_size_x * raster_width, pixel_size_x)\n\n    # Create meshgrid of latitude and longitude\n    lon_grid, lat_grid = np.meshgrid(lons, lats)\n\n    # Flatten the data and the lat/lon grids\n    elevation_data_flat = elevation_data.flatten()\n    lat_grid_flat = lat_grid.flatten()\n    lon_grid_flat = lon_grid.flatten()\n\n    # Create a DataFrame to store the data\n    df = pd.DataFrame({\n      'Latitude': lat_grid_flat,\n      'Longitude': lon_grid_flat,\n      'Elevation': elevation_data_flat,\n    })\n    \n    df.to_csv(result_dem_csv_path)\n    print(f\"DEM geotif is saved to a csv file with only elevation {result_dem_csv_path}\")\n\n  \ndef read_elevation_data(file_path, neighborhood_size=6):\n    \n    \n    # Create an empty DataFrame with column names\n    columns = ['lat', 'lon', 'elevation', 'slope', 'aspect', 'curvature', 'northness', 'eastness']\n    all_df = pd.DataFrame(columns=columns)\n    \n    print(f\"neighborhood_size // 2 = {neighborhood_size // 2}\")\n    \n    for index, row in df.iterrows():\n      # Access individual row elements using row['column_name']\n      # Convert latitude and longitude to pixel indices\n      x, y = lat_lon_to_pixel(row['Latitude'], row['Longitude'], geotransform)\n      \n      if index %1000 == 0:\n        print(f\"processing {x} {y}\")\n\t  \n      if x < neighborhood_size // 2 or y < neighborhood_size // 2 or x > (raster_width - neighborhood_size // 2) or y > (raster_height - neighborhood_size // 2):\n      \tdata_row = {\n            'lat': row['Latitude'],\n            'lon': row['Longitude'],\n            'elevation': row['Elevation'],\n            'slope': -1,\n            'aspect': -1,\n            'curvature': -1,\n            'northness': -1,\n            'eastness': -1\n        }\n      else:\n        # Read a small neighborhood of elevation data around the selected point\n        small_elevation_data = band.ReadAsArray(x - neighborhood_size // 2, y - neighborhood_size // 2, neighborhood_size, neighborhood_size)\n\n        # Calculate slope and aspect\n        slope_data, aspect_data = calculate_slope_aspect(small_elevation_data, pixel_size_x, pixel_size_y)\n\n        # Calculate curvature\n        curvature_data = calculate_curvature(small_elevation_data, pixel_size_x, pixel_size_y)\n        northness_data = np.abs(np.sin(np.radians(aspect_data)))\n        eastness_data = np.abs(np.cos(np.radians(aspect_data)))\n\n\n        data_row = {\n            'lat': row['Latitude'],\n            'lon': row['Longitude'],\n            'elevation': row['Elevation'],\n            'slope': slope_data[neighborhood_size // 2, neighborhood_size // 2],\n            'aspect': aspect_data[neighborhood_size // 2, neighborhood_size // 2],\n            'curvature': curvature_data[neighborhood_size // 2, neighborhood_size // 2],\n            'northness': northness_data[neighborhood_size // 2, neighborhood_size // 2],\n            'eastness': eastness_data[neighborhood_size // 2, neighborhood_size // 2]\n        }\n      \n      \n      # Append a row to the DataFrame\n      all_df = all_df.append(data_row, ignore_index=True)\n    \n    all_df.to_csv(result_dem_feature_csv_path)\n    print(f\"DEM and other columns are saved to file {result_dem_feature_csv_path}\")\n    return all_df\n\n\n\n# Usage example:\nread_elevation_data_only(\"/home/chetana/gridmet_test_run/output_4km_clipped.tif\")\n#final_dem_all_cols = read_elevation_data(\"/home/chetana/gridmet_test_run/output_4km_clipped.tif\")\n",
  "history_output" : "  File \"/home/chetana/gw-workspace/wyAej3SXUywU/western_us_dem.py\", line 41\n    print(\"Error: Could not open the file.\")\n                                            ^\nIndentationError: unindent does not match any outer indentation level\n",
  "history_begin_time" : 1690257033217,
  "history_end_time" : 1690257033272,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : null,
  "indicator" : "Failed"
},{
  "history_id" : "71H7z0mzsp1y",
  "history_input" : "import numpy as np\nimport pandas as pd\nfrom osgeo import gdal\nimport warnings\n\n# Set the warning filter globally to ignore the FutureWarning\nwarnings.simplefilter(\"ignore\", FutureWarning)\n\ndef lat_lon_to_pixel(lat, lon, geotransform):\n    x = int((lon - geotransform[0]) / geotransform[1])\n    y = int((lat - geotransform[3]) / geotransform[5])\n    return x, y\n\n\ndef calculate_slope_aspect(elevation_data, pixel_size_x, pixel_size_y):\n    # Calculate slope using the Sobel operator\n    slope_x = np.gradient(elevation_data, pixel_size_x, axis=1)\n    slope_y = np.gradient(elevation_data, pixel_size_y, axis=0)\n    slope_rad = np.arctan(np.sqrt(slope_x ** 2 + slope_y ** 2))\n    slope_deg = np.degrees(slope_rad)\n\n    # Calculate aspect (direction of the steepest descent)\n    aspect_rad = np.arctan2(slope_y, -slope_x)\n    aspect_deg = (np.degrees(aspect_rad) + 360) % 360\n\n    return slope_deg, aspect_deg\n\n\ndef calculate_curvature(elevation_data, pixel_size_x, pixel_size_y):\n    # Calculate curvature using the Laplacian operator\n    curvature_x = np.gradient(np.gradient(elevation_data, pixel_size_x, axis=1), pixel_size_x, axis=1)\n    curvature_y = np.gradient(np.gradient(elevation_data, pixel_size_y, axis=0), pixel_size_y, axis=0)\n    curvature = curvature_x + curvature_y\n\n    return curvature\n\n\ndef read_elevation_data_only(file_path):\n  \tdataset = gdal.Open(file_path)\n  \tif dataset is None:\n      print(\"Error: Could not open the file.\")\n      return None\n\t\n    result_dem_csv_path = \"/home/chetana/gridmet_test_run/dem_template.csv\"\n    result_dem_feature_csv_path = \"/home/chetana/gridmet_test_run/dem_all.csv\"\n    \n    print(f\"start to first convert geotiff to {result_dem_csv_path}\")\n    \n    band = dataset.GetRasterBand(1)\n    elevation_data = band.ReadAsArray()\n\n    # Get geotransform information\n    geotransform = dataset.GetGeoTransform()\n    min_lon, pixel_size_x, _, max_lat, _, pixel_size_y = geotransform\n\n    # Calculate raster size\n    raster_width = dataset.RasterXSize\n    raster_height = dataset.RasterYSize\n\n    # Generate latitude and longitude arrays\n    lats = np.arange(max_lat, max_lat - pixel_size_y * raster_height, -pixel_size_y)\n    lons = np.arange(min_lon, min_lon + pixel_size_x * raster_width, pixel_size_x)\n\n    # Create meshgrid of latitude and longitude\n    lon_grid, lat_grid = np.meshgrid(lons, lats)\n\n    # Flatten the data and the lat/lon grids\n    elevation_data_flat = elevation_data.flatten()\n    lat_grid_flat = lat_grid.flatten()\n    lon_grid_flat = lon_grid.flatten()\n\n    # Create a DataFrame to store the data\n    df = pd.DataFrame({\n      'Latitude': lat_grid_flat,\n      'Longitude': lon_grid_flat,\n      'Elevation': elevation_data_flat,\n    })\n    \n    df.to_csv(result_dem_csv_path)\n    print(f\"DEM geotif is saved to a csv file with only elevation {result_dem_csv_path}\")\n\n  \ndef read_elevation_data(file_path, neighborhood_size=6):\n    \n    \n    # Create an empty DataFrame with column names\n    columns = ['lat', 'lon', 'elevation', 'slope', 'aspect', 'curvature', 'northness', 'eastness']\n    all_df = pd.DataFrame(columns=columns)\n    \n    print(f\"neighborhood_size // 2 = {neighborhood_size // 2}\")\n    \n    for index, row in df.iterrows():\n      # Access individual row elements using row['column_name']\n      # Convert latitude and longitude to pixel indices\n      x, y = lat_lon_to_pixel(row['Latitude'], row['Longitude'], geotransform)\n      \n      if index %1000 == 0:\n        print(f\"processing {x} {y}\")\n\t  \n      if x < neighborhood_size // 2 or y < neighborhood_size // 2 or x > (raster_width - neighborhood_size // 2) or y > (raster_height - neighborhood_size // 2):\n      \tdata_row = {\n            'lat': row['Latitude'],\n            'lon': row['Longitude'],\n            'elevation': row['Elevation'],\n            'slope': -1,\n            'aspect': -1,\n            'curvature': -1,\n            'northness': -1,\n            'eastness': -1\n        }\n      else:\n        # Read a small neighborhood of elevation data around the selected point\n        small_elevation_data = band.ReadAsArray(x - neighborhood_size // 2, y - neighborhood_size // 2, neighborhood_size, neighborhood_size)\n\n        # Calculate slope and aspect\n        slope_data, aspect_data = calculate_slope_aspect(small_elevation_data, pixel_size_x, pixel_size_y)\n\n        # Calculate curvature\n        curvature_data = calculate_curvature(small_elevation_data, pixel_size_x, pixel_size_y)\n        northness_data = np.abs(np.sin(np.radians(aspect_data)))\n        eastness_data = np.abs(np.cos(np.radians(aspect_data)))\n\n\n        data_row = {\n            'lat': row['Latitude'],\n            'lon': row['Longitude'],\n            'elevation': row['Elevation'],\n            'slope': slope_data[neighborhood_size // 2, neighborhood_size // 2],\n            'aspect': aspect_data[neighborhood_size // 2, neighborhood_size // 2],\n            'curvature': curvature_data[neighborhood_size // 2, neighborhood_size // 2],\n            'northness': northness_data[neighborhood_size // 2, neighborhood_size // 2],\n            'eastness': eastness_data[neighborhood_size // 2, neighborhood_size // 2]\n        }\n      \n      \n      # Append a row to the DataFrame\n      all_df = all_df.append(data_row, ignore_index=True)\n    \n    all_df.to_csv(result_dem_feature_csv_path)\n    print(f\"DEM and other columns are saved to file {result_dem_feature_csv_path}\")\n    return all_df\n\n\n\n# Usage example:\nread_elevation_data_only(\"/home/chetana/gridmet_test_run/output_4km_clipped.tif\")\n#final_dem_all_cols = read_elevation_data(\"/home/chetana/gridmet_test_run/output_4km_clipped.tif\")\n",
  "history_output" : "  File \"/home/chetana/gw-workspace/71H7z0mzsp1y/western_us_dem.py\", line 41\n    print(\"Error: Could not open the file.\")\n                                            ^\nIndentationError: unindent does not match any outer indentation level\n",
  "history_begin_time" : 1690256987836,
  "history_end_time" : 1690256987891,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : null,
  "indicator" : "Failed"
},{
  "history_id" : "idhNlAu5xDrz",
  "history_input" : "import numpy as np\nimport pandas as pd\nfrom osgeo import gdal\nimport warnings\n\n# Set the warning filter globally to ignore the FutureWarning\nwarnings.simplefilter(\"ignore\", FutureWarning)\n\ndef lat_lon_to_pixel(lat, lon, geotransform):\n    x = int((lon - geotransform[0]) / geotransform[1])\n    y = int((lat - geotransform[3]) / geotransform[5])\n    return x, y\n\n\ndef calculate_slope_aspect(elevation_data, pixel_size_x, pixel_size_y):\n    # Calculate slope using the Sobel operator\n    slope_x = np.gradient(elevation_data, pixel_size_x, axis=1)\n    slope_y = np.gradient(elevation_data, pixel_size_y, axis=0)\n    slope_rad = np.arctan(np.sqrt(slope_x ** 2 + slope_y ** 2))\n    slope_deg = np.degrees(slope_rad)\n\n    # Calculate aspect (direction of the steepest descent)\n    aspect_rad = np.arctan2(slope_y, -slope_x)\n    aspect_deg = (np.degrees(aspect_rad) + 360) % 360\n\n    return slope_deg, aspect_deg\n\n\ndef calculate_curvature(elevation_data, pixel_size_x, pixel_size_y):\n    # Calculate curvature using the Laplacian operator\n    curvature_x = np.gradient(np.gradient(elevation_data, pixel_size_x, axis=1), pixel_size_x, axis=1)\n    curvature_y = np.gradient(np.gradient(elevation_data, pixel_size_y, axis=0), pixel_size_y, axis=0)\n    curvature = curvature_x + curvature_y\n\n    return curvature\n\n\ndef read_elevation_data_only(file_path):\n  \tdataset = gdal.Open(file_path)\n  \tif dataset is None:\n      print(\"Error: Could not open the file.\")\n      return None\n\t\n    result_dem_csv_path = \"/home/chetana/gridmet_test_run/dem_template.csv\"\n    result_dem_feature_csv_path = \"/home/chetana/gridmet_test_run/dem_all.csv\"\n    \n    print(f\"start to first convert geotiff to {result_dem_csv_path}\")\n    \n    band = dataset.GetRasterBand(1)\n    elevation_data = band.ReadAsArray()\n\n    # Get geotransform information\n    geotransform = dataset.GetGeoTransform()\n    min_lon, pixel_size_x, _, max_lat, _, pixel_size_y = geotransform\n\n    # Calculate raster size\n    raster_width = dataset.RasterXSize\n    raster_height = dataset.RasterYSize\n\n    # Generate latitude and longitude arrays\n    lats = np.arange(max_lat, max_lat - pixel_size_y * raster_height, -pixel_size_y)\n    lons = np.arange(min_lon, min_lon + pixel_size_x * raster_width, pixel_size_x)\n\n    # Create meshgrid of latitude and longitude\n    lon_grid, lat_grid = np.meshgrid(lons, lats)\n\n    # Flatten the data and the lat/lon grids\n    elevation_data_flat = elevation_data.flatten()\n    lat_grid_flat = lat_grid.flatten()\n    lon_grid_flat = lon_grid.flatten()\n\n    # Create a DataFrame to store the data\n    df = pd.DataFrame({\n      'Latitude': lat_grid_flat,\n      'Longitude': lon_grid_flat,\n      'Elevation': elevation_data_flat,\n    })\n    \n    df.to_csv(result_dem_csv_path)\n    print(f\"DEM geotif is saved to a csv file with only elevation {result_dem_csv_path}\")\n\n  \ndef read_elevation_data(file_path, neighborhood_size=6):\n    \n    \n    # Create an empty DataFrame with column names\n    columns = ['lat', 'lon', 'elevation', 'slope', 'aspect', 'curvature', 'northness', 'eastness']\n    all_df = pd.DataFrame(columns=columns)\n    \n    print(f\"neighborhood_size // 2 = {neighborhood_size // 2}\")\n    \n    for index, row in df.iterrows():\n      # Access individual row elements using row['column_name']\n      # Convert latitude and longitude to pixel indices\n      x, y = lat_lon_to_pixel(row['Latitude'], row['Longitude'], geotransform)\n      \n      if index %1000 == 0:\n        print(f\"processing {x} {y}\")\n\t  \n      if x < neighborhood_size // 2 or y < neighborhood_size // 2 or x > (raster_width - neighborhood_size // 2) or y > (raster_height - neighborhood_size // 2):\n      \tdata_row = {\n            'lat': row['Latitude'],\n            'lon': row['Longitude'],\n            'elevation': row['Elevation'],\n            'slope': -1,\n            'aspect': -1,\n            'curvature': -1,\n            'northness': -1,\n            'eastness': -1\n        }\n      else:\n        # Read a small neighborhood of elevation data around the selected point\n        small_elevation_data = band.ReadAsArray(x - neighborhood_size // 2, y - neighborhood_size // 2, neighborhood_size, neighborhood_size)\n\n        # Calculate slope and aspect\n        slope_data, aspect_data = calculate_slope_aspect(small_elevation_data, pixel_size_x, pixel_size_y)\n\n        # Calculate curvature\n        curvature_data = calculate_curvature(small_elevation_data, pixel_size_x, pixel_size_y)\n        northness_data = np.abs(np.sin(np.radians(aspect_data)))\n        eastness_data = np.abs(np.cos(np.radians(aspect_data)))\n\n\n        data_row = {\n            'lat': row['Latitude'],\n            'lon': row['Longitude'],\n            'elevation': row['Elevation'],\n            'slope': slope_data[neighborhood_size // 2, neighborhood_size // 2],\n            'aspect': aspect_data[neighborhood_size // 2, neighborhood_size // 2],\n            'curvature': curvature_data[neighborhood_size // 2, neighborhood_size // 2],\n            'northness': northness_data[neighborhood_size // 2, neighborhood_size // 2],\n            'eastness': eastness_data[neighborhood_size // 2, neighborhood_size // 2]\n        }\n      \n      \n      # Append a row to the DataFrame\n      all_df = all_df.append(data_row, ignore_index=True)\n    \n    all_df.to_csv(result_dem_feature_csv_path)\n    print(f\"DEM and other columns are saved to file {result_dem_feature_csv_path}\")\n    return all_df\n\n\n\n# Usage example:\nread_elevation_data_only(\"/home/chetana/gridmet_test_run/output_4km_clipped.tif\")\n#final_dem_all_cols = read_elevation_data(\"/home/chetana/gridmet_test_run/output_4km_clipped.tif\")\n",
  "history_output" : "  File \"/home/chetana/gw-workspace/idhNlAu5xDrz/western_us_dem.py\", line 41\n    print(\"Error: Could not open the file.\")\n                                            ^\nIndentationError: unindent does not match any outer indentation level\n",
  "history_begin_time" : 1690256968370,
  "history_end_time" : 1690256968426,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : null,
  "indicator" : "Failed"
},{
  "history_id" : "JObHVqJCHvFA",
  "history_input" : "import numpy as np\nimport pandas as pd\nfrom osgeo import gdal\nimport warnings\n\n# Set the warning filter globally to ignore the FutureWarning\nwarnings.simplefilter(\"ignore\", FutureWarning)\n\ndef lat_lon_to_pixel(lat, lon, geotransform):\n    x = int((lon - geotransform[0]) / geotransform[1])\n    y = int((lat - geotransform[3]) / geotransform[5])\n    return x, y\n\n\ndef calculate_slope_aspect(elevation_data, pixel_size_x, pixel_size_y):\n    # Calculate slope using the Sobel operator\n    slope_x = np.gradient(elevation_data, pixel_size_x, axis=1)\n    slope_y = np.gradient(elevation_data, pixel_size_y, axis=0)\n    slope_rad = np.arctan(np.sqrt(slope_x ** 2 + slope_y ** 2))\n    slope_deg = np.degrees(slope_rad)\n\n    # Calculate aspect (direction of the steepest descent)\n    aspect_rad = np.arctan2(slope_y, -slope_x)\n    aspect_deg = (np.degrees(aspect_rad) + 360) % 360\n\n    return slope_deg, aspect_deg\n\n\ndef calculate_curvature(elevation_data, pixel_size_x, pixel_size_y):\n    # Calculate curvature using the Laplacian operator\n    curvature_x = np.gradient(np.gradient(elevation_data, pixel_size_x, axis=1), pixel_size_x, axis=1)\n    curvature_y = np.gradient(np.gradient(elevation_data, pixel_size_y, axis=0), pixel_size_y, axis=0)\n    curvature = curvature_x + curvature_y\n\n    return curvature\n\n\ndef read_elevation_data_only(file_path):\n  \tdataset = gdal.Open(file_path)\n    if dataset is None:\n      print(\"Error: Could not open the file.\")\n      return None\n\t\n    result_dem_csv_path = \"/home/chetana/gridmet_test_run/dem_template.csv\"\n    result_dem_feature_csv_path = \"/home/chetana/gridmet_test_run/dem_all.csv\"\n    \n    print(f\"start to first convert geotiff to {result_dem_csv_path}\")\n    \n    band = dataset.GetRasterBand(1)\n    elevation_data = band.ReadAsArray()\n\n    # Get geotransform information\n    geotransform = dataset.GetGeoTransform()\n    min_lon, pixel_size_x, _, max_lat, _, pixel_size_y = geotransform\n\n    # Calculate raster size\n    raster_width = dataset.RasterXSize\n    raster_height = dataset.RasterYSize\n\n    # Generate latitude and longitude arrays\n    lats = np.arange(max_lat, max_lat - pixel_size_y * raster_height, -pixel_size_y)\n    lons = np.arange(min_lon, min_lon + pixel_size_x * raster_width, pixel_size_x)\n\n    # Create meshgrid of latitude and longitude\n    lon_grid, lat_grid = np.meshgrid(lons, lats)\n\n    # Flatten the data and the lat/lon grids\n    elevation_data_flat = elevation_data.flatten()\n    lat_grid_flat = lat_grid.flatten()\n    lon_grid_flat = lon_grid.flatten()\n\n    # Create a DataFrame to store the data\n    df = pd.DataFrame({\n      'Latitude': lat_grid_flat,\n      'Longitude': lon_grid_flat,\n      'Elevation': elevation_data_flat,\n    })\n    \n    df.to_csv(result_dem_csv_path)\n    print(f\"DEM geotif is saved to a csv file with only elevation {result_dem_csv_path}\")\n\n  \ndef read_elevation_data(file_path, neighborhood_size=6):\n    \n    \n    # Create an empty DataFrame with column names\n    columns = ['lat', 'lon', 'elevation', 'slope', 'aspect', 'curvature', 'northness', 'eastness']\n    all_df = pd.DataFrame(columns=columns)\n    \n    print(f\"neighborhood_size // 2 = {neighborhood_size // 2}\")\n    \n    for index, row in df.iterrows():\n      # Access individual row elements using row['column_name']\n      # Convert latitude and longitude to pixel indices\n      x, y = lat_lon_to_pixel(row['Latitude'], row['Longitude'], geotransform)\n      \n      if index %1000 == 0:\n        print(f\"processing {x} {y}\")\n\t  \n      if x < neighborhood_size // 2 or y < neighborhood_size // 2 or x > (raster_width - neighborhood_size // 2) or y > (raster_height - neighborhood_size // 2):\n      \tdata_row = {\n            'lat': row['Latitude'],\n            'lon': row['Longitude'],\n            'elevation': row['Elevation'],\n            'slope': -1,\n            'aspect': -1,\n            'curvature': -1,\n            'northness': -1,\n            'eastness': -1\n        }\n      else:\n        # Read a small neighborhood of elevation data around the selected point\n        small_elevation_data = band.ReadAsArray(x - neighborhood_size // 2, y - neighborhood_size // 2, neighborhood_size, neighborhood_size)\n\n        # Calculate slope and aspect\n        slope_data, aspect_data = calculate_slope_aspect(small_elevation_data, pixel_size_x, pixel_size_y)\n\n        # Calculate curvature\n        curvature_data = calculate_curvature(small_elevation_data, pixel_size_x, pixel_size_y)\n        northness_data = np.abs(np.sin(np.radians(aspect_data)))\n        eastness_data = np.abs(np.cos(np.radians(aspect_data)))\n\n\n        data_row = {\n            'lat': row['Latitude'],\n            'lon': row['Longitude'],\n            'elevation': row['Elevation'],\n            'slope': slope_data[neighborhood_size // 2, neighborhood_size // 2],\n            'aspect': aspect_data[neighborhood_size // 2, neighborhood_size // 2],\n            'curvature': curvature_data[neighborhood_size // 2, neighborhood_size // 2],\n            'northness': northness_data[neighborhood_size // 2, neighborhood_size // 2],\n            'eastness': eastness_data[neighborhood_size // 2, neighborhood_size // 2]\n        }\n      \n      \n      # Append a row to the DataFrame\n      all_df = all_df.append(data_row, ignore_index=True)\n    \n    all_df.to_csv(result_dem_feature_csv_path)\n    print(f\"DEM and other columns are saved to file {result_dem_feature_csv_path}\")\n    return all_df\n\n\n\n# Usage example:\nread_elevation_data_only(\"/home/chetana/gridmet_test_run/output_4km_clipped.tif\")\n#final_dem_all_cols = read_elevation_data(\"/home/chetana/gridmet_test_run/output_4km_clipped.tif\")\n",
  "history_output" : "  File \"/home/chetana/gw-workspace/JObHVqJCHvFA/western_us_dem.py\", line 40\n    if dataset is None:\n                       ^\nIndentationError: unindent does not match any outer indentation level\n",
  "history_begin_time" : 1690256945810,
  "history_end_time" : 1690256945861,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : null,
  "indicator" : "Failed"
},{
  "history_id" : "YrXxni6XK2b0",
  "history_input" : "import numpy as np\nimport pandas as pd\nfrom osgeo import gdal\nimport warnings\n\n# Set the warning filter globally to ignore the FutureWarning\nwarnings.simplefilter(\"ignore\", FutureWarning)\n\ndef lat_lon_to_pixel(lat, lon, geotransform):\n    x = int((lon - geotransform[0]) / geotransform[1])\n    y = int((lat - geotransform[3]) / geotransform[5])\n    return x, y\n\n\ndef calculate_slope_aspect(elevation_data, pixel_size_x, pixel_size_y):\n    # Calculate slope using the Sobel operator\n    slope_x = np.gradient(elevation_data, pixel_size_x, axis=1)\n    slope_y = np.gradient(elevation_data, pixel_size_y, axis=0)\n    slope_rad = np.arctan(np.sqrt(slope_x ** 2 + slope_y ** 2))\n    slope_deg = np.degrees(slope_rad)\n\n    # Calculate aspect (direction of the steepest descent)\n    aspect_rad = np.arctan2(slope_y, -slope_x)\n    aspect_deg = (np.degrees(aspect_rad) + 360) % 360\n\n    return slope_deg, aspect_deg\n\n\ndef calculate_curvature(elevation_data, pixel_size_x, pixel_size_y):\n    # Calculate curvature using the Laplacian operator\n    curvature_x = np.gradient(np.gradient(elevation_data, pixel_size_x, axis=1), pixel_size_x, axis=1)\n    curvature_y = np.gradient(np.gradient(elevation_data, pixel_size_y, axis=0), pixel_size_y, axis=0)\n    curvature = curvature_x + curvature_y\n\n    return curvature\n\n\ndef read_elevation_data_only(file_path):\n  \tdataset = gdal.Open(file_path)\n    if dataset is None:\n        print(\"Error: Could not open the file.\")\n        return None\n\t\n    result_dem_csv_path = \"/home/chetana/gridmet_test_run/dem_template.csv\"\n    result_dem_feature_csv_path = \"/home/chetana/gridmet_test_run/dem_all.csv\"\n    \n    print(f\"start to first convert geotiff to {result_dem_csv_path}\")\n    \n    band = dataset.GetRasterBand(1)\n    elevation_data = band.ReadAsArray()\n\n    # Get geotransform information\n    geotransform = dataset.GetGeoTransform()\n    min_lon, pixel_size_x, _, max_lat, _, pixel_size_y = geotransform\n\n    # Calculate raster size\n    raster_width = dataset.RasterXSize\n    raster_height = dataset.RasterYSize\n\n    # Generate latitude and longitude arrays\n    lats = np.arange(max_lat, max_lat - pixel_size_y * raster_height, -pixel_size_y)\n    lons = np.arange(min_lon, min_lon + pixel_size_x * raster_width, pixel_size_x)\n\n    # Create meshgrid of latitude and longitude\n    lon_grid, lat_grid = np.meshgrid(lons, lats)\n\n    # Flatten the data and the lat/lon grids\n    elevation_data_flat = elevation_data.flatten()\n    lat_grid_flat = lat_grid.flatten()\n    lon_grid_flat = lon_grid.flatten()\n\n    # Create a DataFrame to store the data\n    df = pd.DataFrame({\n        'Latitude': lat_grid_flat,\n        'Longitude': lon_grid_flat,\n        'Elevation': elevation_data_flat,\n    })\n    \n    df.to_csv(result_dem_csv_path)\n    print(f\"DEM geotif is saved to a csv file with only elevation {result_dem_csv_path}\")\n\n  \ndef read_elevation_data(file_path, neighborhood_size=6):\n    \n    \n    # Create an empty DataFrame with column names\n    columns = ['lat', 'lon', 'elevation', 'slope', 'aspect', 'curvature', 'northness', 'eastness']\n    all_df = pd.DataFrame(columns=columns)\n    \n    print(f\"neighborhood_size // 2 = {neighborhood_size // 2}\")\n    \n    for index, row in df.iterrows():\n      # Access individual row elements using row['column_name']\n      # Convert latitude and longitude to pixel indices\n      x, y = lat_lon_to_pixel(row['Latitude'], row['Longitude'], geotransform)\n      \n      if index %1000 == 0:\n        print(f\"processing {x} {y}\")\n\t  \n      if x < neighborhood_size // 2 or y < neighborhood_size // 2 or x > (raster_width - neighborhood_size // 2) or y > (raster_height - neighborhood_size // 2):\n      \tdata_row = {\n            'lat': row['Latitude'],\n            'lon': row['Longitude'],\n            'elevation': row['Elevation'],\n            'slope': -1,\n            'aspect': -1,\n            'curvature': -1,\n            'northness': -1,\n            'eastness': -1\n        }\n      else:\n        # Read a small neighborhood of elevation data around the selected point\n        small_elevation_data = band.ReadAsArray(x - neighborhood_size // 2, y - neighborhood_size // 2, neighborhood_size, neighborhood_size)\n\n        # Calculate slope and aspect\n        slope_data, aspect_data = calculate_slope_aspect(small_elevation_data, pixel_size_x, pixel_size_y)\n\n        # Calculate curvature\n        curvature_data = calculate_curvature(small_elevation_data, pixel_size_x, pixel_size_y)\n        northness_data = np.abs(np.sin(np.radians(aspect_data)))\n        eastness_data = np.abs(np.cos(np.radians(aspect_data)))\n\n\n        data_row = {\n            'lat': row['Latitude'],\n            'lon': row['Longitude'],\n            'elevation': row['Elevation'],\n            'slope': slope_data[neighborhood_size // 2, neighborhood_size // 2],\n            'aspect': aspect_data[neighborhood_size // 2, neighborhood_size // 2],\n            'curvature': curvature_data[neighborhood_size // 2, neighborhood_size // 2],\n            'northness': northness_data[neighborhood_size // 2, neighborhood_size // 2],\n            'eastness': eastness_data[neighborhood_size // 2, neighborhood_size // 2]\n        }\n      \n      \n      # Append a row to the DataFrame\n      all_df = all_df.append(data_row, ignore_index=True)\n    \n    all_df.to_csv(result_dem_feature_csv_path)\n    print(f\"DEM and other columns are saved to file {result_dem_feature_csv_path}\")\n    return all_df\n\n\n\n# Usage example:\nread_elevation_data_only(\"/home/chetana/gridmet_test_run/output_4km_clipped.tif\")\n#final_dem_all_cols = read_elevation_data(\"/home/chetana/gridmet_test_run/output_4km_clipped.tif\")\n",
  "history_output" : "  File \"/home/chetana/gw-workspace/YrXxni6XK2b0/western_us_dem.py\", line 40\n    if dataset is None:\n                       ^\nIndentationError: unindent does not match any outer indentation level\n",
  "history_begin_time" : 1690256927051,
  "history_end_time" : 1690256927108,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : null,
  "indicator" : "Failed"
},{
  "history_id" : "edIkFVqzyTUr",
  "history_input" : "import numpy as np\nimport pandas as pd\nfrom osgeo import gdal\nimport warnings\n\n# Set the warning filter globally to ignore the FutureWarning\nwarnings.simplefilter(\"ignore\", FutureWarning)\n\ndef lat_lon_to_pixel(lat, lon, geotransform):\n    x = int((lon - geotransform[0]) / geotransform[1])\n    y = int((lat - geotransform[3]) / geotransform[5])\n    return x, y\n\n\ndef calculate_slope_aspect(elevation_data, pixel_size_x, pixel_size_y):\n    # Calculate slope using the Sobel operator\n    slope_x = np.gradient(elevation_data, pixel_size_x, axis=1)\n    slope_y = np.gradient(elevation_data, pixel_size_y, axis=0)\n    slope_rad = np.arctan(np.sqrt(slope_x ** 2 + slope_y ** 2))\n    slope_deg = np.degrees(slope_rad)\n\n    # Calculate aspect (direction of the steepest descent)\n    aspect_rad = np.arctan2(slope_y, -slope_x)\n    aspect_deg = (np.degrees(aspect_rad) + 360) % 360\n\n    return slope_deg, aspect_deg\n\n\ndef calculate_curvature(elevation_data, pixel_size_x, pixel_size_y):\n    # Calculate curvature using the Laplacian operator\n    curvature_x = np.gradient(np.gradient(elevation_data, pixel_size_x, axis=1), pixel_size_x, axis=1)\n    curvature_y = np.gradient(np.gradient(elevation_data, pixel_size_y, axis=0), pixel_size_y, axis=0)\n    curvature = curvature_x + curvature_y\n\n    return curvature\n\n\ndef read_elevation_data_only(file_path):\n  \tdataset = gdal.Open(file_path)\n    if dataset is None:\n        print(\"Error: Could not open the file.\")\n        return None\n\t\n    result_dem_csv_path = \"/home/chetana/gridmet_test_run/dem_template.csv\"\n    result_dem_feature_csv_path = \"/home/chetana/gridmet_test_run/dem_all.csv\"\n    \n    print(f\"start to first convert geotiff to {result_dem_csv_path}\")\n    \n    band = dataset.GetRasterBand(1)\n    elevation_data = band.ReadAsArray()\n\n    # Get geotransform information\n    geotransform = dataset.GetGeoTransform()\n    min_lon, pixel_size_x, _, max_lat, _, pixel_size_y = geotransform\n\n    # Calculate raster size\n    raster_width = dataset.RasterXSize\n    raster_height = dataset.RasterYSize\n\n    # Generate latitude and longitude arrays\n    lats = np.arange(max_lat, max_lat - pixel_size_y * raster_height, -pixel_size_y)\n    lons = np.arange(min_lon, min_lon + pixel_size_x * raster_width, pixel_size_x)\n\n    # Create meshgrid of latitude and longitude\n    lon_grid, lat_grid = np.meshgrid(lons, lats)\n\n    # Flatten the data and the lat/lon grids\n    elevation_data_flat = elevation_data.flatten()\n    lat_grid_flat = lat_grid.flatten()\n    lon_grid_flat = lon_grid.flatten()\n\n    # Create a DataFrame to store the data\n    df = pd.DataFrame({\n        'Latitude': lat_grid_flat,\n        'Longitude': lon_grid_flat,\n        'Elevation': elevation_data_flat,\n    })\n    \n    df.to_csv(result_dem_csv_path)\n    print(f\"DEM geotif is saved to a csv file with only elevation {result_dem_csv_path}\")\n\n  \ndef read_elevation_data(file_path, neighborhood_size=6):\n    \n    \n    # Create an empty DataFrame with column names\n    columns = ['lat', 'lon', 'elevation', 'slope', 'aspect', 'curvature', 'northness', 'eastness']\n    all_df = pd.DataFrame(columns=columns)\n    \n    print(f\"neighborhood_size // 2 = {neighborhood_size // 2}\")\n    \n    for index, row in df.iterrows():\n      # Access individual row elements using row['column_name']\n      # Convert latitude and longitude to pixel indices\n      x, y = lat_lon_to_pixel(row['Latitude'], row['Longitude'], geotransform)\n      \n      if index %1000 == 0:\n        print(f\"processing {x} {y}\")\n\t  \n      if x < neighborhood_size // 2 or y < neighborhood_size // 2 or x > (raster_width - neighborhood_size // 2) or y > (raster_height - neighborhood_size // 2):\n      \tdata_row = {\n            'lat': row['Latitude'],\n            'lon': row['Longitude'],\n            'elevation': row['Elevation'],\n            'slope': -1,\n            'aspect': -1,\n            'curvature': -1,\n            'northness': -1,\n            'eastness': -1\n        }\n      else:\n        # Read a small neighborhood of elevation data around the selected point\n        small_elevation_data = band.ReadAsArray(x - neighborhood_size // 2, y - neighborhood_size // 2, neighborhood_size, neighborhood_size)\n\n        # Calculate slope and aspect\n        slope_data, aspect_data = calculate_slope_aspect(small_elevation_data, pixel_size_x, pixel_size_y)\n\n        # Calculate curvature\n        curvature_data = calculate_curvature(small_elevation_data, pixel_size_x, pixel_size_y)\n        northness_data = np.abs(np.sin(np.radians(aspect_data)))\n        eastness_data = np.abs(np.cos(np.radians(aspect_data)))\n\n\n        data_row = {\n            'lat': row['Latitude'],\n            'lon': row['Longitude'],\n            'elevation': row['Elevation'],\n            'slope': slope_data[neighborhood_size // 2, neighborhood_size // 2],\n            'aspect': aspect_data[neighborhood_size // 2, neighborhood_size // 2],\n            'curvature': curvature_data[neighborhood_size // 2, neighborhood_size // 2],\n            'northness': northness_data[neighborhood_size // 2, neighborhood_size // 2],\n            'eastness': eastness_data[neighborhood_size // 2, neighborhood_size // 2]\n        }\n      \n      \n      # Append a row to the DataFrame\n      all_df = all_df.append(data_row, ignore_index=True)\n    \n    all_df.to_csv(result_dem_feature_csv_path)\n    print(f\"DEM and other columns are saved to file {result_dem_feature_csv_path}\")\n    return all_df\n\n\n\n# Usage example:\nread_elevation_data_only(\"/home/chetana/gridmet_test_run/output_4km_clipped.tif\")\n#final_dem_all_cols = read_elevation_data(\"/home/chetana/gridmet_test_run/output_4km_clipped.tif\")\n",
  "history_output" : "  File \"/home/chetana/gw-workspace/edIkFVqzyTUr/western_us_dem.py\", line 40\n    if dataset is None:\n                       ^\nIndentationError: unindent does not match any outer indentation level\n",
  "history_begin_time" : 1690256910025,
  "history_end_time" : 1690256910085,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : null,
  "indicator" : "Failed"
},{
  "history_id" : "YQPIrn1Yt4Ly",
  "history_input" : "import numpy as np\nimport pandas as pd\nfrom osgeo import gdal\nimport warnings\n\n# Set the warning filter globally to ignore the FutureWarning\nwarnings.simplefilter(\"ignore\", FutureWarning)\n\ndef lat_lon_to_pixel(lat, lon, geotransform):\n    x = int((lon - geotransform[0]) / geotransform[1])\n    y = int((lat - geotransform[3]) / geotransform[5])\n    return x, y\n\n\ndef calculate_slope_aspect(elevation_data, pixel_size_x, pixel_size_y):\n    # Calculate slope using the Sobel operator\n    slope_x = np.gradient(elevation_data, pixel_size_x, axis=1)\n    slope_y = np.gradient(elevation_data, pixel_size_y, axis=0)\n    slope_rad = np.arctan(np.sqrt(slope_x ** 2 + slope_y ** 2))\n    slope_deg = np.degrees(slope_rad)\n\n    # Calculate aspect (direction of the steepest descent)\n    aspect_rad = np.arctan2(slope_y, -slope_x)\n    aspect_deg = (np.degrees(aspect_rad) + 360) % 360\n\n    return slope_deg, aspect_deg\n\n\ndef calculate_curvature(elevation_data, pixel_size_x, pixel_size_y):\n    # Calculate curvature using the Laplacian operator\n    curvature_x = np.gradient(np.gradient(elevation_data, pixel_size_x, axis=1), pixel_size_x, axis=1)\n    curvature_y = np.gradient(np.gradient(elevation_data, pixel_size_y, axis=0), pixel_size_y, axis=0)\n    curvature = curvature_x + curvature_y\n\n    return curvature\n\n\ndef read_elevation_data(file_path, neighborhood_size=6):\n    dataset = gdal.Open(file_path)\n    if dataset is None:\n        print(\"Error: Could not open the file.\")\n        return None\n\t\n    result_dem_csv_path = \"/home/chetana/gridmet_test_run/dem_template.csv\"\n    result_dem_feature_csv_path = \"/home/chetana/gridmet_test_run/dem_all.csv\"\n    \n    print(f\"start to first convert geotiff to {result_dem_csv_path}\")\n    \n    band = dataset.GetRasterBand(1)\n    elevation_data = band.ReadAsArray()\n\n    # Get geotransform information\n    geotransform = dataset.GetGeoTransform()\n    min_lon, pixel_size_x, _, max_lat, _, pixel_size_y = geotransform\n\n    # Calculate raster size\n    raster_width = dataset.RasterXSize\n    raster_height = dataset.RasterYSize\n\n    # Generate latitude and longitude arrays\n    lats = np.arange(max_lat, max_lat - pixel_size_y * raster_height, -pixel_size_y)\n    lons = np.arange(min_lon, min_lon + pixel_size_x * raster_width, pixel_size_x)\n\n    # Create meshgrid of latitude and longitude\n    lon_grid, lat_grid = np.meshgrid(lons, lats)\n\n    # Flatten the data and the lat/lon grids\n    elevation_data_flat = elevation_data.flatten()\n    lat_grid_flat = lat_grid.flatten()\n    lon_grid_flat = lon_grid.flatten()\n\n    # Create a DataFrame to store the data\n    df = pd.DataFrame({\n        'Latitude': lat_grid_flat,\n        'Longitude': lon_grid_flat,\n        'Elevation': elevation_data_flat,\n    })\n    \n    df.to_csv(result_dem_csv_path)\n    print(f\"DEM geotif is saved to a csv file with only elevation {result_dem_csv_path}\")\n    \n    # Create an empty DataFrame with column names\n    columns = ['lat', 'lon', 'elevation', 'slope', 'aspect', 'curvature', 'northness', 'eastness']\n    all_df = pd.DataFrame(columns=columns)\n    \n    print(f\"neighborhood_size // 2 = {neighborhood_size // 2}\")\n    \n    for index, row in df.iterrows():\n      # Access individual row elements using row['column_name']\n      # Convert latitude and longitude to pixel indices\n      x, y = lat_lon_to_pixel(row['Latitude'], row['Longitude'], geotransform)\n      \n      if index %1000 == 0:\n        print(f\"processing {x} {y}\")\n\t  \n      if x < neighborhood_size // 2 or y < neighborhood_size // 2 or x > (raster_width - neighborhood_size // 2) or y > (raster_height - neighborhood_size // 2):\n      \tdata_row = {\n            'lat': row['Latitude'],\n            'lon': row['Longitude'],\n            'elevation': row['Elevation'],\n            'slope': -1,\n            'aspect': -1,\n            'curvature': -1,\n            'northness': -1,\n            'eastness': -1\n        }\n      else:\n        # Read a small neighborhood of elevation data around the selected point\n        small_elevation_data = band.ReadAsArray(x - neighborhood_size // 2, y - neighborhood_size // 2, neighborhood_size, neighborhood_size)\n\n        # Calculate slope and aspect\n        slope_data, aspect_data = calculate_slope_aspect(small_elevation_data, pixel_size_x, pixel_size_y)\n\n        # Calculate curvature\n        curvature_data = calculate_curvature(small_elevation_data, pixel_size_x, pixel_size_y)\n        northness_data = np.abs(np.sin(np.radians(aspect_data)))\n        eastness_data = np.abs(np.cos(np.radians(aspect_data)))\n\n\n        data_row = {\n            'lat': row['Latitude'],\n            'lon': row['Longitude'],\n            'elevation': row['Elevation'],\n            'slope': slope_data[neighborhood_size // 2, neighborhood_size // 2],\n            'aspect': aspect_data[neighborhood_size // 2, neighborhood_size // 2],\n            'curvature': curvature_data[neighborhood_size // 2, neighborhood_size // 2],\n            'northness': northness_data[neighborhood_size // 2, neighborhood_size // 2],\n            'eastness': eastness_data[neighborhood_size // 2, neighborhood_size // 2]\n        }\n      \n      \n      # Append a row to the DataFrame\n      all_df = all_df.append(data_row, ignore_index=True)\n    \n    all_df.to_csv(result_dem_feature_csv_path)\n    print(f\"DEM and other columns are saved to file {result_dem_feature_csv_path}\")\n    return all_df\n\n\n\n# Usage example:\n\nfinal_dem_all_cols = read_elevation_data(\"/home/chetana/gridmet_test_run/output_4km_clipped.tif\")\n",
  "history_output" : "",
  "history_begin_time" : 1690255541305,
  "history_end_time" : 1690256845395,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : null,
  "indicator" : "Failed"
},{
  "history_id" : "tgVKU4KyJ8Gi",
  "history_input" : "import numpy as np\nimport pandas as pd\nfrom osgeo import gdal\nimport warnings\n\n# Set the warning filter globally to ignore the FutureWarning\nwarnings.simplefilter(\"ignore\", FutureWarning)\n\ndef lat_lon_to_pixel(lat, lon, geotransform):\n    x = int((lon - geotransform[0]) / geotransform[1])\n    y = int((lat - geotransform[3]) / geotransform[5])\n    return x, y\n\n\ndef calculate_slope_aspect(elevation_data, pixel_size_x, pixel_size_y):\n    # Calculate slope using the Sobel operator\n    slope_x = np.gradient(elevation_data, pixel_size_x, axis=1)\n    slope_y = np.gradient(elevation_data, pixel_size_y, axis=0)\n    slope_rad = np.arctan(np.sqrt(slope_x ** 2 + slope_y ** 2))\n    slope_deg = np.degrees(slope_rad)\n\n    # Calculate aspect (direction of the steepest descent)\n    aspect_rad = np.arctan2(slope_y, -slope_x)\n    aspect_deg = (np.degrees(aspect_rad) + 360) % 360\n\n    return slope_deg, aspect_deg\n\n\ndef calculate_curvature(elevation_data, pixel_size_x, pixel_size_y):\n    # Calculate curvature using the Laplacian operator\n    curvature_x = np.gradient(np.gradient(elevation_data, pixel_size_x, axis=1), pixel_size_x, axis=1)\n    curvature_y = np.gradient(np.gradient(elevation_data, pixel_size_y, axis=0), pixel_size_y, axis=0)\n    curvature = curvature_x + curvature_y\n\n    return curvature\n\n\ndef read_elevation_data(file_path, neighborhood_size=6):\n    dataset = gdal.Open(file_path)\n    if dataset is None:\n        print(\"Error: Could not open the file.\")\n        return None\n\t\n    result_dem_csv_path = \"/home/chetana/gridmet_test_run/dem_template.csv\"\n    result_dem_feature_csv_path = \"/home/chetana/gridmet_test_run/dem_all.csv\"\n    \n    band = dataset.GetRasterBand(1)\n    elevation_data = band.ReadAsArray()\n\n    # Get geotransform information\n    geotransform = dataset.GetGeoTransform()\n    min_lon, pixel_size_x, _, max_lat, _, pixel_size_y = geotransform\n\n    # Calculate raster size\n    raster_width = dataset.RasterXSize\n    raster_height = dataset.RasterYSize\n\n    # Generate latitude and longitude arrays\n    lats = np.arange(max_lat, max_lat - pixel_size_y * raster_height, -pixel_size_y)\n    lons = np.arange(min_lon, min_lon + pixel_size_x * raster_width, pixel_size_x)\n\n    # Create meshgrid of latitude and longitude\n    lon_grid, lat_grid = np.meshgrid(lons, lats)\n\n    # Flatten the data and the lat/lon grids\n    elevation_data_flat = elevation_data.flatten()\n    lat_grid_flat = lat_grid.flatten()\n    lon_grid_flat = lon_grid.flatten()\n\n    # Create a DataFrame to store the data\n    df = pd.DataFrame({\n      'Latitude': lat_grid_flat,\n      'Longitude': lon_grid_flat,\n      'Elevation': elevation_data_flat,\n    })\n    \n    df.to_csv(result_dem_csv_path)\n    print(f\"DEM geotif is saved to a csv file with only elevation {result_dem_csv_path}\")\n    \n    # Create an empty DataFrame with column names\n    columns = ['lat', 'lon', 'elevation', 'slope', 'aspect', 'curvature', 'northness', 'eastness']\n    all_df = pd.DataFrame(columns=columns)\n    \n    print(f\"neighborhood_size // 2 = {neighborhood_size // 2}\")\n    \n    for index, row in df.iterrows():\n      # Access individual row elements using row['column_name']\n      # Convert latitude and longitude to pixel indices\n      x, y = lat_lon_to_pixel(row['Latitude'], row['Longitude'], geotransform)\n      \n      if index %1000 == 0:\n        print(f\"processing {x} {y}\")\n\t  \n      if x < neighborhood_size // 2 or y < neighborhood_size // 2 or x > (raster_width - neighborhood_size // 2) or y > (raster_height - neighborhood_size // 2):\n      \tdata_row = {\n            'lat': row['Latitude'],\n            'lon': row['Longitude'],\n            'elevation': row['Elevation'],\n            'slope': -1,\n            'aspect': -1,\n            'curvature': -1,\n            'northness': -1,\n            'eastness': -1\n        }\n      else:\n        # Read a small neighborhood of elevation data around the selected point\n        small_elevation_data = band.ReadAsArray(x - neighborhood_size // 2, y - neighborhood_size // 2, neighborhood_size, neighborhood_size)\n\n        # Calculate slope and aspect\n        slope_data, aspect_data = calculate_slope_aspect(small_elevation_data, pixel_size_x, pixel_size_y)\n\n        # Calculate curvature\n        curvature_data = calculate_curvature(small_elevation_data, pixel_size_x, pixel_size_y)\n        northness_data = np.abs(np.sin(np.radians(aspect_data)))\n        eastness_data = np.abs(np.cos(np.radians(aspect_data)))\n\n\n        data_row = {\n            'lat': row['Latitude'],\n            'lon': row['Longitude'],\n            'elevation': row['Elevation'],\n            'slope': slope_data[neighborhood_size // 2, neighborhood_size // 2],\n            'aspect': aspect_data[neighborhood_size // 2, neighborhood_size // 2],\n            'curvature': curvature_data[neighborhood_size // 2, neighborhood_size // 2],\n            'northness': northness_data[neighborhood_size // 2, neighborhood_size // 2],\n            'eastness': eastness_data[neighborhood_size // 2, neighborhood_size // 2]\n        }\n      \n      \n      # Append a row to the DataFrame\n      all_df = all_df.append(data_row, ignore_index=True)\n    \n    all_df.to_csv(result_dem_feature_csv_path)\n    print(f\"DEM and other columns are saved to file {result_dem_feature_csv_path}\")\n    return all_df\n\n\n\n# Usage example:\n\nfinal_dem_all_cols = read_elevation_data(\"/home/chetana/gridmet_test_run/output_4km_clipped.tif\")\n",
  "history_output" : "",
  "history_begin_time" : 1690255060659,
  "history_end_time" : 1690255430663,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : null,
  "indicator" : "Failed"
},{
  "history_id" : "XyGXwHdtuoY1",
  "history_input" : "import numpy as np\nimport pandas as pd\nfrom osgeo import gdal\nimport warnings\n\n# Set the warning filter globally to ignore the FutureWarning\nwarnings.simplefilter(\"ignore\", FutureWarning)\n\ndef lat_lon_to_pixel(lat, lon, geotransform):\n    x = int((lon - geotransform[0]) / geotransform[1])\n    y = int((lat - geotransform[3]) / geotransform[5])\n    return x, y\n\n\ndef calculate_slope_aspect(elevation_data, pixel_size_x, pixel_size_y):\n    # Calculate slope using the Sobel operator\n    slope_x = np.gradient(elevation_data, pixel_size_x, axis=1)\n    slope_y = np.gradient(elevation_data, pixel_size_y, axis=0)\n    slope_rad = np.arctan(np.sqrt(slope_x ** 2 + slope_y ** 2))\n    slope_deg = np.degrees(slope_rad)\n\n    # Calculate aspect (direction of the steepest descent)\n    aspect_rad = np.arctan2(slope_y, -slope_x)\n    aspect_deg = (np.degrees(aspect_rad) + 360) % 360\n\n    return slope_deg, aspect_deg\n\n\ndef calculate_curvature(elevation_data, pixel_size_x, pixel_size_y):\n    # Calculate curvature using the Laplacian operator\n    curvature_x = np.gradient(np.gradient(elevation_data, pixel_size_x, axis=1), pixel_size_x, axis=1)\n    curvature_y = np.gradient(np.gradient(elevation_data, pixel_size_y, axis=0), pixel_size_y, axis=0)\n    curvature = curvature_x + curvature_y\n\n    return curvature\n\n\ndef read_elevation_data(file_path, neighborhood_size=6):\n    dataset = gdal.Open(file_path)\n    if dataset is None:\n        print(\"Error: Could not open the file.\")\n        return None\n\t\n    result_dem_csv_path = \"/home/chetana/gridmet_test_run/dem_template.csv\"\n    result_dem_feature_csv_path = \"/home/chetana/gridmet_test_run/dem_all.csv\"\n    \n    band = dataset.GetRasterBand(1)\n    elevation_data = band.ReadAsArray()\n\n    # Get geotransform information\n    geotransform = dataset.GetGeoTransform()\n    min_lon, pixel_size_x, _, max_lat, _, pixel_size_y = geotransform\n\n    # Calculate raster size\n    raster_width = dataset.RasterXSize\n    raster_height = dataset.RasterYSize\n\n    # Generate latitude and longitude arrays\n    lats = np.arange(max_lat, max_lat - pixel_size_y * raster_height, -pixel_size_y)\n    lons = np.arange(min_lon, min_lon + pixel_size_x * raster_width, pixel_size_x)\n\n    # Create meshgrid of latitude and longitude\n    lon_grid, lat_grid = np.meshgrid(lons, lats)\n\n    # Flatten the data and the lat/lon grids\n    elevation_data_flat = elevation_data.flatten()\n    lat_grid_flat = lat_grid.flatten()\n    lon_grid_flat = lon_grid.flatten()\n\n    # Create a DataFrame to store the data\n    df = pd.DataFrame({\n      'Latitude': lat_grid_flat,\n      'Longitude': lon_grid_flat,\n      'Elevation': elevation_data_flat,\n    })\n    \n    df.to_csv(result_dem_csv_path)\n    print(f\"DEM geotif is saved to a csv file with only elevation {result_dem_csv_path}\")\n    \n    # Create an empty DataFrame with column names\n    columns = ['lat', 'lon', 'elevation', 'slope', 'aspect', 'curvature', 'northness', 'eastness']\n    all_df = pd.DataFrame(columns=columns)\n    \n    print(f\"neighborhood_size // 2 = {neighborhood_size // 2}\")\n    \n    for index, row in df.iterrows():\n      # Access individual row elements using row['column_name']\n      # Convert latitude and longitude to pixel indices\n      x, y = lat_lon_to_pixel(row['Latitude'], row['Longitude'], geotransform)\n\t  \n      if x < neighborhood_size // 2 or y < neighborhood_size // 2 or x > (raster_width - neighborhood_size // 2) or y > (raster_height - neighborhood_size // 2):\n      \tdata_row = {\n            'lat': row['Latitude'],\n            'lon': row['Longitude'],\n            'elevation': row['Elevation'],\n            'slope': -1,\n            'aspect': -1,\n            'curvature': -1,\n            'northness': -1,\n            'eastness': -1\n        }\n      else:\n        # Read a small neighborhood of elevation data around the selected point\n        small_elevation_data = band.ReadAsArray(x - neighborhood_size // 2, y - neighborhood_size // 2, neighborhood_size, neighborhood_size)\n\n        # Calculate slope and aspect\n        slope_data, aspect_data = calculate_slope_aspect(small_elevation_data, pixel_size_x, pixel_size_y)\n\n        # Calculate curvature\n        curvature_data = calculate_curvature(small_elevation_data, pixel_size_x, pixel_size_y)\n        northness_data = np.abs(np.sin(np.radians(aspect_data)))\n        eastness_data = np.abs(np.cos(np.radians(aspect_data)))\n\n\n        data_row = {\n            'lat': row['Latitude'],\n            'lon': row['Longitude'],\n            'elevation': row['Elevation'],\n            'slope': slope_data[neighborhood_size // 2, neighborhood_size // 2],\n            'aspect': aspect_data[neighborhood_size // 2, neighborhood_size // 2],\n            'curvature': curvature_data[neighborhood_size // 2, neighborhood_size // 2],\n            'northness': northness_data[neighborhood_size // 2, neighborhood_size // 2],\n            'eastness': eastness_data[neighborhood_size // 2, neighborhood_size // 2]\n        }\n      \n      \n      # Append a row to the DataFrame\n      all_df = all_df.append(data_row, ignore_index=True)\n    \n    all_df.to_csv(result_dem_feature_csv_path)\n    print(f\"DEM and other columns are saved to file {result_dem_feature_csv_path}\")\n    return all_df\n\n\n\n# Usage example:\n\nfinal_dem_all_cols = read_elevation_data(\"/home/chetana/gridmet_test_run/output_4km_clipped.tif\")\n",
  "history_output" : "",
  "history_begin_time" : 1690254789864,
  "history_end_time" : 1690255004215,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : null,
  "indicator" : "Failed"
},{
  "history_id" : "eKxdshPGPkKx",
  "history_input" : "import numpy as np\nimport pandas as pd\nfrom osgeo import gdal\nimport warnings\n\n# Set the warning filter globally to ignore the FutureWarning\nwarnings.simplefilter(\"ignore\", FutureWarning)\n\ndef lat_lon_to_pixel(lat, lon, geotransform):\n    x = int((lon - geotransform[0]) / geotransform[1])\n    y = int((lat - geotransform[3]) / geotransform[5])\n    return x, y\n\n\ndef calculate_slope_aspect(elevation_data, pixel_size_x, pixel_size_y):\n    # Calculate slope using the Sobel operator\n    slope_x = np.gradient(elevation_data, pixel_size_x, axis=1)\n    slope_y = np.gradient(elevation_data, pixel_size_y, axis=0)\n    slope_rad = np.arctan(np.sqrt(slope_x ** 2 + slope_y ** 2))\n    slope_deg = np.degrees(slope_rad)\n\n    # Calculate aspect (direction of the steepest descent)\n    aspect_rad = np.arctan2(slope_y, -slope_x)\n    aspect_deg = (np.degrees(aspect_rad) + 360) % 360\n\n    return slope_deg, aspect_deg\n\n\ndef calculate_curvature(elevation_data, pixel_size_x, pixel_size_y):\n    # Calculate curvature using the Laplacian operator\n    curvature_x = np.gradient(np.gradient(elevation_data, pixel_size_x, axis=1), pixel_size_x, axis=1)\n    curvature_y = np.gradient(np.gradient(elevation_data, pixel_size_y, axis=0), pixel_size_y, axis=0)\n    curvature = curvature_x + curvature_y\n\n    return curvature\n\n\ndef read_elevation_data(file_path, neighborhood_size=6):\n    dataset = gdal.Open(file_path)\n    if dataset is None:\n        print(\"Error: Could not open the file.\")\n        return None\n\t\n    result_dem_csv_path = \"/home/chetana/gridmet_test_run/dem_template.csv\"\n    result_dem_feature_csv_path = \"/home/chetana/gridmet_test_run/dem_all.csv\"\n    \n    band = dataset.GetRasterBand(1)\n    elevation_data = band.ReadAsArray()\n\n    # Get geotransform information\n    geotransform = dataset.GetGeoTransform()\n    min_lon, pixel_size_x, _, max_lat, _, pixel_size_y = geotransform\n\n    # Calculate raster size\n    raster_width = dataset.RasterXSize\n    raster_height = dataset.RasterYSize\n\n    # Generate latitude and longitude arrays\n    lats = np.arange(max_lat, max_lat - pixel_size_y * raster_height, -pixel_size_y)\n    lons = np.arange(min_lon, min_lon + pixel_size_x * raster_width, pixel_size_x)\n\n    # Create meshgrid of latitude and longitude\n    lon_grid, lat_grid = np.meshgrid(lons, lats)\n\n    # Flatten the data and the lat/lon grids\n    elevation_data_flat = elevation_data.flatten()\n    lat_grid_flat = lat_grid.flatten()\n    lon_grid_flat = lon_grid.flatten()\n\n    # Create a DataFrame to store the data\n    df = pd.DataFrame({\n      'Latitude': lat_grid_flat,\n      'Longitude': lon_grid_flat,\n      'Elevation': elevation_data_flat,\n    })\n    \n    df.to_csv(result_dem_csv_path)\n    print(f\"DEM geotif is saved to a csv file with only elevation {result_dem_csv_path}\")\n    \n    # Create an empty DataFrame with column names\n    columns = ['lat', 'lon', 'elevation', 'slope', 'aspect', 'curvature', 'northness', 'eastness']\n    all_df = pd.DataFrame(columns=columns)\n    \n    print(f\"neighborhood_size // 2 = {neighborhood_size // 2}\")\n    \n    for index, row in df.iterrows():\n      # Access individual row elements using row['column_name']\n      # Convert latitude and longitude to pixel indices\n      x, y = lat_lon_to_pixel(row['Latitude'], row['Longitude'], geotransform)\n\t  \n      if x < neighborhood_size // 2 or y < neighborhood_size // 2 or x > (raster_width - neighborhood_size // 2) or y > (raster_height - neighborhood_size // 2):\n      \tdata_row = {\n            'lat': row['Latitude'],\n            'lon': row['Longitude'],\n            'elevation': row['Elevation'],\n            'slope': -1,\n            'aspect': -1,\n            'curvature': -1,\n            'northness': -1,\n            'eastness': -1\n        }\n      else:\n        # Read a small neighborhood of elevation data around the selected point\n        small_elevation_data = band.ReadAsArray(x - neighborhood_size // 2, y - neighborhood_size // 2, neighborhood_size, neighborhood_size)\n\n        # Calculate slope and aspect\n        slope_data, aspect_data = calculate_slope_aspect(small_elevation_data, pixel_size_x, pixel_size_y)\n\n        # Calculate curvature\n        curvature_data = calculate_curvature(small_elevation_data, pixel_size_x, pixel_size_y)\n        northness_data = np.abs(np.sin(np.radians(aspect_data)))\n        eastness_data = np.abs(np.cos(np.radians(aspect_data)))\n\n\n        data_row = {\n            'lat': row['Latitude'],\n            'lon': row['Longitude'],\n            'elevation': row['Elevation'],\n            'slope': slope_data[neighborhood_size // 2, neighborhood_size // 2],\n            'aspect': aspect_data[neighborhood_size // 2, neighborhood_size // 2],\n            'curvature': curvature_data[neighborhood_size // 2, neighborhood_size // 2],\n            'northness': northness_data[neighborhood_size // 2, neighborhood_size // 2],\n            'eastness': eastness_data[neighborhood_size // 2, neighborhood_size // 2]\n        }\n      \n      \n      # Append a row to the DataFrame\n      all_df = all_df.append(data_row, ignore_index=True)\n    \n    all_df.to_csv(result_dem_feature_csv_path)\n    print(f\"DEM and other columns are saved to file {result_dem_feature_csv_path}\")\n    return all_df\n\n\n\n# Usage example:\n\nfinal_dem_all_cols = read_elevation_data(\"/home/chetana/gridmet_test_run/output_4km_clipped.tif\")\n\n#clim_data = pd.read_csv(result_dem_feature_csv_path)\n\n# Apply read_elevation_data function to calculate elevation, slope, aspect, and curvature\n#elevation_data = clim_data.apply(lambda row: read_elevation_data(\"/home/chetana/gridmet_test_run/output_4km_clipped.tif\", row['lat'], row['lon']), axis=1, result_type='expand')\n\n# Merge elevation data with the original DataFrame\n#final_testing_df = pd.concat([clim_data, elevation_data], axis=1)\n\n# Save the updated DataFrame to a new CSV file\n#final_testing_df.to_csv('final_testing.csv', index=False)\n\n# if not os.path.exists(result_dem_csv_path):\n#     elevation_df = read_elevation_data(\"/home/chetana/gridmet_test_run/output_4km_clipped.tif\")\n#     print(elevation_df)\n#     elevation_df.to_csv(result_dem_csv_path)\n#     data = {\n#         'Latitude': [],\n#         'Longitude': [],\n#         'Elevation': [],\n#         'Slope': [],\n#         'Aspect': [],\n#       \t'Curvature': [],\n#     }\n#     new_df = pd.DataFrame(data)\n#     for index, row in elevation_df.iterrows():\n#         latitude = row['Latitude']  # Replace 'Latitude' with the actual name of your latitude column\n#         longitude = row['Longitude']  # Replace 'Longitude' with the actual name of your longitude column\n#         elevation, slope, aspect, curvature = get_elevation_slope_aspect_curvature(elevation_df, latitude, longitude)\n#         new_row = {\n#             'Latitude': latitude,\n#             'Longitude': longitude,\n#             'Elevation': elevation,\n#             'Slope': slope,\n#             'Aspect': aspect,\n#             'Curvature': curvature,\n#         }\n\n#         new_df = new_df.append(new_row, ignore_index=True)\n        \n#     new_df.to_csv(result_dem_feature_csv_path)\n# else:\n# \tprint(\"dem_template.csv exists. Skipping...\")\n    \n\n\n# # Get elevation, slope, aspect, and curvature based on the given lat and lon\n# latitude_to_find = 34.5  # Replace with the desired latitude\n# longitude_to_find = -120.5  # Replace with the desired longitude\n\n# elevation, slope, aspect, curvature = get_elevation_slope_aspect_curvature(elevation_df, latitude_to_find,\n#                                                                            longitude_to_find)\n\n# print(\"Latitude:\", latitude_to_find)\n# print(\"Longitude:\", longitude_to_find)\n# print(\"Elevation:\", elevation)\n# print(\"Slope:\", slope)\n# print(\"Aspect:\", aspect)\n# print(\"Curvature:\", curvature)\n#convert_the_original_dem_to_template_spatial_extent()\n",
  "history_output" : "",
  "history_begin_time" : 1690254390980,
  "history_end_time" : 1690254772627,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : null,
  "indicator" : "Failed"
},{
  "history_id" : "GdphUimvsRrb",
  "history_input" : "import numpy as np\nimport pandas as pd\nfrom osgeo import gdal\nimport warnings\n\n# Set the warning filter globally to ignore the FutureWarning\nwarnings.simplefilter(\"ignore\", FutureWarning)\n\ndef lat_lon_to_pixel(lat, lon, geotransform):\n    x = int((lon - geotransform[0]) / geotransform[1])\n    y = int((lat - geotransform[3]) / geotransform[5])\n    return x, y\n\n\ndef calculate_slope_aspect(elevation_data, pixel_size_x, pixel_size_y):\n    # Calculate slope using the Sobel operator\n    slope_x = np.gradient(elevation_data, pixel_size_x, axis=1)\n    slope_y = np.gradient(elevation_data, pixel_size_y, axis=0)\n    slope_rad = np.arctan(np.sqrt(slope_x ** 2 + slope_y ** 2))\n    slope_deg = np.degrees(slope_rad)\n\n    # Calculate aspect (direction of the steepest descent)\n    aspect_rad = np.arctan2(slope_y, -slope_x)\n    aspect_deg = (np.degrees(aspect_rad) + 360) % 360\n\n    return slope_deg, aspect_deg\n\n\ndef calculate_curvature(elevation_data, pixel_size_x, pixel_size_y):\n    # Calculate curvature using the Laplacian operator\n    curvature_x = np.gradient(np.gradient(elevation_data, pixel_size_x, axis=1), pixel_size_x, axis=1)\n    curvature_y = np.gradient(np.gradient(elevation_data, pixel_size_y, axis=0), pixel_size_y, axis=0)\n    curvature = curvature_x + curvature_y\n\n    return curvature\n\n\ndef read_elevation_data(file_path, neighborhood_size=6):\n    dataset = gdal.Open(file_path)\n    if dataset is None:\n        print(\"Error: Could not open the file.\")\n        return None\n\t\n    result_dem_csv_path = \"/home/chetana/gridmet_test_run/dem_template.csv\"\n    result_dem_feature_csv_path = \"/home/chetana/gridmet_test_run/dem_all.csv\"\n    \n    band = dataset.GetRasterBand(1)\n    elevation_data = band.ReadAsArray()\n\n    # Get geotransform information\n    geotransform = dataset.GetGeoTransform()\n    min_lon, pixel_size_x, _, max_lat, _, pixel_size_y = geotransform\n\n    # Calculate raster size\n    raster_width = dataset.RasterXSize\n    raster_height = dataset.RasterYSize\n\n    # Generate latitude and longitude arrays\n    lats = np.arange(max_lat, max_lat - pixel_size_y * raster_height, -pixel_size_y)\n    lons = np.arange(min_lon, min_lon + pixel_size_x * raster_width, pixel_size_x)\n\n    # Create meshgrid of latitude and longitude\n    lon_grid, lat_grid = np.meshgrid(lons, lats)\n\n    # Flatten the data and the lat/lon grids\n    elevation_data_flat = elevation_data.flatten()\n    lat_grid_flat = lat_grid.flatten()\n    lon_grid_flat = lon_grid.flatten()\n\n    # Create a DataFrame to store the data\n    df = pd.DataFrame({\n      'Latitude': lat_grid_flat,\n      'Longitude': lon_grid_flat,\n      'Elevation': elevation_data_flat,\n    })\n    \n    df.to_csv(result_dem_csv_path)\n    print(f\"DEM geotif is saved to a csv file with only elevation {result_dem_csv_path}\")\n    \n    # Create an empty DataFrame with column names\n    columns = ['lat', 'lon', 'elevation', 'slope', 'aspect', 'curvature', 'northness', 'eastness']\n    all_df = pd.DataFrame(columns=columns)\n    \n    print(f\"neighborhood_size // 2 = {neighborhood_size // 2}\")\n    \n    for index, row in df.iterrows():\n      # Access individual row elements using row['column_name']\n      # Convert latitude and longitude to pixel indices\n      x, y = lat_lon_to_pixel(row['Latitude'], row['Longitude'], geotransform)\n\t  \n      if x < neighborhood_size // 2 or y < neighborhood_size // 2 or x > (raster_width - neighborhood_size // 2) or y > (raster_height - neighborhood_size // 2):\n      \n        # Read a small neighborhood of elevation data around the selected point\n        small_elevation_data = band.ReadAsArray(x - neighborhood_size // 2, y - neighborhood_size // 2, neighborhood_size, neighborhood_size)\n\n        # Calculate slope and aspect\n        slope_data, aspect_data = calculate_slope_aspect(small_elevation_data, pixel_size_x, pixel_size_y)\n\n        # Calculate curvature\n        curvature_data = calculate_curvature(small_elevation_data, pixel_size_x, pixel_size_y)\n        northness_data = np.abs(np.sin(np.radians(aspect_data)))\n        eastness_data = np.abs(np.cos(np.radians(aspect_data)))\n\n\n        data_row = {\n            'lat': row['Latitude'],\n            'lon': row['Longitude'],\n            'elevation': row['Elevation'],\n            'slope': slope_data[neighborhood_size // 2, neighborhood_size // 2],\n            'aspect': aspect_data[neighborhood_size // 2, neighborhood_size // 2],\n            'curvature': curvature_data[neighborhood_size // 2, neighborhood_size // 2],\n            'northness': northness_data[neighborhood_size // 2, neighborhood_size // 2],\n            'eastness': eastness_data[neighborhood_size // 2, neighborhood_size // 2]\n        }\n        \n      else:\n        data_row = {\n            'lat': row['Latitude'],\n            'lon': row['Longitude'],\n            'elevation': row['Elevation'],\n            'slope': -1,\n            'aspect': -1,\n            'curvature': -1,\n            'northness': -1,\n            'eastness': -1\n        }\n      \n      # Append a row to the DataFrame\n      all_df = all_df.append(data_row, ignore_index=True)\n    \n    all_df.to_csv(result_dem_feature_csv_path)\n    print(f\"DEM and other columns are saved to file {result_dem_feature_csv_path}\")\n    return all_df\n\n\n\n# Usage example:\n\nfinal_dem_all_cols = read_elevation_data(\"/home/chetana/gridmet_test_run/output_4km_clipped.tif\")\n\n#clim_data = pd.read_csv(result_dem_feature_csv_path)\n\n# Apply read_elevation_data function to calculate elevation, slope, aspect, and curvature\n#elevation_data = clim_data.apply(lambda row: read_elevation_data(\"/home/chetana/gridmet_test_run/output_4km_clipped.tif\", row['lat'], row['lon']), axis=1, result_type='expand')\n\n# Merge elevation data with the original DataFrame\n#final_testing_df = pd.concat([clim_data, elevation_data], axis=1)\n\n# Save the updated DataFrame to a new CSV file\n#final_testing_df.to_csv('final_testing.csv', index=False)\n\n# if not os.path.exists(result_dem_csv_path):\n#     elevation_df = read_elevation_data(\"/home/chetana/gridmet_test_run/output_4km_clipped.tif\")\n#     print(elevation_df)\n#     elevation_df.to_csv(result_dem_csv_path)\n#     data = {\n#         'Latitude': [],\n#         'Longitude': [],\n#         'Elevation': [],\n#         'Slope': [],\n#         'Aspect': [],\n#       \t'Curvature': [],\n#     }\n#     new_df = pd.DataFrame(data)\n#     for index, row in elevation_df.iterrows():\n#         latitude = row['Latitude']  # Replace 'Latitude' with the actual name of your latitude column\n#         longitude = row['Longitude']  # Replace 'Longitude' with the actual name of your longitude column\n#         elevation, slope, aspect, curvature = get_elevation_slope_aspect_curvature(elevation_df, latitude, longitude)\n#         new_row = {\n#             'Latitude': latitude,\n#             'Longitude': longitude,\n#             'Elevation': elevation,\n#             'Slope': slope,\n#             'Aspect': aspect,\n#             'Curvature': curvature,\n#         }\n\n#         new_df = new_df.append(new_row, ignore_index=True)\n        \n#     new_df.to_csv(result_dem_feature_csv_path)\n# else:\n# \tprint(\"dem_template.csv exists. Skipping...\")\n    \n\n\n# # Get elevation, slope, aspect, and curvature based on the given lat and lon\n# latitude_to_find = 34.5  # Replace with the desired latitude\n# longitude_to_find = -120.5  # Replace with the desired longitude\n\n# elevation, slope, aspect, curvature = get_elevation_slope_aspect_curvature(elevation_df, latitude_to_find,\n#                                                                            longitude_to_find)\n\n# print(\"Latitude:\", latitude_to_find)\n# print(\"Longitude:\", longitude_to_find)\n# print(\"Elevation:\", elevation)\n# print(\"Slope:\", slope)\n# print(\"Aspect:\", aspect)\n# print(\"Curvature:\", curvature)\n#convert_the_original_dem_to_template_spatial_extent()\n",
  "history_output" : "ERROR 5: /home/chetana/gridmet_test_run/output_4km_clipped.tif, band 1: Access window out of range in RasterIO().  Requested\n(-2,-2) of size 6x6 on raster of 694x666.\nDEM geotif is saved to a csv file with only elevation /home/chetana/gridmet_test_run/dem_template.csv\nneighborhood_size // 2 = 3\nTraceback (most recent call last):\n  File \"/home/chetana/gw-workspace/GdphUimvsRrb/western_us_dem.py\", line 139, in <module>\n    final_dem_all_cols = read_elevation_data(\"/home/chetana/gridmet_test_run/output_4km_clipped.tif\")\n  File \"/home/chetana/gw-workspace/GdphUimvsRrb/western_us_dem.py\", line 97, in read_elevation_data\n    slope_data, aspect_data = calculate_slope_aspect(small_elevation_data, pixel_size_x, pixel_size_y)\n  File \"/home/chetana/gw-workspace/GdphUimvsRrb/western_us_dem.py\", line 17, in calculate_slope_aspect\n    slope_x = np.gradient(elevation_data, pixel_size_x, axis=1)\n  File \"<__array_function__ internals>\", line 5, in gradient\n  File \"/home/chetana/anaconda3/lib/python3.9/site-packages/numpy/lib/function_base.py\", line 995, in gradient\n    axes = _nx.normalize_axis_tuple(axis, N)\n  File \"/home/chetana/anaconda3/lib/python3.9/site-packages/numpy/core/numeric.py\", line 1385, in normalize_axis_tuple\n    axis = tuple([normalize_axis_index(ax, ndim, argname) for ax in axis])\n  File \"/home/chetana/anaconda3/lib/python3.9/site-packages/numpy/core/numeric.py\", line 1385, in <listcomp>\n    axis = tuple([normalize_axis_index(ax, ndim, argname) for ax in axis])\nnumpy.AxisError: axis 1 is out of bounds for array of dimension 0\n",
  "history_begin_time" : 1690254332584,
  "history_end_time" : 1690254335112,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : null,
  "indicator" : "Failed"
},{
  "history_id" : "IxeeYlTn1RyU",
  "history_input" : "import numpy as np\nimport pandas as pd\nfrom osgeo import gdal\nimport warnings\n\n# Set the warning filter globally to ignore the FutureWarning\nwarnings.simplefilter(\"ignore\", FutureWarning)\n\ndef lat_lon_to_pixel(lat, lon, geotransform):\n    x = int((lon - geotransform[0]) / geotransform[1])\n    y = int((lat - geotransform[3]) / geotransform[5])\n    return x, y\n\n\ndef calculate_slope_aspect(elevation_data, pixel_size_x, pixel_size_y):\n    # Calculate slope using the Sobel operator\n    slope_x = np.gradient(elevation_data, pixel_size_x, axis=1)\n    slope_y = np.gradient(elevation_data, pixel_size_y, axis=0)\n    slope_rad = np.arctan(np.sqrt(slope_x ** 2 + slope_y ** 2))\n    slope_deg = np.degrees(slope_rad)\n\n    # Calculate aspect (direction of the steepest descent)\n    aspect_rad = np.arctan2(slope_y, -slope_x)\n    aspect_deg = (np.degrees(aspect_rad) + 360) % 360\n\n    return slope_deg, aspect_deg\n\n\ndef calculate_curvature(elevation_data, pixel_size_x, pixel_size_y):\n    # Calculate curvature using the Laplacian operator\n    curvature_x = np.gradient(np.gradient(elevation_data, pixel_size_x, axis=1), pixel_size_x, axis=1)\n    curvature_y = np.gradient(np.gradient(elevation_data, pixel_size_y, axis=0), pixel_size_y, axis=0)\n    curvature = curvature_x + curvature_y\n\n    return curvature\n\n\ndef read_elevation_data(file_path, neighborhood_size=6):\n    dataset = gdal.Open(file_path)\n    if dataset is None:\n        print(\"Error: Could not open the file.\")\n        return None\n\t\n    result_dem_csv_path = \"/home/chetana/gridmet_test_run/dem_template.csv\"\n    result_dem_feature_csv_path = \"/home/chetana/gridmet_test_run/dem_all.csv\"\n    \n    band = dataset.GetRasterBand(1)\n    elevation_data = band.ReadAsArray()\n\n    # Get geotransform information\n    geotransform = dataset.GetGeoTransform()\n    min_lon, pixel_size_x, _, max_lat, _, pixel_size_y = geotransform\n\n    # Calculate raster size\n    raster_width = dataset.RasterXSize\n    raster_height = dataset.RasterYSize\n\n    # Generate latitude and longitude arrays\n    lats = np.arange(max_lat, max_lat - pixel_size_y * raster_height, -pixel_size_y)\n    lons = np.arange(min_lon, min_lon + pixel_size_x * raster_width, pixel_size_x)\n\n    # Create meshgrid of latitude and longitude\n    lon_grid, lat_grid = np.meshgrid(lons, lats)\n\n    # Flatten the data and the lat/lon grids\n    elevation_data_flat = elevation_data.flatten()\n    lat_grid_flat = lat_grid.flatten()\n    lon_grid_flat = lon_grid.flatten()\n\n    # Create a DataFrame to store the data\n    df = pd.DataFrame({\n      'Latitude': lat_grid_flat,\n      'Longitude': lon_grid_flat,\n      'Elevation': elevation_data_flat,\n    })\n    \n    df.to_csv(result_dem_csv_path)\n    print(f\"DEM geotif is saved to a csv file with only elevation {result_dem_csv_path}\")\n    \n    # Create an empty DataFrame with column names\n    columns = ['lat', 'lon', 'elevation', 'slope', 'aspect', 'curvature', 'northness', 'eastness']\n    all_df = pd.DataFrame(columns=columns)\n    \n    for index, row in df.iterrows():\n      # Access individual row elements using row['column_name']\n      # Convert latitude and longitude to pixel indices\n      x, y = lat_lon_to_pixel(row['Latitude'], row['Longitude'], geotransform)\n\t  \n      if x < neighborhood_size // 2 or y < neighborhood_size // 2 or x > (raster_width - neighborhood_size // 2) or y > (raster_height - neighborhood_size // 2):\n      \n        # Read a small neighborhood of elevation data around the selected point\n        small_elevation_data = band.ReadAsArray(x - neighborhood_size // 2, y - neighborhood_size // 2, neighborhood_size, neighborhood_size)\n\n        # Calculate slope and aspect\n        slope_data, aspect_data = calculate_slope_aspect(small_elevation_data, pixel_size_x, pixel_size_y)\n\n        # Calculate curvature\n        curvature_data = calculate_curvature(small_elevation_data, pixel_size_x, pixel_size_y)\n        northness_data = np.abs(np.sin(np.radians(aspect_data)))\n        eastness_data = np.abs(np.cos(np.radians(aspect_data)))\n\n\n        data_row = {\n            'lat': row['Latitude'],\n            'lon': row['Longitude'],\n            'elevation': row['Elevation'],\n            'slope': slope_data[neighborhood_size // 2, neighborhood_size // 2],\n            'aspect': aspect_data[neighborhood_size // 2, neighborhood_size // 2],\n            'curvature': curvature_data[neighborhood_size // 2, neighborhood_size // 2],\n            'northness': northness_data[neighborhood_size // 2, neighborhood_size // 2],\n            'eastness': eastness_data[neighborhood_size // 2, neighborhood_size // 2]\n        }\n        \n      else:\n        data_row = {\n            'lat': row['Latitude'],\n            'lon': row['Longitude'],\n            'elevation': row['Elevation'],\n            'slope': -1,\n            'aspect': -1,\n            'curvature': -1,\n            'northness': -1,\n            'eastness': -1\n        }\n      \n      # Append a row to the DataFrame\n      all_df = all_df.append(data_row, ignore_index=True)\n    \n    all_df.to_csv(result_dem_feature_csv_path)\n    print(f\"DEM and other columns are saved to file {result_dem_feature_csv_path}\")\n    return all_df\n\n\n\n# Usage example:\n\nfinal_dem_all_cols = read_elevation_data(\"/home/chetana/gridmet_test_run/output_4km_clipped.tif\")\n\n#clim_data = pd.read_csv(result_dem_feature_csv_path)\n\n# Apply read_elevation_data function to calculate elevation, slope, aspect, and curvature\n#elevation_data = clim_data.apply(lambda row: read_elevation_data(\"/home/chetana/gridmet_test_run/output_4km_clipped.tif\", row['lat'], row['lon']), axis=1, result_type='expand')\n\n# Merge elevation data with the original DataFrame\n#final_testing_df = pd.concat([clim_data, elevation_data], axis=1)\n\n# Save the updated DataFrame to a new CSV file\n#final_testing_df.to_csv('final_testing.csv', index=False)\n\n# if not os.path.exists(result_dem_csv_path):\n#     elevation_df = read_elevation_data(\"/home/chetana/gridmet_test_run/output_4km_clipped.tif\")\n#     print(elevation_df)\n#     elevation_df.to_csv(result_dem_csv_path)\n#     data = {\n#         'Latitude': [],\n#         'Longitude': [],\n#         'Elevation': [],\n#         'Slope': [],\n#         'Aspect': [],\n#       \t'Curvature': [],\n#     }\n#     new_df = pd.DataFrame(data)\n#     for index, row in elevation_df.iterrows():\n#         latitude = row['Latitude']  # Replace 'Latitude' with the actual name of your latitude column\n#         longitude = row['Longitude']  # Replace 'Longitude' with the actual name of your longitude column\n#         elevation, slope, aspect, curvature = get_elevation_slope_aspect_curvature(elevation_df, latitude, longitude)\n#         new_row = {\n#             'Latitude': latitude,\n#             'Longitude': longitude,\n#             'Elevation': elevation,\n#             'Slope': slope,\n#             'Aspect': aspect,\n#             'Curvature': curvature,\n#         }\n\n#         new_df = new_df.append(new_row, ignore_index=True)\n        \n#     new_df.to_csv(result_dem_feature_csv_path)\n# else:\n# \tprint(\"dem_template.csv exists. Skipping...\")\n    \n\n\n# # Get elevation, slope, aspect, and curvature based on the given lat and lon\n# latitude_to_find = 34.5  # Replace with the desired latitude\n# longitude_to_find = -120.5  # Replace with the desired longitude\n\n# elevation, slope, aspect, curvature = get_elevation_slope_aspect_curvature(elevation_df, latitude_to_find,\n#                                                                            longitude_to_find)\n\n# print(\"Latitude:\", latitude_to_find)\n# print(\"Longitude:\", longitude_to_find)\n# print(\"Elevation:\", elevation)\n# print(\"Slope:\", slope)\n# print(\"Aspect:\", aspect)\n# print(\"Curvature:\", curvature)\n#convert_the_original_dem_to_template_spatial_extent()\n",
  "history_output" : "ERROR 5: /home/chetana/gridmet_test_run/output_4km_clipped.tif, band 1: Access window out of range in RasterIO().  Requested\n(-2,-2) of size 6x6 on raster of 694x666.\nDEM geotif is saved to a csv file with only elevation /home/chetana/gridmet_test_run/dem_template.csv\nTraceback (most recent call last):\n  File \"/home/chetana/gw-workspace/IxeeYlTn1RyU/western_us_dem.py\", line 137, in <module>\n    final_dem_all_cols = read_elevation_data(\"/home/chetana/gridmet_test_run/output_4km_clipped.tif\")\n  File \"/home/chetana/gw-workspace/IxeeYlTn1RyU/western_us_dem.py\", line 95, in read_elevation_data\n    slope_data, aspect_data = calculate_slope_aspect(small_elevation_data, pixel_size_x, pixel_size_y)\n  File \"/home/chetana/gw-workspace/IxeeYlTn1RyU/western_us_dem.py\", line 17, in calculate_slope_aspect\n    slope_x = np.gradient(elevation_data, pixel_size_x, axis=1)\n  File \"<__array_function__ internals>\", line 5, in gradient\n  File \"/home/chetana/anaconda3/lib/python3.9/site-packages/numpy/lib/function_base.py\", line 995, in gradient\n    axes = _nx.normalize_axis_tuple(axis, N)\n  File \"/home/chetana/anaconda3/lib/python3.9/site-packages/numpy/core/numeric.py\", line 1385, in normalize_axis_tuple\n    axis = tuple([normalize_axis_index(ax, ndim, argname) for ax in axis])\n  File \"/home/chetana/anaconda3/lib/python3.9/site-packages/numpy/core/numeric.py\", line 1385, in <listcomp>\n    axis = tuple([normalize_axis_index(ax, ndim, argname) for ax in axis])\nnumpy.AxisError: axis 1 is out of bounds for array of dimension 0\n",
  "history_begin_time" : 1690254222444,
  "history_end_time" : 1690254224913,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : null,
  "indicator" : "Failed"
},{
  "history_id" : "wGFhrtxocGy7",
  "history_input" : "import numpy as np\nimport pandas as pd\nfrom osgeo import gdal\nimport warnings\n\n# Set the warning filter globally to ignore the FutureWarning\nwarnings.simplefilter(\"ignore\", FutureWarning)\n\ndef lat_lon_to_pixel(lat, lon, geotransform):\n    x = int((lon - geotransform[0]) / geotransform[1])\n    y = int((lat - geotransform[3]) / geotransform[5])\n    return x, y\n\n\ndef calculate_slope_aspect(elevation_data, pixel_size_x, pixel_size_y):\n    # Calculate slope using the Sobel operator\n    print(elevation_data)\n    slope_x = np.gradient(elevation_data, pixel_size_x, axis=1)\n    slope_y = np.gradient(elevation_data, pixel_size_y, axis=0)\n    slope_rad = np.arctan(np.sqrt(slope_x ** 2 + slope_y ** 2))\n    slope_deg = np.degrees(slope_rad)\n\n    # Calculate aspect (direction of the steepest descent)\n    aspect_rad = np.arctan2(slope_y, -slope_x)\n    aspect_deg = (np.degrees(aspect_rad) + 360) % 360\n\n    return slope_deg, aspect_deg\n\n\ndef calculate_curvature(elevation_data, pixel_size_x, pixel_size_y):\n    # Calculate curvature using the Laplacian operator\n    curvature_x = np.gradient(np.gradient(elevation_data, pixel_size_x, axis=1), pixel_size_x, axis=1)\n    curvature_y = np.gradient(np.gradient(elevation_data, pixel_size_y, axis=0), pixel_size_y, axis=0)\n    curvature = curvature_x + curvature_y\n\n    return curvature\n\n\ndef read_elevation_data(file_path, neighborhood_size=6):\n    dataset = gdal.Open(file_path)\n    if dataset is None:\n        print(\"Error: Could not open the file.\")\n        return None\n\t\n    result_dem_csv_path = \"/home/chetana/gridmet_test_run/dem_template.csv\"\n    result_dem_feature_csv_path = \"/home/chetana/gridmet_test_run/dem_all.csv\"\n    \n    band = dataset.GetRasterBand(1)\n    elevation_data = band.ReadAsArray()\n\n    # Get geotransform information\n    geotransform = dataset.GetGeoTransform()\n    min_lon, pixel_size_x, _, max_lat, _, pixel_size_y = geotransform\n\n    # Calculate raster size\n    raster_width = dataset.RasterXSize\n    raster_height = dataset.RasterYSize\n\n    # Generate latitude and longitude arrays\n    lats = np.arange(max_lat, max_lat - pixel_size_y * raster_height, -pixel_size_y)\n    lons = np.arange(min_lon, min_lon + pixel_size_x * raster_width, pixel_size_x)\n\n    # Create meshgrid of latitude and longitude\n    lon_grid, lat_grid = np.meshgrid(lons, lats)\n\n    # Flatten the data and the lat/lon grids\n    elevation_data_flat = elevation_data.flatten()\n    lat_grid_flat = lat_grid.flatten()\n    lon_grid_flat = lon_grid.flatten()\n\n    # Create a DataFrame to store the data\n    df = pd.DataFrame({\n      'Latitude': lat_grid_flat,\n      'Longitude': lon_grid_flat,\n      'Elevation': elevation_data_flat,\n    })\n    \n    df.to_csv(result_dem_csv_path)\n    print(f\"DEM geotif is saved to a csv file with only elevation {result_dem_csv_path}\")\n    \n    # Create an empty DataFrame with column names\n    columns = ['lat', 'lon', 'elevation', 'slope', 'aspect', 'curvature', 'northness', 'eastness']\n    all_df = pd.DataFrame(columns=columns)\n\n    for index, row in df.iterrows():\n      # Access individual row elements using row['column_name']\n      # Convert latitude and longitude to pixel indices\n      x, y = lat_lon_to_pixel(row['Latitude'], row['Longitude'], geotransform)\n\n      # Read a small neighborhood of elevation data around the selected point\n      small_elevation_data = band.ReadAsArray(x - neighborhood_size // 2, y - neighborhood_size // 2, neighborhood_size, neighborhood_size)\n\n      # Calculate slope and aspect\n      slope_data, aspect_data = calculate_slope_aspect(small_elevation_data, pixel_size_x, pixel_size_y)\n\n      # Calculate curvature\n      curvature_data = calculate_curvature(small_elevation_data, pixel_size_x, pixel_size_y)\n      northness_data = np.abs(np.sin(np.radians(aspect_data)))\n      eastness_data = np.abs(np.cos(np.radians(aspect_data)))\n      \n\n      # Append a row to the DataFrame\n      data_row = {\n          'lat': row['Latitude'],\n          'lon': row['Longitude'],\n          'elevation': small_elevation_data[neighborhood_size // 2, neighborhood_size // 2],\n          'slope': slope_data[neighborhood_size // 2, neighborhood_size // 2],\n          'aspect': aspect_data[neighborhood_size // 2, neighborhood_size // 2],\n          'curvature': curvature_data[neighborhood_size // 2, neighborhood_size // 2],\n          'northness': northness_data[neighborhood_size // 2, neighborhood_size // 2],\n          'eastness': eastness_data[neighborhood_size // 2, neighborhood_size // 2]\n      }\n      all_df = all_df.append(data_row, ignore_index=True)\n    \n    all_df.to_csv(result_dem_feature_csv_path)\n    print(f\"DEM and other columns are saved to file {result_dem_feature_csv_path}\")\n    return all_df\n\n\n\n# Usage example:\n\nfinal_dem_all_cols = read_elevation_data(\"/home/chetana/gridmet_test_run/output_4km_clipped.tif\")\n\n#clim_data = pd.read_csv(result_dem_feature_csv_path)\n\n# Apply read_elevation_data function to calculate elevation, slope, aspect, and curvature\n#elevation_data = clim_data.apply(lambda row: read_elevation_data(\"/home/chetana/gridmet_test_run/output_4km_clipped.tif\", row['lat'], row['lon']), axis=1, result_type='expand')\n\n# Merge elevation data with the original DataFrame\n#final_testing_df = pd.concat([clim_data, elevation_data], axis=1)\n\n# Save the updated DataFrame to a new CSV file\n#final_testing_df.to_csv('final_testing.csv', index=False)\n\n# if not os.path.exists(result_dem_csv_path):\n#     elevation_df = read_elevation_data(\"/home/chetana/gridmet_test_run/output_4km_clipped.tif\")\n#     print(elevation_df)\n#     elevation_df.to_csv(result_dem_csv_path)\n#     data = {\n#         'Latitude': [],\n#         'Longitude': [],\n#         'Elevation': [],\n#         'Slope': [],\n#         'Aspect': [],\n#       \t'Curvature': [],\n#     }\n#     new_df = pd.DataFrame(data)\n#     for index, row in elevation_df.iterrows():\n#         latitude = row['Latitude']  # Replace 'Latitude' with the actual name of your latitude column\n#         longitude = row['Longitude']  # Replace 'Longitude' with the actual name of your longitude column\n#         elevation, slope, aspect, curvature = get_elevation_slope_aspect_curvature(elevation_df, latitude, longitude)\n#         new_row = {\n#             'Latitude': latitude,\n#             'Longitude': longitude,\n#             'Elevation': elevation,\n#             'Slope': slope,\n#             'Aspect': aspect,\n#             'Curvature': curvature,\n#         }\n\n#         new_df = new_df.append(new_row, ignore_index=True)\n        \n#     new_df.to_csv(result_dem_feature_csv_path)\n# else:\n# \tprint(\"dem_template.csv exists. Skipping...\")\n    \n\n\n# # Get elevation, slope, aspect, and curvature based on the given lat and lon\n# latitude_to_find = 34.5  # Replace with the desired latitude\n# longitude_to_find = -120.5  # Replace with the desired longitude\n\n# elevation, slope, aspect, curvature = get_elevation_slope_aspect_curvature(elevation_df, latitude_to_find,\n#                                                                            longitude_to_find)\n\n# print(\"Latitude:\", latitude_to_find)\n# print(\"Longitude:\", longitude_to_find)\n# print(\"Elevation:\", elevation)\n# print(\"Slope:\", slope)\n# print(\"Aspect:\", aspect)\n# print(\"Curvature:\", curvature)\n#convert_the_original_dem_to_template_spatial_extent()\n",
  "history_output" : "ERROR 5: /home/chetana/gridmet_test_run/output_4km_clipped.tif, band 1: Access window out of range in RasterIO().  Requested\n(-2,-2) of size 6x6 on raster of 694x666.\nDEM geotif is saved to a csv file with only elevation /home/chetana/gridmet_test_run/dem_template.csv\nNone\nTraceback (most recent call last):\n  File \"/home/chetana/gw-workspace/wGFhrtxocGy7/western_us_dem.py\", line 123, in <module>\n    final_dem_all_cols = read_elevation_data(\"/home/chetana/gridmet_test_run/output_4km_clipped.tif\")\n  File \"/home/chetana/gw-workspace/wGFhrtxocGy7/western_us_dem.py\", line 94, in read_elevation_data\n    slope_data, aspect_data = calculate_slope_aspect(small_elevation_data, pixel_size_x, pixel_size_y)\n  File \"/home/chetana/gw-workspace/wGFhrtxocGy7/western_us_dem.py\", line 18, in calculate_slope_aspect\n    slope_x = np.gradient(elevation_data, pixel_size_x, axis=1)\n  File \"<__array_function__ internals>\", line 5, in gradient\n  File \"/home/chetana/anaconda3/lib/python3.9/site-packages/numpy/lib/function_base.py\", line 995, in gradient\n    axes = _nx.normalize_axis_tuple(axis, N)\n  File \"/home/chetana/anaconda3/lib/python3.9/site-packages/numpy/core/numeric.py\", line 1385, in normalize_axis_tuple\n    axis = tuple([normalize_axis_index(ax, ndim, argname) for ax in axis])\n  File \"/home/chetana/anaconda3/lib/python3.9/site-packages/numpy/core/numeric.py\", line 1385, in <listcomp>\n    axis = tuple([normalize_axis_index(ax, ndim, argname) for ax in axis])\nnumpy.AxisError: axis 1 is out of bounds for array of dimension 0\n",
  "history_begin_time" : 1690253734475,
  "history_end_time" : 1690253736976,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : null,
  "indicator" : "Failed"
},{
  "history_id" : "oDqwivyF7etD",
  "history_input" : "import numpy as np\nimport pandas as pd\nfrom osgeo import gdal\nimport warnings\n\n# Set the warning filter globally to ignore the FutureWarning\nwarnings.simplefilter(\"ignore\", FutureWarning)\n\ndef lat_lon_to_pixel(lat, lon, geotransform):\n    x = int((lon - geotransform[0]) / geotransform[1])\n    y = int((lat - geotransform[3]) / geotransform[5])\n    return x, y\n\n\ndef calculate_slope_aspect(elevation_data, pixel_size_x, pixel_size_y):\n    # Calculate slope using the Sobel operator\n    slope_x = np.gradient(elevation_data, pixel_size_x, axis=1)\n    slope_y = np.gradient(elevation_data, pixel_size_y, axis=0)\n    slope_rad = np.arctan(np.sqrt(slope_x ** 2 + slope_y ** 2))\n    slope_deg = np.degrees(slope_rad)\n\n    # Calculate aspect (direction of the steepest descent)\n    aspect_rad = np.arctan2(slope_y, -slope_x)\n    aspect_deg = (np.degrees(aspect_rad) + 360) % 360\n\n    return slope_deg, aspect_deg\n\n\ndef calculate_curvature(elevation_data, pixel_size_x, pixel_size_y):\n    # Calculate curvature using the Laplacian operator\n    curvature_x = np.gradient(np.gradient(elevation_data, pixel_size_x, axis=1), pixel_size_x, axis=1)\n    curvature_y = np.gradient(np.gradient(elevation_data, pixel_size_y, axis=0), pixel_size_y, axis=0)\n    curvature = curvature_x + curvature_y\n\n    return curvature\n\n\ndef read_elevation_data(file_path, neighborhood_size=6):\n    dataset = gdal.Open(file_path)\n    if dataset is None:\n        print(\"Error: Could not open the file.\")\n        return None\n\t\n    result_dem_csv_path = \"/home/chetana/gridmet_test_run/dem_template.csv\"\n    result_dem_feature_csv_path = \"/home/chetana/gridmet_test_run/dem_all.csv\"\n    \n    band = dataset.GetRasterBand(1)\n    elevation_data = band.ReadAsArray()\n\n    # Get geotransform information\n    geotransform = dataset.GetGeoTransform()\n    min_lon, pixel_size_x, _, max_lat, _, pixel_size_y = geotransform\n\n    # Calculate raster size\n    raster_width = dataset.RasterXSize\n    raster_height = dataset.RasterYSize\n\n    # Generate latitude and longitude arrays\n    lats = np.arange(max_lat, max_lat - pixel_size_y * raster_height, -pixel_size_y)\n    lons = np.arange(min_lon, min_lon + pixel_size_x * raster_width, pixel_size_x)\n\n    # Create meshgrid of latitude and longitude\n    lon_grid, lat_grid = np.meshgrid(lons, lats)\n\n    # Flatten the data and the lat/lon grids\n    elevation_data_flat = elevation_data.flatten()\n    lat_grid_flat = lat_grid.flatten()\n    lon_grid_flat = lon_grid.flatten()\n\n    # Create a DataFrame to store the data\n    df = pd.DataFrame({\n      'Latitude': lat_grid_flat,\n      'Longitude': lon_grid_flat,\n      'Elevation': elevation_data_flat,\n    })\n    \n    df.to_csv(result_dem_csv_path)\n    print(f\"DEM geotif is saved to a csv file with only elevation {result_dem_csv_path}\")\n    \n    # Create an empty DataFrame with column names\n    columns = ['lat', 'lon', 'elevation', 'slope', 'aspect', 'curvature', 'northness', 'eastness']\n    all_df = pd.DataFrame(columns=columns)\n\n    for index, row in df.iterrows():\n      # Access individual row elements using row['column_name']\n      # Convert latitude and longitude to pixel indices\n      x, y = lat_lon_to_pixel(row['Latitude'], row['Longitude'], geotransform)\n\n      # Read a small neighborhood of elevation data around the selected point\n      small_elevation_data = band.ReadAsArray(x - neighborhood_size // 2, y - neighborhood_size // 2, neighborhood_size, neighborhood_size)\n\n      # Calculate slope and aspect\n      slope_data, aspect_data = calculate_slope_aspect(small_elevation_data, pixel_size_x, pixel_size_y)\n\n      # Calculate curvature\n      curvature_data = calculate_curvature(small_elevation_data, pixel_size_x, pixel_size_y)\n      northness_data = np.abs(np.sin(np.radians(aspect_data)))\n      eastness_data = np.abs(np.cos(np.radians(aspect_data)))\n      \n\n      # Append a row to the DataFrame\n      data_row = {\n          'lat': row['Latitude'],\n          'lon': row['Longitude'],\n          'elevation': small_elevation_data[neighborhood_size // 2, neighborhood_size // 2],\n          'slope': slope_data[neighborhood_size // 2, neighborhood_size // 2],\n          'aspect': aspect_data[neighborhood_size // 2, neighborhood_size // 2],\n          'curvature': curvature_data[neighborhood_size // 2, neighborhood_size // 2],\n          'northness': northness_data[neighborhood_size // 2, neighborhood_size // 2],\n          'eastness': eastness_data[neighborhood_size // 2, neighborhood_size // 2]\n      }\n      all_df = all_df.append(data_row, ignore_index=True)\n    \n    all_df.to_csv(result_dem_feature_csv_path)\n    print(f\"DEM and other columns are saved to file {result_dem_feature_csv_path}\")\n    return all_df\n\n\n\n# Usage example:\n\nfinal_dem_all_cols = read_elevation_data(\"/home/chetana/gridmet_test_run/output_4km_clipped.tif\")\n\n#clim_data = pd.read_csv(result_dem_feature_csv_path)\n\n# Apply read_elevation_data function to calculate elevation, slope, aspect, and curvature\n#elevation_data = clim_data.apply(lambda row: read_elevation_data(\"/home/chetana/gridmet_test_run/output_4km_clipped.tif\", row['lat'], row['lon']), axis=1, result_type='expand')\n\n# Merge elevation data with the original DataFrame\n#final_testing_df = pd.concat([clim_data, elevation_data], axis=1)\n\n# Save the updated DataFrame to a new CSV file\n#final_testing_df.to_csv('final_testing.csv', index=False)\n\n# if not os.path.exists(result_dem_csv_path):\n#     elevation_df = read_elevation_data(\"/home/chetana/gridmet_test_run/output_4km_clipped.tif\")\n#     print(elevation_df)\n#     elevation_df.to_csv(result_dem_csv_path)\n#     data = {\n#         'Latitude': [],\n#         'Longitude': [],\n#         'Elevation': [],\n#         'Slope': [],\n#         'Aspect': [],\n#       \t'Curvature': [],\n#     }\n#     new_df = pd.DataFrame(data)\n#     for index, row in elevation_df.iterrows():\n#         latitude = row['Latitude']  # Replace 'Latitude' with the actual name of your latitude column\n#         longitude = row['Longitude']  # Replace 'Longitude' with the actual name of your longitude column\n#         elevation, slope, aspect, curvature = get_elevation_slope_aspect_curvature(elevation_df, latitude, longitude)\n#         new_row = {\n#             'Latitude': latitude,\n#             'Longitude': longitude,\n#             'Elevation': elevation,\n#             'Slope': slope,\n#             'Aspect': aspect,\n#             'Curvature': curvature,\n#         }\n\n#         new_df = new_df.append(new_row, ignore_index=True)\n        \n#     new_df.to_csv(result_dem_feature_csv_path)\n# else:\n# \tprint(\"dem_template.csv exists. Skipping...\")\n    \n\n\n# # Get elevation, slope, aspect, and curvature based on the given lat and lon\n# latitude_to_find = 34.5  # Replace with the desired latitude\n# longitude_to_find = -120.5  # Replace with the desired longitude\n\n# elevation, slope, aspect, curvature = get_elevation_slope_aspect_curvature(elevation_df, latitude_to_find,\n#                                                                            longitude_to_find)\n\n# print(\"Latitude:\", latitude_to_find)\n# print(\"Longitude:\", longitude_to_find)\n# print(\"Elevation:\", elevation)\n# print(\"Slope:\", slope)\n# print(\"Aspect:\", aspect)\n# print(\"Curvature:\", curvature)\n#convert_the_original_dem_to_template_spatial_extent()\n",
  "history_output" : "ERROR 5: /home/chetana/gridmet_test_run/output_4km_clipped.tif, band 1: Access window out of range in RasterIO().  Requested\n(-2,-2) of size 6x6 on raster of 694x666.\nDEM geotif is saved to a csv file with only elevation /home/chetana/gridmet_test_run/dem_template.csv\nTraceback (most recent call last):\n  File \"/home/chetana/gw-workspace/oDqwivyF7etD/western_us_dem.py\", line 122, in <module>\n    final_dem_all_cols = read_elevation_data(\"/home/chetana/gridmet_test_run/output_4km_clipped.tif\")\n  File \"/home/chetana/gw-workspace/oDqwivyF7etD/western_us_dem.py\", line 93, in read_elevation_data\n    slope_data, aspect_data = calculate_slope_aspect(small_elevation_data, pixel_size_x, pixel_size_y)\n  File \"/home/chetana/gw-workspace/oDqwivyF7etD/western_us_dem.py\", line 17, in calculate_slope_aspect\n    slope_x = np.gradient(elevation_data, pixel_size_x, axis=1)\n  File \"<__array_function__ internals>\", line 5, in gradient\n  File \"/home/chetana/anaconda3/lib/python3.9/site-packages/numpy/lib/function_base.py\", line 995, in gradient\n    axes = _nx.normalize_axis_tuple(axis, N)\n  File \"/home/chetana/anaconda3/lib/python3.9/site-packages/numpy/core/numeric.py\", line 1385, in normalize_axis_tuple\n    axis = tuple([normalize_axis_index(ax, ndim, argname) for ax in axis])\n  File \"/home/chetana/anaconda3/lib/python3.9/site-packages/numpy/core/numeric.py\", line 1385, in <listcomp>\n    axis = tuple([normalize_axis_index(ax, ndim, argname) for ax in axis])\nnumpy.AxisError: axis 1 is out of bounds for array of dimension 0\n",
  "history_begin_time" : 1690253707509,
  "history_end_time" : 1690253710011,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : null,
  "indicator" : "Failed"
},{
  "history_id" : "xdkpoiHuSpfi",
  "history_input" : "import numpy as np\nimport pandas as pd\nfrom osgeo import gdal\nimport warnings\n\n# Set the warning filter globally to ignore the FutureWarning\nwarnings.simplefilter(\"ignore\", FutureWarning)\n\ndef lat_lon_to_pixel(lat, lon, geotransform):\n    x = int((lon - geotransform[0]) / geotransform[1])\n    y = int((lat - geotransform[3]) / geotransform[5])\n    return x, y\n\n\ndef calculate_slope_aspect(elevation_data, pixel_size_x, pixel_size_y):\n    # Calculate slope using the Sobel operator\n    slope_x = np.gradient(elevation_data, pixel_size_x, axis=1)\n    slope_y = np.gradient(elevation_data, pixel_size_y, axis=0)\n    slope_rad = np.arctan(np.sqrt(slope_x ** 2 + slope_y ** 2))\n    slope_deg = np.degrees(slope_rad)\n\n    # Calculate aspect (direction of the steepest descent)\n    aspect_rad = np.arctan2(slope_y, -slope_x)\n    aspect_deg = (np.degrees(aspect_rad) + 360) % 360\n\n    return slope_deg, aspect_deg\n\n\ndef calculate_curvature(elevation_data, pixel_size_x, pixel_size_y):\n    # Calculate curvature using the Laplacian operator\n    curvature_x = np.gradient(np.gradient(elevation_data, pixel_size_x, axis=1), pixel_size_x, axis=1)\n    curvature_y = np.gradient(np.gradient(elevation_data, pixel_size_y, axis=0), pixel_size_y, axis=0)\n    curvature = curvature_x + curvature_y\n\n    return curvature\n\n\ndef read_elevation_data(file_path, neighborhood_size=3):\n    dataset = gdal.Open(file_path)\n    if dataset is None:\n        print(\"Error: Could not open the file.\")\n        return None\n\t\n    result_dem_csv_path = \"/home/chetana/gridmet_test_run/dem_template.csv\"\n    result_dem_feature_csv_path = \"/home/chetana/gridmet_test_run/dem_all.csv\"\n    \n    band = dataset.GetRasterBand(1)\n    elevation_data = band.ReadAsArray()\n\n    # Get geotransform information\n    geotransform = dataset.GetGeoTransform()\n    min_lon, pixel_size_x, _, max_lat, _, pixel_size_y = geotransform\n\n    # Calculate raster size\n    raster_width = dataset.RasterXSize\n    raster_height = dataset.RasterYSize\n\n    # Generate latitude and longitude arrays\n    lats = np.arange(max_lat, max_lat - pixel_size_y * raster_height, -pixel_size_y)\n    lons = np.arange(min_lon, min_lon + pixel_size_x * raster_width, pixel_size_x)\n\n    # Create meshgrid of latitude and longitude\n    lon_grid, lat_grid = np.meshgrid(lons, lats)\n\n    # Flatten the data and the lat/lon grids\n    elevation_data_flat = elevation_data.flatten()\n    lat_grid_flat = lat_grid.flatten()\n    lon_grid_flat = lon_grid.flatten()\n\n    # Create a DataFrame to store the data\n    df = pd.DataFrame({\n      'Latitude': lat_grid_flat,\n      'Longitude': lon_grid_flat,\n      'Elevation': elevation_data_flat,\n    })\n    \n    df.to_csv(result_dem_csv_path)\n    print(f\"DEM geotif is saved to a csv file with only elevation {result_dem_csv_path}\")\n    \n    # Create an empty DataFrame with column names\n    columns = ['lat', 'lon', 'elevation', 'slope', 'aspect', 'curvature', 'northness', 'eastness']\n    all_df = pd.DataFrame(columns=columns)\n\n    for index, row in df.iterrows():\n      # Access individual row elements using row['column_name']\n      # Convert latitude and longitude to pixel indices\n      x, y = lat_lon_to_pixel(row['Latitude'], row['Longitude'], geotransform)\n\n      # Read a small neighborhood of elevation data around the selected point\n      small_elevation_data = band.ReadAsArray(x - neighborhood_size // 2, y - neighborhood_size // 2, neighborhood_size, neighborhood_size)\n\n      # Calculate slope and aspect\n      slope_data, aspect_data = calculate_slope_aspect(small_elevation_data, pixel_size_x, pixel_size_y)\n\n      # Calculate curvature\n      curvature_data = calculate_curvature(small_elevation_data, pixel_size_x, pixel_size_y)\n      northness_data = np.abs(np.sin(np.radians(aspect_data)))\n      eastness_data = np.abs(np.cos(np.radians(aspect_data)))\n      \n\n      # Append a row to the DataFrame\n      data_row = {\n          'lat': row['Latitude'],\n          'lon': row['Longitude'],\n          'elevation': small_elevation_data[neighborhood_size // 2, neighborhood_size // 2],\n          'slope': slope_data[neighborhood_size // 2, neighborhood_size // 2],\n          'aspect': aspect_data[neighborhood_size // 2, neighborhood_size // 2],\n          'curvature': curvature_data[neighborhood_size // 2, neighborhood_size // 2],\n          'northness': northness_data[neighborhood_size // 2, neighborhood_size // 2],\n          'eastness': eastness_data[neighborhood_size // 2, neighborhood_size // 2]\n      }\n      all_df = all_df.append(data_row, ignore_index=True)\n    \n    all_df.to_csv(result_dem_feature_csv_path)\n    print(f\"DEM and other columns are saved to file {result_dem_feature_csv_path}\")\n    return all_df\n\n\n\n# Usage example:\n\nfinal_dem_all_cols = read_elevation_data(\"/home/chetana/gridmet_test_run/output_4km_clipped.tif\")\n\n#clim_data = pd.read_csv(result_dem_feature_csv_path)\n\n# Apply read_elevation_data function to calculate elevation, slope, aspect, and curvature\n#elevation_data = clim_data.apply(lambda row: read_elevation_data(\"/home/chetana/gridmet_test_run/output_4km_clipped.tif\", row['lat'], row['lon']), axis=1, result_type='expand')\n\n# Merge elevation data with the original DataFrame\n#final_testing_df = pd.concat([clim_data, elevation_data], axis=1)\n\n# Save the updated DataFrame to a new CSV file\n#final_testing_df.to_csv('final_testing.csv', index=False)\n\n# if not os.path.exists(result_dem_csv_path):\n#     elevation_df = read_elevation_data(\"/home/chetana/gridmet_test_run/output_4km_clipped.tif\")\n#     print(elevation_df)\n#     elevation_df.to_csv(result_dem_csv_path)\n#     data = {\n#         'Latitude': [],\n#         'Longitude': [],\n#         'Elevation': [],\n#         'Slope': [],\n#         'Aspect': [],\n#       \t'Curvature': [],\n#     }\n#     new_df = pd.DataFrame(data)\n#     for index, row in elevation_df.iterrows():\n#         latitude = row['Latitude']  # Replace 'Latitude' with the actual name of your latitude column\n#         longitude = row['Longitude']  # Replace 'Longitude' with the actual name of your longitude column\n#         elevation, slope, aspect, curvature = get_elevation_slope_aspect_curvature(elevation_df, latitude, longitude)\n#         new_row = {\n#             'Latitude': latitude,\n#             'Longitude': longitude,\n#             'Elevation': elevation,\n#             'Slope': slope,\n#             'Aspect': aspect,\n#             'Curvature': curvature,\n#         }\n\n#         new_df = new_df.append(new_row, ignore_index=True)\n        \n#     new_df.to_csv(result_dem_feature_csv_path)\n# else:\n# \tprint(\"dem_template.csv exists. Skipping...\")\n    \n\n\n# # Get elevation, slope, aspect, and curvature based on the given lat and lon\n# latitude_to_find = 34.5  # Replace with the desired latitude\n# longitude_to_find = -120.5  # Replace with the desired longitude\n\n# elevation, slope, aspect, curvature = get_elevation_slope_aspect_curvature(elevation_df, latitude_to_find,\n#                                                                            longitude_to_find)\n\n# print(\"Latitude:\", latitude_to_find)\n# print(\"Longitude:\", longitude_to_find)\n# print(\"Elevation:\", elevation)\n# print(\"Slope:\", slope)\n# print(\"Aspect:\", aspect)\n# print(\"Curvature:\", curvature)\n#convert_the_original_dem_to_template_spatial_extent()\n",
  "history_output" : "ERROR 5: /home/chetana/gridmet_test_run/output_4km_clipped.tif, band 1: Access window out of range in RasterIO().  Requested\n(692,0) of size 3x3 on raster of 694x666.\nDEM geotif is saved to a csv file with only elevation /home/chetana/gridmet_test_run/dem_template.csv\nTraceback (most recent call last):\n  File \"/home/chetana/gw-workspace/xdkpoiHuSpfi/western_us_dem.py\", line 122, in <module>\n    final_dem_all_cols = read_elevation_data(\"/home/chetana/gridmet_test_run/output_4km_clipped.tif\")\n  File \"/home/chetana/gw-workspace/xdkpoiHuSpfi/western_us_dem.py\", line 93, in read_elevation_data\n    slope_data, aspect_data = calculate_slope_aspect(small_elevation_data, pixel_size_x, pixel_size_y)\n  File \"/home/chetana/gw-workspace/xdkpoiHuSpfi/western_us_dem.py\", line 17, in calculate_slope_aspect\n    slope_x = np.gradient(elevation_data, pixel_size_x, axis=1)\n  File \"<__array_function__ internals>\", line 5, in gradient\n  File \"/home/chetana/anaconda3/lib/python3.9/site-packages/numpy/lib/function_base.py\", line 995, in gradient\n    axes = _nx.normalize_axis_tuple(axis, N)\n  File \"/home/chetana/anaconda3/lib/python3.9/site-packages/numpy/core/numeric.py\", line 1385, in normalize_axis_tuple\n    axis = tuple([normalize_axis_index(ax, ndim, argname) for ax in axis])\n  File \"/home/chetana/anaconda3/lib/python3.9/site-packages/numpy/core/numeric.py\", line 1385, in <listcomp>\n    axis = tuple([normalize_axis_index(ax, ndim, argname) for ax in axis])\nnumpy.AxisError: axis 1 is out of bounds for array of dimension 0\n",
  "history_begin_time" : 1690253352652,
  "history_end_time" : 1690253355837,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : null,
  "indicator" : "Failed"
},{
  "history_id" : "dUIViGLYzXag",
  "history_input" : "import numpy as np\nimport pandas as pd\nfrom osgeo import gdal\nimport warnings\n\n# Temporarily ignore the FutureWarning\nwith warnings.catch_warnings():\n    warnings.simplefilter(\"ignore\")\n    df = df.append(new_row, ignore_index=True)\n\ndef lat_lon_to_pixel(lat, lon, geotransform):\n    x = int((lon - geotransform[0]) / geotransform[1])\n    y = int((lat - geotransform[3]) / geotransform[5])\n    return x, y\n\n\ndef calculate_slope_aspect(elevation_data, pixel_size_x, pixel_size_y):\n    # Calculate slope using the Sobel operator\n    slope_x = np.gradient(elevation_data, pixel_size_x, axis=1)\n    slope_y = np.gradient(elevation_data, pixel_size_y, axis=0)\n    slope_rad = np.arctan(np.sqrt(slope_x ** 2 + slope_y ** 2))\n    slope_deg = np.degrees(slope_rad)\n\n    # Calculate aspect (direction of the steepest descent)\n    aspect_rad = np.arctan2(slope_y, -slope_x)\n    aspect_deg = (np.degrees(aspect_rad) + 360) % 360\n\n    return slope_deg, aspect_deg\n\n\ndef calculate_curvature(elevation_data, pixel_size_x, pixel_size_y):\n    # Calculate curvature using the Laplacian operator\n    curvature_x = np.gradient(np.gradient(elevation_data, pixel_size_x, axis=1), pixel_size_x, axis=1)\n    curvature_y = np.gradient(np.gradient(elevation_data, pixel_size_y, axis=0), pixel_size_y, axis=0)\n    curvature = curvature_x + curvature_y\n\n    return curvature\n\n\ndef read_elevation_data(file_path, neighborhood_size=3):\n    dataset = gdal.Open(file_path)\n    if dataset is None:\n        print(\"Error: Could not open the file.\")\n        return None\n\t\n    result_dem_csv_path = \"/home/chetana/gridmet_test_run/dem_template.csv\"\n    result_dem_feature_csv_path = \"/home/chetana/gridmet_test_run/dem_all.csv\"\n    \n    band = dataset.GetRasterBand(1)\n    elevation_data = band.ReadAsArray()\n\n    # Get geotransform information\n    geotransform = dataset.GetGeoTransform()\n    min_lon, pixel_size_x, _, max_lat, _, pixel_size_y = geotransform\n\n    # Calculate raster size\n    raster_width = dataset.RasterXSize\n    raster_height = dataset.RasterYSize\n\n    # Generate latitude and longitude arrays\n    lats = np.arange(max_lat, max_lat - pixel_size_y * raster_height, -pixel_size_y)\n    lons = np.arange(min_lon, min_lon + pixel_size_x * raster_width, pixel_size_x)\n\n    # Create meshgrid of latitude and longitude\n    lon_grid, lat_grid = np.meshgrid(lons, lats)\n\n    # Flatten the data and the lat/lon grids\n    elevation_data_flat = elevation_data.flatten()\n    lat_grid_flat = lat_grid.flatten()\n    lon_grid_flat = lon_grid.flatten()\n\n    # Create a DataFrame to store the data\n    df = pd.DataFrame({\n      'Latitude': lat_grid_flat,\n      'Longitude': lon_grid_flat,\n      'Elevation': elevation_data_flat,\n    })\n    \n    df.to_csv(result_dem_csv_path)\n    print(f\"DEM geotif is saved to a csv file with only elevation {result_dem_csv_path}\")\n    \n    # Create an empty DataFrame with column names\n    columns = ['lat', 'lon', 'elevation', 'slope', 'aspect', 'curvature', 'northness', 'eastness']\n    all_df = pd.DataFrame(columns=columns)\n\n    for index, row in df.iterrows():\n      # Access individual row elements using row['column_name']\n      # Convert latitude and longitude to pixel indices\n      x, y = lat_lon_to_pixel(row['Latitude'], row['Longitude'], geotransform)\n\n      # Read a small neighborhood of elevation data around the selected point\n      small_elevation_data = band.ReadAsArray(x - neighborhood_size // 2, y - neighborhood_size // 2, neighborhood_size, neighborhood_size)\n\n      # Calculate slope and aspect\n      slope_data, aspect_data = calculate_slope_aspect(small_elevation_data, pixel_size_x, pixel_size_y)\n\n      # Calculate curvature\n      curvature_data = calculate_curvature(small_elevation_data, pixel_size_x, pixel_size_y)\n      northness_data = np.abs(np.sin(np.radians(aspect_data)))\n      eastness_data = np.abs(np.cos(np.radians(aspect_data)))\n      \n\n      # Append a row to the DataFrame\n      data_row = {\n          'lat': row['Latitude'],\n          'lon': row['Longitude'],\n          'elevation': small_elevation_data[neighborhood_size // 2, neighborhood_size // 2],\n          'slope': slope_data[neighborhood_size // 2, neighborhood_size // 2],\n          'aspect': aspect_data[neighborhood_size // 2, neighborhood_size // 2],\n          'curvature': curvature_data[neighborhood_size // 2, neighborhood_size // 2],\n          'northness': northness_data[neighborhood_size // 2, neighborhood_size // 2],\n          'eastness': eastness_data[neighborhood_size // 2, neighborhood_size // 2]\n      }\n      all_df = all_df.append(data_row, ignore_index=True)\n    \n    all_df.to_csv(result_dem_feature_csv_path)\n    print(f\"DEM and other columns are saved to file {result_dem_feature_csv_path}\")\n    return all_df\n\n\n\n# Usage example:\n\nfinal_dem_all_cols = read_elevation_data(\"/home/chetana/gridmet_test_run/output_4km_clipped.tif\")\n\n#clim_data = pd.read_csv(result_dem_feature_csv_path)\n\n# Apply read_elevation_data function to calculate elevation, slope, aspect, and curvature\n#elevation_data = clim_data.apply(lambda row: read_elevation_data(\"/home/chetana/gridmet_test_run/output_4km_clipped.tif\", row['lat'], row['lon']), axis=1, result_type='expand')\n\n# Merge elevation data with the original DataFrame\n#final_testing_df = pd.concat([clim_data, elevation_data], axis=1)\n\n# Save the updated DataFrame to a new CSV file\n#final_testing_df.to_csv('final_testing.csv', index=False)\n\n# if not os.path.exists(result_dem_csv_path):\n#     elevation_df = read_elevation_data(\"/home/chetana/gridmet_test_run/output_4km_clipped.tif\")\n#     print(elevation_df)\n#     elevation_df.to_csv(result_dem_csv_path)\n#     data = {\n#         'Latitude': [],\n#         'Longitude': [],\n#         'Elevation': [],\n#         'Slope': [],\n#         'Aspect': [],\n#       \t'Curvature': [],\n#     }\n#     new_df = pd.DataFrame(data)\n#     for index, row in elevation_df.iterrows():\n#         latitude = row['Latitude']  # Replace 'Latitude' with the actual name of your latitude column\n#         longitude = row['Longitude']  # Replace 'Longitude' with the actual name of your longitude column\n#         elevation, slope, aspect, curvature = get_elevation_slope_aspect_curvature(elevation_df, latitude, longitude)\n#         new_row = {\n#             'Latitude': latitude,\n#             'Longitude': longitude,\n#             'Elevation': elevation,\n#             'Slope': slope,\n#             'Aspect': aspect,\n#             'Curvature': curvature,\n#         }\n\n#         new_df = new_df.append(new_row, ignore_index=True)\n        \n#     new_df.to_csv(result_dem_feature_csv_path)\n# else:\n# \tprint(\"dem_template.csv exists. Skipping...\")\n    \n\n\n# # Get elevation, slope, aspect, and curvature based on the given lat and lon\n# latitude_to_find = 34.5  # Replace with the desired latitude\n# longitude_to_find = -120.5  # Replace with the desired longitude\n\n# elevation, slope, aspect, curvature = get_elevation_slope_aspect_curvature(elevation_df, latitude_to_find,\n#                                                                            longitude_to_find)\n\n# print(\"Latitude:\", latitude_to_find)\n# print(\"Longitude:\", longitude_to_find)\n# print(\"Elevation:\", elevation)\n# print(\"Slope:\", slope)\n# print(\"Aspect:\", aspect)\n# print(\"Curvature:\", curvature)\n#convert_the_original_dem_to_template_spatial_extent()\n",
  "history_output" : "Traceback (most recent call last):\n  File \"/home/chetana/gw-workspace/dUIViGLYzXag/western_us_dem.py\", line 9, in <module>\n    df = df.append(new_row, ignore_index=True)\nNameError: name 'df' is not defined\n",
  "history_begin_time" : 1690253268266,
  "history_end_time" : 1690253268809,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : null,
  "indicator" : "Failed"
},{
  "history_id" : "OZsFWg1lstjS",
  "history_input" : "import numpy as np\nimport pandas as pd\nfrom osgeo import gdal\n\n\ndef lat_lon_to_pixel(lat, lon, geotransform):\n    x = int((lon - geotransform[0]) / geotransform[1])\n    y = int((lat - geotransform[3]) / geotransform[5])\n    return x, y\n\n\ndef calculate_slope_aspect(elevation_data, pixel_size_x, pixel_size_y):\n    # Calculate slope using the Sobel operator\n    slope_x = np.gradient(elevation_data, pixel_size_x, axis=1)\n    slope_y = np.gradient(elevation_data, pixel_size_y, axis=0)\n    slope_rad = np.arctan(np.sqrt(slope_x ** 2 + slope_y ** 2))\n    slope_deg = np.degrees(slope_rad)\n\n    # Calculate aspect (direction of the steepest descent)\n    aspect_rad = np.arctan2(slope_y, -slope_x)\n    aspect_deg = (np.degrees(aspect_rad) + 360) % 360\n\n    return slope_deg, aspect_deg\n\n\ndef calculate_curvature(elevation_data, pixel_size_x, pixel_size_y):\n    # Calculate curvature using the Laplacian operator\n    curvature_x = np.gradient(np.gradient(elevation_data, pixel_size_x, axis=1), pixel_size_x, axis=1)\n    curvature_y = np.gradient(np.gradient(elevation_data, pixel_size_y, axis=0), pixel_size_y, axis=0)\n    curvature = curvature_x + curvature_y\n\n    return curvature\n\n\ndef read_elevation_data(file_path, neighborhood_size=3):\n    dataset = gdal.Open(file_path)\n    if dataset is None:\n        print(\"Error: Could not open the file.\")\n        return None\n\t\n    result_dem_csv_path = \"/home/chetana/gridmet_test_run/dem_template.csv\"\n    result_dem_feature_csv_path = \"/home/chetana/gridmet_test_run/dem_all.csv\"\n    \n    band = dataset.GetRasterBand(1)\n    elevation_data = band.ReadAsArray()\n\n    # Get geotransform information\n    geotransform = dataset.GetGeoTransform()\n    min_lon, pixel_size_x, _, max_lat, _, pixel_size_y = geotransform\n\n    # Calculate raster size\n    raster_width = dataset.RasterXSize\n    raster_height = dataset.RasterYSize\n\n    # Generate latitude and longitude arrays\n    lats = np.arange(max_lat, max_lat - pixel_size_y * raster_height, -pixel_size_y)\n    lons = np.arange(min_lon, min_lon + pixel_size_x * raster_width, pixel_size_x)\n\n    # Create meshgrid of latitude and longitude\n    lon_grid, lat_grid = np.meshgrid(lons, lats)\n\n    # Flatten the data and the lat/lon grids\n    elevation_data_flat = elevation_data.flatten()\n    lat_grid_flat = lat_grid.flatten()\n    lon_grid_flat = lon_grid.flatten()\n\n    # Create a DataFrame to store the data\n    df = pd.DataFrame({\n      'Latitude': lat_grid_flat,\n      'Longitude': lon_grid_flat,\n      'Elevation': elevation_data_flat,\n    })\n    \n    df.to_csv(result_dem_csv_path)\n    \n    # Create an empty DataFrame with column names\n    columns = ['lat', 'lon', 'elevation', 'slope', 'aspect', 'curvature', 'northness', 'eastness']\n    all_df = pd.DataFrame(columns=columns)\n\n    for index, row in df.iterrows():\n      # Access individual row elements using row['column_name']\n      # Convert latitude and longitude to pixel indices\n      x, y = lat_lon_to_pixel(row['Latitude'], row['Longitude'], geotransform)\n\n      # Read a small neighborhood of elevation data around the selected point\n      small_elevation_data = band.ReadAsArray(x - neighborhood_size // 2, y - neighborhood_size // 2, neighborhood_size, neighborhood_size)\n\n      # Calculate slope and aspect\n      slope_data, aspect_data = calculate_slope_aspect(small_elevation_data, pixel_size_x, pixel_size_y)\n\n      # Calculate curvature\n      curvature_data = calculate_curvature(small_elevation_data, pixel_size_x, pixel_size_y)\n      northness_data = np.abs(np.sin(np.radians(aspect_data)))\n      eastness_data = np.abs(np.cos(np.radians(aspect_data)))\n      \n\n      # Append a row to the DataFrame\n      data_row = {\n          'lat': lat,\n          'lon': lon,\n          'elevation': small_elevation_data[neighborhood_size // 2, neighborhood_size // 2],\n          'slope': slope_data[neighborhood_size // 2, neighborhood_size // 2],\n          'aspect': aspect_data[neighborhood_size // 2, neighborhood_size // 2],\n          'curvature': curvature_data[neighborhood_size // 2, neighborhood_size // 2],\n          'northness': northness_data[neighborhood_size // 2, neighborhood_size // 2],\n          'eastness': eastness_data[neighborhood_size // 2, neighborhood_size // 2]\n      }\n      all_df = all_df.append(data_row, ignore_index=True)\n    \n    all_df.to_csv(result_dem_feature_csv_path)\n    return all_df\n\n\n\n# Usage example:\n\nfinal_dem_all_cols = read_elevation_data(\"/home/chetana/gridmet_test_run/output_4km_clipped.tif\")\n\n#clim_data = pd.read_csv(result_dem_feature_csv_path)\n\n# Apply read_elevation_data function to calculate elevation, slope, aspect, and curvature\n#elevation_data = clim_data.apply(lambda row: read_elevation_data(\"/home/chetana/gridmet_test_run/output_4km_clipped.tif\", row['lat'], row['lon']), axis=1, result_type='expand')\n\n# Merge elevation data with the original DataFrame\n#final_testing_df = pd.concat([clim_data, elevation_data], axis=1)\n\n# Save the updated DataFrame to a new CSV file\n#final_testing_df.to_csv('final_testing.csv', index=False)\n\n# if not os.path.exists(result_dem_csv_path):\n#     elevation_df = read_elevation_data(\"/home/chetana/gridmet_test_run/output_4km_clipped.tif\")\n#     print(elevation_df)\n#     elevation_df.to_csv(result_dem_csv_path)\n#     data = {\n#         'Latitude': [],\n#         'Longitude': [],\n#         'Elevation': [],\n#         'Slope': [],\n#         'Aspect': [],\n#       \t'Curvature': [],\n#     }\n#     new_df = pd.DataFrame(data)\n#     for index, row in elevation_df.iterrows():\n#         latitude = row['Latitude']  # Replace 'Latitude' with the actual name of your latitude column\n#         longitude = row['Longitude']  # Replace 'Longitude' with the actual name of your longitude column\n#         elevation, slope, aspect, curvature = get_elevation_slope_aspect_curvature(elevation_df, latitude, longitude)\n#         new_row = {\n#             'Latitude': latitude,\n#             'Longitude': longitude,\n#             'Elevation': elevation,\n#             'Slope': slope,\n#             'Aspect': aspect,\n#             'Curvature': curvature,\n#         }\n\n#         new_df = new_df.append(new_row, ignore_index=True)\n        \n#     new_df.to_csv(result_dem_feature_csv_path)\n# else:\n# \tprint(\"dem_template.csv exists. Skipping...\")\n    \n\n\n# # Get elevation, slope, aspect, and curvature based on the given lat and lon\n# latitude_to_find = 34.5  # Replace with the desired latitude\n# longitude_to_find = -120.5  # Replace with the desired longitude\n\n# elevation, slope, aspect, curvature = get_elevation_slope_aspect_curvature(elevation_df, latitude_to_find,\n#                                                                            longitude_to_find)\n\n# print(\"Latitude:\", latitude_to_find)\n# print(\"Longitude:\", longitude_to_find)\n# print(\"Elevation:\", elevation)\n# print(\"Slope:\", slope)\n# print(\"Aspect:\", aspect)\n# print(\"Curvature:\", curvature)\n#convert_the_original_dem_to_template_spatial_extent()\n",
  "history_output" : "Traceback (most recent call last):\n  File \"/home/chetana/gw-workspace/OZsFWg1lstjS/western_us_dem.py\", line 117, in <module>\n    final_dem_all_cols = read_elevation_data(\"/home/chetana/gridmet_test_run/output_4km_clipped.tif\")\n  File \"/home/chetana/gw-workspace/OZsFWg1lstjS/western_us_dem.py\", line 99, in read_elevation_data\n    'lat': lat,\nNameError: name 'lat' is not defined\n",
  "history_begin_time" : 1690252860893,
  "history_end_time" : 1690252863451,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : null,
  "indicator" : "Failed"
},{
  "history_id" : "6SGlgnmGCsB4",
  "history_input" : "import numpy as np\nimport pandas as pd\nfrom osgeo import gdal\n\n\ndef lat_lon_to_pixel(lat, lon, geotransform):\n    x = int((lon - geotransform[0]) / geotransform[1])\n    y = int((lat - geotransform[3]) / geotransform[5])\n    return x, y\n\n\ndef calculate_slope_aspect(elevation_data, pixel_size_x, pixel_size_y):\n    # Calculate slope using the Sobel operator\n    slope_x = np.gradient(elevation_data, pixel_size_x, axis=1)\n    slope_y = np.gradient(elevation_data, pixel_size_y, axis=0)\n    slope_rad = np.arctan(np.sqrt(slope_x ** 2 + slope_y ** 2))\n    slope_deg = np.degrees(slope_rad)\n\n    # Calculate aspect (direction of the steepest descent)\n    aspect_rad = np.arctan2(slope_y, -slope_x)\n    aspect_deg = (np.degrees(aspect_rad) + 360) % 360\n\n    return slope_deg, aspect_deg\n\n\ndef calculate_curvature(elevation_data, pixel_size_x, pixel_size_y):\n    # Calculate curvature using the Laplacian operator\n    curvature_x = np.gradient(np.gradient(elevation_data, pixel_size_x, axis=1), pixel_size_x, axis=1)\n    curvature_y = np.gradient(np.gradient(elevation_data, pixel_size_y, axis=0), pixel_size_y, axis=0)\n    curvature = curvature_x + curvature_y\n\n    return curvature\n\n\ndef read_elevation_data(file_path, neighborhood_size=3):\n    dataset = gdal.Open(file_path)\n    if dataset is None:\n        print(\"Error: Could not open the file.\")\n        return None\n\t\n    result_dem_csv_path = \"/home/chetana/gridmet_test_run/dem_template.csv\"\n    result_dem_feature_csv_path = \"/home/chetana/gridmet_test_run/dem_all.csv\"\n    \n    band = dataset.GetRasterBand(1)\n    elevation_data = band.ReadAsArray()\n\n    # Get geotransform information\n    geotransform = dataset.GetGeoTransform()\n    min_lon, pixel_size_x, _, max_lat, _, pixel_size_y = geotransform\n\n    # Calculate raster size\n    raster_width = dataset.RasterXSize\n    raster_height = dataset.RasterYSize\n\n    # Generate latitude and longitude arrays\n    lats = np.arange(max_lat, max_lat - pixel_size_y * raster_height, -pixel_size_y)\n    lons = np.arange(min_lon, min_lon + pixel_size_x * raster_width, pixel_size_x)\n\n    # Create meshgrid of latitude and longitude\n    lon_grid, lat_grid = np.meshgrid(lons, lats)\n\n    # Flatten the data and the lat/lon grids\n    elevation_data_flat = elevation_data.flatten()\n    lat_grid_flat = lat_grid.flatten()\n    lon_grid_flat = lon_grid.flatten()\n\n    # Create a DataFrame to store the data\n    df = pd.DataFrame({\n      'Latitude': lat_grid_flat,\n      'Longitude': lon_grid_flat,\n      'Elevation': elevation_data_flat,\n    })\n    \n    df.to_csv(result_dem_csv_path)\n    \n    # Create an empty DataFrame with column names\n    columns = ['lat', 'lon', 'elevation', 'slope', 'aspect', 'curvature', 'northness', 'eastness']\n    all_df = pd.DataFrame(columns=columns)\n\n    for index, row in iterrows(df):\n      # Access individual row elements using row['column_name']\n      # Convert latitude and longitude to pixel indices\n      x, y = lat_lon_to_pixel(row['Latitude'], row['Longitude'], geotransform)\n\n      # Read a small neighborhood of elevation data around the selected point\n      small_elevation_data = band.ReadAsArray(x - neighborhood_size // 2, y - neighborhood_size // 2, neighborhood_size, neighborhood_size)\n\n      # Calculate slope and aspect\n      slope_data, aspect_data = calculate_slope_aspect(small_elevation_data, pixel_size_x, pixel_size_y)\n\n      # Calculate curvature\n      curvature_data = calculate_curvature(small_elevation_data, pixel_size_x, pixel_size_y)\n      northness_data = np.abs(np.sin(np.radians(aspect_data)))\n      eastness_data = np.abs(np.cos(np.radians(aspect_data)))\n      \n\n      # Append a row to the DataFrame\n      data_row = {\n          'lat': lat,\n          'lon': lon,\n          'elevation': small_elevation_data[neighborhood_size // 2, neighborhood_size // 2],\n          'slope': slope_data[neighborhood_size // 2, neighborhood_size // 2],\n          'aspect': aspect_data[neighborhood_size // 2, neighborhood_size // 2],\n          'curvature': curvature_data[neighborhood_size // 2, neighborhood_size // 2],\n          'northness': northness_data[neighborhood_size // 2, neighborhood_size // 2],\n          'eastness': eastness_data[neighborhood_size // 2, neighborhood_size // 2]\n      }\n      all_df = all_df.append(data_row, ignore_index=True)\n    \n    all_df.to_csv(result_dem_feature_csv_path)\n    return all_df\n\n\n\n# Usage example:\n\nfinal_dem_all_cols = read_elevation_data(\"/home/chetana/gridmet_test_run/output_4km_clipped.tif\")\n\n#clim_data = pd.read_csv(result_dem_feature_csv_path)\n\n# Apply read_elevation_data function to calculate elevation, slope, aspect, and curvature\n#elevation_data = clim_data.apply(lambda row: read_elevation_data(\"/home/chetana/gridmet_test_run/output_4km_clipped.tif\", row['lat'], row['lon']), axis=1, result_type='expand')\n\n# Merge elevation data with the original DataFrame\n#final_testing_df = pd.concat([clim_data, elevation_data], axis=1)\n\n# Save the updated DataFrame to a new CSV file\n#final_testing_df.to_csv('final_testing.csv', index=False)\n\n# if not os.path.exists(result_dem_csv_path):\n#     elevation_df = read_elevation_data(\"/home/chetana/gridmet_test_run/output_4km_clipped.tif\")\n#     print(elevation_df)\n#     elevation_df.to_csv(result_dem_csv_path)\n#     data = {\n#         'Latitude': [],\n#         'Longitude': [],\n#         'Elevation': [],\n#         'Slope': [],\n#         'Aspect': [],\n#       \t'Curvature': [],\n#     }\n#     new_df = pd.DataFrame(data)\n#     for index, row in elevation_df.iterrows():\n#         latitude = row['Latitude']  # Replace 'Latitude' with the actual name of your latitude column\n#         longitude = row['Longitude']  # Replace 'Longitude' with the actual name of your longitude column\n#         elevation, slope, aspect, curvature = get_elevation_slope_aspect_curvature(elevation_df, latitude, longitude)\n#         new_row = {\n#             'Latitude': latitude,\n#             'Longitude': longitude,\n#             'Elevation': elevation,\n#             'Slope': slope,\n#             'Aspect': aspect,\n#             'Curvature': curvature,\n#         }\n\n#         new_df = new_df.append(new_row, ignore_index=True)\n        \n#     new_df.to_csv(result_dem_feature_csv_path)\n# else:\n# \tprint(\"dem_template.csv exists. Skipping...\")\n    \n\n\n# # Get elevation, slope, aspect, and curvature based on the given lat and lon\n# latitude_to_find = 34.5  # Replace with the desired latitude\n# longitude_to_find = -120.5  # Replace with the desired longitude\n\n# elevation, slope, aspect, curvature = get_elevation_slope_aspect_curvature(elevation_df, latitude_to_find,\n#                                                                            longitude_to_find)\n\n# print(\"Latitude:\", latitude_to_find)\n# print(\"Longitude:\", longitude_to_find)\n# print(\"Elevation:\", elevation)\n# print(\"Slope:\", slope)\n# print(\"Aspect:\", aspect)\n# print(\"Curvature:\", curvature)\n#convert_the_original_dem_to_template_spatial_extent()\n",
  "history_output" : "Traceback (most recent call last):\n  File \"/home/chetana/gw-workspace/6SGlgnmGCsB4/western_us_dem.py\", line 117, in <module>\n    final_dem_all_cols = read_elevation_data(\"/home/chetana/gridmet_test_run/output_4km_clipped.tif\")\n  File \"/home/chetana/gw-workspace/6SGlgnmGCsB4/western_us_dem.py\", line 80, in read_elevation_data\n    for index, row in iterrows(df):\nNameError: name 'iterrows' is not defined\n",
  "history_begin_time" : 1690252691933,
  "history_end_time" : 1690252697472,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : null,
  "indicator" : "Failed"
},{
  "history_id" : "MOTdsXMYFCWm",
  "history_input" : "import numpy as np\nimport pandas as pd\nfrom osgeo import gdal\n\n\ndef lat_lon_to_pixel(lat, lon, geotransform):\n    x = int((lon - geotransform[0]) / geotransform[1])\n    y = int((lat - geotransform[3]) / geotransform[5])\n    return x, y\n\n\ndef calculate_slope_aspect(elevation_data, pixel_size_x, pixel_size_y):\n    # Calculate slope using the Sobel operator\n    slope_x = np.gradient(elevation_data, pixel_size_x, axis=1)\n    slope_y = np.gradient(elevation_data, pixel_size_y, axis=0)\n    slope_rad = np.arctan(np.sqrt(slope_x ** 2 + slope_y ** 2))\n    slope_deg = np.degrees(slope_rad)\n\n    # Calculate aspect (direction of the steepest descent)\n    aspect_rad = np.arctan2(slope_y, -slope_x)\n    aspect_deg = (np.degrees(aspect_rad) + 360) % 360\n\n    return slope_deg, aspect_deg\n\n\ndef calculate_curvature(elevation_data, pixel_size_x, pixel_size_y):\n    # Calculate curvature using the Laplacian operator\n    curvature_x = np.gradient(np.gradient(elevation_data, pixel_size_x, axis=1), pixel_size_x, axis=1)\n    curvature_y = np.gradient(np.gradient(elevation_data, pixel_size_y, axis=0), pixel_size_y, axis=0)\n    curvature = curvature_x + curvature_y\n\n    return curvature\n\n\ndef read_elevation_data(file_path, neighborhood_size=3):\n    dataset = gdal.Open(file_path)\n    if dataset is None:\n        print(\"Error: Could not open the file.\")\n        return None\n\t\n    result_dem_csv_path = \"/home/chetana/gridmet_test_run/dem_template.csv\"\n    result_dem_feature_csv_path = \"/home/chetana/gridmet_test_run/dem_all.csv\"\n    \n    band = dataset.GetRasterBand(1)\n    elevation_data = band.ReadAsArray()\n\n    # Get geotransform information\n    geotransform = dataset.GetGeoTransform()\n    min_lon, pixel_size_x, _, max_lat, _, pixel_size_y = geotransform\n\n    # Calculate raster size\n    raster_width = dataset.RasterXSize\n    raster_height = dataset.RasterYSize\n\n    # Generate latitude and longitude arrays\n    lats = np.arange(max_lat, max_lat - pixel_size_y * raster_height, -pixel_size_y)\n    lons = np.arange(min_lon, min_lon + pixel_size_x * raster_width, pixel_size_x)\n\n    # Create meshgrid of latitude and longitude\n    lon_grid, lat_grid = np.meshgrid(lons, lats)\n\n    # Flatten the data and the lat/lon grids\n    elevation_data_flat = elevation_data.flatten()\n    lat_grid_flat = lat_grid.flatten()\n    lon_grid_flat = lon_grid.flatten()\n\n    # Create a DataFrame to store the data\n    df = pd.DataFrame({\n      'Latitude': lat_grid_flat,\n      'Longitude': lon_grid_flat,\n      'Elevation': elevation_data_flat,\n    })\n    \n    df.to_csv(result_dem_csv_path)\n    \n    # Create an empty DataFrame with column names\n    columns = ['lat', 'lon', 'elevation', 'slope', 'aspect', 'curvature', 'northness', 'eastness']\n    all_df = pd.DataFrame(columns=columns)\n\n    for index, row in iterrows(df):\n      # Access individual row elements using row['column_name']\n      # Convert latitude and longitude to pixel indices\n      x, y = lat_lon_to_pixel(row['Latitude'], row['Longitude'], geotransform)\n\n      # Read a small neighborhood of elevation data around the selected point\n      small_elevation_data = band.ReadAsArray(x - neighborhood_size // 2, y - neighborhood_size // 2, neighborhood_size, neighborhood_size)\n\n      # Calculate slope and aspect\n      slope_data, aspect_data = calculate_slope_aspect(small_elevation_data, pixel_size_x, pixel_size_y)\n\n      # Calculate curvature\n      curvature_data = calculate_curvature(small_elevation_data, pixel_size_x, pixel_size_y)\n      northness_data = np.abs(np.sin(np.radians(aspect_data)))\n      eastness_data = np.abs(np.cos(np.radians(aspect_data)))\n      \n\n      # Append a row to the DataFrame\n      data_row = {\n          'lat': lat,\n          'lon': lon,\n          'elevation': small_elevation_data[neighborhood_size // 2, neighborhood_size // 2],\n          'slope': slope_data[neighborhood_size // 2, neighborhood_size // 2],\n          'aspect': aspect_data[neighborhood_size // 2, neighborhood_size // 2],\n          'curvature': curvature_data[neighborhood_size // 2, neighborhood_size // 2],\n          'northness': northness_data[neighborhood_size // 2, neighborhood_size // 2],\n          'eastness': eastness_data[neighborhood_size // 2, neighborhood_size // 2]\n      }\n      all_df = all_df.append(data_row, ignore_index=True)\n    \n    all_df.to_csv(result_dem_feature_csv_path)\n\treturn all_df\n\n\n\n# Usage example:\n\nfinal_dem_all_cols = read_elevation_data(\"/home/chetana/gridmet_test_run/output_4km_clipped.tif\")\n\n#clim_data = pd.read_csv(result_dem_feature_csv_path)\n\n# Apply read_elevation_data function to calculate elevation, slope, aspect, and curvature\n#elevation_data = clim_data.apply(lambda row: read_elevation_data(\"/home/chetana/gridmet_test_run/output_4km_clipped.tif\", row['lat'], row['lon']), axis=1, result_type='expand')\n\n# Merge elevation data with the original DataFrame\n#final_testing_df = pd.concat([clim_data, elevation_data], axis=1)\n\n# Save the updated DataFrame to a new CSV file\n#final_testing_df.to_csv('final_testing.csv', index=False)\n\n# if not os.path.exists(result_dem_csv_path):\n#     elevation_df = read_elevation_data(\"/home/chetana/gridmet_test_run/output_4km_clipped.tif\")\n#     print(elevation_df)\n#     elevation_df.to_csv(result_dem_csv_path)\n#     data = {\n#         'Latitude': [],\n#         'Longitude': [],\n#         'Elevation': [],\n#         'Slope': [],\n#         'Aspect': [],\n#       \t'Curvature': [],\n#     }\n#     new_df = pd.DataFrame(data)\n#     for index, row in elevation_df.iterrows():\n#         latitude = row['Latitude']  # Replace 'Latitude' with the actual name of your latitude column\n#         longitude = row['Longitude']  # Replace 'Longitude' with the actual name of your longitude column\n#         elevation, slope, aspect, curvature = get_elevation_slope_aspect_curvature(elevation_df, latitude, longitude)\n#         new_row = {\n#             'Latitude': latitude,\n#             'Longitude': longitude,\n#             'Elevation': elevation,\n#             'Slope': slope,\n#             'Aspect': aspect,\n#             'Curvature': curvature,\n#         }\n\n#         new_df = new_df.append(new_row, ignore_index=True)\n        \n#     new_df.to_csv(result_dem_feature_csv_path)\n# else:\n# \tprint(\"dem_template.csv exists. Skipping...\")\n    \n\n\n# # Get elevation, slope, aspect, and curvature based on the given lat and lon\n# latitude_to_find = 34.5  # Replace with the desired latitude\n# longitude_to_find = -120.5  # Replace with the desired longitude\n\n# elevation, slope, aspect, curvature = get_elevation_slope_aspect_curvature(elevation_df, latitude_to_find,\n#                                                                            longitude_to_find)\n\n# print(\"Latitude:\", latitude_to_find)\n# print(\"Longitude:\", longitude_to_find)\n# print(\"Elevation:\", elevation)\n# print(\"Slope:\", slope)\n# print(\"Aspect:\", aspect)\n# print(\"Curvature:\", curvature)\n#convert_the_original_dem_to_template_spatial_extent()\n",
  "history_output" : "  File \"/home/chetana/gw-workspace/MOTdsXMYFCWm/western_us_dem.py\", line 111\n    return all_df\nTabError: inconsistent use of tabs and spaces in indentation\n",
  "history_begin_time" : 1690252656308,
  "history_end_time" : 1690252656365,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : null,
  "indicator" : "Failed"
},{
  "history_id" : "tUqdeAUm3jbX",
  "history_input" : "import numpy as np\nimport pandas as pd\nfrom osgeo import gdal\n\n\ndef lat_lon_to_pixel(lat, lon, geotransform):\n    x = int((lon - geotransform[0]) / geotransform[1])\n    y = int((lat - geotransform[3]) / geotransform[5])\n    return x, y\n\n\ndef calculate_slope_aspect(elevation_data, pixel_size_x, pixel_size_y):\n    # Calculate slope using the Sobel operator\n    slope_x = np.gradient(elevation_data, pixel_size_x, axis=1)\n    slope_y = np.gradient(elevation_data, pixel_size_y, axis=0)\n    slope_rad = np.arctan(np.sqrt(slope_x ** 2 + slope_y ** 2))\n    slope_deg = np.degrees(slope_rad)\n\n    # Calculate aspect (direction of the steepest descent)\n    aspect_rad = np.arctan2(slope_y, -slope_x)\n    aspect_deg = (np.degrees(aspect_rad) + 360) % 360\n\n    return slope_deg, aspect_deg\n\n\ndef calculate_curvature(elevation_data, pixel_size_x, pixel_size_y):\n    # Calculate curvature using the Laplacian operator\n    curvature_x = np.gradient(np.gradient(elevation_data, pixel_size_x, axis=1), pixel_size_x, axis=1)\n    curvature_y = np.gradient(np.gradient(elevation_data, pixel_size_y, axis=0), pixel_size_y, axis=0)\n    curvature = curvature_x + curvature_y\n\n    return curvature\n\n\ndef read_elevation_data(file_path, neighborhood_size=3):\n    dataset = gdal.Open(file_path)\n    if dataset is None:\n        print(\"Error: Could not open the file.\")\n        return None\n\t\n    result_dem_csv_path = \"/home/chetana/gridmet_test_run/dem_template.csv\"\n    result_dem_feature_csv_path = \"/home/chetana/gridmet_test_run/dem_all.csv\"\n    \n    band = dataset.GetRasterBand(1)\n    elevation_data = band.ReadAsArray()\n\n    # Get geotransform information\n    geotransform = dataset.GetGeoTransform()\n    min_lon, pixel_size_x, _, max_lat, _, pixel_size_y = geotransform\n\n    # Calculate raster size\n    raster_width = dataset.RasterXSize\n    raster_height = dataset.RasterYSize\n\n    # Generate latitude and longitude arrays\n    lats = np.arange(max_lat, max_lat - pixel_size_y * raster_height, -pixel_size_y)\n    lons = np.arange(min_lon, min_lon + pixel_size_x * raster_width, pixel_size_x)\n\n    # Create meshgrid of latitude and longitude\n    lon_grid, lat_grid = np.meshgrid(lons, lats)\n\n    # Flatten the data and the lat/lon grids\n    elevation_data_flat = elevation_data.flatten()\n    lat_grid_flat = lat_grid.flatten()\n    lon_grid_flat = lon_grid.flatten()\n\n    # Create a DataFrame to store the data\n    df = pd.DataFrame({\n      'Latitude': lat_grid_flat,\n      'Longitude': lon_grid_flat,\n      'Elevation': elevation_data_flat,\n    })\n    \n    df.to_csv(result_dem_csv_path)\n    \n    # Create an empty DataFrame with column names\n    columns = ['lat', 'lon', 'elevation', 'slope', 'aspect', 'curvature', 'northness', 'eastness']\n    all_df = pd.DataFrame(columns=columns)\n\n    for index, row in iterrows(df):\n      # Access individual row elements using row['column_name']\n      # Convert latitude and longitude to pixel indices\n      x, y = lat_lon_to_pixel(row['Latitude'], row['Longitude'], geotransform)\n\n      # Read a small neighborhood of elevation data around the selected point\n      small_elevation_data = band.ReadAsArray(x - neighborhood_size // 2, y - neighborhood_size // 2, neighborhood_size, neighborhood_size)\n\n      # Calculate slope and aspect\n      slope_data, aspect_data = calculate_slope_aspect(small_elevation_data, pixel_size_x, pixel_size_y)\n\n      # Calculate curvature\n      curvature_data = calculate_curvature(small_elevation_data, pixel_size_x, pixel_size_y)\n      northness_data = np.abs(np.sin(np.radians(aspect_data)))\n      eastness_data = np.abs(np.cos(np.radians(aspect_data)))\n      \n\n      # Append a row to the DataFrame\n      data_row = {\n          'lat': lat,\n          'lon': lon,\n          'elevation': small_elevation_data[neighborhood_size // 2, neighborhood_size // 2],\n          'slope': slope_data[neighborhood_size // 2, neighborhood_size // 2],\n          'aspect': aspect_data[neighborhood_size // 2, neighborhood_size // 2],\n          'curvature': curvature_data[neighborhood_size // 2, neighborhood_size // 2],\n          'northness': northness_data[neighborhood_size // 2, neighborhood_size // 2],\n          'eastness': eastness_data[neighborhood_size // 2, neighborhood_size // 2]\n      }\n      all_df = all_df.append(data_row, ignore_index=True)\n\n\tall_df.to_csv(result_dem_feature_csv_path)\n\treturn all_df\n\n\n\n# Usage example:\n\nfinal_dem_all_cols = read_elevation_data(\"/home/chetana/gridmet_test_run/output_4km_clipped.tif\")\n\n#clim_data = pd.read_csv(result_dem_feature_csv_path)\n\n# Apply read_elevation_data function to calculate elevation, slope, aspect, and curvature\n#elevation_data = clim_data.apply(lambda row: read_elevation_data(\"/home/chetana/gridmet_test_run/output_4km_clipped.tif\", row['lat'], row['lon']), axis=1, result_type='expand')\n\n# Merge elevation data with the original DataFrame\n#final_testing_df = pd.concat([clim_data, elevation_data], axis=1)\n\n# Save the updated DataFrame to a new CSV file\n#final_testing_df.to_csv('final_testing.csv', index=False)\n\n# if not os.path.exists(result_dem_csv_path):\n#     elevation_df = read_elevation_data(\"/home/chetana/gridmet_test_run/output_4km_clipped.tif\")\n#     print(elevation_df)\n#     elevation_df.to_csv(result_dem_csv_path)\n#     data = {\n#         'Latitude': [],\n#         'Longitude': [],\n#         'Elevation': [],\n#         'Slope': [],\n#         'Aspect': [],\n#       \t'Curvature': [],\n#     }\n#     new_df = pd.DataFrame(data)\n#     for index, row in elevation_df.iterrows():\n#         latitude = row['Latitude']  # Replace 'Latitude' with the actual name of your latitude column\n#         longitude = row['Longitude']  # Replace 'Longitude' with the actual name of your longitude column\n#         elevation, slope, aspect, curvature = get_elevation_slope_aspect_curvature(elevation_df, latitude, longitude)\n#         new_row = {\n#             'Latitude': latitude,\n#             'Longitude': longitude,\n#             'Elevation': elevation,\n#             'Slope': slope,\n#             'Aspect': aspect,\n#             'Curvature': curvature,\n#         }\n\n#         new_df = new_df.append(new_row, ignore_index=True)\n        \n#     new_df.to_csv(result_dem_feature_csv_path)\n# else:\n# \tprint(\"dem_template.csv exists. Skipping...\")\n    \n\n\n# # Get elevation, slope, aspect, and curvature based on the given lat and lon\n# latitude_to_find = 34.5  # Replace with the desired latitude\n# longitude_to_find = -120.5  # Replace with the desired longitude\n\n# elevation, slope, aspect, curvature = get_elevation_slope_aspect_curvature(elevation_df, latitude_to_find,\n#                                                                            longitude_to_find)\n\n# print(\"Latitude:\", latitude_to_find)\n# print(\"Longitude:\", longitude_to_find)\n# print(\"Elevation:\", elevation)\n# print(\"Slope:\", slope)\n# print(\"Aspect:\", aspect)\n# print(\"Curvature:\", curvature)\n#convert_the_original_dem_to_template_spatial_extent()\n",
  "history_output" : "  File \"/home/chetana/gw-workspace/tUqdeAUm3jbX/western_us_dem.py\", line 110\n    all_df.to_csv(result_dem_feature_csv_path)\nTabError: inconsistent use of tabs and spaces in indentation\n",
  "history_begin_time" : 1690252562033,
  "history_end_time" : 1690252562089,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : null,
  "indicator" : "Failed"
},{
  "history_id" : "6TlJlkLRlWkO",
  "history_input" : "import numpy as np\nimport pandas as pd\nfrom osgeo import gdal\n\n\ndef lat_lon_to_pixel(lat, lon, geotransform):\n    x = int((lon - geotransform[0]) / geotransform[1])\n    y = int((lat - geotransform[3]) / geotransform[5])\n    return x, y\n\n\ndef calculate_slope_aspect(elevation_data, pixel_size_x, pixel_size_y):\n    # Calculate slope using the Sobel operator\n    slope_x = np.gradient(elevation_data, pixel_size_x, axis=1)\n    slope_y = np.gradient(elevation_data, pixel_size_y, axis=0)\n    slope_rad = np.arctan(np.sqrt(slope_x ** 2 + slope_y ** 2))\n    slope_deg = np.degrees(slope_rad)\n\n    # Calculate aspect (direction of the steepest descent)\n    aspect_rad = np.arctan2(slope_y, -slope_x)\n    aspect_deg = (np.degrees(aspect_rad) + 360) % 360\n\n    return slope_deg, aspect_deg\n\n\ndef calculate_curvature(elevation_data, pixel_size_x, pixel_size_y):\n    # Calculate curvature using the Laplacian operator\n    curvature_x = np.gradient(np.gradient(elevation_data, pixel_size_x, axis=1), pixel_size_x, axis=1)\n    curvature_y = np.gradient(np.gradient(elevation_data, pixel_size_y, axis=0), pixel_size_y, axis=0)\n    curvature = curvature_x + curvature_y\n\n    return curvature\n\n\ndef read_elevation_data(file_path, neighborhood_size=3):\n    dataset = gdal.Open(file_path)\n    if dataset is None:\n        print(\"Error: Could not open the file.\")\n        return None\n\t\n    result_dem_csv_path = \"/home/chetana/gridmet_test_run/dem_template.csv\"\n\tresult_dem_feature_csv_path = \"/home/chetana/gridmet_test_run/dem_all.csv\"\n    \n    band = dataset.GetRasterBand(1)\n    elevation_data = band.ReadAsArray()\n\n    # Get geotransform information\n    geotransform = dataset.GetGeoTransform()\n    min_lon, pixel_size_x, _, max_lat, _, pixel_size_y = geotransform\n\n    # Calculate raster size\n    raster_width = dataset.RasterXSize\n    raster_height = dataset.RasterYSize\n\n    # Generate latitude and longitude arrays\n    lats = np.arange(max_lat, max_lat - pixel_size_y * raster_height, -pixel_size_y)\n    lons = np.arange(min_lon, min_lon + pixel_size_x * raster_width, pixel_size_x)\n\n    # Create meshgrid of latitude and longitude\n    lon_grid, lat_grid = np.meshgrid(lons, lats)\n\n    # Flatten the data and the lat/lon grids\n    elevation_data_flat = elevation_data.flatten()\n    lat_grid_flat = lat_grid.flatten()\n    lon_grid_flat = lon_grid.flatten()\n\n    # Create a DataFrame to store the data\n    df = pd.DataFrame({\n        'Latitude': lat_grid_flat,\n        'Longitude': lon_grid_flat,\n        'Elevation': elevation_data_flat,\n    })\n    \n    df.to_csv(result_dem_csv_path)\n    \n    # Create an empty DataFrame with column names\n    columns = ['lat', 'lon', 'elevation', 'slope', 'aspect', 'curvature', 'northness', 'eastness']\n    all_df = pd.DataFrame(columns=columns)\n\n    for index, row in iterrows(df):\n      # Access individual row elements using row['column_name']\n      # Convert latitude and longitude to pixel indices\n      x, y = lat_lon_to_pixel(row['Latitude'], row['Longitude'], geotransform)\n\n      # Read a small neighborhood of elevation data around the selected point\n      small_elevation_data = band.ReadAsArray(x - neighborhood_size // 2, y - neighborhood_size // 2, neighborhood_size, neighborhood_size)\n\n      # Calculate slope and aspect\n      slope_data, aspect_data = calculate_slope_aspect(small_elevation_data, pixel_size_x, pixel_size_y)\n\n      # Calculate curvature\n      curvature_data = calculate_curvature(small_elevation_data, pixel_size_x, pixel_size_y)\n      northness_data = np.abs(np.sin(np.radians(aspect_data)))\n      eastness_data = np.abs(np.cos(np.radians(aspect_data)))\n      \n\n      # Append a row to the DataFrame\n      data_row = {\n          'lat': lat,\n          'lon': lon,\n          'elevation': small_elevation_data[neighborhood_size // 2, neighborhood_size // 2],\n          'slope': slope_data[neighborhood_size // 2, neighborhood_size // 2],\n          'aspect': aspect_data[neighborhood_size // 2, neighborhood_size // 2],\n          'curvature': curvature_data[neighborhood_size // 2, neighborhood_size // 2],\n          'northness': northness_data[neighborhood_size // 2, neighborhood_size // 2],\n          'eastness': eastness_data[neighborhood_size // 2, neighborhood_size // 2]\n      }\n      all_df = all_df.append(data_row, ignore_index=True)\n\n\tall_df.to_csv(result_dem_feature_csv_path)\n\treturn all_df\n\n\n\n# Usage example:\n\nfinal_dem_all_cols = read_elevation_data(\"/home/chetana/gridmet_test_run/output_4km_clipped.tif\")\n\n#clim_data = pd.read_csv(result_dem_feature_csv_path)\n\n# Apply read_elevation_data function to calculate elevation, slope, aspect, and curvature\n#elevation_data = clim_data.apply(lambda row: read_elevation_data(\"/home/chetana/gridmet_test_run/output_4km_clipped.tif\", row['lat'], row['lon']), axis=1, result_type='expand')\n\n# Merge elevation data with the original DataFrame\n#final_testing_df = pd.concat([clim_data, elevation_data], axis=1)\n\n# Save the updated DataFrame to a new CSV file\n#final_testing_df.to_csv('final_testing.csv', index=False)\n\n# if not os.path.exists(result_dem_csv_path):\n#     elevation_df = read_elevation_data(\"/home/chetana/gridmet_test_run/output_4km_clipped.tif\")\n#     print(elevation_df)\n#     elevation_df.to_csv(result_dem_csv_path)\n#     data = {\n#         'Latitude': [],\n#         'Longitude': [],\n#         'Elevation': [],\n#         'Slope': [],\n#         'Aspect': [],\n#       \t'Curvature': [],\n#     }\n#     new_df = pd.DataFrame(data)\n#     for index, row in elevation_df.iterrows():\n#         latitude = row['Latitude']  # Replace 'Latitude' with the actual name of your latitude column\n#         longitude = row['Longitude']  # Replace 'Longitude' with the actual name of your longitude column\n#         elevation, slope, aspect, curvature = get_elevation_slope_aspect_curvature(elevation_df, latitude, longitude)\n#         new_row = {\n#             'Latitude': latitude,\n#             'Longitude': longitude,\n#             'Elevation': elevation,\n#             'Slope': slope,\n#             'Aspect': aspect,\n#             'Curvature': curvature,\n#         }\n\n#         new_df = new_df.append(new_row, ignore_index=True)\n        \n#     new_df.to_csv(result_dem_feature_csv_path)\n# else:\n# \tprint(\"dem_template.csv exists. Skipping...\")\n    \n\n\n# # Get elevation, slope, aspect, and curvature based on the given lat and lon\n# latitude_to_find = 34.5  # Replace with the desired latitude\n# longitude_to_find = -120.5  # Replace with the desired longitude\n\n# elevation, slope, aspect, curvature = get_elevation_slope_aspect_curvature(elevation_df, latitude_to_find,\n#                                                                            longitude_to_find)\n\n# print(\"Latitude:\", latitude_to_find)\n# print(\"Longitude:\", longitude_to_find)\n# print(\"Elevation:\", elevation)\n# print(\"Slope:\", slope)\n# print(\"Aspect:\", aspect)\n# print(\"Curvature:\", curvature)\n#convert_the_original_dem_to_template_spatial_extent()\n",
  "history_output" : "  File \"/home/chetana/gw-workspace/6TlJlkLRlWkO/western_us_dem.py\", line 42\n    result_dem_feature_csv_path = \"/home/chetana/gridmet_test_run/dem_all.csv\"\nTabError: inconsistent use of tabs and spaces in indentation\n",
  "history_begin_time" : 1690251790877,
  "history_end_time" : 1690251791956,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : null,
  "indicator" : "Failed"
},{
  "history_id" : "VREpTCbMapHh",
  "history_input" : "import numpy as np\nimport pandas as pd\nfrom osgeo import gdal\nimport os\nimport rasterio\nfrom rasterio.warp import calculate_default_transform, reproject, Resampling\n\nimport numpy as np\n\n\ndef calculate_slope_aspect(elevation_data, pixel_size_x, pixel_size_y):\n    # Calculate slope using the Sobel operator\n    slope_x = np.gradient(elevation_data, pixel_size_x, axis=1)\n    slope_y = np.gradient(elevation_data, pixel_size_y, axis=0)\n    slope_rad = np.arctan(np.sqrt(slope_x ** 2 + slope_y ** 2))\n    slope_deg = np.degrees(slope_rad)\n\n    # Calculate aspect (direction of the steepest descent)\n    aspect_rad = np.arctan2(slope_y, -slope_x)\n    aspect_deg = (np.degrees(aspect_rad) + 360) % 360\n\n    return slope_deg, aspect_deg\n\n\ndef calculate_curvature(elevation_data, pixel_size_x, pixel_size_y):\n    # Calculate curvature using the Laplacian operator\n    curvature_x = np.gradient(np.gradient(elevation_data, pixel_size_x, axis=1), pixel_size_x, axis=1)\n    curvature_y = np.gradient(np.gradient(elevation_data, pixel_size_y, axis=0), pixel_size_y, axis=0)\n    curvature = curvature_x + curvature_y\n\n    return curvature\n\n\ndef read_elevation_data(file_path):\n    dataset = gdal.Open(file_path)\n    if dataset is None:\n        print(\"Error: Could not open the file.\")\n        return None\n\n    band = dataset.GetRasterBand(1)\n    elevation_data = band.ReadAsArray()\n\n    # Get geotransform information\n    geotransform = dataset.GetGeoTransform()\n    min_lon, pixel_size_x, _, max_lat, _, pixel_size_y = geotransform\n\n    # Calculate raster size\n    raster_width = dataset.RasterXSize\n    raster_height = dataset.RasterYSize\n\n    # Generate latitude and longitude arrays\n    lats = np.arange(max_lat, max_lat - pixel_size_y * raster_height, -pixel_size_y)\n    lons = np.arange(min_lon, min_lon + pixel_size_x * raster_width, pixel_size_x)\n\n    # Create meshgrid of latitude and longitude\n    lon_grid, lat_grid = np.meshgrid(lons, lats)\n\n    # Flatten the data and the lat/lon grids\n    elevation_data_flat = elevation_data.flatten()\n    lat_grid_flat = lat_grid.flatten()\n    lon_grid_flat = lon_grid.flatten()\n\n    # Create a DataFrame to store the data\n    df = pd.DataFrame({\n        'Latitude': lat_grid_flat,\n        'Longitude': lon_grid_flat,\n        'Elevation': elevation_data_flat,\n    })\n\n    return df\n\n\ndef get_elevation_slope_aspect_curvature(df, lat, lon):\n    # Find the closest latitude and longitude in the DataFrame\n    lat_diff = np.abs(df['Latitude'] - lat)\n    lon_diff = np.abs(df['Longitude'] - lon)\n    closest_index = np.argmin(lat_diff + lon_diff)\n\n    # Extract the elevation, slope, aspect, and curvature at the closest location\n    elevation = df['Elevation'][closest_index]\n    slope = df['Slope'][closest_index]\n    aspect = df['Aspect'][closest_index]\n    curvature = df['Curvature'][closest_index]\n\n    return elevation, slope, aspect, curvature\n\n\n# Usage example:\nresult_dem_csv_path = \"/home/chetana/gridmet_test_run/dem_template.csv\"\nresult_dem_feature_csv_path = \"/home/chetana/gridmet_test_run/dem_all.csv\"\nif not os.path.exists(result_dem_csv_path):\n    elevation_df = read_elevation_data(\"/home/chetana/gridmet_test_run/output_4km_clipped.tif\")\n    print(elevation_df)\n    elevation_df.to_csv(result_dem_csv_path)\n    data = {\n        'Latitude': [],\n        'Longitude': [],\n        'Elevation': [],\n        'Slope': [],\n        'Aspect': [],\n      \t'Curvature': [],\n    }\n    new_df = pd.DataFrame(data)\n    for index, row in elevation_df.iterrows():\n        latitude = row['Latitude']  # Replace 'Latitude' with the actual name of your latitude column\n        longitude = row['Longitude']  # Replace 'Longitude' with the actual name of your longitude column\n        elevation, slope, aspect, curvature = get_elevation_slope_aspect_curvature(elevation_df, latitude, longitude)\n        new_row = {\n            'Latitude': latitude,\n            'Longitude': longitude,\n            'Elevation': elevation,\n            'Slope': slope,\n            'Aspect': aspect,\n            'Curvature': curvature,\n        }\n\n        new_df = new_df.append(new_row, ignore_index=True)\n        \n    new_df.to_csv(result_dem_feature_csv_path)\nelse:\n\tprint(\"dem_template.csv exists. Skipping...\")\n    \n\n\n# # Get elevation, slope, aspect, and curvature based on the given lat and lon\n# latitude_to_find = 34.5  # Replace with the desired latitude\n# longitude_to_find = -120.5  # Replace with the desired longitude\n\n# elevation, slope, aspect, curvature = get_elevation_slope_aspect_curvature(elevation_df, latitude_to_find,\n#                                                                            longitude_to_find)\n\n# print(\"Latitude:\", latitude_to_find)\n# print(\"Longitude:\", longitude_to_find)\n# print(\"Elevation:\", elevation)\n# print(\"Slope:\", slope)\n# print(\"Aspect:\", aspect)\n# print(\"Curvature:\", curvature)\n#convert_the_original_dem_to_template_spatial_extent()\n",
  "history_output" : "Variable name: rmax\n\nStream closed",
  "history_begin_time" : 1690185888276,
  "history_end_time" : 1690186670286,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : null,
  "indicator" : "Failed"
},{
  "history_id" : "2gGWi5SOAnsg",
  "history_input" : "import numpy as np\nimport pandas as pd\nfrom osgeo import gdal\nimport os\nimport rasterio\nfrom rasterio.warp import calculate_default_transform, reproject, Resampling\n\nimport numpy as np\n\n\ndef calculate_slope_aspect(elevation_data, pixel_size_x, pixel_size_y):\n    # Calculate slope using the Sobel operator\n    slope_x = np.gradient(elevation_data, pixel_size_x, axis=1)\n    slope_y = np.gradient(elevation_data, pixel_size_y, axis=0)\n    slope_rad = np.arctan(np.sqrt(slope_x ** 2 + slope_y ** 2))\n    slope_deg = np.degrees(slope_rad)\n\n    # Calculate aspect (direction of the steepest descent)\n    aspect_rad = np.arctan2(slope_y, -slope_x)\n    aspect_deg = (np.degrees(aspect_rad) + 360) % 360\n\n    return slope_deg, aspect_deg\n\n\ndef calculate_curvature(elevation_data, pixel_size_x, pixel_size_y):\n    # Calculate curvature using the Laplacian operator\n    curvature_x = np.gradient(np.gradient(elevation_data, pixel_size_x, axis=1), pixel_size_x, axis=1)\n    curvature_y = np.gradient(np.gradient(elevation_data, pixel_size_y, axis=0), pixel_size_y, axis=0)\n    curvature = curvature_x + curvature_y\n\n    return curvature\n\n\ndef read_elevation_data(file_path):\n    dataset = gdal.Open(file_path)\n    if dataset is None:\n        print(\"Error: Could not open the file.\")\n        return None\n\n    band = dataset.GetRasterBand(1)\n    elevation_data = band.ReadAsArray()\n\n    # Get geotransform information\n    geotransform = dataset.GetGeoTransform()\n    min_lon, pixel_size_x, _, max_lat, _, pixel_size_y = geotransform\n\n    # Calculate raster size\n    raster_width = dataset.RasterXSize\n    raster_height = dataset.RasterYSize\n\n    # Generate latitude and longitude arrays\n    lats = np.arange(max_lat, max_lat - pixel_size_y * raster_height, -pixel_size_y)\n    lons = np.arange(min_lon, min_lon + pixel_size_x * raster_width, pixel_size_x)\n\n    # Create meshgrid of latitude and longitude\n    lon_grid, lat_grid = np.meshgrid(lons, lats)\n\n    # Flatten the data and the lat/lon grids\n    elevation_data_flat = elevation_data.flatten()\n    lat_grid_flat = lat_grid.flatten()\n    lon_grid_flat = lon_grid.flatten()\n\n    # Create a DataFrame to store the data\n    df = pd.DataFrame({\n        'Latitude': lat_grid_flat,\n        'Longitude': lon_grid_flat,\n        'Elevation': elevation_data_flat,\n    })\n\n    return df\n\n\ndef get_elevation_slope_aspect_curvature(df, lat, lon):\n    # Find the closest latitude and longitude in the DataFrame\n    lat_diff = np.abs(df['Latitude'] - lat)\n    lon_diff = np.abs(df['Longitude'] - lon)\n    closest_index = np.argmin(lat_diff + lon_diff)\n\n    # Extract the elevation, slope, aspect, and curvature at the closest location\n    elevation = df['Elevation'][closest_index]\n    slope = df['Slope'][closest_index]\n    aspect = df['Aspect'][closest_index]\n    curvature = df['Curvature'][closest_index]\n\n    return elevation, slope, aspect, curvature\n\n\n# Usage example:\nresult_dem_csv_path = \"/home/chetana/gridmet_test_run/dem_template.csv\"\nresult_dem_feature_csv_path = \"/home/chetana/gridmet_test_run/dem_all.csv\"\nif not os.path.exists(result_dem_csv_path):\n    elevation_df = read_elevation_data(\"/home/chetana/gridmet_test_run/output_4km_clipped.tif\")\n    print(elevation_df)\n    elevation_df.to_csv(result_dem_csv_path)\n    data = {\n        'Latitude': [],\n        'Longitude': [],\n        'Elevation': [],\n        'Slope': [],\n        'Aspect': [],\n      \t'Curvature': [],\n    }\n    new_df = pd.DataFrame(data)\n    for index, row in elevation_df.iterrows():\n        latitude = row['Latitude']  # Replace 'Latitude' with the actual name of your latitude column\n        longitude = row['Longitude']  # Replace 'Longitude' with the actual name of your longitude column\n\t\televation, slope, aspect, curvature = get_elevation_slope_aspect_curvature(elevation_df, latitude, longitude)\n        new_row = {\n            'Latitude': latitude,\n            'Longitude': longitude,\n            'Elevation': elevation,\n            'Slope': slope,\n            'Aspect': aspect,\n            'Curvature': curvature,\n        }\n\n        new_df = new_df.append(new_row, ignore_index=True)\n        \n    new_df.to_csv(result_dem_feature_csv_path)\nelse:\n\tprint(\"dem_template.csv exists. Skipping...\")\n    \n\n\n# # Get elevation, slope, aspect, and curvature based on the given lat and lon\n# latitude_to_find = 34.5  # Replace with the desired latitude\n# longitude_to_find = -120.5  # Replace with the desired longitude\n\n# elevation, slope, aspect, curvature = get_elevation_slope_aspect_curvature(elevation_df, latitude_to_find,\n#                                                                            longitude_to_find)\n\n# print(\"Latitude:\", latitude_to_find)\n# print(\"Longitude:\", longitude_to_find)\n# print(\"Elevation:\", elevation)\n# print(\"Slope:\", slope)\n# print(\"Aspect:\", aspect)\n# print(\"Curvature:\", curvature)\n#convert_the_original_dem_to_template_spatial_extent()\n",
  "history_output" : "  File \"/home/chetana/gw-workspace/2gGWi5SOAnsg/western_us_dem.py\", line 107\n    elevation, slope, aspect, curvature = get_elevation_slope_aspect_curvature(elevation_df, latitude, longitude)\nTabError: inconsistent use of tabs and spaces in indentation\n",
  "history_begin_time" : 1690185863453,
  "history_end_time" : 1690185864920,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : null,
  "indicator" : "Failed"
},{
  "history_id" : "FPLX6u9Dguzp",
  "history_input" : "import numpy as np\nimport pandas as pd\nfrom osgeo import gdal\nimport os\nimport rasterio\nfrom rasterio.warp import calculate_default_transform, reproject, Resampling\n\nimport numpy as np\n\n\ndef calculate_slope_aspect(elevation_data, pixel_size_x, pixel_size_y):\n    # Calculate slope using the Sobel operator\n    slope_x = np.gradient(elevation_data, pixel_size_x, axis=1)\n    slope_y = np.gradient(elevation_data, pixel_size_y, axis=0)\n    slope_rad = np.arctan(np.sqrt(slope_x ** 2 + slope_y ** 2))\n    slope_deg = np.degrees(slope_rad)\n\n    # Calculate aspect (direction of the steepest descent)\n    aspect_rad = np.arctan2(slope_y, -slope_x)\n    aspect_deg = (np.degrees(aspect_rad) + 360) % 360\n\n    return slope_deg, aspect_deg\n\n\ndef calculate_curvature(elevation_data, pixel_size_x, pixel_size_y):\n    # Calculate curvature using the Laplacian operator\n    curvature_x = np.gradient(np.gradient(elevation_data, pixel_size_x, axis=1), pixel_size_x, axis=1)\n    curvature_y = np.gradient(np.gradient(elevation_data, pixel_size_y, axis=0), pixel_size_y, axis=0)\n    curvature = curvature_x + curvature_y\n\n    return curvature\n\n\ndef read_elevation_data(file_path):\n    dataset = gdal.Open(file_path)\n    if dataset is None:\n        print(\"Error: Could not open the file.\")\n        return None\n\n    band = dataset.GetRasterBand(1)\n    elevation_data = band.ReadAsArray()\n\n    # Get geotransform information\n    geotransform = dataset.GetGeoTransform()\n    min_lon, pixel_size_x, _, max_lat, _, pixel_size_y = geotransform\n\n    # Calculate raster size\n    raster_width = dataset.RasterXSize\n    raster_height = dataset.RasterYSize\n\n    # Generate latitude and longitude arrays\n    lats = np.arange(max_lat, max_lat - pixel_size_y * raster_height, -pixel_size_y)\n    lons = np.arange(min_lon, min_lon + pixel_size_x * raster_width, pixel_size_x)\n\n    # Create meshgrid of latitude and longitude\n    lon_grid, lat_grid = np.meshgrid(lons, lats)\n\n    # Flatten the data and the lat/lon grids\n    elevation_data_flat = elevation_data.flatten()\n    lat_grid_flat = lat_grid.flatten()\n    lon_grid_flat = lon_grid.flatten()\n\n    # Create a DataFrame to store the data\n    df = pd.DataFrame({\n        'Latitude': lat_grid_flat,\n        'Longitude': lon_grid_flat,\n        'Elevation': elevation_data_flat,\n    })\n\n    return df\n\n\ndef get_elevation_slope_aspect_curvature(df, lat, lon):\n    # Find the closest latitude and longitude in the DataFrame\n    lat_diff = np.abs(df['Latitude'] - lat)\n    lon_diff = np.abs(df['Longitude'] - lon)\n    closest_index = np.argmin(lat_diff + lon_diff)\n\n    # Extract the elevation, slope, aspect, and curvature at the closest location\n    elevation = df['Elevation'][closest_index]\n    slope = df['Slope'][closest_index]\n    aspect = df['Aspect'][closest_index]\n    curvature = df['Curvature'][closest_index]\n\n    return elevation, slope, aspect, curvature\n\n\n# Usage example:\nresult_dem_csv_path = \"/home/chetana/gridmet_test_run/dem_template.csv\"\nif not os.path.exists(result_dem_csv_path):\n    elevation_df = read_elevation_data(\"/home/chetana/gridmet_test_run/output_4km_clipped.tif\")\n    print(elevation_df)\n    elevation_df.to_csv(result_dem_csv_path)\nelse:\n\tprint(\"dem_template.csv exists. Skipping...\")\n\n# # Get elevation, slope, aspect, and curvature based on the given lat and lon\n# latitude_to_find = 34.5  # Replace with the desired latitude\n# longitude_to_find = -120.5  # Replace with the desired longitude\n\n# elevation, slope, aspect, curvature = get_elevation_slope_aspect_curvature(elevation_df, latitude_to_find,\n#                                                                            longitude_to_find)\n\n# print(\"Latitude:\", latitude_to_find)\n# print(\"Longitude:\", longitude_to_find)\n# print(\"Elevation:\", elevation)\n# print(\"Slope:\", slope)\n# print(\"Aspect:\", aspect)\n# print(\"Curvature:\", curvature)\n#convert_the_original_dem_to_template_spatial_extent()\n",
  "history_output" : "dem_template.csv exists. Skipping...\n",
  "history_begin_time" : 1690171073196,
  "history_end_time" : 1690171073918,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "lUjM4NIxc5tv",
  "history_input" : "import numpy as np\nimport pandas as pd\nfrom osgeo import gdal\nimport os\nimport rasterio\nfrom rasterio.warp import calculate_default_transform, reproject, Resampling\n\nimport numpy as np\n\n\ndef calculate_slope_aspect(elevation_data, pixel_size_x, pixel_size_y):\n    # Calculate slope using the Sobel operator\n    slope_x = np.gradient(elevation_data, pixel_size_x, axis=1)\n    slope_y = np.gradient(elevation_data, pixel_size_y, axis=0)\n    slope_rad = np.arctan(np.sqrt(slope_x ** 2 + slope_y ** 2))\n    slope_deg = np.degrees(slope_rad)\n\n    # Calculate aspect (direction of the steepest descent)\n    aspect_rad = np.arctan2(slope_y, -slope_x)\n    aspect_deg = (np.degrees(aspect_rad) + 360) % 360\n\n    return slope_deg, aspect_deg\n\n\ndef calculate_curvature(elevation_data, pixel_size_x, pixel_size_y):\n    # Calculate curvature using the Laplacian operator\n    curvature_x = np.gradient(np.gradient(elevation_data, pixel_size_x, axis=1), pixel_size_x, axis=1)\n    curvature_y = np.gradient(np.gradient(elevation_data, pixel_size_y, axis=0), pixel_size_y, axis=0)\n    curvature = curvature_x + curvature_y\n\n    return curvature\n\n\ndef read_elevation_data(file_path):\n    dataset = gdal.Open(file_path)\n    if dataset is None:\n        print(\"Error: Could not open the file.\")\n        return None\n\n    band = dataset.GetRasterBand(1)\n    elevation_data = band.ReadAsArray()\n\n    # Get geotransform information\n    geotransform = dataset.GetGeoTransform()\n    min_lon, pixel_size_x, _, max_lat, _, pixel_size_y = geotransform\n\n    # Calculate raster size\n    raster_width = dataset.RasterXSize\n    raster_height = dataset.RasterYSize\n\n    # Generate latitude and longitude arrays\n    lats = np.arange(max_lat, max_lat - pixel_size_y * raster_height, -pixel_size_y)\n    lons = np.arange(min_lon, min_lon + pixel_size_x * raster_width, pixel_size_x)\n\n    # Create meshgrid of latitude and longitude\n    lon_grid, lat_grid = np.meshgrid(lons, lats)\n\n    # Flatten the data and the lat/lon grids\n    elevation_data_flat = elevation_data.flatten()\n    lat_grid_flat = lat_grid.flatten()\n    lon_grid_flat = lon_grid.flatten()\n\n    # Create a DataFrame to store the data\n    df = pd.DataFrame({\n        'Latitude': lat_grid_flat,\n        'Longitude': lon_grid_flat,\n        'Elevation': elevation_data_flat,\n    })\n\n    return df\n\n\ndef get_elevation_slope_aspect_curvature(df, lat, lon):\n    # Find the closest latitude and longitude in the DataFrame\n    lat_diff = np.abs(df['Latitude'] - lat)\n    lon_diff = np.abs(df['Longitude'] - lon)\n    closest_index = np.argmin(lat_diff + lon_diff)\n\n    # Extract the elevation, slope, aspect, and curvature at the closest location\n    elevation = df['Elevation'][closest_index]\n    slope = df['Slope'][closest_index]\n    aspect = df['Aspect'][closest_index]\n    curvature = df['Curvature'][closest_index]\n\n    return elevation, slope, aspect, curvature\n\n\n# Usage example:\nif not os.path.exists(file_path):\n    elevation_df = read_elevation_data(\"/home/chetana/gridmet_test_run/output_4km_clipped.tif\")\n    print(elevation_df)\n    elevation_df.to_csv(\"/home/chetana/gridmet_test_run/dem_template.csv\")\nelse:\n\tprint(\"dem_template.csv exists. Skipping...\")\n\n# # Get elevation, slope, aspect, and curvature based on the given lat and lon\n# latitude_to_find = 34.5  # Replace with the desired latitude\n# longitude_to_find = -120.5  # Replace with the desired longitude\n\n# elevation, slope, aspect, curvature = get_elevation_slope_aspect_curvature(elevation_df, latitude_to_find,\n#                                                                            longitude_to_find)\n\n# print(\"Latitude:\", latitude_to_find)\n# print(\"Longitude:\", longitude_to_find)\n# print(\"Elevation:\", elevation)\n# print(\"Slope:\", slope)\n# print(\"Aspect:\", aspect)\n# print(\"Curvature:\", curvature)\n#convert_the_original_dem_to_template_spatial_extent()\n",
  "history_output" : "Traceback (most recent call last):\n  File \"/home/chetana/gw-workspace/lUjM4NIxc5tv/western_us_dem.py\", line 89, in <module>\n    if not os.path.exists(file_path):\nNameError: name 'file_path' is not defined\n",
  "history_begin_time" : 1690171048665,
  "history_end_time" : 1690171049412,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : null,
  "indicator" : "Failed"
},{
  "history_id" : "jCgI7AVuqVVg",
  "history_input" : "import numpy as np\nimport pandas as pd\nfrom osgeo import gdal\n\nimport rasterio\nfrom rasterio.warp import calculate_default_transform, reproject, Resampling\n\nimport numpy as np\n\n\ndef calculate_slope_aspect(elevation_data, pixel_size_x, pixel_size_y):\n    # Calculate slope using the Sobel operator\n    slope_x = np.gradient(elevation_data, pixel_size_x, axis=1)\n    slope_y = np.gradient(elevation_data, pixel_size_y, axis=0)\n    slope_rad = np.arctan(np.sqrt(slope_x ** 2 + slope_y ** 2))\n    slope_deg = np.degrees(slope_rad)\n\n    # Calculate aspect (direction of the steepest descent)\n    aspect_rad = np.arctan2(slope_y, -slope_x)\n    aspect_deg = (np.degrees(aspect_rad) + 360) % 360\n\n    return slope_deg, aspect_deg\n\n\ndef calculate_curvature(elevation_data, pixel_size_x, pixel_size_y):\n    # Calculate curvature using the Laplacian operator\n    curvature_x = np.gradient(np.gradient(elevation_data, pixel_size_x, axis=1), pixel_size_x, axis=1)\n    curvature_y = np.gradient(np.gradient(elevation_data, pixel_size_y, axis=0), pixel_size_y, axis=0)\n    curvature = curvature_x + curvature_y\n\n    return curvature\n\n\ndef read_elevation_data(file_path):\n    dataset = gdal.Open(file_path)\n    if dataset is None:\n        print(\"Error: Could not open the file.\")\n        return None\n\n    band = dataset.GetRasterBand(1)\n    elevation_data = band.ReadAsArray()\n\n    # Get geotransform information\n    geotransform = dataset.GetGeoTransform()\n    min_lon, pixel_size_x, _, max_lat, _, pixel_size_y = geotransform\n\n    # Calculate raster size\n    raster_width = dataset.RasterXSize\n    raster_height = dataset.RasterYSize\n\n    # Generate latitude and longitude arrays\n    lats = np.arange(max_lat, max_lat - pixel_size_y * raster_height, -pixel_size_y)\n    lons = np.arange(min_lon, min_lon + pixel_size_x * raster_width, pixel_size_x)\n\n    # Create meshgrid of latitude and longitude\n    lon_grid, lat_grid = np.meshgrid(lons, lats)\n\n    # Flatten the data and the lat/lon grids\n    elevation_data_flat = elevation_data.flatten()\n    lat_grid_flat = lat_grid.flatten()\n    lon_grid_flat = lon_grid.flatten()\n\n    # Create a DataFrame to store the data\n    df = pd.DataFrame({\n        'Latitude': lat_grid_flat,\n        'Longitude': lon_grid_flat,\n        'Elevation': elevation_data_flat,\n    })\n\n    return df\n\n\ndef get_elevation_slope_aspect_curvature(df, lat, lon):\n    # Find the closest latitude and longitude in the DataFrame\n    lat_diff = np.abs(df['Latitude'] - lat)\n    lon_diff = np.abs(df['Longitude'] - lon)\n    closest_index = np.argmin(lat_diff + lon_diff)\n\n    # Extract the elevation, slope, aspect, and curvature at the closest location\n    elevation = df['Elevation'][closest_index]\n    slope = df['Slope'][closest_index]\n    aspect = df['Aspect'][closest_index]\n    curvature = df['Curvature'][closest_index]\n\n    return elevation, slope, aspect, curvature\n\n\n# Usage example:\nif not os.path.exists(file_path):\n    elevation_df = read_elevation_data(\"/home/chetana/gridmet_test_run/output_4km_clipped.tif\")\n    print(elevation_df)\n    elevation_df.to_csv(\"/home/chetana/gridmet_test_run/dem_template.csv\")\nelse:\n\tprint(\"dem_template.csv exists. Skipping...\")\n\n# # Get elevation, slope, aspect, and curvature based on the given lat and lon\n# latitude_to_find = 34.5  # Replace with the desired latitude\n# longitude_to_find = -120.5  # Replace with the desired longitude\n\n# elevation, slope, aspect, curvature = get_elevation_slope_aspect_curvature(elevation_df, latitude_to_find,\n#                                                                            longitude_to_find)\n\n# print(\"Latitude:\", latitude_to_find)\n# print(\"Longitude:\", longitude_to_find)\n# print(\"Elevation:\", elevation)\n# print(\"Slope:\", slope)\n# print(\"Aspect:\", aspect)\n# print(\"Curvature:\", curvature)\n#convert_the_original_dem_to_template_spatial_extent()\n",
  "history_output" : "Traceback (most recent call last):\n  File \"/home/chetana/gw-workspace/jCgI7AVuqVVg/western_us_dem.py\", line 89, in <module>\n    if not os.path.exists(file_path):\nNameError: name 'os' is not defined\n",
  "history_begin_time" : 1690171039385,
  "history_end_time" : 1690171040117,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : null,
  "indicator" : "Failed"
},{
  "history_id" : "ZoRngiEEpmN3",
  "history_input" : "import numpy as np\nimport pandas as pd\nfrom osgeo import gdal\n\nimport rasterio\nfrom rasterio.warp import calculate_default_transform, reproject, Resampling\n\nimport numpy as np\n\n\ndef calculate_slope_aspect(elevation_data, pixel_size_x, pixel_size_y):\n    # Calculate slope using the Sobel operator\n    slope_x = np.gradient(elevation_data, pixel_size_x, axis=1)\n    slope_y = np.gradient(elevation_data, pixel_size_y, axis=0)\n    slope_rad = np.arctan(np.sqrt(slope_x ** 2 + slope_y ** 2))\n    slope_deg = np.degrees(slope_rad)\n\n    # Calculate aspect (direction of the steepest descent)\n    aspect_rad = np.arctan2(slope_y, -slope_x)\n    aspect_deg = (np.degrees(aspect_rad) + 360) % 360\n\n    return slope_deg, aspect_deg\n\n\ndef calculate_curvature(elevation_data, pixel_size_x, pixel_size_y):\n    # Calculate curvature using the Laplacian operator\n    curvature_x = np.gradient(np.gradient(elevation_data, pixel_size_x, axis=1), pixel_size_x, axis=1)\n    curvature_y = np.gradient(np.gradient(elevation_data, pixel_size_y, axis=0), pixel_size_y, axis=0)\n    curvature = curvature_x + curvature_y\n\n    return curvature\n\n\ndef read_elevation_data(file_path):\n    dataset = gdal.Open(file_path)\n    if dataset is None:\n        print(\"Error: Could not open the file.\")\n        return None\n\n    band = dataset.GetRasterBand(1)\n    elevation_data = band.ReadAsArray()\n\n    # Get geotransform information\n    geotransform = dataset.GetGeoTransform()\n    min_lon, pixel_size_x, _, max_lat, _, pixel_size_y = geotransform\n\n    # Calculate raster size\n    raster_width = dataset.RasterXSize\n    raster_height = dataset.RasterYSize\n\n    # Generate latitude and longitude arrays\n    lats = np.arange(max_lat, max_lat - pixel_size_y * raster_height, -pixel_size_y)\n    lons = np.arange(min_lon, min_lon + pixel_size_x * raster_width, pixel_size_x)\n\n    # Create meshgrid of latitude and longitude\n    lon_grid, lat_grid = np.meshgrid(lons, lats)\n\n    # Flatten the data and the lat/lon grids\n    elevation_data_flat = elevation_data.flatten()\n    lat_grid_flat = lat_grid.flatten()\n    lon_grid_flat = lon_grid.flatten()\n\n    # Create a DataFrame to store the data\n    df = pd.DataFrame({\n        'Latitude': lat_grid_flat,\n        'Longitude': lon_grid_flat,\n        'Elevation': elevation_data_flat,\n    })\n\n    return df\n\n\ndef get_elevation_slope_aspect_curvature(df, lat, lon):\n    # Find the closest latitude and longitude in the DataFrame\n    lat_diff = np.abs(df['Latitude'] - lat)\n    lon_diff = np.abs(df['Longitude'] - lon)\n    closest_index = np.argmin(lat_diff + lon_diff)\n\n    # Extract the elevation, slope, aspect, and curvature at the closest location\n    elevation = df['Elevation'][closest_index]\n    slope = df['Slope'][closest_index]\n    aspect = df['Aspect'][closest_index]\n    curvature = df['Curvature'][closest_index]\n\n    return elevation, slope, aspect, curvature\n\n\n# Usage example:\nelevation_df = read_elevation_data(\"/home/chetana/gridmet_test_run/output_4km_clipped.tif\")\nprint(elevation_df)\nelevation_df.to_csv(\"/home/chetana/gridmet_test_run/dem_template.csv\")\n\n# # Get elevation, slope, aspect, and curvature based on the given lat and lon\n# latitude_to_find = 34.5  # Replace with the desired latitude\n# longitude_to_find = -120.5  # Replace with the desired longitude\n\n# elevation, slope, aspect, curvature = get_elevation_slope_aspect_curvature(elevation_df, latitude_to_find,\n#                                                                            longitude_to_find)\n\n# print(\"Latitude:\", latitude_to_find)\n# print(\"Longitude:\", longitude_to_find)\n# print(\"Elevation:\", elevation)\n# print(\"Slope:\", slope)\n# print(\"Aspect:\", aspect)\n# print(\"Curvature:\", curvature)\n#convert_the_original_dem_to_template_spatial_extent()\n",
  "history_output" : "        Latitude  Longitude    Elevation\n0          49.00   -125.000    15.124211\n1          49.00   -124.964   136.762283\n2          49.00   -124.928   258.745087\n3          49.00   -124.892   387.150482\n4          49.00   -124.856   213.531708\n...          ...        ...          ...\n462199     72.94   -100.196  1687.865112\n462200     72.94   -100.160  1154.707764\n462201     72.94   -100.124   926.116699\n462202     72.94   -100.088  1275.832886\n462203     72.94   -100.052  1350.978394\n[462204 rows x 3 columns]\n",
  "history_begin_time" : 1690170556858,
  "history_end_time" : 1690170559478,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "QodDZ1b6pDZQ",
  "history_input" : "import numpy as np\nimport pandas as pd\nfrom osgeo import gdal\n\nimport rasterio\nfrom rasterio.warp import calculate_default_transform, reproject, Resampling\n\nimport numpy as np\n\n\ndef calculate_slope_aspect(elevation_data, pixel_size_x, pixel_size_y):\n    # Calculate slope using the Sobel operator\n    slope_x = np.gradient(elevation_data, pixel_size_x, axis=1)\n    slope_y = np.gradient(elevation_data, pixel_size_y, axis=0)\n    slope_rad = np.arctan(np.sqrt(slope_x ** 2 + slope_y ** 2))\n    slope_deg = np.degrees(slope_rad)\n\n    # Calculate aspect (direction of the steepest descent)\n    aspect_rad = np.arctan2(slope_y, -slope_x)\n    aspect_deg = (np.degrees(aspect_rad) + 360) % 360\n\n    return slope_deg, aspect_deg\n\n\ndef calculate_curvature(elevation_data, pixel_size_x, pixel_size_y):\n    # Calculate curvature using the Laplacian operator\n    curvature_x = np.gradient(np.gradient(elevation_data, pixel_size_x, axis=1), pixel_size_x, axis=1)\n    curvature_y = np.gradient(np.gradient(elevation_data, pixel_size_y, axis=0), pixel_size_y, axis=0)\n    curvature = curvature_x + curvature_y\n\n    return curvature\n\n\ndef read_elevation_data(file_path):\n    dataset = gdal.Open(file_path)\n    if dataset is None:\n        print(\"Error: Could not open the file.\")\n        return None\n\n    band = dataset.GetRasterBand(1)\n    elevation_data = band.ReadAsArray()\n\n    # Get geotransform information\n    geotransform = dataset.GetGeoTransform()\n    min_lon, pixel_size_x, _, max_lat, _, pixel_size_y = geotransform\n\n    # Calculate raster size\n    raster_width = dataset.RasterXSize\n    raster_height = dataset.RasterYSize\n\n    # Generate latitude and longitude arrays\n    lats = np.arange(max_lat, max_lat - pixel_size_y * raster_height, -pixel_size_y)\n    lons = np.arange(min_lon, min_lon + pixel_size_x * raster_width, pixel_size_x)\n\n    # Create meshgrid of latitude and longitude\n    lon_grid, lat_grid = np.meshgrid(lons, lats)\n\n    # Flatten the data and the lat/lon grids\n    elevation_data_flat = elevation_data.flatten()\n    lat_grid_flat = lat_grid.flatten()\n    lon_grid_flat = lon_grid.flatten()\n\n    # Create a DataFrame to store the data\n    df = pd.DataFrame({\n        'Latitude': lat_grid_flat,\n        'Longitude': lon_grid_flat,\n        'Elevation': elevation_data_flat,\n    })\n\n    return df\n\n\ndef get_elevation_slope_aspect_curvature(df, lat, lon):\n    # Find the closest latitude and longitude in the DataFrame\n    lat_diff = np.abs(df['Latitude'] - lat)\n    lon_diff = np.abs(df['Longitude'] - lon)\n    closest_index = np.argmin(lat_diff + lon_diff)\n\n    # Extract the elevation, slope, aspect, and curvature at the closest location\n    elevation = df['Elevation'][closest_index]\n    slope = df['Slope'][closest_index]\n    aspect = df['Aspect'][closest_index]\n    curvature = df['Curvature'][closest_index]\n\n    return elevation, slope, aspect, curvature\n\n  \n# Usage example:\nelevation_df = read_elevation_data(\"/home/chetana/gridmet_test_run/output_4km_clipped.tif\")\nprint(elevation_df)\n\n# # Get elevation, slope, aspect, and curvature based on the given lat and lon\n# latitude_to_find = 34.5  # Replace with the desired latitude\n# longitude_to_find = -120.5  # Replace with the desired longitude\n\n# elevation, slope, aspect, curvature = get_elevation_slope_aspect_curvature(elevation_df, latitude_to_find,\n#                                                                            longitude_to_find)\n\n# print(\"Latitude:\", latitude_to_find)\n# print(\"Longitude:\", longitude_to_find)\n# print(\"Elevation:\", elevation)\n# print(\"Slope:\", slope)\n# print(\"Aspect:\", aspect)\n# print(\"Curvature:\", curvature)\n#convert_the_original_dem_to_template_spatial_extent()\n",
  "history_output" : "        Latitude  Longitude    Elevation\n0          49.00   -125.000    15.124211\n1          49.00   -124.964   136.762283\n2          49.00   -124.928   258.745087\n3          49.00   -124.892   387.150482\n4          49.00   -124.856   213.531708\n...          ...        ...          ...\n462199     72.94   -100.196  1687.865112\n462200     72.94   -100.160  1154.707764\n462201     72.94   -100.124   926.116699\n462202     72.94   -100.088  1275.832886\n462203     72.94   -100.052  1350.978394\n[462204 rows x 3 columns]\n",
  "history_begin_time" : 1690169075437,
  "history_end_time" : 1690169076221,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "ce1Ty77qBdAe",
  "history_input" : "import numpy as np\nimport pandas as pd\nfrom osgeo import gdal\n\nimport rasterio\nfrom rasterio.warp import calculate_default_transform, reproject, Resampling\n\nimport numpy as np\n\n\ndef calculate_slope_aspect(elevation_data, pixel_size_x, pixel_size_y):\n    # Calculate slope using the Sobel operator\n    slope_x = np.gradient(elevation_data, pixel_size_x, axis=1)\n    slope_y = np.gradient(elevation_data, pixel_size_y, axis=0)\n    slope_rad = np.arctan(np.sqrt(slope_x ** 2 + slope_y ** 2))\n    slope_deg = np.degrees(slope_rad)\n\n    # Calculate aspect (direction of the steepest descent)\n    aspect_rad = np.arctan2(slope_y, -slope_x)\n    aspect_deg = (np.degrees(aspect_rad) + 360) % 360\n\n    return slope_deg, aspect_deg\n\n\ndef calculate_curvature(elevation_data, pixel_size_x, pixel_size_y):\n    # Calculate curvature using the Laplacian operator\n    curvature_x = np.gradient(np.gradient(elevation_data, pixel_size_x, axis=1), pixel_size_x, axis=1)\n    curvature_y = np.gradient(np.gradient(elevation_data, pixel_size_y, axis=0), pixel_size_y, axis=0)\n    curvature = curvature_x + curvature_y\n\n    return curvature\n\n\ndef read_elevation_data(file_path):\n    dataset = gdal.Open(file_path)\n    if dataset is None:\n        print(\"Error: Could not open the file.\")\n        return None\n\n    band = dataset.GetRasterBand(1)\n    elevation_data = band.ReadAsArray()\n\n    # Get geotransform information\n    geotransform = dataset.GetGeoTransform()\n    min_lon, pixel_size_x, _, max_lat, _, pixel_size_y = geotransform\n\n    # Calculate raster size\n    raster_width = dataset.RasterXSize\n    raster_height = dataset.RasterYSize\n\n    # Generate latitude and longitude arrays\n    lats = np.arange(max_lat, max_lat - pixel_size_y * raster_height, -pixel_size_y)\n    lons = np.arange(min_lon, min_lon + pixel_size_x * raster_width, pixel_size_x)\n\n    # Create meshgrid of latitude and longitude\n    lon_grid, lat_grid = np.meshgrid(lons, lats)\n\n    # Flatten the data and the lat/lon grids\n    elevation_data_flat = elevation_data.flatten()\n    lat_grid_flat = lat_grid.flatten()\n    lon_grid_flat = lon_grid.flatten()\n\n    # Create a DataFrame to store the data\n    df = pd.DataFrame({\n        'Latitude': lat_grid_flat,\n        'Longitude': lon_grid_flat,\n        'Elevation': elevation_data_flat,\n    })\n\n    return df\n\n\ndef get_elevation_slope_aspect_curvature(df, lat, lon):\n    # Find the closest latitude and longitude in the DataFrame\n    lat_diff = np.abs(df['Latitude'] - lat)\n    lon_diff = np.abs(df['Longitude'] - lon)\n    closest_index = np.argmin(lat_diff + lon_diff)\n\n    # Extract the elevation, slope, aspect, and curvature at the closest location\n    elevation = df['Elevation'][closest_index]\n    slope = df['Slope'][closest_index]\n    aspect = df['Aspect'][closest_index]\n    curvature = df['Curvature'][closest_index]\n\n    return elevation, slope, aspect, curvature\n\n  \n# Usage example:\nelevation_df = read_elevation_data(\"/home/chetana/gridmet_test_run/output_4km_clipped.tif\")\n\n# # Get elevation, slope, aspect, and curvature based on the given lat and lon\n# latitude_to_find = 34.5  # Replace with the desired latitude\n# longitude_to_find = -120.5  # Replace with the desired longitude\n\n# elevation, slope, aspect, curvature = get_elevation_slope_aspect_curvature(elevation_df, latitude_to_find,\n#                                                                            longitude_to_find)\n\n# print(\"Latitude:\", latitude_to_find)\n# print(\"Longitude:\", longitude_to_find)\n# print(\"Elevation:\", elevation)\n# print(\"Slope:\", slope)\n# print(\"Aspect:\", aspect)\n# print(\"Curvature:\", curvature)\n#convert_the_original_dem_to_template_spatial_extent()\n",
  "history_output" : "",
  "history_begin_time" : 1690169014497,
  "history_end_time" : 1690169016614,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "QDiDyVo8JZNh",
  "history_input" : "import numpy as np\nimport pandas as pd\nfrom osgeo import gdal\n\nimport rasterio\nfrom rasterio.warp import calculate_default_transform, reproject, Resampling\n\nimport numpy as np\n\n\ndef calculate_slope_aspect(elevation_data, pixel_size_x, pixel_size_y):\n    # Calculate slope using the Sobel operator\n    slope_x = np.gradient(elevation_data, pixel_size_x, axis=1)\n    slope_y = np.gradient(elevation_data, pixel_size_y, axis=0)\n    slope_rad = np.arctan(np.sqrt(slope_x ** 2 + slope_y ** 2))\n    slope_deg = np.degrees(slope_rad)\n\n    # Calculate aspect (direction of the steepest descent)\n    aspect_rad = np.arctan2(slope_y, -slope_x)\n    aspect_deg = (np.degrees(aspect_rad) + 360) % 360\n\n    return slope_deg, aspect_deg\n\n\ndef calculate_curvature(elevation_data, pixel_size_x, pixel_size_y):\n    # Calculate curvature using the Laplacian operator\n    curvature_x = np.gradient(np.gradient(elevation_data, pixel_size_x, axis=1), pixel_size_x, axis=1)\n    curvature_y = np.gradient(np.gradient(elevation_data, pixel_size_y, axis=0), pixel_size_y, axis=0)\n    curvature = curvature_x + curvature_y\n\n    return curvature\n\n\ndef read_elevation_data(file_path):\n    dataset = gdal.Open(file_path)\n    if dataset is None:\n        print(\"Error: Could not open the file.\")\n        return None\n\n    band = dataset.GetRasterBand(1)\n    elevation_data = band.ReadAsArray()\n\n    # Get geotransform information\n    geotransform = dataset.GetGeoTransform()\n    min_lon, pixel_size_x, _, max_lat, _, pixel_size_y = geotransform\n\n    # Calculate raster size\n    raster_width = dataset.RasterXSize\n    raster_height = dataset.RasterYSize\n\n    # Generate latitude and longitude arrays\n    lats = np.arange(max_lat, max_lat - pixel_size_y * raster_height, -pixel_size_y)\n    lons = np.arange(min_lon, min_lon + pixel_size_x * raster_width, pixel_size_x)\n\n    # Create meshgrid of latitude and longitude\n    lon_grid, lat_grid = np.meshgrid(lons, lats)\n\n    # Flatten the data and the lat/lon grids\n    elevation_data_flat = elevation_data.flatten()\n    lat_grid_flat = lat_grid.flatten()\n    lon_grid_flat = lon_grid.flatten()\n\n    # Create a DataFrame to store the data\n    df = pd.DataFrame({\n        'Latitude': lat_grid_flat,\n        'Longitude': lon_grid_flat,\n        'Elevation': elevation_data_flat,\n    })\n\n    return df\n\n\ndef get_elevation_slope_aspect_curvature(df, lat, lon):\n    # Find the closest latitude and longitude in the DataFrame\n    lat_diff = np.abs(df['Latitude'] - lat)\n    lon_diff = np.abs(df['Longitude'] - lon)\n    closest_index = np.argmin(lat_diff + lon_diff)\n\n    # Extract the elevation, slope, aspect, and curvature at the closest location\n    elevation = df['Elevation'][closest_index]\n    slope = df['Slope'][closest_index]\n    aspect = df['Aspect'][closest_index]\n    curvature = df['Curvature'][closest_index]\n\n    return elevation, slope, aspect, curvature\n\n\ndef convert_the_original_dem_to_template_spatial_extent():\n    # Define the spatial extent of the western U.S. (minx, miny, maxx, maxy)\n    minx, miny, maxx, maxy = -125, 25, -100, 49\n\n    # Define the resolution in degrees (4km is approximately 0.036 degrees)\n    resolution = 0.036\n\n    # Define the filename of the original DEM image to be clipped and resampled\n    original_dem_filename = \"/home/chetana/gridmet_test_run/output_4km.tif\"\n\n    # Define the filename of the template DEM image\n    template_dem_filename = \"/home/chetana/western_us_geotiff_template.tif\"\n\n    # Open the original DEM image with rasterio\n    with rasterio.open(original_dem_filename) as src:\n        # Get the CRS of the original DEM\n        src_crs = src.crs\n\n        # Calculate the window for the portion of the original DEM image that overlaps with the template\n        window = src.window(minx, miny, maxx, maxy)\n\n        # Read the data in the window\n        data = src.read(1, window=window)\n\n        # Calculate the transformation parameters to align the original DEM with the template DEM\n        transform, width, height = calculate_default_transform(\n            src_crs, 'EPSG:4326', window.width, window.height, *src.bounds)\n\n        # Create a destination array to store the resampled data\n        destination = np.zeros((height, width), dtype=src.dtypes[0])\n\n        # Reproject and resample the original DEM image to match the template DEM\n        reproject(\n            source=data,\n            destination=destination,\n            src_transform=src.transform,\n            src_crs=src_crs,\n            dst_transform=transform,\n            dst_crs='EPSG:4326',\n            resampling=Resampling.nearest,\n        )\n\n        # Create the output GeoTIFF with the clipped and resampled data\n        with rasterio.open(\n            \"clipped_resampled_dem.tif\",\n            'w',\n            driver='GTiff',\n            height=height,\n            width=width,\n            count=1,\n            dtype=src.dtypes[0],\n            crs='EPSG:4326',\n            transform=transform,\n        ) as dst:\n            # Write the clipped and resampled data to the raster\n            dst.write(destination, 1)\n\n  \n# Usage example:\n# elevation_df = read_elevation_data(\"/home/chetana/gridmet_test_run/output_4km.tif\")\n\n# # Get elevation, slope, aspect, and curvature based on the given lat and lon\n# latitude_to_find = 34.5  # Replace with the desired latitude\n# longitude_to_find = -120.5  # Replace with the desired longitude\n\n# elevation, slope, aspect, curvature = get_elevation_slope_aspect_curvature(elevation_df, latitude_to_find,\n#                                                                            longitude_to_find)\n\n# print(\"Latitude:\", latitude_to_find)\n# print(\"Longitude:\", longitude_to_find)\n# print(\"Elevation:\", elevation)\n# print(\"Slope:\", slope)\n# print(\"Aspect:\", aspect)\n# print(\"Curvature:\", curvature)\nconvert_the_original_dem_to_template_spatial_extent()\n",
  "history_output" : "Traceback (most recent call last):\n  File \"/home/chetana/gw-workspace/QDiDyVo8JZNh/western_us_dem.py\", line 162, in <module>\n    convert_the_original_dem_to_template_spatial_extent()\n  File \"/home/chetana/gw-workspace/QDiDyVo8JZNh/western_us_dem.py\", line 120, in convert_the_original_dem_to_template_spatial_extent\n    reproject(\n  File \"/home/chetana/anaconda3/lib/python3.9/site-packages/rasterio/env.py\", line 398, in wrapper\n    return f(*args, **kwds)\n  File \"/home/chetana/anaconda3/lib/python3.9/site-packages/rasterio/warp.py\", line 344, in reproject\n    _reproject(\n  File \"rasterio/_warp.pyx\", line 400, in rasterio._warp._reproject\n  File \"rasterio/_warp.pyx\", line 362, in rasterio._warp._reproject\nrasterio.errors.CRSError: Missing src_crs.\n",
  "history_begin_time" : 1690160673243,
  "history_end_time" : 1690160680081,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : null,
  "indicator" : "Failed"
},{
  "history_id" : "aqFJQeJA68FY",
  "history_input" : "import numpy as np\nimport pandas as pd\nfrom osgeo import gdal\n\nimport rasterio\nfrom rasterio.warp import calculate_default_transform, reproject, Resampling\n\nimport numpy as np\n\n\ndef calculate_slope_aspect(elevation_data, pixel_size_x, pixel_size_y):\n    # Calculate slope using the Sobel operator\n    slope_x = np.gradient(elevation_data, pixel_size_x, axis=1)\n    slope_y = np.gradient(elevation_data, pixel_size_y, axis=0)\n    slope_rad = np.arctan(np.sqrt(slope_x ** 2 + slope_y ** 2))\n    slope_deg = np.degrees(slope_rad)\n\n    # Calculate aspect (direction of the steepest descent)\n    aspect_rad = np.arctan2(slope_y, -slope_x)\n    aspect_deg = (np.degrees(aspect_rad) + 360) % 360\n\n    return slope_deg, aspect_deg\n\n\ndef calculate_curvature(elevation_data, pixel_size_x, pixel_size_y):\n    # Calculate curvature using the Laplacian operator\n    curvature_x = np.gradient(np.gradient(elevation_data, pixel_size_x, axis=1), pixel_size_x, axis=1)\n    curvature_y = np.gradient(np.gradient(elevation_data, pixel_size_y, axis=0), pixel_size_y, axis=0)\n    curvature = curvature_x + curvature_y\n\n    return curvature\n\n\ndef read_elevation_data(file_path):\n    dataset = gdal.Open(file_path)\n    if dataset is None:\n        print(\"Error: Could not open the file.\")\n        return None\n\n    band = dataset.GetRasterBand(1)\n    elevation_data = band.ReadAsArray()\n\n    # Get geotransform information\n    geotransform = dataset.GetGeoTransform()\n    min_lon, pixel_size_x, _, max_lat, _, pixel_size_y = geotransform\n\n    # Calculate raster size\n    raster_width = dataset.RasterXSize\n    raster_height = dataset.RasterYSize\n\n    # Generate latitude and longitude arrays\n    lats = np.arange(max_lat, max_lat - pixel_size_y * raster_height, -pixel_size_y)\n    lons = np.arange(min_lon, min_lon + pixel_size_x * raster_width, pixel_size_x)\n\n    # Create meshgrid of latitude and longitude\n    lon_grid, lat_grid = np.meshgrid(lons, lats)\n\n    # Flatten the data and the lat/lon grids\n    elevation_data_flat = elevation_data.flatten()\n    lat_grid_flat = lat_grid.flatten()\n    lon_grid_flat = lon_grid.flatten()\n\n    # Create a DataFrame to store the data\n    df = pd.DataFrame({\n        'Latitude': lat_grid_flat,\n        'Longitude': lon_grid_flat,\n        'Elevation': elevation_data_flat,\n    })\n\n    return df\n\n\ndef get_elevation_slope_aspect_curvature(df, lat, lon):\n    # Find the closest latitude and longitude in the DataFrame\n    lat_diff = np.abs(df['Latitude'] - lat)\n    lon_diff = np.abs(df['Longitude'] - lon)\n    closest_index = np.argmin(lat_diff + lon_diff)\n\n    # Extract the elevation, slope, aspect, and curvature at the closest location\n    elevation = df['Elevation'][closest_index]\n    slope = df['Slope'][closest_index]\n    aspect = df['Aspect'][closest_index]\n    curvature = df['Curvature'][closest_index]\n\n    return elevation, slope, aspect, curvature\n\n\ndef convert_the_original_dem_to_template_spatial_extent():\n    # Define the spatial extent of the western U.S. (minx, miny, maxx, maxy)\n    minx, miny, maxx, maxy = -125, 25, -100, 49\n\n    # Define the resolution in degrees (4km is approximately 0.036 degrees)\n    resolution = 0.036\n\n    # Define the filename of the original DEM image to be clipped and resampled\n    original_dem_filename = \"/home/chetana/gridmet_test_run/output_4km.tif\"\n\n    # Define the filename of the template DEM image\n    template_dem_filename = \"/home/chetana/western_us_geotiff_template.tif\"\n\n    # Open the original DEM image with rasterio\n    with rasterio.open(original_dem_filename) as src:\n        # Calculate the window for the portion of the original DEM image that overlaps with the template\n        window = src.window(minx, miny, maxx, maxy)\n\n        # Read the data in the window\n        data = src.read(1, window=window)\n\n        # Calculate the transformation parameters to align the original DEM with the template DEM\n        transform, width, height = calculate_default_transform(\n            src.crs, 'EPSG:4326', window.width, window.height, *src.bounds)\n\n        # Create a destination array to store the resampled data\n        destination = np.zeros((height, width), dtype=src.dtypes[0])\n\n        # Reproject and resample the original DEM image to match the template DEM\n        reproject(\n            source=data,\n            destination=destination,\n            src_transform=src.transform,\n            src_crs=src.crs,\n            dst_transform=transform,\n            dst_crs='EPSG:4326',\n            resampling=Resampling.nearest,\n        )\n\n        # Create the output GeoTIFF with the clipped and resampled data\n        with rasterio.open(\n            \"clipped_resampled_dem.tif\",\n            'w',\n            driver='GTiff',\n            height=height,\n            width=width,\n            count=1,\n            dtype=src.dtypes[0],\n            crs='EPSG:4326',\n            transform=transform,\n        ) as dst:\n            # Write the clipped and resampled data to the raster\n            dst.write(destination, 1)\n\n  \n# Usage example:\n# elevation_df = read_elevation_data(\"/home/chetana/gridmet_test_run/output_4km.tif\")\n\n# # Get elevation, slope, aspect, and curvature based on the given lat and lon\n# latitude_to_find = 34.5  # Replace with the desired latitude\n# longitude_to_find = -120.5  # Replace with the desired longitude\n\n# elevation, slope, aspect, curvature = get_elevation_slope_aspect_curvature(elevation_df, latitude_to_find,\n#                                                                            longitude_to_find)\n\n# print(\"Latitude:\", latitude_to_find)\n# print(\"Longitude:\", longitude_to_find)\n# print(\"Elevation:\", elevation)\n# print(\"Slope:\", slope)\n# print(\"Aspect:\", aspect)\n# print(\"Curvature:\", curvature)\nconvert_the_original_dem_to_template_spatial_extent()\n",
  "history_output" : "Traceback (most recent call last):\n  File \"/home/chetana/gw-workspace/aqFJQeJA68FY/western_us_dem.py\", line 159, in <module>\n    convert_the_original_dem_to_template_spatial_extent()\n  File \"/home/chetana/gw-workspace/aqFJQeJA68FY/western_us_dem.py\", line 117, in convert_the_original_dem_to_template_spatial_extent\n    reproject(\n  File \"/home/chetana/anaconda3/lib/python3.9/site-packages/rasterio/env.py\", line 398, in wrapper\n    return f(*args, **kwds)\n  File \"/home/chetana/anaconda3/lib/python3.9/site-packages/rasterio/warp.py\", line 344, in reproject\n    _reproject(\n  File \"rasterio/_warp.pyx\", line 400, in rasterio._warp._reproject\n  File \"rasterio/_warp.pyx\", line 362, in rasterio._warp._reproject\nrasterio.errors.CRSError: Missing src_crs.\n",
  "history_begin_time" : 1690160621734,
  "history_end_time" : 1690160628169,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : null,
  "indicator" : "Failed"
},{
  "history_id" : "8AkbFwTOLJlO",
  "history_input" : "import numpy as np\nimport pandas as pd\nfrom osgeo import gdal\n\nimport rasterio\nfrom rasterio.warp import reproject, Resampling\nimport numpy as np\n\n\ndef calculate_slope_aspect(elevation_data, pixel_size_x, pixel_size_y):\n    # Calculate slope using the Sobel operator\n    slope_x = np.gradient(elevation_data, pixel_size_x, axis=1)\n    slope_y = np.gradient(elevation_data, pixel_size_y, axis=0)\n    slope_rad = np.arctan(np.sqrt(slope_x ** 2 + slope_y ** 2))\n    slope_deg = np.degrees(slope_rad)\n\n    # Calculate aspect (direction of the steepest descent)\n    aspect_rad = np.arctan2(slope_y, -slope_x)\n    aspect_deg = (np.degrees(aspect_rad) + 360) % 360\n\n    return slope_deg, aspect_deg\n\n\ndef calculate_curvature(elevation_data, pixel_size_x, pixel_size_y):\n    # Calculate curvature using the Laplacian operator\n    curvature_x = np.gradient(np.gradient(elevation_data, pixel_size_x, axis=1), pixel_size_x, axis=1)\n    curvature_y = np.gradient(np.gradient(elevation_data, pixel_size_y, axis=0), pixel_size_y, axis=0)\n    curvature = curvature_x + curvature_y\n\n    return curvature\n\n\ndef read_elevation_data(file_path):\n    dataset = gdal.Open(file_path)\n    if dataset is None:\n        print(\"Error: Could not open the file.\")\n        return None\n\n    band = dataset.GetRasterBand(1)\n    elevation_data = band.ReadAsArray()\n\n    # Get geotransform information\n    geotransform = dataset.GetGeoTransform()\n    min_lon, pixel_size_x, _, max_lat, _, pixel_size_y = geotransform\n\n    # Calculate raster size\n    raster_width = dataset.RasterXSize\n    raster_height = dataset.RasterYSize\n\n    # Generate latitude and longitude arrays\n    lats = np.arange(max_lat, max_lat - pixel_size_y * raster_height, -pixel_size_y)\n    lons = np.arange(min_lon, min_lon + pixel_size_x * raster_width, pixel_size_x)\n\n    # Create meshgrid of latitude and longitude\n    lon_grid, lat_grid = np.meshgrid(lons, lats)\n\n    # Flatten the data and the lat/lon grids\n    elevation_data_flat = elevation_data.flatten()\n    lat_grid_flat = lat_grid.flatten()\n    lon_grid_flat = lon_grid.flatten()\n\n    # Create a DataFrame to store the data\n    df = pd.DataFrame({\n        'Latitude': lat_grid_flat,\n        'Longitude': lon_grid_flat,\n        'Elevation': elevation_data_flat,\n    })\n\n    return df\n\n\ndef get_elevation_slope_aspect_curvature(df, lat, lon):\n    # Find the closest latitude and longitude in the DataFrame\n    lat_diff = np.abs(df['Latitude'] - lat)\n    lon_diff = np.abs(df['Longitude'] - lon)\n    closest_index = np.argmin(lat_diff + lon_diff)\n\n    # Extract the elevation, slope, aspect, and curvature at the closest location\n    elevation = df['Elevation'][closest_index]\n    slope = df['Slope'][closest_index]\n    aspect = df['Aspect'][closest_index]\n    curvature = df['Curvature'][closest_index]\n\n    return elevation, slope, aspect, curvature\n\n\ndef convert_the_original_dem_to_template_spatial_extent():\n    # Define the spatial extent of the western U.S. (minx, miny, maxx, maxy)\n    minx, miny, maxx, maxy = -125, 25, -100, 49\n\n    # Define the resolution in degrees (4km is approximately 0.036 degrees)\n    resolution = 0.036\n\n    # Define the filename of the original DEM image to be clipped and resampled\n    original_dem_filename = \"/home/chetana/gridmet_test_run/output_4km.tif\"\n\n    # Define the filename of the template DEM image\n    template_dem_filename = \"/home/chetana/western_us_geotiff_template.tif\"\n\n    # Open the original DEM image with rasterio\n    with rasterio.open(original_dem_filename) as src:\n        # Calculate the window for the portion of the original DEM image that overlaps with the template\n        window = src.window(minx, miny, maxx, maxy)\n\n        # Read the data in the window\n        data = src.read(1, window=window)\n\n        # Calculate the transformation parameters to align the original DEM with the template DEM\n        transform, width, height = calculate_default_transform(\n            src.crs, 'EPSG:4326', window.width, window.height, *src.bounds)\n\n        # Create a destination array to store the resampled data\n        destination = np.zeros((height, width), dtype=src.dtypes[0])\n\n        # Reproject and resample the original DEM image to match the template DEM\n        reproject(\n            source=data,\n            destination=destination,\n            src_transform=src.transform,\n            src_crs=src.crs,\n            dst_transform=transform,\n            dst_crs='EPSG:4326',\n            resampling=Resampling.nearest,\n        )\n\n        # Create the output GeoTIFF with the clipped and resampled data\n        with rasterio.open(\n            \"clipped_resampled_dem.tif\",\n            'w',\n            driver='GTiff',\n            height=height,\n            width=width,\n            count=1,\n            dtype=src.dtypes[0],\n            crs='EPSG:4326',\n            transform=transform,\n        ) as dst:\n            # Write the clipped and resampled data to the raster\n            dst.write(destination, 1)\n\n  \n# Usage example:\n# elevation_df = read_elevation_data(\"/home/chetana/gridmet_test_run/output_4km.tif\")\n\n# # Get elevation, slope, aspect, and curvature based on the given lat and lon\n# latitude_to_find = 34.5  # Replace with the desired latitude\n# longitude_to_find = -120.5  # Replace with the desired longitude\n\n# elevation, slope, aspect, curvature = get_elevation_slope_aspect_curvature(elevation_df, latitude_to_find,\n#                                                                            longitude_to_find)\n\n# print(\"Latitude:\", latitude_to_find)\n# print(\"Longitude:\", longitude_to_find)\n# print(\"Elevation:\", elevation)\n# print(\"Slope:\", slope)\n# print(\"Aspect:\", aspect)\n# print(\"Curvature:\", curvature)\nconvert_the_original_dem_to_template_spatial_extent()\n",
  "history_output" : "Traceback (most recent call last):\n  File \"/home/chetana/gw-workspace/8AkbFwTOLJlO/western_us_dem.py\", line 158, in <module>\n    convert_the_original_dem_to_template_spatial_extent()\n  File \"/home/chetana/gw-workspace/8AkbFwTOLJlO/western_us_dem.py\", line 109, in convert_the_original_dem_to_template_spatial_extent\n    transform, width, height = calculate_default_transform(\nNameError: name 'calculate_default_transform' is not defined\n",
  "history_begin_time" : 1690157843005,
  "history_end_time" : 1690157857271,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : null,
  "indicator" : "Failed"
},{
  "history_id" : "O1scJsIW32NY",
  "history_input" : "import numpy as np\nimport pandas as pd\nfrom osgeo import gdal\n\nimport rasterio\nfrom rasterio.warp import reproject, Resampling\nimport numpy as np\n\n\ndef calculate_slope_aspect(elevation_data, pixel_size_x, pixel_size_y):\n    # Calculate slope using the Sobel operator\n    slope_x = np.gradient(elevation_data, pixel_size_x, axis=1)\n    slope_y = np.gradient(elevation_data, pixel_size_y, axis=0)\n    slope_rad = np.arctan(np.sqrt(slope_x ** 2 + slope_y ** 2))\n    slope_deg = np.degrees(slope_rad)\n\n    # Calculate aspect (direction of the steepest descent)\n    aspect_rad = np.arctan2(slope_y, -slope_x)\n    aspect_deg = (np.degrees(aspect_rad) + 360) % 360\n\n    return slope_deg, aspect_deg\n\n\ndef calculate_curvature(elevation_data, pixel_size_x, pixel_size_y):\n    # Calculate curvature using the Laplacian operator\n    curvature_x = np.gradient(np.gradient(elevation_data, pixel_size_x, axis=1), pixel_size_x, axis=1)\n    curvature_y = np.gradient(np.gradient(elevation_data, pixel_size_y, axis=0), pixel_size_y, axis=0)\n    curvature = curvature_x + curvature_y\n\n    return curvature\n\n\ndef read_elevation_data(file_path):\n    dataset = gdal.Open(file_path)\n    if dataset is None:\n        print(\"Error: Could not open the file.\")\n        return None\n\n    band = dataset.GetRasterBand(1)\n    elevation_data = band.ReadAsArray()\n\n    # Get geotransform information\n    geotransform = dataset.GetGeoTransform()\n    min_lon, pixel_size_x, _, max_lat, _, pixel_size_y = geotransform\n\n    # Calculate raster size\n    raster_width = dataset.RasterXSize\n    raster_height = dataset.RasterYSize\n\n    # Generate latitude and longitude arrays\n    lats = np.arange(max_lat, max_lat - pixel_size_y * raster_height, -pixel_size_y)\n    lons = np.arange(min_lon, min_lon + pixel_size_x * raster_width, pixel_size_x)\n\n    # Create meshgrid of latitude and longitude\n    lon_grid, lat_grid = np.meshgrid(lons, lats)\n\n    # Flatten the data and the lat/lon grids\n    elevation_data_flat = elevation_data.flatten()\n    lat_grid_flat = lat_grid.flatten()\n    lon_grid_flat = lon_grid.flatten()\n\n    # Create a DataFrame to store the data\n    df = pd.DataFrame({\n        'Latitude': lat_grid_flat,\n        'Longitude': lon_grid_flat,\n        'Elevation': elevation_data_flat,\n    })\n\n    return df\n\n\ndef get_elevation_slope_aspect_curvature(df, lat, lon):\n    # Find the closest latitude and longitude in the DataFrame\n    lat_diff = np.abs(df['Latitude'] - lat)\n    lon_diff = np.abs(df['Longitude'] - lon)\n    closest_index = np.argmin(lat_diff + lon_diff)\n\n    # Extract the elevation, slope, aspect, and curvature at the closest location\n    elevation = df['Elevation'][closest_index]\n    slope = df['Slope'][closest_index]\n    aspect = df['Aspect'][closest_index]\n    curvature = df['Curvature'][closest_index]\n\n    return elevation, slope, aspect, curvature\n\n\ndef convert_the_original_dem_to_template_spatial_extent():\n    # Define the spatial extent of the western U.S. (minx, miny, maxx, maxy)\n    minx, miny, maxx, maxy = -125, 25, -100, 49\n\n    # Define the resolution in degrees (4km is approximately 0.036 degrees)\n    resolution = 0.036\n\n    # Define the filename of the original DEM image to be clipped and resampled\n    original_dem_filename = \"/home/chetana/gridmet_test_run/output_4km.tif\"\n\n    # Define the filename of the template DEM image\n    template_dem_filename = \"/home/chetana/western_us_geotiff_template.tif\"\n\n    # Open the original DEM image with rasterio\n    with rasterio.open(original_dem_filename) as src:\n        # Calculate the window for the portion of the original DEM image that overlaps with the template\n        window = src.window(minx, miny, maxx, maxy)\n\n        # Read the data in the window\n        data = src.read(1, window=window)\n\n        # Calculate the transformation parameters to align the original DEM with the template DEM\n        transform, width, height = rasterio.warp.calculate_default_transform(\n            src.crs, 'EPSG:4326', window.width, window.height, *window.bounds)\n\n        # Create a destination array to store the resampled data\n        destination = np.zeros((height, width), dtype=src.dtypes[0])\n\n        # Reproject and resample the original DEM image to match the template DEM\n        reproject(\n            source=data,\n            destination=destination,\n            src_transform=src.transform,\n            src_crs=src.crs,\n            dst_transform=transform,\n            dst_crs='EPSG:4326',\n            resampling=Resampling.nearest,\n        )\n\n        # Create the output GeoTIFF with the clipped and resampled data\n        with rasterio.open(\n            \"clipped_resampled_dem.tif\",\n            'w',\n            driver='GTiff',\n            height=height,\n            width=width,\n            count=1,\n            dtype=src.dtypes[0],\n            crs='EPSG:4326',\n            transform=transform,\n        ) as dst:\n            # Write the clipped and resampled data to the raster\n            dst.write(destination, 1)\n\n  \n# Usage example:\n# elevation_df = read_elevation_data(\"/home/chetana/gridmet_test_run/output_4km.tif\")\n\n# # Get elevation, slope, aspect, and curvature based on the given lat and lon\n# latitude_to_find = 34.5  # Replace with the desired latitude\n# longitude_to_find = -120.5  # Replace with the desired longitude\n\n# elevation, slope, aspect, curvature = get_elevation_slope_aspect_curvature(elevation_df, latitude_to_find,\n#                                                                            longitude_to_find)\n\n# print(\"Latitude:\", latitude_to_find)\n# print(\"Longitude:\", longitude_to_find)\n# print(\"Elevation:\", elevation)\n# print(\"Slope:\", slope)\n# print(\"Aspect:\", aspect)\n# print(\"Curvature:\", curvature)\nconvert_the_original_dem_to_template_spatial_extent()\n",
  "history_output" : "Traceback (most recent call last):\n  File \"/home/chetana/gw-workspace/O1scJsIW32NY/western_us_dem.py\", line 158, in <module>\n    convert_the_original_dem_to_template_spatial_extent()\n  File \"/home/chetana/gw-workspace/O1scJsIW32NY/western_us_dem.py\", line 110, in convert_the_original_dem_to_template_spatial_extent\n    src.crs, 'EPSG:4326', window.width, window.height, *window.bounds)\nAttributeError: 'Window' object has no attribute 'bounds'\n",
  "history_begin_time" : 1690157516604,
  "history_end_time" : 1690157535564,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : null,
  "indicator" : "Failed"
},{
  "history_id" : "2TnCj0nfE3qa",
  "history_input" : "import numpy as np\nimport pandas as pd\nfrom osgeo import gdal\n\n\ndef calculate_slope_aspect(elevation_data, pixel_size_x, pixel_size_y):\n    # Calculate slope using the Sobel operator\n    slope_x = np.gradient(elevation_data, pixel_size_x, axis=1)\n    slope_y = np.gradient(elevation_data, pixel_size_y, axis=0)\n    slope_rad = np.arctan(np.sqrt(slope_x ** 2 + slope_y ** 2))\n    slope_deg = np.degrees(slope_rad)\n\n    # Calculate aspect (direction of the steepest descent)\n    aspect_rad = np.arctan2(slope_y, -slope_x)\n    aspect_deg = (np.degrees(aspect_rad) + 360) % 360\n\n    return slope_deg, aspect_deg\n\n\ndef calculate_curvature(elevation_data, pixel_size_x, pixel_size_y):\n    # Calculate curvature using the Laplacian operator\n    curvature_x = np.gradient(np.gradient(elevation_data, pixel_size_x, axis=1), pixel_size_x, axis=1)\n    curvature_y = np.gradient(np.gradient(elevation_data, pixel_size_y, axis=0), pixel_size_y, axis=0)\n    curvature = curvature_x + curvature_y\n\n    return curvature\n\n\ndef read_elevation_data(file_path):\n    dataset = gdal.Open(file_path)\n    if dataset is None:\n        print(\"Error: Could not open the file.\")\n        return None\n\n    band = dataset.GetRasterBand(1)\n    elevation_data = band.ReadAsArray()\n\n    # Get geotransform information\n    geotransform = dataset.GetGeoTransform()\n    min_lon, pixel_size_x, _, max_lat, _, pixel_size_y = geotransform\n\n    # Calculate raster size\n    raster_width = dataset.RasterXSize\n    raster_height = dataset.RasterYSize\n\n    # Generate latitude and longitude arrays\n    lats = np.arange(max_lat, max_lat - pixel_size_y * raster_height, -pixel_size_y)\n    lons = np.arange(min_lon, min_lon + pixel_size_x * raster_width, pixel_size_x)\n\n    # Create meshgrid of latitude and longitude\n    lon_grid, lat_grid = np.meshgrid(lons, lats)\n\n    # Flatten the data and the lat/lon grids\n    elevation_data_flat = elevation_data.flatten()\n    lat_grid_flat = lat_grid.flatten()\n    lon_grid_flat = lon_grid.flatten()\n\n    # Create a DataFrame to store the data\n    df = pd.DataFrame({\n        'Latitude': lat_grid_flat,\n        'Longitude': lon_grid_flat,\n        'Elevation': elevation_data_flat,\n    })\n\n    return df\n\n\ndef get_elevation_slope_aspect_curvature(df, lat, lon):\n    # Find the closest latitude and longitude in the DataFrame\n    lat_diff = np.abs(df['Latitude'] - lat)\n    lon_diff = np.abs(df['Longitude'] - lon)\n    closest_index = np.argmin(lat_diff + lon_diff)\n\n    # Extract the elevation, slope, aspect, and curvature at the closest location\n    elevation = df['Elevation'][closest_index]\n    slope = df['Slope'][closest_index]\n    aspect = df['Aspect'][closest_index]\n    curvature = df['Curvature'][closest_index]\n\n    return elevation, slope, aspect, curvature\n\n\n# Usage example:\nelevation_df = read_elevation_data(\"/home/chetana/gridmet_test_run/output_4km.tif\")\n\n# Get elevation, slope, aspect, and curvature based on the given lat and lon\nlatitude_to_find = 34.5  # Replace with the desired latitude\nlongitude_to_find = -120.5  # Replace with the desired longitude\n\nelevation, slope, aspect, curvature = get_elevation_slope_aspect_curvature(elevation_df, latitude_to_find,\n                                                                           longitude_to_find)\n\nprint(\"Latitude:\", latitude_to_find)\nprint(\"Longitude:\", longitude_to_find)\nprint(\"Elevation:\", elevation)\nprint(\"Slope:\", slope)\nprint(\"Aspect:\", aspect)\nprint(\"Curvature:\", curvature)\n",
  "history_output" : "Traceback (most recent call last):\n  File \"western_us_dem.py\", line 2, in <module>\n    import pandas as pd\nImportError: No module named pandas\n",
  "history_begin_time" : 1690139482059,
  "history_end_time" : 1690139483928,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "5lDGIJ82ayGf",
  "history_input" : "import numpy as np\nimport pandas as pd\nfrom osgeo import gdal\n\n\ndef calculate_slope_aspect(elevation_data, pixel_size_x, pixel_size_y):\n    # Calculate slope using the Sobel operator\n    slope_x = np.gradient(elevation_data, pixel_size_x, axis=1)\n    slope_y = np.gradient(elevation_data, pixel_size_y, axis=0)\n    slope_rad = np.arctan(np.sqrt(slope_x ** 2 + slope_y ** 2))\n    slope_deg = np.degrees(slope_rad)\n\n    # Calculate aspect (direction of the steepest descent)\n    aspect_rad = np.arctan2(slope_y, -slope_x)\n    aspect_deg = (np.degrees(aspect_rad) + 360) % 360\n\n    return slope_deg, aspect_deg\n\n\ndef calculate_curvature(elevation_data, pixel_size_x, pixel_size_y):\n    # Calculate curvature using the Laplacian operator\n    curvature_x = np.gradient(np.gradient(elevation_data, pixel_size_x, axis=1), pixel_size_x, axis=1)\n    curvature_y = np.gradient(np.gradient(elevation_data, pixel_size_y, axis=0), pixel_size_y, axis=0)\n    curvature = curvature_x + curvature_y\n\n    return curvature\n\n\ndef read_elevation_data(file_path):\n    dataset = gdal.Open(file_path)\n    if dataset is None:\n        print(\"Error: Could not open the file.\")\n        return None\n\n    band = dataset.GetRasterBand(1)\n    elevation_data = band.ReadAsArray()\n\n    # Get geotransform information\n    geotransform = dataset.GetGeoTransform()\n    min_lon, pixel_size_x, _, max_lat, _, pixel_size_y = geotransform\n\n    # Calculate raster size\n    raster_width = dataset.RasterXSize\n    raster_height = dataset.RasterYSize\n\n    # Generate latitude and longitude arrays\n    lats = np.arange(max_lat, max_lat - pixel_size_y * raster_height, -pixel_size_y)\n    lons = np.arange(min_lon, min_lon + pixel_size_x * raster_width, pixel_size_x)\n\n    # Create meshgrid of latitude and longitude\n    lon_grid, lat_grid = np.meshgrid(lons, lats)\n\n    # Flatten the data and the lat/lon grids\n    elevation_data_flat = elevation_data.flatten()\n    lat_grid_flat = lat_grid.flatten()\n    lon_grid_flat = lon_grid.flatten()\n\n    # Create a DataFrame to store the data\n    df = pd.DataFrame({\n        'Latitude': lat_grid_flat,\n        'Longitude': lon_grid_flat,\n        'Elevation': elevation_data_flat,\n    })\n\n    return df\n\n\ndef get_elevation_slope_aspect_curvature(df, lat, lon):\n    # Find the closest latitude and longitude in the DataFrame\n    lat_diff = np.abs(df['Latitude'] - lat)\n    lon_diff = np.abs(df['Longitude'] - lon)\n    closest_index = np.argmin(lat_diff + lon_diff)\n\n    # Extract the elevation, slope, aspect, and curvature at the closest location\n    elevation = df['Elevation'][closest_index]\n    slope = df['Slope'][closest_index]\n    aspect = df['Aspect'][closest_index]\n    curvature = df['Curvature'][closest_index]\n\n    return elevation, slope, aspect, curvature\n\n\n# Usage example:\nelevation_df = read_elevation_data(\"/home/chetana/gridmet_test_run/output_4km.tif\")\n\n# Get elevation, slope, aspect, and curvature based on the given lat and lon\nlatitude_to_find = 34.5  # Replace with the desired latitude\nlongitude_to_find = -120.5  # Replace with the desired longitude\n\nelevation, slope, aspect, curvature = get_elevation_slope_aspect_curvature(elevation_df, latitude_to_find,\n                                                                           longitude_to_find)\n\nprint(\"Latitude:\", latitude_to_find)\nprint(\"Longitude:\", longitude_to_find)\nprint(\"Elevation:\", elevation)\nprint(\"Slope:\", slope)\nprint(\"Aspect:\", aspect)\nprint(\"Curvature:\", curvature)\n",
  "history_output" : "Traceback (most recent call last):\n  File \"/home/chetana/gw-workspace/5lDGIJ82ayGf/western_us_dem.py\", line 3, in <module>\n    from osgeo import gdal\nModuleNotFoundError: No module named 'osgeo'\n",
  "history_begin_time" : 1690139463911,
  "history_end_time" : 1690139468138,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "y8PuXVGFm7Jg",
  "history_input" : "import numpy as np\nimport pandas as pd\nfrom osgeo import gdal\n\ndef calculate_slope_aspect(elevation_data, pixel_size_x, pixel_size_y):\n    # Calculate slope using the Sobel operator\n    slope_x = np.gradient(elevation_data, pixel_size_x, axis=1)\n    slope_y = np.gradient(elevation_data, pixel_size_y, axis=0)\n    slope_rad = np.arctan(np.sqrt(slope_x ** 2 + slope_y ** 2))\n    slope_deg = np.degrees(slope_rad)\n\n    # Calculate aspect (direction of the steepest descent)\n    aspect_rad = np.arctan2(slope_y, -slope_x)\n    aspect_deg = (np.degrees(aspect_rad) + 360) % 360\n\n    return slope_deg, aspect_deg\n\ndef calculate_curvature(elevation_data, pixel_size_x, pixel_size_y):\n    # Calculate curvature using the Laplacian operator\n    curvature_x = np.gradient(np.gradient(elevation_data, pixel_size_x, axis=1), pixel_size_x, axis=1)\n    curvature_y = np.gradient(np.gradient(elevation_data, pixel_size_y, axis=0), pixel_size_y, axis=0)\n    curvature = curvature_x + curvature_y\n\n    return curvature\n\ndef read_elevation_data(file_path):\n    dataset = gdal.Open(file_path)\n    if dataset is None:\n        print(\"Error: Could not open the file.\")\n        return None\n\n    band = dataset.GetRasterBand(1)\n    elevation_data = band.ReadAsArray()\n\n    # Get geotransform information\n    geotransform = dataset.GetGeoTransform()\n    min_lon, pixel_size_x, _, max_lat, _, pixel_size_y = geotransform\n\n    # Calculate raster size\n    raster_width = dataset.RasterXSize\n    raster_height = dataset.RasterYSize\n\n    # Generate latitude and longitude arrays\n    lats = np.arange(max_lat, max_lat - pixel_size_y * raster_height, -pixel_size_y)\n    lons = np.arange(min_lon, min_lon + pixel_size_x * raster_width, pixel_size_x)\n\n    # Calculate slope and aspect\n    slope_data, aspect_data = calculate_slope_aspect(elevation_data, pixel_size_x, pixel_size_y)\n\n    # Calculate curvature\n    curvature_data = calculate_curvature(elevation_data, pixel_size_x, pixel_size_y)\n\n    # Create meshgrid of latitude and longitude\n    lon_grid, lat_grid = np.meshgrid(lons, lats)\n\n    # Flatten the data and the lat/lon grids\n    elevation_data_flat = elevation_data.flatten()\n    slope_data_flat = slope_data.flatten()\n    aspect_data_flat = aspect_data.flatten()\n    curvature_data_flat = curvature_data.flatten()\n    lat_grid_flat = lat_grid.flatten()\n    lon_grid_flat = lon_grid.flatten()\n\n    # Create a DataFrame to store the data\n    df = pd.DataFrame({\n        'Latitude': lat_grid_flat,\n        'Longitude': lon_grid_flat,\n        'Elevation': elevation_data_flat,\n        'Slope': slope_data_flat,\n        'Aspect': aspect_data_flat,\n        'Curvature': curvature_data_flat\n    })\n\n    return df\n\n# Usage example:\nelevation_df = read_elevation_data(\"/home/chetana/gridmet_test_run/output_4km.tif\")\nelevation_df.to_csv('/home/chetana/gridmet_test_run/western_us_dem_testing.csv')",
  "history_output" : "Cannot run program \"/home/chetana/anaconda3/conda/bin/python\" (in directory \"/home/chetana/gw-workspace/y8PuXVGFm7Jg\"): error=2, No such file or directory",
  "history_begin_time" : 1690133122274,
  "history_end_time" : 1690133122278,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : null,
  "indicator" : "Failed"
},{
  "history_id" : "POdXS31NUews",
  "history_input" : "import geopandas as gpd\nimport json\nimport geojson\nfrom pystac_client import Client\nimport planetary_computer\nimport xarray\nimport rioxarray\nimport xrspatial\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport pandas as pd\nfrom pyproj import Proj, transform\nimport os\nimport sys, traceback\nimport requests\n\nhome_dir = os.path.expanduser('~')\nsnowcast_github_dir = f\"{home_dir}/Documents/GitHub/SnowCast/\"\n\n# Exit if this process is no longer needed\n# exit() \n\n# User-defined paths for data access\ndata_dir = f'{snowcast_github_dir}data/'\ngridcells_file = data_dir+'snowcast_provided/grid_cells_eval.geojson'\ngridcells_outfile = data_dir+'terrain/gridcells_terrainData_eval_new.csv'\n\n# Load metadata\ngridcellsGPD = gpd.read_file(gridcells_file)\ngridcells = geojson.load(open(gridcells_file))\n\n# Instantiate output pandas dataframe\ndf_gridcells = pd.DataFrame(columns=(\"Longitude [deg]\",\"Latitude [deg]\",\n                                     \"Elevation [m]\",\"Aspect [deg]\",\n                                     \"Curvature [ratio]\",\"Slope [deg]\",\n                                     \"Eastness [unitCirc.]\",\"Northness [unitCirc.]\"))\n\ndef prepareWesternUSTerrain():\n    # Calculate grid cell characteristics using Copernicus DEM data\n    print(\"Preparing Western US Terrain data\")\n    \n    # read the geotif image\n    \n    # traverse the grid cells\n    spatial_extent = (-103, -90, 20, 50)\n    \n    image_size = (500, 500)\n    \n    for x in image_size[0]:\n      for y in image_size[1]:\n        lat, lon  = convert_xy_to_latlon(x, y)\n        \n        # read the pixel value of location (lat, lon) from the downloaded DEM 90 meter geotif\n        # bounding box\n        lat_range = (lat-0.1, lat+0.1)\n        lon_range = (lon-0.1, lon+0.1)\n        \n        pixel_value_dataarray = read_geotif_values_by_lat_lon_range(lat_range, lon_range)\n        \n        \n    \tprint(\"Reprojecting data to EPSG:32612\")\n\n        # Calculate directional components\n        aspect = xrspatial.aspect(pixel_value_dataarray)\n        aspect_xcomp = np.nansum(np.cos(aspect.values * (np.pi / 180)))\n        aspect_ycomp = np.nansum(np.sin(aspect.values * (np.pi / 180)))\n        mean_aspect = np.arctan2(aspect_ycomp, aspect_xcomp) * (180 / np.pi)\n        if mean_aspect < 0:\n            mean_aspect = 360 + mean_aspect\n        print(\"Aspect:\", mean_aspect)\n        mean_eastness = np.cos(mean_aspect * (np.pi / 180))\n        mean_northness = np.sin(mean_aspect * (np.pi / 180))\n        print(\"Eastness:\", mean_eastness)\n        print(\"Northness:\", mean_northness)\n\n        # Positive curvature = upward convex\n        curvature = xrspatial.curvature(cropped_data)\n        mean_curvature = curvature.mean().values\n        print(\"Curvature:\", mean_curvature)\n\n        # Calculate mean slope\n        slope = xrspatial.slope(cropped_data)\n        mean_slope = slope.mean().values\n        print(\"Slope:\", mean_slope)\n\n        # Fill pandas dataframe\n        image_df.loc[idx] = [lat, lon,\n                                 mean_elev, mean_aspect,\n                                 mean_curvature, mean_slope,\n                                 mean_eastness, mean_northness]\n\n    # Save output data into CSV format\n    image_df.to_csv(image_outfile)\n    \n    \ntry:\n    prepareWesternUSTerrain()\nexcept:\n    traceback.print_exc(file=sys.stdout)\n",
  "history_output" : "Cannot run program \"/home/chetana/anaconda3/conda/bin/python\" (in directory \"/home/chetana/gw-workspace/POdXS31NUews\"): error=2, No such file or directory",
  "history_begin_time" : 1689633328420,
  "history_end_time" : 1689633328761,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : null,
  "indicator" : "Failed"
},{
  "history_id" : "38YDrCVxqHsg",
  "history_input" : "import geopandas as gpd\nimport json\nimport geojson\nfrom pystac_client import Client\nimport planetary_computer\nimport xarray\nimport rioxarray\nimport xrspatial\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport pandas as pd\nfrom pyproj import Proj, transform\nimport os\nimport sys, traceback\nimport requests\n\nhome_dir = os.path.expanduser('~')\nsnowcast_github_dir = f\"{home_dir}/Documents/GitHub/SnowCast/\"\n\n# Exit if this process is no longer needed\n# exit() \n\n# User-defined paths for data access\ndata_dir = f'{snowcast_github_dir}data/'\ngridcells_file = data_dir+'snowcast_provided/grid_cells_eval.geojson'\ngridcells_outfile = data_dir+'terrain/gridcells_terrainData_eval_new.csv'\n\n# Load metadata\ngridcellsGPD = gpd.read_file(gridcells_file)\ngridcells = geojson.load(open(gridcells_file))\n\n# Instantiate output pandas dataframe\ndf_gridcells = pd.DataFrame(columns=(\"Longitude [deg]\",\"Latitude [deg]\",\n                                     \"Elevation [m]\",\"Aspect [deg]\",\n                                     \"Curvature [ratio]\",\"Slope [deg]\",\n                                     \"Eastness [unitCirc.]\",\"Northness [unitCirc.]\"))\n\ndef prepareGridCellTerrain():\n    # Calculate grid cell characteristics using Copernicus DEM data\n    print(\"Preparing GridCell Terrain data\")\n    for idx, cell in enumerate(gridcells['features']):\n        print(\"Processing grid\", idx)\n        # Modify the search parameters to cover the entire western USA region\n        search = client.search(\n            collections=[\"cop-dem-glo-30\"],\n            bbox=[-125.0, 31.0, -102.0, 49.0]  # Western USA bounding box: [min_lon, min_lat, max_lon, max_lat]\n        )\n        items = list(search.get_items())\n        print(\"==> Searched items:\", len(items))\n\n        # Skip if no DEM items are found for the specified region\n        if len(items) == 0:\n            print(\"No DEM data found for the specified region.\")\n            continue\n\n        # Select the first DEM item\n        signed_asset = planetary_computer.sign(items[0].assets[\"data\"])\n        data = (\n            xarray.open_rasterio(signed_asset.href)\n            .squeeze()\n            .drop(\"band\")\n            .coarsen({\"y\": 1, \"x\": 1})\n            .mean()\n        )\n        cropped_data = data.rio.clip(cell['geometry'])\n\n        # Calculate lat/long of the center of the grid cell\n        longitude = np.mean(cell['geometry']['coordinates'][0][0])\n        latitude = np.mean(cell['geometry']['coordinates'][0][1])\n\n        print(\"Reprojecting data to EPSG:32612\")\n        # Reproject the cropped DEM data\n        cropped_data = cropped_data.rio.reproject(\"EPSG:32612\")\n\n        # Mean elevation of the grid cell\n        mean_elev = cropped_data.mean().values\n        print(\"Elevation:\", mean_elev)\n\n        # Calculate directional components\n        aspect = xrspatial.aspect(cropped_data)\n        aspect_xcomp = np.nansum(np.cos(aspect.values * (np.pi / 180)))\n        aspect_ycomp = np.nansum(np.sin(aspect.values * (np.pi / 180)))\n        mean_aspect = np.arctan2(aspect_ycomp, aspect_xcomp) * (180 / np.pi)\n        if mean_aspect < 0:\n            mean_aspect = 360 + mean_aspect\n        print(\"Aspect:\", mean_aspect)\n        mean_eastness = np.cos(mean_aspect * (np.pi / 180))\n        mean_northness = np.sin(mean_aspect * (np.pi / 180))\n        print(\"Eastness:\", mean_eastness)\n        print(\"Northness:\", mean_northness)\n\n        # Positive curvature = upward convex\n        curvature = xrspatial.curvature(cropped_data)\n        mean_curvature = curvature.mean().values\n        print(\"Curvature:\", mean_curvature)\n\n        # Calculate mean slope\n        slope = xrspatial.slope(cropped_data)\n        mean_slope = slope.mean().values\n        print(\"Slope:\", mean_slope)\n\n        # Fill pandas dataframe\n        df_gridcells.loc[idx] = [longitude, latitude,\n                                 mean_elev, mean_aspect,\n                                 mean_curvature, mean_slope,\n                                 mean_eastness, mean_northness]\n\n    # Save output data into CSV format\n    df_gridcells.set_index(gridcellsGPD['cell_id'][0:idx+1], inplace=True)\n    df_gridcells.to_csv(gridcells_outfile)\n\ntry:\n    prepareGridCellTerrain()\nexcept:\n    traceback.print_exc(file=sys.stdout)\n",
  "history_output" : "Preparing GridCell Terrain data\nProcessing grid 0\nTraceback (most recent call last):\n  File \"/home/chetana/gw-workspace/38YDrCVxqHsg/western_us_dem.py\", line 113, in <module>\n    prepareGridCellTerrain()\n  File \"/home/chetana/gw-workspace/38YDrCVxqHsg/western_us_dem.py\", line 44, in prepareGridCellTerrain\n    search = client.search(\nNameError: name 'client' is not defined\n",
  "history_begin_time" : 1689628171519,
  "history_end_time" : 1689628180117,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "uwLOtawhCLKC",
  "history_input" : "import geopandas as gpd\nimport geojson\nimport xarray\nimport xrspatial\nimport numpy as np\nimport pandas as pd\nimport os\nimport sys, traceback\nimport requests\n\nhome_dir = os.path.expanduser('~')\nsnowcast_github_dir = f\"{home_dir}/Documents/GitHub/SnowCast/\"\n\n# Exit if this process is no longer needed\n# exit() \n\n# User-defined paths for data access\ndata_dir = f'{snowcast_github_dir}data/'\ngridcells_file = data_dir+'snowcast_provided/grid_cells_eval.geojson'\ngridcells_outfile = data_dir+'terrain/gridcells_terrainData_eval_new.csv'\n\n# Load metadata\ngridcellsGPD = gpd.read_file(gridcells_file)\ngridcells = geojson.load(open(gridcells_file))\n\n# Instantiate output pandas dataframe\ndf_gridcells = pd.DataFrame(columns=(\"Longitude [deg]\",\"Latitude [deg]\",\n                                     \"Elevation [m]\",\"Aspect [deg]\",\n                                     \"Curvature [ratio]\",\"Slope [deg]\",\n                                     \"Eastness [unitCirc.]\",\"Northness [unitCirc.]\"))\n\ndef prepareGridCellTerrain():\n    # Calculate grid cell characteristics using Copernicus DEM data\n    print(\"Preparing GridCell Terrain data\")\n    for idx, cell in enumerate(gridcells['features']):\n        print(\"Processing grid\", idx)\n        # Modify the search parameters to cover the entire western USA region\n        search = client.search(\n            collections=[\"cop-dem-glo-30\"],\n            bbox=[-125.0, 31.0, -102.0, 49.0]  # Western USA bounding box: [min_lon, min_lat, max_lon, max_lat]\n        )\n        items = list(search.get_items())\n        print(\"==> Searched items:\", len(items))\n\n        # Skip if no DEM items are found for the specified region\n        if len(items) == 0:\n            print(\"No DEM data found for the specified region.\")\n            continue\n\n        # Select the first DEM item\n        signed_asset = planetary_computer.sign(items[0].assets[\"data\"])\n        data = (\n            xarray.open_rasterio(signed_asset.href)\n            .squeeze()\n            .drop(\"band\")\n            .coarsen({\"y\": 1, \"x\": 1})\n            .mean()\n        )\n        cropped_data = data.rio.clip(cell['geometry'])\n\n        # Calculate lat/long of the center of the grid cell\n        longitude = np.mean(cell['geometry']['coordinates'][0][0])\n        latitude = np.mean(cell['geometry']['coordinates'][0][1])\n\n        print(\"Reprojecting data to EPSG:32612\")\n        # Reproject the cropped DEM data\n        cropped_data = cropped_data.rio.reproject(\"EPSG:32612\")\n\n        # Mean elevation of the grid cell\n        mean_elev = cropped_data.mean().values\n        print(\"Elevation:\", mean_elev)\n\n        # Calculate directional components\n        aspect = xrspatial.aspect(cropped_data)\n        aspect_xcomp = np.nansum(np.cos(aspect.values * (np.pi / 180)))\n        aspect_ycomp = np.nansum(np.sin(aspect.values * (np.pi / 180)))\n        mean_aspect = np.arctan2(aspect_ycomp, aspect_xcomp) * (180 / np.pi)\n        if mean_aspect < 0:\n            mean_aspect = 360 + mean_aspect\n        print(\"Aspect:\", mean_aspect)\n        mean_eastness = np.cos(mean_aspect * (np.pi / 180))\n        mean_northness = np.sin(mean_aspect * (np.pi / 180))\n        print(\"Eastness:\", mean_eastness)\n        print(\"Northness:\", mean_northness)\n\n        # Positive curvature = upward convex\n        curvature = xrspatial.curvature(cropped_data)\n        mean_curvature = curvature.mean().values\n        print(\"Curvature:\", mean_curvature)\n\n        # Calculate mean slope\n        slope = xrspatial.slope(cropped_data)\n        mean_slope = slope.mean().values\n        print(\"Slope:\", mean_slope)\n\n        # Fill pandas dataframe\n        df_gridcells.loc[idx] = [longitude, latitude,\n                                 mean_elev, mean_aspect,\n                                 mean_curvature, mean_slope,\n                                 mean_eastness, mean_northness]\n\n    # Save output data into CSV format\n    df_gridcells.set_index(gridcellsGPD['cell_id'][0:idx+1], inplace=True)\n    df_gridcells.to_csv(gridcells_outfile)\n\ntry:\n    prepareGridCellTerrain()\nexcept:\n    traceback.print_exc(file=sys.stdout)\n",
  "history_output" : "Preparing GridCell Terrain data\nProcessing grid 0\nTraceback (most recent call last):\n  File \"/home/chetana/gw-workspace/uwLOtawhCLKC/western_us_dem.py\", line 107, in <module>\n    prepareGridCellTerrain()\n  File \"/home/chetana/gw-workspace/uwLOtawhCLKC/western_us_dem.py\", line 38, in prepareGridCellTerrain\n    search = client.search(\nNameError: name 'client' is not defined\n",
  "history_begin_time" : 1689627972306,
  "history_end_time" : 1689627986043,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : null,
  "indicator" : "Done"
},{
  "history_id" : "ivfi6w3rpql",
  "history_input" : null,
  "history_output" : null,
  "history_begin_time" : null,
  "history_end_time" : 1691530622438,
  "history_notes" : null,
  "history_process" : "oon4sb",
  "host_id" : "tq3z35",
  "indicator" : "Stopped"
},]
